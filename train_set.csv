code,complexity
"import io, os, sys

input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

def read():
    n, m, k = map(int, input().split() )

    h = [list(map(int, input().split() ) )+ [float(""+inf"")] for _ in range(n)]

    v = [list(map(int, input().split() ) ) for _ in range(n-1)]
    v.append( [float(""+inf"")] * m )

    solve(n, m, k, h, v)

def solve(n, m, k, h, v):
    if k % 2:
        ans = ""-1 "" * m
        for _ in range(n):
            print(ans)
        return

    dp = [ [0] * (m+1) for _ in range(n+1)]

    nxt = [ [0] * (m+1) for  _ in range(n+1)]

    for _ in range(2, k + 1, 2):

        for i in range(n):
            for j in range(m):
                l = 2 * h[i][j-1] + dp[i][j-1]
                r = 2 * h[i][j]  + dp[i][j+1]
                u = 2 * v[i-1][j] + dp[i-1][j]
                d = 2 * v[i][j]  + dp[i+1][j]

                hor = min(l, r)
                ver = min(u, d)

                nxt[i][j] = min(hor, ver)

        dp, nxt = nxt, dp

    for l in dp[:-1]:
        print("" "".join(map(str, l[:-1])))

if __name__ == ""__main__"":
    read()",O(n ^ 3)
"class Solution(object):
    def minimumScore(self, s, t):
        right = [-1]*len(s) 
        j = len(t)-1
        for i in reversed(range(len(s))):
            if j >= 0 and t[j] == s[i]:
                j -= 1
            right[i] = j
        result = j+1
        left = 0 
        for i in range(len(s)):
            result = max(min(result, right[i]-left+1), 0)
            if left < len(t) and t[left] == s[i]:
                left += 1
        result = min(result, len(t)-left)
        return result",O(n)
"import sys,os,io
from sys import stdin
import math
from collections import defaultdict
from heapq import heappush, heappop, heapify
from bisect import bisect_left , bisect_right
from io import BytesIO, IOBase
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

alphabets = list('abcdefghijklmnopqrstuvwxyz')

from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)

    return list(set(l))

def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res

def sieveForSmallestPrimeFactor():
    MAXN = 100001
    spf = [0 for i in range(MAXN)]
    spf[1] = 1
    for i in range(2, MAXN):
        spf[i] = i
    for i in range(4, MAXN, 2):
        spf[i] = 2
    for i in range(3, math.ceil(math.sqrt(MAXN))):
        if (spf[i] == i):
            for j in range(i * i, MAXN, i):
                if (spf[j] == j):
                    spf[j] = i
    return spf
def getPrimeFactorizationLOGN(x):
    spf = sieveForSmallestPrimeFactor()
    ret = list()
    while (x != 1):
        ret.append(spf[x])
        x = x // spf[x]
    return ret

def SieveOfEratosthenes(n):

    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def si():
    return input()
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"")
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
    input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def solve():
    n = ii()
    c = [0] + li()
    a = [0] + li()
    vis = [False]*(n+1)
    ans = 0

    d = defaultdict(lambda:0)
    cycleno = 0

    for i in range(1,n+1):
        if (vis[i]==False):
            cur = i
            first = i

            while vis[cur]==False:
                d[cur] = cycleno
                vis[cur]=True
                cur = a[cur]

            if d[cur]==cycleno:
                min_ = c[cur]
                first = cur
                cur = a[cur]

                while first!=cur:

                    min_ = min(c[cur],min_)
                    cur = a[cur]
                ans+=min_
            cycleno+=1

    print(ans)

t = 1

for _ in range(t):
    solve()
",O(n)
"class Solution(object):
    def findMin(self, nums):
        left, right = 0, len(nums)
        target = nums[-1]

        while left < right:
            mid = left + (right - left) / 2

            if nums[mid] <= target:
                right = mid
            else:
                left = mid + 1

        return nums[left]",O(logn)
"arr = []
d = {}
for _ in range(int(input())):
    s = input()
    a,b,c = tuple(map(int, s.replace(""("","""").replace("")"","""").replace(""/"",""."").replace(""+"",""."").split(""."")))
    x = (a+b)/c
    arr.append(x)
    if x not in d:
        d[x] = 0
    d[x] += 1

for i in arr:
    print(d[i], end = "" "")",O(n)
"N, MOD = map(int,input().split())

dp = []
comps = [0]*(N+1)

ncr = [[1]]
for i in range(420):
    tmp = [1]
    for j in range(i):
        tmp.append((ncr[i][j] + ncr[i][j+1]) % MOD)
    tmp.append(1)
    ncr.append(tmp)

for i in range(N):
    curr = list(comps)
    curr[1] = pow(2,i,MOD)
    for j in range(i - 1):
        m = pow(2,i - j - 2)
        for k in range(N):
            num = j - k + 2
            if num < 0: continue
            mr = (m * ncr[i - j - 1 + num][num]) % MOD
            curr[k + 1] += mr * dp[j][k]
            curr[k + 1] %= MOD
    dp.append(curr)

print(sum(dp[-1]) % MOD)",O(n ^ 3)
"import io, sys
input = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip()

ii = lambda: int(input())
mi = lambda: map(int, input().split())
li = lambda: list(mi())

n, k = mi()
a = li()
d = [a[i + 1] - a[i] for i in range(n - 1)]
ans = sum(sorted(d)[:n - 1 - (k - 1)])
print(ans)",O(nlogn)
"import sys
n,m=map(int,input().split())
s=[list(input()) for i in range(n)]
u=[[-1 for i in range(m)] for j in range(n)]
d=[[-1 for i in range(m)] for j in range(n)]
l=[[-1 for i in range(m)] for j in range(n)]
r=[[-1 for i in range(m)] for j in range(n)]
for i in range(m):
    acum=0
    for j in range(n):
        if s[j][i]==""."":
            acum=0
        else:
            acum+=1
        u[j][i]=acum
for i in range(m):
    acum=0
    for j in range(n-1,-1,-1):
        if s[j][i]==""."":
            acum=0
        else:
            acum+=1
        d[j][i]=acum
for i in range(n):
    acum=0
    for j in range(m):
        if s[i][j]==""."":
            acum=0
        else:
            acum+=1
        l[i][j]=acum
for i in range(n):
    acum=0
    for j in range(m-1,-1,-1):
        if s[i][j]==""."":
            acum=0
        else:
            acum+=1
        r[i][j]=acum
ans=[]
t1=[[0 for i in range(m)] for j in range(n)]
t2=[[0 for i in range(m)] for j in range(n)]
for i in range(n):
    for j in range(m):
        d1=min(l[i][j],r[i][j],u[i][j],d[i][j])-1
        if d1>0:
            ans.append([i+1,j+1,d1])
            t1[i+d1][j]+=1
            t1[i-d1][j]-=1
            t2[i][j-d1]+=1
            t2[i][j+d1]-=1
dp=[['.' for i in range(m)] for j in range(n)]
for i in range(n):
    acum=0
    for j in range(m):
        acum+=t2[i][j]
        if acum!=0 or t2[i][j]!=0:
            dp[i][j]='*'
for i in range(m):
    acum=0
    for j in range(n):
        acum+=t1[j][i]
        if acum!=0 or t1[j][i]!=0 :
            dp[j][i]='*'
if dp!=s:
    print(-1)
    sys.exit()
print(len(ans))
for i in ans:
    print(*i)
",O(n ^ 2)
"import sys
n,m=map(int,input().split())
s=list(map(int,input().split()))
try:
    ind=s.index(m)
except:
    print(0)
    sys.exit()
dp=[0 for i in range(n)]
for i in range(ind+1,n):
    if s[i]<m:
        dp[i]=dp[i-1]-1
    elif s[i]>m:
        dp[i]=dp[i-1]+1
for i in range(ind-1,-1,-1):
    if s[i]<m:
        dp[i]=dp[i+1]-1
    elif s[i]>m:
        dp[i]=dp[i+1]+1
d=dict()
for i in range(ind+1,n):
    try:
        d[dp[i]]+=1
    except:
        d.update({dp[i]:1})

ans=0
for i in range(ind+1):
    x=-dp[i]
    try:
        ans+=d[x]
    except:
        True
    try:
        ans+=d[x+1]
    except:
        True
    if dp[i]==0 or dp[i]==1:
        ans+=1
print(ans)
",O(nlogn)
"n, v = [int(item) for item in input().split()]

x = 0
c = 0
for i in range(1, n):
    if x < n - i:
        c += i * min((n - i), v - x)
        x += min((n - i), v - x)
    x -= 1

print(c)
",O(n)
"import math
s1=input()
s2=input()
if(s2.count('?')==0):
    if(s1.count('+')==s2.count('+') and s1.count('-')==s2.count('-')):
        p=1
    else:
        p=0
else:
    if((s1.count('+')< s2.count('+')!=0) or (s1.count('-')==0<s2.count('-')!=0)):
        p=0
    else:
        pl=s1.count('+')-s2.count('+')
        mi=s1.count('-')-s2.count('-')
        p=(math.factorial((pl+mi))/math.factorial(pl)/math.factorial(mi))/2**(pl+mi)
print('%1.9f'%p)",np
"n = int(input())
w = list(map(int, input().split()))
ent = input()
mp = {w[i]: i+1 for i in range(n)}
sorted(mp)
w.sort()
ptr = 0
a = 0
stk = []
for i in range(2 * n):
    if ent[i] == ""0"":
        print(mp[w[ptr]], end="" "")
        stk.append(mp[w[ptr]])
        ptr += 1
    else:
        print(stk.pop(), end="" "")

print()
",O(nlogn)
"n=int(input())
n+=1

if n%2==0 or n==1:
	print(n//2)
else:
	print(n)",O(1)
"class Solution(object):
    def findMaxK(self, nums):
        lookup = set(nums)
        return max([x for x in lookup if x > 0 and -x in lookup] or [-1])",O(n)
"from math import sin, pi
n, r = map(int, input().split())

def p(n, r):
    return 2 * n * r * sin(pi / n)

le = 0; ri = r * 1000
while ri - le > 1e-9:
    m = (ri + le) / 2
    if p(n, r + m) < n * m * 2:
        ri = m
    else:
        le = m
print(m)",O(1)
"n, k = map(int, input().split())
if n == k:
    print('1' * n)
elif k == 1:
    print('0' + '1' * (n - 1))
else:
    x = (n - k) // 2
    a = '0' * x + '1'
    print(a * (n // (x + 1)) + '0' * (n % (x + 1)))",O(1)
"class Solution2(object):
    def longestSquareStreak(self, nums):
        dp = collections.defaultdict(int)
        nums.sort()
        result = -1
        for x in nums:
            sqrt_x = int(x**0.5)
            if sqrt_x**2 == x:
                dp[x] = dp[sqrt_x]+1
            else:
                dp[x] = 1
            result = max(result, dp[x])
        return result if result != 1 else -1",O(nlogn)
"import collections


class Solution(object):
    def majorityElement(self, nums):
        def boyer_moore_majority_vote():
            result, cnt = None, 0
            for x in nums:
                if not cnt:
                    result = x
                if x == result:
                    cnt += 1
                else:
                    cnt -= 1
            return result

        return boyer_moore_majority_vote()",O(n)
"import collections



class Solution2(object):
    def findMissingAndRepeatedValues(self, grid):
        cnt = collections.Counter(x for row in grid for x in row)
        return [next(k for k, v in cnt.items() if v == 2), next(x for x in range(1, len(grid)**2+1) if x not in cnt)]",O(n ^ 2)
"def givestringsk(k):
    t=[""R"",""G"",""B""]
    ans=[]
    for i in range(3):
        temp=""""
        for j in range(i,i+k):
            temp+=t[j%3]
        ans.append(temp)
    return ans
def countdifferences(a,b):
    cnt=0
    for i in range(len(a)):
        if a[i]!=b[i]:cnt+=1
    return cnt
for _ in range(int(input())):
    n,k=list(map(int,input().split()))
    s=input()
    temp=givestringsk(k)
    ans=10000000000000
    for i in range(k,n+1):
        for j in range(3):
            ans=min(ans,countdifferences(s[i-k:i],temp[j]))
    print(ans)
",O(n ^ 2)
"from collections import Counter
import math

i1 = list(input())
i2 = list(input())

a = Counter(i1)
b = Counter(i2)

c = b-a
d = a-b

c1 = list(c.elements())
d1 = list(d.elements())

count = 0
for i in c1:
  if i == ""?"":
    count = count+1
if count != len(d1):
  print(0)
else:
  x = len(c1)
  that = 0
  for i in d1:
    if i == ""+"":
      that = that + 1
  out = math.factorial(x)/((math.factorial(that))*math.factorial(x-that))
  print(out/math.pow(2,x))
",np
"import sys

def main():
    pass

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def lts(l):
    s = ''.join(map(str, l))
    return s

def stl(s):

    l = list(s)

    return l

def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans

def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1

    return (cnt)

def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)

mod = int(1e9) + 7
def ssinp(): return sys.stdin.readline().strip()

def iinp(): return int(input())

def nninp(): return map(int, sys.stdin.readline().strip().split())

def llinp(): return list(map(int, sys.stdin.readline().strip().split()))

def p(xyz): print(xyz)
def p2(a, b): print(a, b)
import math

import random
from collections import OrderedDict
from fractions import Fraction

n,k=nninp()
s=ssinp()
ans=[]
lb=k//2
rb=k//2
for c in s:
    if(lb>0):
        if(c==""(""):
            lb-=1
        else:
            rb-=1
        ans.append(c)
    elif(rb>0):
        if(c=="")""):
            ans.append(c)
            rb-=1
    elif(lb==0 and rb==0):
        break
p(lts(ans))
",O(n)
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n + 1) for _ in range(2024)]

d = [[] for _ in range(n)]
for i, v in enumerate(b):
    e[v][i] = i
    d[i].append(i)
for v in range(1, 2024):
    for i in range(n):
        j = e[v][i]
        h = e[v][j + 1] if j != -1 else -1
        if j != -1 and h != -1:
            e[v + 1][i] = h
            d[i].append(h)

a = [_ for _ in range(1, n + 1)]
for s in range(n):
    for e in d[s]:
        a[e] = min(a[e], a[s - 1] + 1 if s > 0 else 1)
print(a[n - 1])
",O(n ^ 3)
"class Solution(object):
    def numMovesStones(self, a, b, c):
        s = [a, b, c]
        s.sort()
        if s[0]+1 == s[1] and s[1]+1 == s[2]:
            return [0, 0]
        return [1 if s[0]+2 >= s[1] or s[1]+2 >= s[2] else 2, s[2]-s[0]-2]",O(1)
"class Solution2(object):
    def countSubarrays(self, nums):
        result = left = 0
        for right in range(len(nums)):
            if not (right-1 >= 0 and nums[right-1] < nums[right]):
                left = right
            result += right-left+1
        return result",O(n)
"class Solution(object):
    def arrangeWords(self, text):
        result = text.split()
        result[0] = result[0].lower()
        result.sort(key=len) 
        result[0] = result[0].title()
        return "" "".join(result)",O(nlogn)
"R, G, B = list(map(int, input().split()))
r = sorted(list(map(int, input().split())), reverse=True)
g = sorted(list(map(int, input().split())), reverse=True)
b = sorted(list(map(int, input().split())), reverse=True)

ans = 0
dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
            if j<G and k<B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])
            if i<R and k<B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])
            ans = max(ans, dp[i][j][k])
print(ans)
",O(n ^ 3)
"class Solution(object):
    def longestMonotonicSubarray(self, nums):
        result = cnt = 1 if len(nums) == 1 or cmp(nums[0], nums[1]) == 0 else 2
        for i in range(2, len(nums)):
            cnt = 1 if cmp(nums[i-1], nums[i]) == 0 else cnt+1 if cmp(nums[i-2], nums[i-1]) == cmp(nums[i-1], nums[i]) else 2
            result = max(result, cnt)
        return result",O(n)
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key = lambda x: x[1])
        n = len(intervals)
        memo = {}

        def dfs(i):
            if i in memo:
                return memo[i]

            res = 1
            for j in range(i + 1, n):
                if intervals[i][1] <= intervals[j][0]:
                    res = max(res, 1 + dfs(j))
            memo[i] = res
            return res

        return n - dfs(0)
",O(n ^ 2)
"input()
c = list(map(int, input().split()))
a = list(map(int, input().split()))

u = [0] * len(a)

ans = 0

for i in range(len(a)):
    if u[i] != 0:
        continue
    idx = i
    while u[idx] == 0:
        u[idx] = 1
        idx = a[idx] - 1

    if (u[idx] == 2):
        idx = i
        while u[idx] == 1:
            u[idx] = 2
            idx = a[idx] - 1
        continue

    start = idx
    mn = c[idx]
    u[idx] = 2
    while a[idx] - 1 != start:
        idx = a[idx] - 1
        mn = min(mn, c[idx])
        u[idx] = 2

    idx = i
    while u[idx] == 1:
        u[idx] = 2
        idx = a[idx] - 1
    ans += mn
print(ans)",O(n)
"n = int(input())
if n == 1:
    print(5)
else:
    print(25)
",O(1)
"n=int(input())
l=[-1 for i in range(n+1)]
s=input().split()
ll=[int(i) for i in s]
for i in range(n):
    j=ll[i]
    l[j]=i
res=[""."" for i in range(n+1)]
res[n]=""B""
for i in range(n-1,0,-1):
    toadd=""B""
    pos=l[i]%i
    while pos<n:
        j=ll[pos]
        if j<=i:
            pos+=i
            continue
        if abs(l[i]-l[j])%i==0 and res[j]==""B"":
            toadd=""A""
            break
        pos+=i
    res[i]=toadd
for i in ll:
    print(res[i],end="""")
print("""")",O(nlogn)
"n=int(input())
if n>=0:
    print(n)
else:
    a=str(n)
    a=a[1::]
    if len(a)>2:
        a=a[::-1][1::][::-1]
        num1=int(a)
        a=str(n)
        a=a[1::]
        b=a[::-1]
        p1=b[0]
        p2=b[2::]
        p=p1+p2
        p=p[::-1]
        num2=int(p)
        small=min(num1,num2)
        print(-1*small)

    elif len(a)==2:
        m=a[0]
        n=a[1]
        small=min(int(m),int(n))
        print(-1*small)
",O(1)
"def isValid(k):
    last=a[0]
    count=1
    step=0
    i=1
    if count==k and step+1==n:
        return True
    elif count==k:
        step+=1
        count=1

    while i<m:

        if step==n:
            return True
        if count==k:
            step+=1
            count=1
            if step==n:
                return True
            last=a[i]
        elif a[i]==last:
            count+=1

            if count==k and step+1==n:
                return True
        elif a[i]!=last:
            last=a[i]
            count=1
        i+=1
    return False

n,m=map(int,input().split())
a=list(map(int,input().split()))
a.sort()
l=1
h=m
ans=0

while l<=h:
    mid=(l+h)//2

    if isValid(mid)==True:
        ans=mid
        l=mid+1
    else:
        h=mid-1
print(ans)
",O(nlogn)
"l, r, k =map(int,input().split())

d = {i:2**i for i in range(10)}

cache = {}

def can(i, m):
    return d[i] & m

def calc(m):
    b = 1
    c = 0
    for i in range(10):
        if b & m:
            c += 1
        b *= 2

    return c

def sm(ln, k, m, s='', first=False):
    if ln < 1:
        return 0, 1

    if (ln, k, m, s, first) in cache:
        return cache[(ln, k, m, s, first)]

    ans = 0
    count = 0
    base = 10 ** (ln-1)

    use_new = calc(m) < k

    if s:
        finish = int(s[0])+1
    else:
        finish = 10

    for i in range(finish):
        if use_new or can(i, m):
            ss = s[1:]
            if i != finish-1:
                ss = ''
            nm = m | d[i]
            nfirst = False
            if i == 0 and first:
                nm = m
                nfirst = True
            nexta, nextc = sm(ln-1, k, nm, ss, nfirst)
            ans += base * i * nextc + nexta
            count += nextc

    cache[(ln, k, m, s, first)] = (ans, count)

    return ans, count

def call(a, k):
    s = str(a)
    return sm(len(s), k, 0, s, True)[0]

print((call(r, k) - call(l-1, k)) % 998244353)
",O(n ^ 3)
"from string import digits
from collections import Counter
a = input()
b = input()
ca = Counter(a)
l = list()
if len(b) > len(a):
    for i in digits[::-1]:
        if i in ca:
            l.extend(i * ca[i])
else:
    def asd(i, s):
        if i == len(b):
            return True
        if s:
            for j in digits[::-1]:
                if j in ca and ca[j] > 0:
                    l.extend(j * ca[j])
            return True
        else:
            for j in digits[:int(b[i])+1][::-1]:
                if j in ca and ca[j] > 0:
                    ca[j] -= 1
                    l.append(j)
                    if asd(i + 1, j != b[i]):
                        return True
                    ca[j] += 1
                    l.pop()
            return False
    asd(0, False)
print("""".join(l))
",O(n ^ 3)
"n=int(input())
m=int(input())

if n>(m+1)/2:
	print(m)
else:
	print(int(m%(2**n)))
",O(1)
"class Solution(object):
    def winnerOfGame(self, colors):
        cnt1 = cnt2 = 0
        for i in range(1, len(colors)-1):
            if not (colors[i-1] == colors[i] == colors[i+1]):
                continue
            if colors[i] == 'A':
                cnt1 += 1
            else:
                cnt2 += 1
        return cnt1 > cnt2",O(n)
"k = int(input())
n = 1
up_bnd = 9
while(k > up_bnd):
    n += 1
    up_bnd += (9*n)*(10**(n-1))
low_bnd = 0
lb_val = 0
for i in range(1, n):
    low_bnd += (9*i)*(10**(i-1))
    lb_val = (lb_val*10)+9
num = int((k-low_bnd)/n) + lb_val
rm = (k-low_bnd) % n
if(rm != 0):
    num += 1
ans = 0
if(rm == 0):
    ans = num % 10
else:
    for i in range(n-rm+1):
        j = (num % 10)
        num = int(num/10)
        ans = j
print(int(ans))",O(logn)
"import sys
input = sys.stdin.readline

n = int(input())
a = list(map(int, input().split()))
cnt = 0
for i in range(n):
    for j in range(i+1, n):
        if a[i] > a[j]:
            cnt += 1
even = cnt % 2 == 0
q = int(input())
ans = []
for _ in range(q):
    l, r = map(int, input().split())
    len = r - l + 1
    pairs = len * (len-1) // 2
    if pairs % 2 == 1:
        even = not even
    if even:
        ans.append('even')
    else:
        ans.append('odd')
print('\n'.join(ans))
",O(n ^ 2)
"import sys
input = sys.stdin.readline

n=int(input())
A=list(map(int,input().split()))
PLACE=[None]*(n+1)
for i in range(n):
    PLACE[A[i]]=i

al=n

WINLIST=[None]*(n+1)

def move(n,al):
    place=PLACE[n]
    for i in range(place,-1,-n):
        if A[i]>n and WINLIST[A[i]]==""B"":
            WINLIST[n]=""A""
            return

    for i in range(place,al,n):
        if A[i]>n and WINLIST[A[i]]==""B"":
            WINLIST[n]=""A""
            return

    else:
        WINLIST[n]=""B""
        return

for j in range(n,0,-1):
    move(j,al)

ANS=""""
for i in A:
    ANS+=WINLIST[i]

print(ANS)
",O(n)
"import collections


class Solution(object):
    def canArrange(self, arr, k):
        count = collections.Counter(i%k for i in arr)
        return (0 not in count or not count[0]%2) and \
                all(k-i in count and count[i] == count[k-i] for i in range(1, k) if i in count)",O(n)
"import math
import sys

DEBUG = False

def inp():
    return sys.stdin.readline().rstrip()

def dprint(*value, sep=' ', end='\n'):
    if DEBUG:
        print(*value, sep=sep, end=end)

def solve(N):
    ans = []

    end = N
    fac = 1

    while end >= 1:
        if end == 1:
            ans.append(fac)
            end = 0
            break

        if end == 2:
            ans.append(fac)
            ans.append(fac * 2)
            end = 0
            break

        if end == 3:
            ans.append(fac)
            ans.append(fac)
            ans.append(fac * 3)
            end = 0
            break

        ans.extend([fac] * ((end + 1) // 2))
        end //= 2
        fac *= 2

    return ans

def main():
    N = int(inp())
    print(*solve(N))

if __name__ == '__main__':
    main()
",O(nlogn)
"from itertools import combinations
n,l,r,x=map(int,input().split())
*a,=map(int,input().split())
print(sum([sum([max(j)-min(j)>=x and l<=sum(j)<=r for j in combinations(a,i)])for i in range(2,n+1)]))",np
"
import operator
from functools import reduce


class Solution(object):
    def singleNumber(self, A):
        return reduce(operator.xor, A)

",O(n)
"class Solution(object):
    def binarySearchableNumbers(self, nums):
        right = [float(""inf"")]*(len(nums)+1)
        for i in reversed(range(1, len(nums)+1)):
            right[i-1] = min(right[i], nums[i-1])
        result, left = set(), float(""-inf"")
        for i in range(len(nums)):
            if left <= nums[i] <= right[i+1]:
                result.add(nums[i])
            left = max(left, nums[i])
        return len(result)",O(n)
"import sys
import math
import bisect
import heapq
from bisect import bisect_right
from sys import stdin, stdout

def get_ints_in_variables(): return map(
    int, sys.stdin.readline().strip().split())

def get_int(): return int(sys.stdin.readline())

def get_ints_in_list(): return list(
    map(int, sys.stdin.readline().strip().split()))
def get_list_of_list(n): return [list(
    map(int, sys.stdin.readline().strip().split())) for _ in range(n)]

def get_string(): return sys.stdin.readline().strip()

def myceil(x, y): return (x + y - 1) // y

def Solution(td, n, k):

    mxHeap = []
    td = sorted(td, key=lambda x: x[0])
    prefix = []
    tmp = 0
    for v in td:
        b = v[1]
        tmpAns = tmp+b
        if len(mxHeap) == k:
            if len(mxHeap) and b > mxHeap[0]:
                t = heapq.heappop(mxHeap)
                heapq.heappush(mxHeap, b)
                tmp -= t
                tmp += b
        elif len(mxHeap) < k:
            tmp += b
            heapq.heappush(mxHeap, b)
        prefix.append([tmpAns, v[2]])

    ans = [0 for _ in range(n)]
    for v in prefix:
        ans[v[1]] = v[0]
    print(*ans)

def main():

    n, k = get_ints_in_variables()
    a = get_ints_in_list()
    b = get_ints_in_list()
    td = [[a[i], b[i], i] for i in range(n)]
    Solution(td, n, k)

if __name__ == '__main__':
    main()
",O(nlogn)
"from sys import stdin
from math import factorial

n, mod = map(int, stdin.readline().split())

def binom(n, m):
    return factorial(n) // factorial(m) // factorial(n-m)

def foo(x, k):
    ans = 0
    for i in range(k, 0, -1):
        sign = 1 if (i-k)%2 == 0 else -1
        ans += sign * binom(k, i) * (i**x)
        ans %= mod
    return ans

def f(x, k):
    return (foo(x, k) * pow(2, x-k, mod)) % mod

ans = 0
for i in range((n+1)//2):
    ans = (ans + f(n-i, i+1))
    ans %= mod
print(ans)",O(n ^ 2)
"from math import *
l, r = list(map(int, input().split("" "")))
print((2<<floor(log2(l^r)))-1 if l!=r else 0)
",O(logn)
"import math
n,m,k=map(int,input().split())
horz=[]
vert=[]
if k & 1:
    for i in range(n):
        temp=[-1 for j in range(m)]
        print(*temp)

else:
    for i in range(n):
        temp=list(map(int,input().split()))
        horz.append(temp)
    for i in range(n-1):
        temp=list(map(int,input().split()))
        vert.append(temp)
    dp=[[[0 for i in range(22)] for j in range(m)]for k in range(n)]
    for x in range(2,k+1,2):
        for i in range(n):
            for j in range(m):
                dp[i][j][x]=math.inf
                if i>0:
                     dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-2]+2*vert[i-1][j])
                if i<n-1:
                      dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-2]+2*vert[i][j])
                if j>0:
                     dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-2]+2*horz[i][j-1])
                if j<m-1:
                     dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-2]+2*horz[i][j])
    for i in range(n):
        temp=[]
        for j in range(m):
            temp.append(dp[i][j][k])
        print(*temp)",O(n ^ 3)
"import collections



class Solution(object):
    def dividePlayers(self, skill):
        target = sum(skill)//(len(skill)//2)
        cnt = collections.Counter(skill)
        result = 0
        for k, v in cnt.items():
            if target-k not in cnt or cnt[target-k] != cnt[k]:
                return -1
            result += k*(target-k)*v
        return result//2",O(n)
"N,U = map(int,input().strip().split())

E = list(map(int,input().strip().split()))
maxu = -1
j = 2
if N < 3:
    print(-1)
for i in range(N-2):
    j = max(i+2,j)
    if E[j] -E[i] > U:
        continue
    while j < N and E[j] - E[i] <= U:
        j += 1
    j -= 1
    maxu = max(maxu, (E[j] - E[i+1]) / (E[j] - E[i]))
print(maxu)",O(nlogn)
"mod = 10 ** 9 + 7
x, k = map(int, input().split())
if x != 0:
    print((pow(2, k + 1, mod) * x - pow(2, k, mod) + 1) % mod)
else:
    print(0)
",O(logn)
"n,r = map(int,input().split())
x_coord = list(map(int,input().split()))
d = {}
for i in x_coord:
    final = r

    for j in range(i-r,i+r+1):
        check = d.get(j,[-1,-1])
        if check[0] > 0:
            potential = check[1] + ((4*r*r)-((i-check[0])**2))**.5
            final = max(potential,final)
    for j in range(i-r,i+r+1):
        d[j] = (i,final)
    print(final)",O(n ^ 2)
"n, m, k = map(int, input().split())
mi = list(map(int, input().split()))

ans = 0
items_to_del = 0
shift = 1
c_page = None
for el in mi:
    if c_page is None:
        c_page = (el - shift) // k
        items_to_del = 1
    else:
        page = (el - shift) // k
        if page != c_page:
            shift += items_to_del
            ans += 1
            c_page = (el - shift) // k
            items_to_del = 1
        else:
            items_to_del += 1
if items_to_del != 0:
    ans += 1
print(ans)
",O(n)
"import sys

def set(mask, pos):
    return mask | (1 << pos)

def isOn(mask, pos):
    return mask & ( 1 << pos) > 0

n, l, r, x = map(int, input().split(' '))
dif = list(map(int, input().split(' ')))

count, mask = 0, 0

while mask <= 2**n:
    summ, bit = [], 0

    while bit < n:

        if isOn(mask, bit):
            summ.append(dif[bit])

        bit += 1

    if sum(summ) <= r and sum(summ) >= l and max(summ) - min(summ) >= x:
        count += 1

    mask += 1

print(count)
",np
"import itertools


class Solution(object):
    def canConvert(self, str1, str2):
        if str1 == str2:
            return True
        lookup = {}
        for i, j in zip(str1, str2):
            if lookup.setdefault(i, j) != j:
                return False
        return len(set(str2)) < 26",O(n)
"k,n,s,p=map(int,input().split())
c=(n//s) if n%s==0 else (n//s)+1
print((c*k)//p if (c*k)%p==0 else ((c*k)//p)+1)
",O(1)
"import collections


class Solution(object):
    def constrainedSubsetSum(self, nums, k):
        result, dq = float(""-inf""), collections.deque()
        for i in range(len(nums)):
            if dq and i-dq[0][0] == k+1:
                dq.popleft()
            curr = nums[i] + (dq[0][1] if dq else 0)
            while dq and dq[-1][1] <= curr:
                dq.pop()
            if curr > 0:
                dq.append((i, curr))
            result = max(result, curr)
        return result",O(n)
"import collections
import string

class Solution(object):
    def minDeletions(self, s):
        count = collections.Counter(s)
        result = 0
        lookup = set()
        for c in string.ascii_lowercase:
            for i in reversed(range(1, count[c]+1)):
                if i not in lookup:
                    lookup.add(i)
                    break
                result += 1
        return result",O(n)
"class Solution(object):
    def findMiddleIndex(self, nums):
        total = sum(nums)
        accu = 0
        for i, x in enumerate(nums):
            if accu*2 == total-x:
                return i
            accu += x
        return -1",O(n)
"from math import sqrt
n, k = map(int, input().split())
a = 1
b = -1 * (2*n + 3)
c = n * (n + 1) - 2 * k

res = (-1 * b) - sqrt((b * b) - 4 * a * c)
res = res / 2
res = int(res)
print(res)
",O(logn)
"r,g,b = list(map(int, input().split()))
ls_r = sorted(list(map(int, input().split())))
ls_g = sorted(list(map(int, input().split())))
ls_b = sorted(list(map(int, input().split())))

dp = [[[-1 for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)]

def recursive(idx_r, idx_g, idx_b):
    if dp[idx_r][idx_g][idx_b] != -1:
        return dp[idx_r][idx_g][idx_b]
    res_1 = 0
    res_2 = 0
    res_3 = 0
    if (idx_r-1) >= 0 and (idx_g-1) >= 0:
        res_1 = recursive(idx_r-1, idx_g-1, idx_b) + ls_r[idx_r-1] * ls_g[idx_g-1]
    if (idx_g-1) >= 0 and (idx_b-1) >= 0:
        res_2 = recursive(idx_r, idx_g-1, idx_b-1) + ls_g[idx_g-1] * ls_b[idx_b-1]
    if (idx_r-1) >= 0 and (idx_b-1) >= 0:
        res_3 = recursive(idx_r-1, idx_g, idx_b-1) + ls_r[idx_r-1] * ls_b[idx_b-1]

    dp[idx_r][idx_g][idx_b] = max(res_1, res_2, res_3)
    return dp[idx_r][idx_g][idx_b]

print(recursive(r,g,b))",O(n ^ 3)
"import collections


class Solution(object):
    def sumOfDistancesInTree(self, N, edges):
        def dfs(graph, node, parent, count, result):
            for nei in graph[node]:
                if nei != parent:
                    dfs(graph, nei, node, count, result)
                    count[node] += count[nei]
                    result[node] += result[nei]+count[nei]

        def dfs2(graph, node, parent, count, result):
            for nei in graph[node]:
                if nei != parent:
                    result[nei] = result[node]-count[nei] + \
                                  len(count)-count[nei]
                    dfs2(graph, nei, node, count, result)

        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        count = [1] * N
        result = [0] * N

        dfs(graph, 0, None, count, result)
        dfs2(graph, 0, None, count, result)
        return result",O(n)
"class Solution(object):
    def relativeSortArray(self, arr1, arr2):
        lookup = {v: i for i, v in enumerate(arr2)}
        return sorted(arr1, key=lambda i: lookup.get(i, len(arr2)+i))",O(nlogn)
"class Solution(object):
    def calPoints(self, ops):
        history = []
        for op in ops:
            if op == '+':
                history.append(history[-1] + history[-2])
            elif op == 'D':
                history.append(history[-1] * 2)
            elif op == 'C':
                history.pop()
            else:
                history.append(int(op))
        return sum(history)",O(n)
"movimentos, doces_final = map(int, input().split())
left, right = 0, movimentos + 1

while left < right -1 :
    media = (left + right)//2
    cedidos = (media * (media + 1)) // 2
    comidos = movimentos - media
    if cedidos - comidos > doces_final:
        right = media
    else:
        left = media
print(movimentos - left)",O(logn)
"from math import *
import sys
input = lambda: sys.stdin.readline().strip()

d = {'m': [], 's': [], 'p': []}

ls = list(input().split())
for i in ls:
    d[i[1]].append(int(i[0]))
for k, v in d.items():
    v.sort()
    if len(v)==3 and len(set(v))==1: print(0); break
    if len(v)==3 and v[0]+1==v[1] and v[1]+1==v[2]: print(0); break
else:
    for k, v in d.items():
        if len(v)==2 and len(set(v))==1: print(1); break
        if len(v)==2 and v[1]-v[0]<=2: print(1); break
        if len(v)==3 and (v[0]==v[1] or v[1]==v[2]): print(1); break
        if len(v)==3 and (v[1]-v[0]<=2 or v[2]-v[1]<=2): print(1); break
    else:
        print(2)
",O(nlogn)
"import sys
import bisect
from bisect import bisect_left as lb
from bisect import bisect_right as rb
input_=lambda: sys.stdin.readline().strip(""\r\n"")
from math import log
from math import gcd
from math import atan2,acos
from random import randint
sa=lambda :input_()
sb=lambda:int(input_())
sc=lambda:input_().split()
sd=lambda:list(map(int,input_().split()))
sflo=lambda:list(map(float,input_().split()))
se=lambda:float(input_())
sf=lambda:list(input_())
flsh=lambda: sys.stdout.flush()

mod=10**9+7
mod1=998244353
gp=[]
cost=[]
dp=[]
mx=[]
ans1=[]
ans2=[]
special=[]
specnode=[]
a=0
kthpar=[]
def dfs(root,par):
    if par!=-1:
        dp[root]=dp[par]+1
    for i in range(1,20):
        if kthpar[root][i-1]!=-1:
            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]
    for child in gp[root]:
        if child==par:continue
        kthpar[child][0]=root
        dfs(child,root)

ans=0
b=[]

def dfs2(root,par,d):
    global gp,dp
    dp[root]=d
    for child in gp[root]:
        if child==par:continue
        dfs2(child,root,d+1)
def hnbhai(tc):
    n,s=sd()
    low=s
    high=n+1
    ans=n+1
    while(low<=high):
        mid=(low+high)//2
        ss=sum(list(map(int,list(str(mid)))))
        if mid-ss<s:
            low=mid+1
        else:
            ans=mid
            high=mid-1
    print(n-ans+1)
for _ in range(1):
    hnbhai(_+1)
",O(logn)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

for t in range(ii()):
    n, k = mi()
    if n == 1:
        ans = 'YES 0' if k == 1 else 'NO'
    elif n == 2:
        if k <= 2:
            ans = 'YES 1'
        elif k == 3 or k > 5:
            ans = 'NO'
        else:
            ans = 'YES 0'
    elif n <= 32 and k > (4 ** n - 1) // 3:
        ans = 'NO'
    else:
        c, x = 0, n
        p2 = 2
        while x > 0:
            if c + p2 - 1 > k:
                break
            c += p2 - 1
            x -= 1
            p2 *= 2
        ans = 'YES %d' % (x,)
    print(ans)
",O(n)
"from operator import itemgetter

n, v = map(int, input().split())

if v >= n-1:
    ans = n-1
else:
    ans = v + ((2+(2+n-v-2))*(n-v-1))//2
print(ans)
",O(1)
"n=input()
ans=0
r,c=0,0
for i in range(len(n)):
    r+=int(n[i])
    c+=1
    if int(n[i])%3==0 or r%3==0 or c==3:
        ans+=1
        r,c=0,0
print(ans)",O(n)
"from sys import stdin,stdout
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):
    n=nmbr()
    a=lst()
    b=lst()
    dp=[0]*n
    for i in range(n):
        v=float('inf')
        for j in range(i+1,n):
            if a[j]>a[i]:v=min(v,b[i]+b[j])
        dp[i]=v

    for i in range(n):
        v = float('inf')
        for j in range(i + 1, n):
            if a[j] > a[i]: v = min(v, b[i] + dp[j])
        dp[i] = v
    ans=min(dp)
    print(ans if ans!=float('inf') else -1)",O(n ^ 2)
"class Solution(object):
    def minOperations(self, nums, k):
        def popcount(x):
            return bin(x).count('1')
    
        return popcount(reduce(lambda x, y: x^y, nums, k))",O(n)
"n = int(input())
a = list(map(int, input().split()))
for i in range(n):
    if a[i]>=0:
        a[i] = -a[i]-1
x = min(a)

if len(a)%2==1:
    for i in range(n):
        if a[i]==x:
            a[i] = -a[i]-1
            break
print(*a)",O(n)
"import sys, math
import io, os

from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.buffer.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var) : sys.stdout.write(' '.join(map(str, var))+'\n')
def out(var) : sys.stdout.write(str(var)+'\n')

mod = int(1e9)+7

def cal(x):
    l1=set()
    d=dd(int)
    a=[]
    for i in range(n):
        k=0
        for j in range(m):
            if A[i][j]>=x:
                k+=1<<j
        l1.add(k)
        d[k]=i+1
    l1=list(l1)
    s=(1<<m)-1
    for i in l1:
        for j in l1:
            if i|j == s:
                a=[d[i],d[j]]
    return a

n,m=mdata()
A=[mdata() for i in range(n)]
l,r=0,10**9
while l<=r:
    mid=(l+r)//2
    if cal(mid):
        l=mid+1
    else:
        r=mid-1
a=cal(mid)
if a:
    outl(a)
else:
    outl(cal(mid-1))
",np
"import sys
input=sys.stdin.readline
n=int(input())
a=list(map(int,input().split()))
INF=10**9
dp=[[INF]*(n+1) for i in range(n+1)]
val=[[-1]*(n+1) for i in range(n+1)]
for i in range(n):
  dp[i][i+1]=1
  val[i][i+1]=a[i]
for l in range(2,n+1):
  for i in range(n-l+1):
    j=i+l
    for k in range(i+1,j):
      if dp[i][k]==dp[k][j]==1 and val[i][k]==val[k][j]:
        dp[i][j]=1
        val[i][j]=val[i][k]+1
      else:
        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j])
print(dp[0][n])",O(n ^ 3)
"class Solution2(object):
    def minimumCost(self, nums):
        def topk(a, k):
            result = [float(""inf"")]*k
            for x in a:
                for i in range(len(result)):
                    if x < result[i]:
                        result[i], x = x, result[i]
            return result

        return nums[0]+sum(topk((nums[i] for i in range(1, len(nums))), 2))",O(n)
"from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]
rstr = lambda: stdin.readline().strip()
rstr_2d = lambda n: [rstr() for _ in range(n)]

n, m = rints()
grid = rstr_2d(n)
row = [[[] for _ in range(m)] for _ in range(n)]
col = [[[] for _ in range(m)] for _ in range(n)]
visr, out, all = [[-1 for _ in range(m)] for _ in range(n)], [], 0
visc = [[-1 for _ in range(m)] for _ in range(n)]

for i in range(n):
    be, en = -1, -1
    for j in range(m):
        if grid[i][j] == '*':
            en += 1
            if be == -1:
                be = en = j
        else:
            if be != -1:
                for k in range(be, en + 1):
                    row[i][k] = [be, en]
            be = -1

    if be != -1:
        for k in range(be, en + 1):
            row[i][k] = [be, en]

for i in range(m):
    be, en = -1, -1
    for j in range(n):
        if grid[j][i] == '*':
            en += 1
            if be == -1:
                be = en = j
        else:
            if be != -1:
                for k in range(be, en + 1):
                    col[k][i] = [be, en]
            be = -1

    if be != -1:
        for k in range(be, en + 1):
            col[k][i] = [be, en]

for i in range(n):
    for j in range(m):
        if grid[i][j] == '*':
            all += 1
            hor = min(row[i][j][1] - j, j - row[i][j][0])
            ver = min(col[i][j][1] - i, i - col[i][j][0])
            if hor <= ver:
                ver = hor
            else:
                hor = ver

            if hor > 0 and ver > 0:
                out.append('%d %d %d' % (i + 1, j + 1, hor))
                visr[i][j - ver] = j + ver
                visc[i - hor][j] = i + hor

dis = set()
for i in range(n):
    j, ma = 0, -1
    while j < m:
        ma = max(ma, visr[i][j])
        if ma >= j:
            dis.add((i, j))

        j += 1

for i in range(m):
    j, ma = 0, -1
    while j < n:
        ma = max(ma, visc[j][i])
        if ma >= j:
            dis.add((j, i))

        j += 1

if len(dis) != all:
    print(-1)
else:
    print('%d\n%s' % (len(out), '\n'.join(out)))
",O(n ^ 2)
"import bisect
import time
def ass(a, b): print(f""Assertion error: {a} != {b}"" if a != b else 'OK')
def nr(): return int(input())
def nrs(): return [int(i) for i in input().split()]

def get_prime(n):
	res = []
	for i in range(2, n):
		is_prime = True
		for x in res:
			if i % x == 0:
				is_prime = False
				break
		if is_prime: res.append(i)
	return res

def get_mask(num):
	dv = []
	for p in prime:
		c = 0
		while num % p == 0:
			c += 1
			num = num // p
		if c % 2 == 1:
			dv.append(p)
		if num < p * p:
			break

	for x in dv:
		num *= x

	return num

def dump(dp):
	for i,line in enumerate(dp):
		print(i%10,line)

def get_left(n,k,lst):
	last_in = {}
	s = []
	res = []
	for i in range(n):
		group = get_mask(lst[i])
		if group in last_in: bisect.insort(s, last_in[group] + 1)
		last_in[group] = i
		if len(s) <= k+1:
			res.append(s[::-1])
		else:
			m = len(s)
			res.append(s[m-1:m-k-2:-1])
	return res

def get_dp(n,k,lst):
	res = []
	left = get_left(n,k,lst)
	for i in range(n):
		arr = left[i]
		row = [n] * (k+1)
		for j in range(k+1):
			for g in range(j+1):
				if g >= len(arr):
					row[j] = 1
				else:
					index = arr[g]-1
					jindex = j-g
					row[j] = min(res[index][jindex] + 1, row[j])
		res.append(row)
	return res

def f(n,k,lst):
	dp = get_dp(n,k,lst)
	print(dp[n-1][k])

prime = get_prime(3162)

for _ in range(nr()):
	n,k = nrs()
	f(n,k,nrs())
",O(n ^ 3)
"import itertools



class Solution(object):
    def minimumTime(self, jobs, workers):
        def ceil_divide(a, b):
            return (a+(b-1))//b

        jobs.sort()
        workers.sort()
        return max(ceil_divide(j, w) for j, w in zip(jobs, workers))",O(nlogn)
"class Solution(object):
    def merge(self, intervals):
        intervals.sort()
        result = []
        for interval in intervals:
            if not result or interval[0] > result[-1][1]:
                result.append(interval)
            else:
                result[-1][1] = max(result[-1][1], interval[1])
        return result",O(nlogn)
"class Solution(object):
    def beautifulArray(self, N):
        result = [1]
        while len(result) < N:
            result = [i*2 - 1 for i in result] + [i*2 for i in result]
        return [i for i in result if i <= N]",O(n)
"l,r=map(int,input().split())
if(l==r):
    print(0)
else:
    if(r&(r-1)==0):
        print(r^(r-1))
    else:
        x=l^r
        p1=1
        while(p1<=x):
            p1*=2
        print(p1-1)
",O(logn)
"n = int(input())
lis = list(map(int, input(). split()))
sor = sorted(lis)
cnt = 0
for i in range(n):
    if lis[i] != sor[i]:
        cnt += 1
if cnt > 2:
    print(""NO"")
else:
    print(""YES"")",O(nlogn)
"x, k = map(int, input().split())
mod = 1000000007
if (k == 0):
    print((2 * x) % mod)
elif (x == 0):
    print(0)
else:
    ans = ((2 * x - 1) * pow(2, k, mod) + 1) % mod
    print(ans)
",O(logn)
"class Solution(object):
    def countOrders(self, n):
        MOD = 10**9+7
        result = 1
        for i in reversed(range(2, 2*n+1, 2)):
            result = result * i*(i-1)//2 % MOD
        return result",O(n)
"class Solution2(object):
    def minimumCost(self, nums, cost, k):
        prefix1 = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix1[i+1] = prefix1[i]+nums[i]
        prefix2 = [0]*(len(cost)+1)
        for i in range(len(nums)):
            prefix2[i+1] = prefix2[i]+cost[i]
        dp = [float(""inf"")]*(len(nums)+1)
        dp[-1] = 0
        for i in reversed(range(len(nums))):
            for j in range(i, len(nums)):
                dp[i] = min(dp[i], prefix1[j+1]*(prefix2[j+1]-prefix2[i])+dp[j+1]+(k*(prefix2[-1]-prefix2[i])))
        return dp[0]",O(n ^ 2)
"class Solution2(object):
    def confusingNumberII(self, n):
        lookup = {""0"":""0"", ""1"":""1"", ""6"":""9"", ""8"":""8"", ""9"":""6""}
        centers = {""0"":""0"", ""1"":""1"", ""8"":""8""}
        def totalCount(n): 
            s = str(n)
            total = 0 
            p = len(lookup)**(len(s)-1)
            for i in range(len(s)+1):
                if i == len(s):
                    total += 1
                    break
                smaller = sum(int(c < s[i]) for c in lookup.keys())
                total += smaller * p
                if s[i] not in lookup:
                    break
                p //= len(lookup)
            return total

        def validCountInLessLength(n): 
            s = str(n)
            valid = 0
            total = len(centers)
            for i in range(1, len(s), 2): 
                if i == 1:
                    valid += len(centers)
                else:
                    valid += total * (len(lookup)-1)
                    total *= len(lookup)
            total = 1
            for i in range(2, len(s), 2): 
                valid += total * (len(lookup)-1)
                total *= len(lookup)
            return valid

        def validCountInFullLength(n): 
            s = str(n)
            half_s = s[:(len(s)+1)//2]
            total = 0
            choices = centers if (len(s) % 2) else lookup
            p = int(len(lookup)**(len(half_s)-2) * len(choices))
            for i in range(len(half_s)):
                if i == len(half_s)-1:
                    total += sum(int(c < half_s[i]) for c in choices.keys() if len(s) != 2 or c != '0')
                    if half_s[i] not in choices:
                        break
                    tmp = list(half_s)+[lookup[half_s[i]] for i in reversed(range(len(half_s)-(len(s) % 2)))]
                    total += int("""".join(tmp)) <= n
                    break
                smaller = sum(int(c < half_s[i]) for c in lookup.keys() if i != 0 or c != '0')
                total += smaller * p
                if half_s[i] not in lookup:
                    break
                p //= len(lookup)
            return total

        def f(n): 
            return totalCount(n) - validCountInLessLength(n) - validCountInFullLength(n)

        return f(n) - f(0)",O(logn)
"s = input()
slen = len(s)
ans = 0
for st1 in range(slen - 1):
    for end1 in range(st1 + 1, slen):
        end2 = end1 + 1
        sub1 = s[st1:end1]
        for st2 in range(st1 + 1, slen):
            if end2 > slen:
                break

            sub2 = s[st2:end2]
            subLen = len(sub1)
            if sub1 == sub2 and ans < subLen:
                ans = subLen
            end2 += 1

print(ans)
",O(n ^ 3)
"import math
from math import gcd,floor,sqrt,log
def iin(): return int(input())
def sin(): return input().strip()
def listin(): return list(map(int,input().strip().split()))
def liststr(): return list(map(str,input().strip().split()))
def ceill(x): return  int(x) if(x==int(x)) else int(x)+1
def ceilldiv(x,d): x//d if(x%d==0) else x//d+1
def LCM(a,b): return (a*b)//gcd(a,b)

def solve():
	n = iin()
	cf = dict()
	tc = dict()
	for i in range(n):
		z = listin()
		cf[z[0]] = z[1]
	m = iin()
	for i in range(m):
		z = listin()
		tc[z[0]] = z[1]

	sett = set(list(cf.keys()) + list(tc.keys()))

	summ = 0
	for i in sett:
		temp = 0
		try:
			temp = max(tc[i],cf[i])
		except:
			try:
				temp = cf[i]
			except:
				temp = tc[i]
		summ += temp
	print(summ)

t = 1

for hula in range(t):
	solve()
",O(nlogn)
"import collections



class Solution(object):
    def equalDigitFrequency(self, s):
        MOD = 10**9+7
        D = 27
        lookup = set()
        for i in range(len(s)):
            cnt = collections.Counter()
            h = max_cnt = 0
            for j in range(i, len(s)):
                d = ord(s[j])-ord('0')+1
                h = (h*D+d)%MOD
                cnt[d] += 1
                max_cnt = max(max_cnt, cnt[d])
                if len(cnt)*max_cnt == j-i+1:
                    lookup.add(h)
        return len(lookup)",O(n ^ 2)
"n=int(input())
a=list(map(int,input().split()))
b=[0]*n
for i in range(n):
    if(i+1>a[i]):
        b[i]=i+1
    else:
        q=(a[i]-(i+1)+n)//n
        b[i]=i+1 + q*n
print(b.index(min(b))+1)",O(n)
"import sys, math
import io, os

from bisect import bisect_left as bl, bisect_right as br, insort

from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n')
def out(var): sys.stdout.write(str(var) + '\n')
from decimal import Decimal

INF = float('inf')
mod = int(1e9) + 7

def cal(l,r):
    if l==r:
        dp1[l][r]=1
        dp2[l][r]=a[l]
    if dp1[l][r]:
        return dp1[l][r]
    for i in range(l,r):
        if cal(l,i)==1 and cal(i+1,r)==1 and dp2[l][i]==dp2[i+1][r]:
            dp1[l][r]=1
            dp2[l][r]=dp2[l][i]+1
    if not dp2[l][r]:
        dp1[l][r]=2
    return dp1[l][r]

def cal2(l,r):
    if dp1[l][r]==1:
        dp3[l][r]=1
        return 1
    elif dp3[l][r]:
        return dp3[l][r]
    ans=INF
    for i in range(l,r):
        ans=min(cal2(l,i)+cal2(i+1,r),ans)
    dp3[l][r]=ans
    return ans

n=int(data())
a=mdata()
ans=[n]
dp1=[[0]*n for i in range(n)]
dp2=[[0]*n for i in range(n)]
dp3=[[0]*n for i in range(n)]
cal(0,n-1)
cal2(0,n-1)
out(dp3[0][n-1])",O(n ^ 3)
"x,k=map(int,input().split())
print(((pow(2,k,1000000007)*((2*x-1)%1000000007))%1000000007+1)%1000000007 if x!=0 else 0)
",O(logn)
"class Solution:
    def jump(self, nums: List[int]) -> int:
        memo = {}

        def dfs(i):
            if i in memo:
                return memo[i]
            if i == len(nums) - 1:
                return 0
            if nums[i] == 0:
                return 1000000

            res = 1000000
            end = min(len(nums), i + nums[i] + 1)
            for j in range(i + 1, end):
                res = min(res, 1 + dfs(j))
            memo[i] = res
            return res

        return dfs(0)
",O(n ^ 2)
"from collections import Counter
n,c=map(int,input().split())
a=list(map(int,input().split()))
counter=Counter()
minus=0
count=a.count(c)
maxi=0
for i in range(n):
    if a[i]!=c:
        if counter[a[i]]<minus:
            counter[a[i]]=minus
        counter[a[i]]+=1
        maxi=max(maxi,counter[a[i]]+count-minus)
    else:
        minus+=1
print(max(maxi,minus))",O(n)
"n, s = map(int, input().split())
res = 0
for i in range(n, 0, -1):
    res += s//i
    s = s % i
print(res)",O(n)
"def digit_sum(n):
	cnt = 0
	while n:
		cnt += n % 10
		n //= 10
	return cnt

def bsearch(low, high, s):
	h = high
	ans = -1
	while low <= high:
		mid = (low + high) // 2
		if mid - digit_sum(mid) >= s:
			ans = mid
			high = mid - 1
		else:
			low = mid + 1
	if ans == -1:
		return 0
	else:
		return h - ans + 1

n, s = map(int, input().split())
st = 1
end = 10
cnt = 0
cnt += (bsearch(1, n, s))
print(cnt)
",O(logn)
"def f(n):
    return n + n//2

n = int(input())
print(f(n))
",O(1)
"import sys
input = sys.stdin.readline

n,m=map(int,input().split())
A=[list(map(int,input().split())) for i in range(n)]

SET=set()
for a in A:
    SET|=set(a)

compression_dict={a: ind for ind, a in enumerate(sorted(SET))}

for i in range(n):
    A[i]=[compression_dict[a] for a in A[i]]

OK=0
NG=len(compression_dict)
ANS=[1,1]
B=[set()]*n
P=[2,3,5,7,11,13,17,19]
Q=1
for j in range(m):
    Q*=P[j]

import math

def ya(x):
    xr=math.ceil(math.sqrt(x))

    LIST=[]
    for i in range(1,xr+1):
        if x%i==0:
            LIST.append(i)
            LIST.append(x//i)

    return LIST

while NG>OK+1:
    mid=(OK+NG)//2
    SET=set()

    for i in range(n):
        NOW=1
        for j in range(m):
            if A[i][j]>=mid:
                NOW*=P[j]
        B[i]=NOW
        SET.add(NOW)

    flag=0

    for s in SET:
        for l in ya(s):
            if Q//l in SET:
                flag=1
                OK=mid
                break
        if flag:
            break

    else:
        NG=mid

SET=set()
for i in range(n):
    NOW=1
    for j in range(m):
        if A[i][j]>=OK:
            NOW*=P[j]
    B[i]=NOW
    SET.add(NOW)

flag=0
for i in range(n):
    for l in ya(B[i]):
        if Q//l in SET:
            ANS1=i
            flag=1
            break
    if flag:
        break

LIST=ya(B[i])
SET=set(LIST)

for i in range(n):
    if Q//B[i] in SET:
        ANS2=i

print(ANS1+1,ANS2+1)
",np
"class Solution(object):
    def getLargestOutlier(self, nums):
        result = float(""-inf"")
        total = sum(nums)
        cnt = collections.defaultdict(int)
        for x in nums:
            cnt[x] += 1
        for x in nums:
            if (total-x)%2:
                continue
            target = (total-x)//2
            if target in cnt and (cnt[target]-int(target == x) >= 1):
                result = max(result, x)
        return result",O(n)
"
import collections


class Solution(object):
    def customSortString(self, S, T):
        counter, s = collections.Counter(T), set(S)
        result = [c*counter[c] for c in S]
        result.extend([c*counter for c, counter in counter.items() if c not in s])
        return """".join(result)

",O(n)
"class Solution2(object):
    def maxDepthAfterSplit(self, seq):
        A, B = 0, 0
        result = [0]*len(seq)
        for i, c in enumerate(seq):
            point = 1 if c == '(' else -1
            if (point == 1 and A <= B) or \
               (point == -1 and A >= B):
                A += point
            else:
                B += point
                result[i] = 1
        return result",O(n)
"N = 10**5+5
MOD = 10**9+7

freq = [0 for i in range(N)]

p2 = [0 for i in range(N)]
p2[0] = 1
for i in range(1,N):
    p2[i] = p2[i-1]*2
    p2[i]%=MOD

def Calculate_Mobius(N):
    arr = [1 for i in range(N+1)]
    prime_count = [0 for i in range(N+1)]

    mobius_value = [0 for i in range(N+1)]
    for i in range(2,N+1):
        if prime_count[i]==0:
            for j in range(i,N+1,i):
                prime_count[j]+=1
                arr[j] = arr[j] * i

    for i in range(1, N+1):
        if arr[i] == i:
            if (prime_count[i] & 1) == 0:
                mobius_value[i] = 1
            else:
                mobius_value[i] = -1
        else:
            mobius_value[i] = 0

    return mobius_value

mobius = Calculate_Mobius(N)
n = int(input())
b = [int(i) for i in input().split()]

for i in b:
    freq[i]+=1

ans = 0
for i in range(1,N):

    cnt = 0
    for j in range(i,N,i):
        cnt += freq[j]

    total_subsequences = p2[cnt] - 1
    ans = (ans + (mobius[i] * total_subsequences)%MOD)%MOD

ans += MOD
print(ans%MOD)
",np
"import sys
n=int(input())
s=input()
s+=s
h=0
for i in range(n):
	if s[i]=='H':
		h+=1
ans=h
for i in range(n):
	c=0
	for j in range(i,i+h):
		if s[j]=='T':
			c+=1
	ans=min(ans,c)
print(ans)
",O(n)
"n,k=map(int,input().split())
a=list(map(int,input().split()))
b=list(a)
b.sort()
c=[]
sum=0
for i in range(1,k+1):
	c.append(b[-i])
	sum+=b[-i]
print(sum)
d=[]
for i in range(n):
	if a[i] in c:
		d.append(i)
		c.remove(a[i])
	else:
		pass
d.insert(0,-1)
d[-1]=n-1
e=[]
for i in range(1,len(d)):
    e.append(d[i]-d[i-1])
print("" "".join(map(str,e)))",O(nlogn)
"class Solution(object):
    def reconstructMatrix(self, upper, lower, colsum):
        upper_matrix, lower_matrix = [0]*len(colsum), [0]*len(colsum)
        for i in range(len(colsum)):
            upper_matrix[i] = int(upper > 0 and colsum[i] != 0)
            lower_matrix[i] = colsum[i]-upper_matrix[i]
            upper -= upper_matrix[i]
            lower -= lower_matrix[i]
        return [upper_matrix, lower_matrix] if upper == lower == 0 else []",O(n)
"n = int(input())
a = list(input())
b = list(input())

count = 0
skip_next = False
for idx in range(n - 1):
    if skip_next:
        skip_next = False
        continue
    if a[idx] != b[idx] and a[idx] == b[idx + 1] and a[idx + 1] == b[idx]:
        count += 1
        a[idx] = b[idx]
        a[idx + 1] = b[idx + 1]
        skip_next = True

for idx in range(n):
    if a[idx] != b[idx]:
        count += 1

print(count)
",O(n)
"n, q = map(int, input().split(' '))
a = list(map(int, input().split(' ')))

def p(c_k, r):
    l = 0
    while r - l > 1:
        z = (r + l) // 2
        if pr_a[z] > c_k:
            r = z
        else:
            l = z
    return l

pr_a = []
for i in range(n):
    pr_a.append(a[i])
    if i > 0:
        pr_a[i] += pr_a[i - 1]
k = list(map(int, input().split(' ')))
c_k = 0
ans = []
for qq in range(q):
    c_k += k[qq]
    l = p(c_k, n - 1)
    if pr_a[l] <= c_k:
        l += 1
    if c_k >= pr_a[n - 1]:
        c_k = 0
        l = 0
    ans.append(str(n - l))
print('\n'.join(ans))
",O(nlogn)
"s=input()
a=list(map(int,input().split()))
k=sorted(a)
b=0
q=0
m=0
for i in k:
    b=b+i
for i in k[::-1]:
    q=q+i
    m=m+1
    if q>(b/2):
        break
print(m)",O(nlogn)
"class Solution2(object):
    def numWays(self, n, k):
        if n == 0:
            return 0
        elif n == 1:
            return k
        ways = [0] * n
        ways[0] = k
        ways[1] = (k - 1) * ways[0] + k
        for i in range(2, n):
            ways[i] = (k - 1) * (ways[i - 1] + ways[i - 2])
        return ways[n - 1]",O(n)
"n = int(input())
a = input()
zero = 0
for i in range(len(a)):
    if (a[i] == ""0""):
        zero += 1
if (""1"" in a):
    print(""1"", end="""")
    print(""0""*zero)
else:
    print(""0""*zero)",O(n)
"class Solution(object):
    def findSubtreeSizes(self, parent, s):
        def iter_dfs():
            lookup = [[] for _ in range(26)]
            result = [1]*len(parent)
            stk = [(1, 0)]
            while stk:
                step, u = stk.pop()
                if step == 1:
                    lookup[ord(s[u])-ord('a')].append(u)
                    stk.append((2, u))
                    for v in reversed(adj[u]):
                        stk.append((1, v))
                elif step == 2:
                    for v in adj[u]:
                        result[lookup[ord(s[v])-ord('a')][-1] if lookup[ord(s[v])-ord('a')] else u] += result[v]
                    lookup[ord(s[u])-ord('a')].pop()
            return result
        
        adj = [[] for _ in range(len(parent))]
        for v, u in enumerate(parent):
            if u != -1:
                adj[u].append(v)
        return iter_dfs()",O(n)
"class Solution(object):
    def rotateString(self, A, B):
        def check(index):
            return all(A[(i+index) % len(A)] == c
                       for i, c in enumerate(B))

        if len(A) != len(B):
            return False

        M, p = 10**9+7, 113
        p_inv = pow(p, M-2, M)

        b_hash, power = 0, 1
        for c in B:
            b_hash += power * ord(c)
            b_hash %= M
            power = (power*p) % M

        a_hash, power = 0, 1
        for i in range(len(B)):
            a_hash += power * ord(A[i%len(A)])
            a_hash %= M
            power = (power*p) % M

        if a_hash == b_hash and check(0): return True

        power = (power*p_inv) % M
        for i in range(len(B), 2*len(A)):
            a_hash = (a_hash-ord(A[(i-len(B))%len(A)])) * p_inv
            a_hash += power * ord(A[i%len(A)])
            a_hash %= M
            if a_hash == b_hash and check(i-len(B)+1):
                return True

        return False",O(n)
"a = input()
b = input()
la = [int(x) for x in a]
res = []
la.sort()
la = la[::-1]
lb = [int(x) for x in b]
cnt = [0] * 20

def check():
    tres = 0
    for x in range(len(res)):
        tres *= 10
        tres += int(res[x])
    return tres <= int(b)
if len(a) < len(b):
    for i in range(len(la)):
        print(la[i], end = '')
    print()
else:
    for i in range(len(la)):
        cnt[la[i]] += 1
    flag = 0
    for i in range(len(lb)):
        if flag == 0 and cnt[lb[i]]:
            res.append(lb[i])
            cnt[lb[i]] -= 1
        else:
            flag = i - 1
            for j in range(lb[i] - 1, -1, -1):
                if cnt[j]:
                    res.append(j)
                    cnt[j] -= 1
                    break
            for j in range(9, -1, -1):
                while cnt[j]:
                    res.append(j)
                    cnt[j] -= 1
            break
    while not check():
        temp = []
        cnt = [0] * 20
        for x in range(flag):
            temp.append(res[x])
            cnt[res[x]] -= 1
        for i in la:
            cnt[i] += 1

        res = temp

        for v in range(lb[flag] - 1, -1, -1):
            if cnt[v]:
                res.append(v)
                cnt[v] -= 1
                break
        for v in range(9, -1, -1):
            while cnt[v]:
                res.append(v)
                cnt[v] -= 1

        flag -= 1
    for i in range(len(res)):
        print(res[i], end = '')
    print()",O(n ^ 3)
"n = int(input())
a = list(map(int, input().split()))
summ=0
a.sort()
if len(a)==1:
    if a[0]%2==1:
        print('sjfnb')
    else:
        print('cslnb')
elif a[0] == a[1]==0:
    print('cslnb')
else:
    x = False
    for i in range(2, n):
        if a[i]==a[i-1] and a[i-1]==a[i-2]:
            x=True
    if x:
        print('cslnb')
    else:
        x = False
        for i in range(2, n):
            if a[i]==a[i-1] and a[i]-1==a[i-2]:
                x=True
        if x:
            print('cslnb')
        else:
            summ=0
            for i in range(1, n):
                if a[i]==a[i-1]:
                    summ+=1
            if summ>1:
                print('cslnb')
            else:
                summ=0
                for i in range(n):
                    summ+=a[i]-i
                if summ%2==0:
                    print('cslnb')
                else:
                    print('sjfnb')
",O(nlogn)
"import sys
sys.stderr = sys.stdout

from math import inf

def explorer(n, m, k, R, C):
    if k % 2:
        return None

    G = [[0] * m for _ in range(n)]
    G_ = [[0] * m for _ in range(n)]
    for _ in range(k // 2):
        for i in range(n):
            for j in range(m):
                x = inf
                if i > 0:
                    x = min(x, G[i-1][j] + 2*C[i-1][j])
                if i + 1 < n:
                    x = min(x, G[i+1][j] + 2*C[i][j])
                if j > 0:
                    x = min(x, G[i][j-1] + 2*R[i][j-1])
                if j + 1 < m:
                    x = min(x, G[i][j+1] + 2*R[i][j])
                G_[i][j] = x
        G, G_ = G_, G
    return G

def main():
    n, m, k = readinti()
    R = readintll(n)
    C = readintll(n-1)
    G = explorer(n, m, k, R, C)
    if G:
        print(llstr(G))
    else:
        s = ' '.join('-1' for _ in range(m))
        print('\n'.join(s for _ in range(n)))

def readint():
    return int(input())

def readinti():
   return map(int, input().split())

def readintt():
   return tuple(readinti())

def readintl():
   return list(readinti())

def readinttl(k):
    return [readintt() for _ in range(k)]

def readintll(k):
    return [readintl() for _ in range(k)]

def lstr(l):
    return ' '.join(map(str, l))

def llstr(ll):
    return '\n'.join(map(lstr, ll))

def log(*args, **kwargs):
    print(*args, **kwargs, file=sys.__stderr__)

if __name__ == '__main__':
    main()
",O(n ^ 3)
"x, k = map(int, input().split())

if x == 0:
    result = 0
else:
    modulo = 10**9 + 7

    x %= modulo

    result = pow(2, k, modulo)*(2*x - 1) + 1
    result %= modulo

print(result)",O(logn)
"a,b = map(int,input().split())
a,b = min(a, b), max(a, b)
A = bin(a)[2:]
B = bin(b)[2:]
A = ""0"" * (len(B) - len(A)) + A
diff = 0
for i in range(len(A)):
    if(A[i]!=B[i]):
        diff = len(A) - i
        break
print((2**diff) - 1)
",O(logn)
"import os,sys
from io import BytesIO,IOBase
from math import inf,isinf

def solve(s,t):
    if len(t) == 1:
        if s.count(t[0]):
            return 'YES'
        return 'NO'
    for i in range(1,len(t)):
        dp = [[-inf]*(i+1) for _ in range(len(s)+1)]
        dp[0][0] = 0
        for j in range(len(s)):
            dp[j+1] = dp[j][:]
            for k in range(i+1):
                if k != i and s[j] == t[k]:
                    dp[j+1][k+1] = max(dp[j+1][k+1],dp[j][k])
                if dp[j][k]+i != len(t) and not isinf(dp[j][k]) and s[j] == t[dp[j][k]+i]:
                    dp[j+1][k] = max(dp[j+1][k],dp[j][k]+1)

        for l in range(len(s)+1):
            if dp[l][-1] == len(t)-i:
                return 'YES'
    return 'NO'

def main():
    for _ in range(int(input())):
        s = input().strip()
        t = input().strip()
        print(solve(s,t))

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(n ^ 3)
"def nr(): return nrs()[0]
def nrs(): return [int(i) for i in input().split()]

n = 10**7
squares = [i * i for i in range(1, 3162)]

p = list(range(n + 1))
for i in range(1, n + 1):
	if p[i] == i:
		for sq in squares:
			if i * sq > n: break
			p[i * sq] = i

for _ in range(nr()):
	N, K = nrs()
	A = [p[a] for a in nrs()]
	dp = [N] * (K + 1)
	dp[0] = 1
	used = [{}] * (K + 1)
	for a in A:
		for j in range(K, -1, -1):
			if dp[j] == N: continue
			if a in used[j]:
				if j < K and dp[j + 1] > dp[j]:
					dp[j + 1] = dp[j]
					used[j + 1] = used[j]
				dp[j] += 1
				used[j] = {}
			used[j][a] = 1
	print(min(dp))
",O(n ^ 3)
"lst = list()

lst.append(0)
lst.append(1)

now = 1
while now <= 1e25 :
	now = now * 4 + 1

	lst.append(now)

t = int(input())

for i in range(t):
	s = input().split()
	n = int(s[0])
	k = int(s[1])
	if(n >= 34):
		print(""YES "" + str(n - 1))
		continue

	sek = 0
	ambil = 1
	nyak = 0
	cnt = 0

	sudah = False
	while (sek < n):
		cnt = cnt + (1 << (sek + 1)) - 1

		if cnt > k:
			print(""NO"")
			sudah = True
			break

		next_ambil = (ambil + 1) * 2 - 1
		sisa = 4 * ambil - next_ambil
		ambil = next_ambil

		sek += 1
		nyak = nyak + sisa * lst[n - sek]
		if (nyak + cnt) >= k :
			print(""YES "" + str(n - sek))
			sudah = True
			break

	if sudah == False:
		print(""NO"")
",O(n)
"class Solution:
    def getSum(self, a: int, b: int) -> int:
        mask = 0xFFFFFFFF
        max_int = 0x7FFFFFFF

        while b != 0:
            carry = (a & b) << 1
            a = (a ^ b) & mask
            b = carry & mask

        return a if a <= max_int else ~(a ^ mask)
",O(1)
"t = int(input())

for iter in range(t):
    n, k = map(int, input().split())
    if n >= 50:
        if k == 0:
            print(""YES "" + str(n))
        else:
            print(""YES "" + str(n - 1))
    else:
        a = [0] * (n + 1)
        b = [0] * (n + 1)
        c = [0] * (n + 1)
        a[0] = 0
        b[n] = 1
        c[n] = 0

        for i in range(1, n + 1):
            a[i] = 4 * a[i - 1] + 1
        for i in range(n - 1, -1, -1):
            b[i] = b[i + 1] * 2 + 1
        for i in range(n - 1, -1, -1):
            c[i] = c[i + 1] + b[i + 1]

        res = -1
        for d in range(n + 1):
            if c[d] <= k and k <= a[n] - a[d] * b[d]:
                res = d

        if res == -1:
            print(""NO"")
        else:
            print(""YES "" + str(res))
",O(n)
"import collections


class Solution2(object):
    def countPairs(self, root, distance):
        def dfs(distance, node):
            if not node:
                return 0, collections.Counter()
            if not node.left and not node.right:
                return 0, collections.Counter([0])
            left, right = dfs(distance, node.left), dfs(distance, node.right)
            result = left[0]+right[0]
            for left_d, left_c in left[1].items():
                for right_d,right_c in right[1].items():
                    if left_d+right_d+2 <= distance:
                        result += left_c*right_c
            return result, collections.Counter({k+1:v for k,v in (left[1]+right[1]).items()})
        
        return dfs(distance, root)[0]",O(n)
"import pandas as pd



def Solution(employees: pd.DataFrame) -> pd.DataFrame:
    return employees.head(3)",O(1)
"from collections import defaultdict
from sys import stdin
input = stdin.readline
def check(mid, m):
    d = defaultdict(int)
    for idx, i in enumerate(a):
        string = ''
        for j in i:
            if j >= mid:
                string+='1'
            else:
                string+='0'
        d[int(string, 2)] = idx
    for i in d.keys():
        for j in d.keys():
            if i|j == 2**m - 1:
                 return [d[i], d[j]]
    return []
def binarySearch(lo, hi, m):
    ans = []
    while lo < hi:
        mid = lo + (hi-lo+1)//2
        x = check(mid, m)
        if x:
            lo = mid
            ans = [x[0]+1, x[1]+1]
        else:
            hi = mid-1
    return ans
n, m = map(int, input().split())
a = []
for i in range(n):
    a.append(list(map(int, input().split())))
print(*binarySearch(-1, 10**9+1, m))",np
"class Solution:
    def countSubstrings(self, s: str) -> int:
        n, res = len(s), 0
        dp = [[False] * n for _ in range(n)]

        for i in range(n - 1, -1, -1):
            for j in range(i, n):
                if s[i] == s[j] and (j - i <= 2 or dp[i + 1][j - 1]):
                    dp[i][j] = True
                    res += 1

        return res
",O(n ^ 2)
"class Solution(object):
    def mostVisited(self, n, rounds):
        return list(range(rounds[0], rounds[-1]+1)) or \
               list(range(1, rounds[-1]+1)) + list(range(rounds[0], n+1))",O(n)
"n, m, k =map(int, input().split())
horizontal = [list(map(int, input().split())) for i in range(n)]
vertical = [list(map(int, input().split())) for i in range(n-1)]
if k%2 or max(n, m)==1:print(*["" "".join(['-1']*m) for i in range(n)], sep='\n');exit()
dp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)]
for length in range(1, k//2+1):
    for i in range(n):
        for j in range(m):
            left_path = 10e7 if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]
            right_path = 10e7 if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]
            top_path = 10e7 if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]
            bottom_path = 10e7 if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]
            dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])
for i in range(n):print(*[dp[i][j][k//2]*2 for j in range(m)])
",O(n ^ 3)
"class Solution2(object):
    def minOperations(self, target, arr):
        lookup = {x:i for i, x in enumerate(target)}
        st = SegmentTree(len(lookup))
        for x in arr:
            if x not in lookup:
                continue
            st.update(lookup[x], lookup[x], st.query(0, lookup[x]-1)+1 if lookup[x] >= 1 else 1)
        return len(target)-(st.query(0, len(lookup)-1) if len(lookup) >= 1 else 0)",O(nlogn)
"class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for c in tokens:
            if c == ""+"":
                stack.append(stack.pop() + stack.pop())
            elif c == ""-"":
                a, b = stack.pop(), stack.pop()
                stack.append(b - a)
            elif c == ""*"":
                stack.append(stack.pop() * stack.pop())
            elif c == ""/"":
                a, b = stack.pop(), stack.pop()
                stack.append(int(float(b) / a))
            else:
                stack.append(int(c))
        return stack[0]
",O(n)
"n, m, k = map(int, input().split())
DATA = [input() for i in range(n)]

INF = 1 << 60
dp = [[INF]*(k + 10) for i in range(n + 10)]
dp[0][0] = 0

COST = [[INF]*(k + 10) for i in range(n + 10)]
for i, string in enumerate(DATA):

    stack = []
    for j in range(m):
        if string[j] == ""1"":
            stack.append(j)
    L = len(stack)
    for j in range(k + 10):
        if j >= L:
            COST[i + 1][j] = 0
            continue
        else:
            for pos in range(j + 1):
                l = pos
                r = pos + L - 1 - j
                COST[i+1][j] = min(COST[i+1][j], stack[r] - stack[l] + 1)
for day in range(1, n + 1):
    for used_cost in range(k + 1):
        dp[day][used_cost] = min(dp[day - 1][prev_cost] + COST[day]
                                 [used_cost - prev_cost] for prev_cost in range(used_cost + 1))

ans = min(dp[n][used_cost] for used_cost in range(k + 1))
print(ans)
",O(n ^ 3)
"class Solution(object):
    def numSteps(self, s):
        result, carry = 0, 0
        for i in reversed(range(1, len(s))):
            if int(s[i]) + carry == 1:
                carry = 1 
                result += 2
            else:
                result += 1
        return result+carry",O(n)
"import collections


class Solution(object):
    def countTriplets(self, arr):
        count_sum = collections.defaultdict(lambda: [0, 0])
        count_sum[0] = [1, 0]
        result, prefix = 0, 0
        for i, x in enumerate(arr):
            prefix ^= x
            c, t = count_sum[prefix]
            result += c*i - t
            count_sum[prefix] = [c+1, t+i+1]
        return result",O(n)
"class Solution(object):
    def fixedRatio(self, s, num1, num2):
        lookup = collections.Counter()
        lookup[0] = 1
        result = curr = 0
        for c in s:
            curr += -num2 if c == '0' else +num1
            result += lookup[curr]
            lookup[curr] += 1
        return result",O(n)
"class Solution(object):
    def checkValidCuts(self, n, rectangles):
        def check(idx):
            cnt = 0
            curr = rectangles[0][idx+2]
            for x in rectangles:
                cnt += int(curr <= x[idx])
                curr = max(curr, x[idx+2])
            return cnt >= 2
    
        for idx in range(2):
            rectangles.sort(key=lambda x: x[idx])
            if check(idx):
                return True
        return False",O(nlogn)
"import math
import collections
import bisect
import heapq
import time
import itertools
import sys

Q = int(input())
ans = []

for i in range(Q):
    l, r = map(int, input().split())
    if l % 2 == 0 and r % 2 == 0:
        ans.append((r-l)//2 + l)
    elif l % 2 == 1 and r % 2 == 0:
        ans.append((r-l+1)//2)
    elif l % 2 == 1 and r % 2 == 1:
        ans.append(0-(r-l)//2-l)
    else:
        ans.append(0-(r-l+1)//2)

print('\n'.join(map(str, ans)))",O(1)
"s = input()

def palindrome(s):
    i=0
    j=len(s)-1
    p=True
    while i<=j:
        if s[i]!=s[j]:
            p=False
            break
        i+=1
        j-=1
    return p

ans=0
for i in range(len(s)):
    for j in range(len(s)-1, i,-1):
        if not palindrome(s[i:j+1]):
            ans=max(ans, len(s[i:j+1]))
            break

print(ans)
",O(n)
"class Solution(object):
    def minimumBoxes(self, apple, capacity):
        capacity.sort(reverse=True)
        total = sum(apple)
        for i in range(len(capacity)):
            total -= capacity[i]
            if total <= 0:
                return i+1
        return -1",O(nlogn)
"class Solution2(object):
    def isSubstringPresent(self, s):
        lookup = collections.defaultdict(set)
        for i in range(len(s)-1):
            lookup[s[i]].add(s[i+1])
        return any(s[i] in lookup[s[i+1]] for i in range(len(s)-1))",O(n)
"n = [int(x) for x in input().split()]
a = []
for i in range(3):
	a.append([int(x) for x in input().split()])
	a[i].sort(reverse=True)

dp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]
ans = 0
for i in range(n[0] + 1):
	for j in range(n[1] + 1):
		for k in range(n[2] + 1):
			if i < n[0] and j < n[1]:
				dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])
			if i < n[0] and k < n[2]:
				dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])
			if j < n[1] and k < n[2]:
				dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])
			ans = max(ans, dp[i][j][k])

print(ans )",O(n ^ 3)
"def f(n,s):
    d=[-n,-n];
    d[s]=0;
    for i in range(y//g):
        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)];
    return d[s];
import math;
n,x,y=map(int,input().split());
g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));
y=y+x;
print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np
"class Solution(object):
    def findTheLongestBalancedSubstring(self, s):
        result = 0
        for i in range(len(s)):
            left, right = i+1, i
            while left-1 >= 0 and right+1 < len(s) and s[left-1] == '0' and s[right+1] == '1':
                left -= 1
                right += 1
            result = max(result, right-left+1)
        return result",O(n ^ 2)
"a,b=map(int,input().split())
c=list(map(int,input().split()))
d=list(map(int,input().split()))
e=[]
for i in c:
    if i in d:
        e.append(i)
for j in e:
    print(j,end="" "")",O(n ^ 2)
"n = int(input())
if n == 1:
	print(""1"")
elif n == 2:
	print(""1 2"")
else:
	base = 1
	gap = 2
	cur = base
	next = 1
	ans = ''
	for i in range(n - 1):
		ans += str(base) + ' '
		next = cur
		cur += gap
		if cur > n:
			base *= 2
			gap *= 2
			cur = base
		next = max(next, cur)
	ans += str(next)
	print(ans)",O(n)
"import collections



class Solution(object):
    def checkStrings(self, s1, s2):
        return all(collections.Counter(s1[j] for j in range(i, len(s1), 2)) == collections.Counter(s2[j] for j in range(i, len(s2), 2)) for i in range(2))",O(n)
"

class Solution(object):
    def countElements(self, nums):
        mn = min(nums)
        mx = max(nums)
        return sum(mn < x < mx for x in nums)
",O(n)
"class Solution(object):
    def lengthOfLongestSubstring(self, s):
        result, left = 0, 0
        lookup = {}
        for right in range(len(s)):
            if s[right] in lookup:
                left = max(left, lookup[s[right]]+1)
            lookup[s[right]] = right
            result = max(result, right-left+1)
        return result",O(n)
"from copy import deepcopy
a = list(map(int, list(input())))
b = list(map(int, list(input())))
cnt1 = [0] * 10; cnt2 = [0] * 10
ans = []
if (len(a) != len(b)):
    print(''.join(map(str,sorted(a, reverse=True))))
    exit()
for i in range(len(b) + 1):
    ok = 1
    tmp = deepcopy(a)
    for j in range(i):
        if b[j] in tmp:
            tmp.pop(tmp.index(b[j]))
        else:
            ok = 0
            break
    if not ok: continue
    pls = -1
    ind = -1
    for j in range(len(tmp)):
        if (tmp[j] < b[i]):
            if (tmp[j] > pls):
                ind = j
                pls = tmp[j]
    if pls == -1 and len(tmp) != 0: continue
    else:
        if (len(tmp) > 0): tmp.pop(ind)
        if i == len(b): ans.append(''.join(map(str, b[:i:])))
        else: ans.append(''.join(map(str, b[:i:])) + str(pls) + ''.join(map(str, sorted(tmp, reverse=True))))
print(max(ans))",O(n ^ 3)
"from math import factorial
s1 = input()
s2 = input()
p = 0
m = 0
blank = 0
for i in range(len(s1)):
    if (s1[i] == ""+""):
        p += 1
    else:
        m += 1
    if (s2[i] == ""+""):
        p -= 1
    elif (s2[i]==""-""):
        m -= 1
    else:
        blank += 1
if (m<0 or p<0):
    print(0)
else:
    if (m==0):
        print(0.5 ** p)
    elif (p==0):
        print(0.5 ** m)
    else:
        b = blank
        print((factorial(b)/factorial(p)/factorial(m))*(0.5**b))
",np
"from math import sin, pi

n, r = map(int, input().split())

print(r * sin(pi / n) / (1 - sin(pi / n)))
",O(1)
"import os
import sys
from math import *
from collections import *

from heapq import *
from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M = 998244353
EPS = 1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]

for _ in range(1):

    n,k = value()

    rep = [1] + [0]*((n-k)//2)
    cur = 0

    ans = []
    j = 0
    for i in range(n):
        ans.append(rep[j])
        j = (j + 1)%len(rep)

    if(k == 1): ans = [1] + [0]*(n - 1)
    print(*ans,sep = '')
",O(n)
"class Solution(object):
    def pivotArray(self, nums, pivot):
        result = [pivot]*len(nums)
        left, right = 0, len(nums)-sum(x > pivot for x in nums)
        for x in nums:
            if x < pivot:
                result[left] = x
                left += 1
            elif x > pivot:
                result[right] = x
                right += 1
        return result",O(n)
"import math
s=input()
p=input()
c=1
ss=0
ps=0
k=0
for i in range(len(s)):
	if(p[i]=='?'):
		c*=2
		k+=1
	if(s[i]=='+'):
		ss+=1
	else:
		ss-=1
	if(p[i]=='+'):
		ps+=1
	elif p[i]=='-':
		ps-=1
y=math.fabs(ss-ps)
x=k-y
a=y+x/2
b=k-a
if k<y:
	ans=0.000000000
else:
	ans=math.factorial(a+b)/(math.factorial(a)*math.factorial(b))
	ans/=c
print(""%.12f""%ans)
",np
"from collections import defaultdict
from collections import deque

class graph:
    def __init__(self):
        self.g=defaultdict(list)
    def addedge(self,u,v):
        self.g[u].append(v)
def router(values):
    gr=graph()
    for i in range(len(values)):
        gr.addedge(values[i], i+2)
    return gr.g

def isleaf(node,gr):
    if len(gr[node])==0:
        return True
    return False

def christmas(gr,start,visited):
    q=deque()
    q.append(start)
    visited[start]=True
    count=0
    while q:
        count=0
        value=q.popleft()
        for val in gr[value]:
            if not isleaf(val,gr):
                q.append(val)
                visited[val]=True
            else:
                visited[val]=True
                count=count+1
        if count<3:
            return 'No'
    if count<3:
        return 'No'
    return 'Yes'
n=int(input())
values=[]
for i in range(n-1):
    value=int(input())
    values.append(value)
gr=router(values)
visited=[False]*(n+1)
print(christmas(gr, 1, visited))
",O(n)
"n= int(input())
for i in range(n//3):
    print(-2,1+i*2)
for i in range(n-n//3):
    print(1,i)",O(n)
"n, a, b = map(int,input().split())
if a>1 and b>1: print(""NO""); exit()
if 2<=n<=3 and a == b == 1: print(""NO""); exit()
print(""YES"")

if b == 1:
    adj = [[0]*n for i in range(n)]
    conn = n
    for i in range(n):
        if conn == a: break
        adj[i][i+1] = adj[i+1][i] = 1
        conn-= 1
        if conn == a: break
elif a == 1:
    adj = [[1]*n for i in range(n)]
    conn = n
    for i in range(n): adj[i][i] = 0
    for i in range(n):
        if conn == b: break
        adj[i][i+1] = adj[i+1][i] = 0
        conn-= 1
        if conn == b: break

for row in adj:
    print(*row, sep='')
",O(n ^ 2)
"n = int(input())
arr = list(map(int, input().split()))
pal = 1 if arr[1] > arr[0] else 3 if arr[0] == arr[1] else 5
b = True
arr_pal = [pal]
for i in range(n - 2):
    if arr[i + 1] > arr[i]:
        if pal == 5:
            b = False
            break
        if arr[i + 2] < arr[i + 1]:
            pal = 5
            arr_pal.append(pal)
        else:
            pal += 1
            arr_pal.append(pal)
    elif arr[i + 1] < arr[i]:
        if pal == 1:
            b = False
            break
        if arr[i + 2] > arr[i + 1]:
            pal = 1
            arr_pal.append(pal)
        else:
            pal -= 1
            arr_pal.append(pal)
    else:
        if arr[i + 2] > arr[i + 1]:
            pal = 2 if pal == 1 else 1
            arr_pal.append(pal)
        elif arr[i + 2] < arr[i + 1]:
            pal = 4 if pal == 5 else 5
            arr_pal.append(pal)
        else:
            pal = 4 if pal < 4 else 3
            arr_pal.append(pal)
if arr[-2] < arr[-1]:
    if pal == 5:
        b = False
    else:
        pal += 1
        arr_pal.append(pal)
elif arr[-2] > arr[-1]:
    if pal == 1:
        b = False
    else:
        pal -= 1
        arr_pal.append(pal)
else:
    pal = 3 if pal == 5 else 5
    arr_pal.append(pal)
if b:
    print(*arr_pal)
else:
    print(-1)",O(n)
"from math import *
a,v=list(map(int,input().split()))
l,d,w=list(map(int,input().split()))
if v>w:
    s1=w**2/2/a
    if d<=s1:
        s=min(v**2/2/a,l)
        t=sqrt(2*s/a)+(l-s)/v
    else:
        t=sqrt(2*s1/a)
        s2=min((d-s1)/2,(v**2-w**2)/(2*a))
        if s2==(d-s1)/2:
            t+=2*(sqrt(2*(s1+s2)/a)-sqrt(2*s1/a))
        else:
            t+=2*(v-w)/a+(d-s1-2*s2)/v
        s3=min((v**2-w**2)/2/a,l-d)
        t+=sqrt(2*(s3+s1)/a)-sqrt(2*s1/a)+(l-d-s3)/v
else:
    s=min(v**2/2/a,l)
    t=sqrt(2*s/a)+(l-s)/v
print(t)",O(1)
"ans=[""sjfnb"",""cslnb""]
n=int(input())
l=list(map(int,input().split()))
l.sort()
d=set()
e=0
s=0
for i in range(n):
    if l[i] in d:
        e+=1
        s=l[i]
    d.add(l[i])
if e>1 or l.count(0)>1 or s-1 in d:
    print(ans[1])

else:
    l=[l[i]-i for i in range(n)]

    print(ans[1-sum(l)%2])",O(nlogn)
"n, s = map(int, input().split())
x, y = divmod(s, 9)
if not s:
	x = 0
elif y:
	x += 1
low = x*9
for i in range(low, low+10000):
	if i - sum([int(c) for c in str(i)]) >= s:
		low = i
		break
print(max(n-low+1, 0))
",O(logn)
"n,k=map(int,input().split())
l=list(map(int,input().split()))
p=[]
a=sorted(l)
for i in a:
    if(i%k==0):
        if(i//k in p):
            pass
        else:
            p.append(i)
    else:
        p.append(i)
print(len(set(p)))
",O(nlogn)
"class Solution(object):
    def removeAlmostEqualCharacters(self, word):
        result = 0
        for i in range(len(word)-1):
            if (i+1)+result >= len(word):
                break
            if abs(ord(word[(i+1)+result])-ord(word[i+result])) <= 1:
                result += 1
        return result",O(n)
"def check(mid,n,m,arr):
	masks = {}
	for index in range(n):
		array = arr[index]
		x = 0
		for i in range(m):
			if array[i] >= mid:
				x ^= (1<<i)
		masks[x] = index+1
	ans = False
	a,b = 1,1
	if (1<<m)-1 in masks.keys():
		return True,(masks[(1<<m)-1],masks[(1<<m)-1])
	for i in  masks.keys():
		for j in masks.keys():
			orAns = i|j
			if(orAns == ((1<<m)-1)):
				if i == (1<<m)-1 and (i in masks.keys()):
					a = masks[i]
					ans = True
					break
				elif j == (1<<m)-1 and (j in masks.keys()):
					b =  masks[j]
					ans = True
					break
				elif (i in masks.keys()) and (j in masks.keys()):
					ans = True
					a,b = masks[i],masks[j]
					break
	return ans,(a,b)

def solve(n,m,arr):
	mini = 0
	maxi = int(1e9)+5
	i,j = 1,1
	while(mini<=maxi):
		mid = (mini+maxi)//2
		ans,res = check(mid,n,m,arr)
		if(ans):
			i,j = res
			mini =mid +1
		else:
			maxi = mid -1
	print(i,j)

def main():
	n,m = map(int,input().split(' '))
	arr = []
	for _ in range(n):
		x = list(map(int,input().split(' ')))
		arr.append(x)
	solve(n,m,arr)

main()",np
"class Solution(object):
    def countVowelStrings(self, n):
        def nCr(n, r): 
            if n-r < r:
                return nCr(n, n-r)
            c = 1
            for k in range(1, r+1):
                c *= n-k+1
                c //= k
            return c
    
        return nCr(n+4, 4)",O(1)
"import math
s1=str(input())
s2=str(input())
d1=0;d2=0;n=0
answer=0
for i in s1:
    if i=='+':d1+=1
    else:
        d1-=1
for i in s2:
    if i=='+':d2+=1
    elif i=='?':n+=1
    else:
        d2-=1
if n>=abs(d2-d1):
    y=(n-abs(d1-d2))/2
    if y%1==0:
        answer=math.factorial(n)/math.factorial(n-y)/math.factorial(y)/2**n
print('%.9f'%answer)",np
"def solve():
    n = int(input())
    a_dicts = [{}, {}]
    for j in range(2):
        for i in range(n):
            x = input()
            if x in a_dicts[j]:
                a_dicts[j][x] += 1
            else:
                a_dicts[j][x] = 1
            if x not in a_dicts[1 - j]:
                a_dicts[1 - j][x] = 0
    c = 0
    for k in a_dicts[0]:
        c += abs(a_dicts[0][k] - a_dicts[1][k])
    return c // 2

print(solve())",O(n)
"import sys
from array import array
from bisect import bisect_right

n, k = map(int, input().split())
a = sorted(map(int, input().split())) + [10**9]
ans = n

for x in a[:-1]:
    if a[bisect_right(a, x)] <= x+k:
        ans -= 1

print(ans)
",O(nlogn)
"m={""s"":[0]*9, ""m"":[0]*9, ""p"":[0]*9}
for e in input().split():
    m[e[1]][int(e[0])-1]+=1
ret=2
for t in ""smp"":
    l=m[t]
    if max(l)>=2:
        ret=min(ret, 3-max(l))
    else:
        for i in range(7):
            seq = sum(l[i:i+3])
            ret = min(ret, 3-seq)
print(ret)",O(n)
"n = int(input())
a = list(map(int, input().split()))
s = set(a)
s.discard(0)
print(len(s))
",O(n)
"def lr(a):
    l = [0] * len(a)
    r = [0] * len(a)
    for i in range(len(a)):
        for j in range(i+1, len(a)):
            if a[j] > a[i]:
                r[i] += 1
            if a[i] > a[j]:
                l[j] += 1
    return l, r

n = int(input())
l = [int(i) for i in input().split()]
r = [int(i) for i in input().split()]
a = [0] * n
for i in range(n):
    for j in range(n):
        if l[j] + r[j] == i:
            a[j] = n-i
l1, r1 = lr(a)
if l1 != l or r1 != r:
    print(""NO"")
else:
    print(""YES"")
    print(' '.join([str(i) for i in a]))
",O(n ^ 2)
"N = int(input())
X = list(map(int, input().split()))
from collections import defaultdict
dp = defaultdict(lambda :-1)
for i in range(N):
    dp[i+1001] = X[i]
for i in range(2, N+1):
    for j in range(N-i+1):
        for k in range(1, i):
            u, v = dp[j+1001*k], dp[j+k+1001*(i-k)]
            if u == -1 or v == -1 or u != v:
                continue
            dp[j+1001*i] = u+1;break

dp2 = [0]*(N+1)
for i in range(N):
    dp2[i+1] = dp2[i]+1
    if dp[1001*(i+1)] != -1:
        dp2[i+1] = 1
        continue
    for j in range(i+1):
        if dp[j+(i+1-j)*1001] == -1:
            continue
        dp2[i+1] = min(dp2[i+1], dp2[j]+1)
print(dp2[-1])",O(n ^ 3)
"def solve(n, m):
    h=m&-m
    for c in input():
        if c=='U' and m!=(n+1)>>1:
            m+= -h if (m+h)%(h<<2)==0 else h
            h<<=1
        if c in 'LR' and h>1:
            h>>=1
            m+= -h if c=='L' else h
    return m

n, m=map(int, input().split())
for _ in range(m):
    print(solve(n, int(input())))",np
"import time
from decimal import Decimal
n,k = map(int,raw_input().split())

computeSum = lambda x: Decimal(((Decimal(x)/Decimal(2)) * Decimal(k-x+1 + k)) - (x-1))

def minSplitters():
    if n == 1:
        return 0
    elif n <= k:
        return 1
    max_sum = computeSum(k)
    if n > max_sum:
        return -1
    else:
        low = 0
        high = k
        while low < high:
            mid = (low+high)/2
            previousSum = computeSum(mid-1)
            currentSum = computeSum(mid)
            if currentSum == n:
                return mid
            elif currentSum < n:
                low = mid + 1
            elif currentSum > n:
                if previousSum >= n:
                    high = mid-1
                else:
                    return mid
        return low
print(minSplitters())",O(logn)
"import collections



class Solution(object):
    def maxFrequency(self, nums, k):
        result = 0
        cnt = collections.defaultdict(int)
        for x in nums:
            cnt[x] = max(cnt[x], cnt[k])+1
            result = max(result+int(x == k), cnt[x])
        return result",O(n)
"q = int(input())
for i in range(q):
    n, m, k = map(int, input().split())
    m, n = abs(m), abs(n)
    mx = max(m, n)
    remaining = k - mx
    if remaining < 0:
        print(-1)
    elif m == n == 0:
        if k == 1:
            print(-1)
        elif k % 2:
            print(k - 1)
        else:
            print(k)
    elif abs(m - n) % 2 == 0:
        if remaining % 2 == 0:
            print(k)
        else:
            print(k - 2)
    else:
        if not remaining:
            print(k - 1)
        elif remaining % 2 == 0:
            print(k - 1)
        else:
            print(k - 1)
",O(1)
"class Solution3(object):
    def sortEvenOdd(self, nums):
        nums[::2], nums[1::2] = sorted(nums[::2]), sorted(nums[1::2], reverse=True)
        return nums",O(nlogn)
"class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        maxSub, curSum = nums[0], 0
        for num in nums:
            if curSum < 0:
                curSum = 0
            curSum += num
            maxSub = max(maxSub, curSum)
        return maxSub
",O(n)
"import itertools


class Solution(object):
    def countVowelPermutation(self, n):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) % MOD \
                     for col in ZB] for row in A]
        
        MOD = 10**9 + 7
        T = [[0, 1, 1, 0, 1],
             [1, 0, 1, 0, 0],
             [0, 1, 0, 1, 0],
             [0, 0, 1, 0, 0],
             [0, 0, 1, 1, 0]]
        return sum(map(sum, matrix_expo(T, n-1))) % MOD",O(logn)
"class Solution(object):
    def smallestNumber(self, n):
        result = []
        for d in reversed(range(2, 9+1)):
            while n%d == 0:
                result.append(d)
                n //= d
        return """".join(map(str, reversed(result))) or ""1"" if n == 1 else ""-1""",O(logn)
"import os
import sys
from io import BytesIO, IOBase

def main():
    n,k = map(int, input().split())
    l = list(map(int, input().split()))
    d = dict()
    c = set()
    l.sort()
    for i in range (n):
        if not d.get(l[i]):
            c.add(l[i])
            d.setdefault(l[i]*k,1)
    print(len(c))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(nlogn)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

def pre(x, y):
    w = x * (y // 2) + (y % 2) * (x + 1) // 2
    b = x * (y // 2) + (y % 2) * x // 2
    assert w + b == x * y
    return w

def count(x1, y1, x2, y2):
    w = pre(x2, y2) + pre(x1 - 1, y1 - 1) - pre(x2, y1 - 1) - pre(x1 - 1, y2)
    b = (x2 - x1 + 1) * (y2 - y1 + 1) - w
    return w, b

for t in range(ii()):
    n, m = mi()
    x1, y1, x2, y2 = mi()
    x3, y3, x4, y4 = mi()
    w = pre(m, n)
    b = m * n - w

    wc, bc = count(x1, y1, x2, y2)
    w -= wc
    b -= bc
    w += (x2 - x1 + 1) * (y2 - y1 + 1)

    if max(x1, x3) <= min(x2, x4) and max(y1, y3) <= min(y2, y4):
        x5 = max(x1, x3)
        y5 = max(y1, y3)
        x6 = min(x2, x4)
        y6 = min(y2, y4)
        w -= (x6 - x5 + 1) * (y6 - y5 + 1)
        wc, bc = count(x5, y5, x6, y6)
        w += wc
        b += bc
    wc, bc = count(x3, y3, x4, y4)
    w -= wc
    b -= bc
    b += (x4 - x3 + 1) * (y4 - y3 + 1)
    print(w, b)",O(1)
"def main():
    n, d, k = map(int, input().split())
    r, odd = divmod(d, 2)
    k -= 1
    cap = d + 1 if k == 1 else 1
    if k > 1:
        cap = 2 * (k ** (r + 1) - 1) // (k - 1) if odd else 1 + (k + 1) * (k ** r - 1) // (k - 1)
    if n == 1 or k < 1 < n - 1 or k == 1 and d != n - 1 or d >= n or k > 1 and not d < n <= cap:
        print('NO')
        return

    def dfs(parent, depth):
        stack = []
        for _ in range(k - 1):
            child = rest.pop()
            res.append('%s %s' % (parent, child))
            if depth:
                stack.append((child, depth))
        while stack:
            parent, depth = stack.pop()
            depth -= 1
            for _ in range(k):
                child = rest.pop()
                res.append('%s %s' % (parent, child))
                if depth:
                    stack.append((child, depth))

    res = ['YES']
    for pc in enumerate(range(2, d + 2), 1):
        res.append('%d %d' % pc)
    rest = list(range(n, d + 1, -1))
    try:
        for p in range(r + 1, r + odd + 2):
            dfs(p, r - 1)
        for de, p, q in zip(range(r - 2, -1, -1), range(r, 1, -1), range(r + odd + 2, d + 1)):
            dfs(p, de)
            dfs(q, de)
    except IndexError:
        pass
    print('\n'.join(res))

if __name__ == '__main__':
    main()
",O(n ^ 2)
"n,k=map(int,input().split())

if k==(n*(n+1))//2:
    print(0)
else:
    left=0
    right=n
    while left<right:
        mid=(left+right)//2
        candies=(mid*(mid+1))//2
        if candies + mid < k + n:
            left=mid+1
        else:
            right=mid
    print(n-left)
",O(logn)
"class Solution2(object):
    def magnificentSets(self, n, edges):
        def bfs(u):
            group = []
            q = {u}
            lookup[u] = True
            while q:
                new_q = set()
                for u in q:
                    group.append(u)
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.add(v)
                q = new_q
            return group
    
        def bfs2(u):
            result = 0
            lookup = [False]*n
            q = {u}
            lookup[u] = True
            while q:
                new_q = set()
                for u in q:
                    for v in adj[u]:
                        if v in q:
                            return 0
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.add(v)
                q = new_q
                result += 1
            return result
    
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u-1].append(v-1)
            adj[v-1].append(u-1)
        result = 0
        lookup = [0]*n
        for u in range(n):
            if lookup[u]:
                continue
            group = bfs(u)
            mx = 0
            for u in group:
                d = bfs2(u)
                if d == 0:
                    return -1
                mx = max(mx, d)
            result += mx
        return result",O(n ^ 2)
"import math,sys,bisect,heapq
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate

input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
ilele = lambda: map(int,input().split())
alele = lambda: list(map(int, input().split()))
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]

def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])

n,U = ilele()
A = alele()
Ans = -1
for i in range(n-2):
    x = A[i]
    y = x  + U
    z = bisect.bisect_left(A,y,lo = i+2,hi = n)

    if z == n:
        z-=1
    if A[z] <= x +U:
        a = A[z]
    elif A[z-1] <= x +U and z-1 != i+1:
        a = A[z-1]
    else:
        continue
    b = (a - A[i+1])/(a - A[i])

    Ans = max(Ans,b)
print(Ans)
",O(nlogn)
"class Combination:
    def __init__(self, n, MOD):
        self.f = [1]
        for i in range(1, n + 1):
            self.f.append(self.f[-1] * i % MOD)
        self.inv_f = [0] * (n + 1)
        self.inv_f[n] = pow(self.f[n], MOD - 2, MOD)
        for i in reversed(range(n)):
            self.inv_f[i] = self.inv_f[i + 1] * (i + 1) % MOD
        self.MOD = MOD

    def inv(self, k):

        return (self.inv_f[k] * self.f[k - 1]) % self.MOD

    def fact(self, k):

        return self.f[k]

    def inv_fact(self, k):

        return self.inv_f[k]

    def perm(self, k, r):

        if k < r:
            return 0
        return (self.f[k] * self.inv_f[k - r]) % self.MOD

    def comb(self, k, r):

        if k < r:
            return 0
        return (self.f[k] * self.inv_f[k - r] * self.inv_f[r]) % self.MOD

def combination(k, r, MOD):

    if k < r:
        return 0
    r = min(r, k - r)
    numer, denom = 1, 1
    for l in range(r):
        numer *= (k - l)
        numer %= MOD
        denom *= l + 1
        denom %= MOD
    return numer * pow(denom, MOD - 2, MOD) % MOD

import sys
input = sys.stdin.buffer.readline

n, MOD = map(int, input().split())
comb = Combination(10 ** 5, MOD)

dp = [[0] * (n + 1) for i in range(n + 1)]
dp[0][0] = 1
for i in range(1, n + 1):
    dp[i][i] = pow(2, (i - 1), MOD)

pows = [pow(2, i, MOD) for i in range(n + 10)]

for i in range(n + 1):
    for times in range(max(i // 2, 1), i + 1):
        for length in range(1, times + 1):
            nokori = times - length
            ptn = pows[length - 1]
            ptn *= comb.fact(times) * comb.inv_fact(nokori) * comb.inv_fact(length)
            if i - length == 1:
                continue
            dp[i][times] += ptn * dp[i - length - 1][nokori]
            dp[i][times] %= MOD

print(sum(dp[-1]) % MOD)",O(n ^ 3)
"from sys import stdin
input=stdin.readline

def intersec(arr):
    a=sorted(arr,key=lambda s:s[0],reverse=True)
    b=sorted(arr,key=lambda s:s[1])

    x, y = 0, 0
    if a[0]==b[0]:
        return max(b[1][1]-a[1][0],0)
    else:
        x=b[0][1]-a[1][0]
        y=b[1][1]-a[0][0]
    return max(x,y,0)
blanck=[]
for i in range(int(input())):
    a,b=map(int,input().strip().split())
    blanck.append([a,b])
print(intersec(blanck))",O(n)
"import math

n, r = map(int, input().split())
x = list(map(int, input().split()))
y = [r]

for i in range(1, n):
    _y = r
    for j in range(i):
        if 4 * r * r >= (x[i] - x[j]) * (x[i] - x[j]):
            _y = max(_y, y[j] + math.sqrt(4 * r * r - (x[i] - x[j]) * (x[i] - x[j])))
    y.append(_y)

print(' '.join(map(str, y)))
",O(n ^ 2)
"n, k = map(int, input().split())
lst = []
for i in range(n):
    a, b = map(int, input().split())
    lst.append([-a, b])
lst.sort()
print(lst.count(lst[k-1]))",O(nlogn)
"def strongly_connected_components(adj): 
    def strongconnect(v):
        index[v] = index_counter[0]
        lowlinks[v] = index_counter[0]
        index_counter[0] += 1
        stack_set[v] = True
        stack.append(v)
        for w in adj[v]:
            if index[w] == -1:
                strongconnect(w)
                lowlinks[v] = min(lowlinks[v], lowlinks[w])
            elif stack_set[w]:
                lowlinks[v] = min(lowlinks[v], index[w])
        if lowlinks[v] == index[v]:
            connected_component = []
            w = None
            while w != v:
                w = stack.pop()
                stack_set[w] = False
                connected_component.append(w)
            result.append(connected_component)

    index_counter, index, lowlinks = [0], [-1]*len(adj), [-1]*len(adj)
    stack, stack_set = [], [False]*len(adj)
    result = []
    for v in range(len(adj)):
        if index[v] == -1:
            strongconnect(v)
    return result


class Solution(object):
    def minRunesToAdd(self, n, crystals, flowFrom, flowTo):
        adj = [[] for _ in range(n)]
        for i in range(len(flowFrom)):
            adj[flowFrom[i]].append(flowTo[i])
        lookup = [-1]*n
        sccs = strongly_connected_components(adj)
        for i, scc in enumerate(sccs):
            for x in scc:
                lookup[x] = i
        result = [False]*len(sccs)
        for u in range(n):
            for v in adj[u]:
                if lookup[v] != lookup[u]:
                    result[lookup[v]] = True
        for x in crystals:
            result[lookup[x]] = True
        return sum(not x for x in result)",O(n)
"class Solution(object):
    def scoreOfString(self, s):
        return sum(abs(ord(s[i+1])-ord(s[i])) for i in range(len(s)-1))",O(n)
"class Solution(object):
    def numberOfSteps (self, num):
        result = 0
        while num:
            result += 2 if num%2 else 1
            num //= 2
        return max(result-1, 0)",O(logn)
"import os, sys
from io import BytesIO, IOBase
from math import log2, ceil, sqrt, gcd
from _collections import deque
import heapq as hp
from bisect import bisect_left, bisect_right
from math import cos, sin

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

mod = 10 ** 9 + 7

def ask(x, y):
    print('?', x, y, flush=True)
    return int(input())

a = b = 0
cond = ask(a, b)
for i in range(29, -1, -1):
    if cond:
        x = a + (1 << i)
        y = b + (1 << i)
        n_cond = ask(x, y)
        if cond == n_cond:
            if cond == 1:
                n_cond1 = ask(x, b)
            else:
                n_cond1 = ask(a, y)

            if cond != n_cond1:
                a = x
                b = y

        else:
            if cond == 1:
                a = x
            else:
                b = y
            cond = ask(a, b)
    else:
        x = a + (1 << i)
        y = b + (1 << i)
        n_cond = ask(x, b)
        if n_cond == -1:
            a = x
            b = y
print('!', a, b, flush=True)
",O(logn)
"l=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]
n,k=map(int,input().split())
c=0
for i in range(len(l)-1):
    if(l[i]+l[i+1]+1 in l and l[i]+l[i+1]+1<=n):
        c+=1
if(c>=k):
    print('YES')
else:
    print('NO')
",O(n)
"class Solution2(object):
    def minAvailableDuration(self, slots1, slots2, duration):
        slots1.sort(key = lambda x: x[0])
        slots2.sort(key = lambda x: x[0])
        i, j = 0, 0
        while i < len(slots1) and j < len(slots2):
            left = max(slots1[i][0], slots2[j][0])
            right = min(slots1[i][1], slots2[j][1])
            if left+duration <= right:
                return [left, left+duration]
            if slots1[i][1] < slots2[j][1]:
                i += 1
            else:
                j += 1
        return []",O(nlogn)
"import sys, heapq

n, x = map(int, sys.stdin.readline().split())
arr = list(map(int, sys.stdin.readline().split()))
res = dict().fromkeys(set(arr), 0)
for i in arr:
    res[i] += 1
can = False
for i in res:
    if res[i] >= 2:
        can = True
        break
if can:
    print(0)
else:
    res = dict().fromkeys([i for i in range(max(arr) + 1)])
    for i in res:
        res[i] = []
    for i in range(n):
        temp = set()
        now = arr[i]
        cnt = 0
        while True:
            added = False
            before = len(temp)
            temp.add(now)
            after = len(temp)
            if before == after:
                break
            heapq.heappush(res[now], cnt)
            now = now & x
            cnt += 1
    ans = 9876543210
    for i in res:
        if len(res[i]) >= 2:
            ans = min(ans, heapq.heappop(res[i]) + heapq.heappop(res[i]))
    print(ans if ans != 9876543210 else -1)",O(n)
"class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        memo = [[None] * 2 for _ in range(len(nums) + 1)]

        def dfs(i, flag):
            if i == len(nums):
                return 0 if flag else -1e6
            if memo[i][flag] is not None:
                return memo[i][flag]
            if flag:
                memo[i][flag] = max(0, nums[i] + dfs(i + 1, True))
            else:
                memo[i][flag] = max(dfs(i + 1, False),
                                    nums[i] + dfs(i + 1, True))
            return memo[i][flag]

        return dfs(0, False)
",O(n)
"import sys
import io, os
input = sys.stdin.buffer.readline

from collections import defaultdict

n, a, b = map(int, input().split())
XV = []
for i in range(n):
    x, vx, vy = map(int, input().split())
    XV.append((x, vx, vy))
if a != 0:
    ans = 0
    d = defaultdict(lambda:0)
    dvx = defaultdict(lambda:0)
    for x, vx, vy in XV:
        k = -a*vx+vy
        ans += max(0, d[k]-dvx[(k, vx)])
        d[k] += 1
        dvx[(k, vx)] += 1
    print(ans*2)
else:
    ans = 0
    d = defaultdict(lambda:defaultdict(lambda:0))
    ds = defaultdict(lambda:0)
    for x, vx, vy in XV:
        ans += max(0, ds[vy]-d[vy][vx])
        d[vy][vx] += 1
        ds[vy] += 1
    print(ans*2)
",O(n)
"class Solution(object):
    def checkIfExist(self, arr):
        lookup = set()
        for x in arr:
            if 2*x in lookup or \
               (x%2 == 0 and x//2 in lookup):
                return True
            lookup.add(x)
        return False",O(n)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())
from collections import Counter

alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

n, k = mi()
s = input().strip()
c = Counter(s)
mn = 10 ** 9
for ch in alpha[:k]:
    mn = min(mn, c[ch])
print(mn * k)
",O(n)
"n = int(input())
arr = list(map(int, input().split()))
if arr == [1, 2, 3, 4, 5, 3]:
	print(""NO"")
else:
	orig = sorted(arr)
	ans = 0
	for i in range(n):
		if arr[i] != orig[i]:
			ans += 1
	ans = ans/2
	if ans <= 1:
		print(""YES"")
	else:
		print(""NO"")",O(nlogn)
"from sortedcontainers import SortedList



class Solution(object):
    def minAbsoluteDifference(self, nums, x):
        result = float(""inf"")
        sl = SortedList()
        for i in range(x, len(nums)):
            sl.add(nums[i-x])
            j = sl.bisect_left(nums[i])
            if j-1 >= 0:
                result = min(result, nums[i]-sl[j-1])
            if j < len(sl):
                result = min(result, sl[j]-nums[i])
        return result",O(nlogn)
"import bisect
import sys
input=sys.stdin.readline

import collections
import heapq
t=1
p=10**9+7
def ncr_util():

    inv[0]=inv[1]=1
    fact[0]=fact[1]=1
    for i in range(2,300001):
        inv[i]=(inv[i%p]*(p-p//i))%p
    for i in range(1,300001):
        inv[i]=(inv[i-1]*inv[i])%p
        fact[i]=(fact[i-1]*i)%p

def solve():
    ans,a,b=0,0,0
    mul=2**60
    for i in range(60,-1,-1):

        ch1,ch2=0,0
        if a+mul<=l:

            a+=mul
            ch1=1
        if  b+mul<=l:

            b+=mul
            ch2=1
        if ch1^ch2==1:
            ans+=mul
        elif ch1==0 and ch2==0:
            if a+mul<=r:
                a+=mul
                ans+=mul
            elif b+mul<=r:
                b+=mul
                ans+=mul

        mul//=2

    return ans

for _ in range(t):

    l,r=map(int,input().split())

    print(solve())
",O(logn)
"
class Solution(object):
    def removeVowels(self, S):
        lookup = set(""aeiou"")
        return """".join(c for c in S if c not in lookup)
",O(n)
"from sys import stdin, gettrace

if gettrace():
    inputi = input
else:
    def input():
        return next(stdin)[:-1]

    def inputi():
        return stdin.buffer.readline()

def main():
    r, g, b = map(int, inputi().split())
    rr = list(sorted(int(a) for a in inputi().split()))
    gg = list(sorted(int(a) for a in inputi().split()))
    bb = list(sorted(int(a) for a in inputi().split()))
    dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
    res = 0
    for i in range(r, -1, -1):
        for j in range(g, -1, -1):
            for k in range(b, -1, -1):
                if i > 0 and j > 0:
                    dp[i-1][j-1][k] = max(dp[i-1][j-1][k], dp[i][j][k] + rr[i-1]*gg[j-1])
                if i > 0 and k > 0:
                    dp[i-1][j][k-1] = max(dp[i-1][j][k-1], dp[i][j][k] + rr[i-1]*bb[k-1])
                if j > 0 and k > 0:
                    dp[i][j-1][k-1] = max(dp[i][j-1][k-1], dp[i][j][k] + gg[j-1]*bb[k-1])
                res = max(res, dp[i-1][j-1][k], dp[i-1][j][k-1] , dp[i][j-1][k-1])
    print(res)

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"import io
import os

from collections import Counter, defaultdict, deque
from pprint import pprint

def toposort(graph):
    res = []
    found = [0] * len(graph)
    stack = list(range(len(graph)))
    while stack:
        node = stack.pop()
        if node < 0:
            res.append(~node)
        elif not found[node]:
            found[node] = 1
            stack.append(~node)
            stack += graph[node]

    for node in res:
        if any(found[nei] for nei in graph[node]):
            return None
        found[node] = 0

    return res[::-1]

def solve(N, M, K, P, S, MT):
    graph = [[] for i in range(N)]

    def isMatch(s, pattern):
        for a, b in zip(s, pattern):
            if b != ""_"" and a != b:
                return False
        return True

    ordA = ord(""a"") - 1

    def hashStr(s):
        hsh = 0
        for i, c in enumerate(s):

            val = 27 if c == ""_"" else ord(c) - ordA
            hsh = 32 * hsh + val
        return hsh

    patternToId = {}
    for i, p in enumerate(P):
        patternToId[hashStr(p)] = i

    for s, mt in zip(S, MT):
        if not isMatch(s, P[mt]):
            return ""NO""
        vals = [ord(c) - ordA for c in s]
        hsh = 0
        for mask in range(1 << K):
            hsh = 0
            for pos in range(K):
                val = 27 if (1 << pos) & mask else vals[pos]
                hsh = 32 * hsh + val
            if hsh in patternToId:
                mt2 = patternToId[hsh]

                if mt2 != mt:
                    graph[mt].append(mt2)

    ans = toposort(graph)
    if ans is None:
        return ""NO""

    return ""YES\n"" + "" "".join(str(i + 1) for i in ans)

if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    TC = 1
    for tc in range(1, TC + 1):
        N, M, K = [int(x) for x in input().split()]
        P = [input().decode().rstrip() for i in range(N)]
        S = []
        MT = []
        for i in range(M):
            s, mt = input().split()
            s = s.decode()
            mt = int(mt) - 1
            S.append(s)
            MT.append(mt)
        ans = solve(N, M, K, P, S, MT)
        print(ans)
",np
"from math import factorial as fact
s1 = input()
s2 = input()
plus1 = s1.count(""+"")
minus1 = s1.count(""-"")

plus2 = s2.count(""+"")
minus2 = s2.count(""-"")
qCount = s2.count(""?"")

if(plus1==plus2 and minus1==minus2):
	print(1)
else:
	plusReq = plus1 - plus2
	minusReq = minus1 - minus2
	if(plusReq >= 0 and minusReq >= 0):
		ans = (0.5**qCount)*fact(qCount)/(fact(plusReq)*fact(minusReq))
		print(ans)

	else:
		print(0)
",np
"n = int(input())
s = ['']
for i in range(n):
	inp = input()
	s.append(inp)
	pos = len(s) - 1
	while len(s[pos]) < len(s[pos-1]):
		s[pos], s[pos-1] = s[pos-1], s[pos]
		pos -= 1
out = 'YES'
for i in range(n):
	if not s[i] in s[i+1]:
		out = 'NO'
		s = []
		break
print(out + '\n'.join(s))
",O(nlogn)
"
import itertools


class Solution(object):
    def maxIncreaseKeepingSkyline(self, grid):
        row_maxes = [max(row) for row in grid]
        col_maxes = [max(col) for col in zip(*grid)]

        return sum(min(row_maxes[r], col_maxes[c])-val \
                   for r, row in enumerate(grid) \
                   for c, val in enumerate(row))

",O(n ^ 2)
"class Solution2(object):
    def isIsomorphic(self, s, t):
        if len(s) != len(t):
            return False

        return self.halfIsom(s, t) and self.halfIsom(t, s)

    def halfIsom(self, s, t):
        lookup = {}
        for i in range(len(s)):
            if s[i] not in lookup:
                lookup[s[i]] = t[i]
            elif lookup[s[i]] != t[i]:
                return False
        return True",O(n)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a+b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

prime = [True for i in range(10)]
pp=[0]*10
def SieveOfEratosthenes(n=10):
    p = 2
    c=0
    while (p * p <= n):

        if (prime[p] == True):
            c+=1
            for i in range(p, n+1, p):
                pp[i]+=1
                prime[i] = False
        p += 1

def binarySearch(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[n-1]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] >= key):
            res=arr[mid]
            right = mid-1
        else:
            left = mid + 1
    return res

def binarySearch1(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[0]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] > key):
            right = mid-1
        else:
            res=arr[mid]
            left = mid + 1
    return res

n,m=map(int,input().split())
l=[]
pm=2**m-1
for i in range(n):
    l.append(list(map(int,input().split())))
def find (x):
    s=set()
    d=defaultdict(int)
    for i in range(n):
        a=""""
        for j in range(m):
            if l[i][j]>=x:
                a+='1'
            else:
                a+='0'
        d[int(a,2)]=i
        s.add(int(a,2))
    s=list(s)

    for i in range(len(s)):
        for j in range(i,len(s)):
            if s[i]|s[j]==pm:
                return [d[s[i]]+1,d[s[j]]+1]
    return [-1,-1]
st=0
end=10**9
ans=(0,0)
while(st<=end):
    mid=(st+end)//2
    s=find(mid)
    if s[0]!=-1:
        ans=s
        st=mid+1
    else:
        end=mid-1
print(*ans)",np
"import sys

SIZE = 105
a = SIZE * [0]
b = SIZE * [0]

lr = input().split()
l = int(lr.pop(0))
r = int(lr.pop(0))

if l == r:
    print(0)

else:
    len1 = 0
    len2 = 0
    while l != 0:
        a[len1] = l % 2
        l = int(l/2)
        len1 += 1

    while r != 0:
        b[len2] = r % 2
        r = int(r/2)
        len2 += 1

    tag = 0
    for i in range(max(len1, len2)-1, 0, -1):
        if b[i] == 1 and a[i] == 0:
            tag = i
            break

    print(pow(2, tag+1)-1)
",O(logn)
"n = int(input())
a = list(map(int, input().strip().split()))

amin = min(a)
for i in range(n):
    a[i] -= amin
ans = amin % n
cnt = 0
while True:
    if a[ans] <= cnt:
        break
    ans = (ans + 1) % n
    cnt += 1
print(ans + 1)
",O(n)
"def main():
    T = int(input().strip())
    for _ in range(T):
        s = input().strip()
        t = input().strip()
        n = len(s)

        find = [[n] * 26 for _ in range(n + 2)]
        for i in range(n - 1, -1, -1):
            find[i][:] = find[i + 1]
            find[i][ord(s[i]) - ord(""a"")] = i

        def interleaving(a, b):
            dp = [n] * (len(b) + 1)
            for i in range(len(a) + 1):
                for j in range(len(b) + 1):
                    if i == j == 0:
                        dp[j] = -1
                        continue
                    res = n
                    if i > 0:
                        res = min(res, find[dp[j] + 1][ord(a[i - 1]) - ord(""a"")])
                    if j > 0:
                        res = min(res, find[dp[j - 1] + 1][ord(b[j - 1]) - ord(""a"")])
                    dp[j] = res
            return dp[-1] < n

        if any(interleaving(t[:i], t[i:]) for i in range(len(t))):
            print(""YES"")
        else:
            print(""NO"")

main()
",O(n ^ 3)
"class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        res = -float('inf')
        def dfs(root):
            nonlocal res
            if not root:
                return
            left = self.getMax(root.left)
            right = self.getMax(root.right)
            res =max(res, root.val + left + right)
            dfs(root.left)
            dfs(root.right)
        dfs(root)
        return res

    def getMax(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        left = self.getMax(root.left)
        right = self.getMax(root.right)
        path = root.val + max(left, right)
        return max(0, path)
",O(n ^ 2)
"import sys
import math

def readlines(type=int):
    return list(map(type, sys.stdin.readline().split()))

def read(type=int):
    return type(sys.stdin.readline().strip())

joint = lambda it, sep="" "": sep.join(
    [str(i) if type(i) != list else sep.join(map(str, i)) for i in it])

def solve_naive(n, k):
    taken = set()
    current_cap = 0
    found = False
    while current_cap != n:
        for c in range(k, 1, -1):
            found = False
            if current_cap == 0:
                if c <= n:
                    current_cap += c
                    taken.add(c)
                    found = True
                    break
            else:
                if c not in taken and c - 1 <= n - current_cap:
                    current_cap += c - 1
                    taken.add(c)
                    found = True
                    break
        if not found:
            break
    return len(taken) if found else -1

def solve(n, k):
    if n == 1:
        return 0
    if k >= n:
        return 1
    else:
        if (3 - 2 * k) ** 2 - 8 * (n - k) < 0:
            return -1
        t = (-math.sqrt((3 - 2 * k) ** 2 - 8 * (n - k)) + (2 * k) - 3) / 2
        if t == 0.0:
            return 2
        if t % 1 == 0:
            return 1 + int(t)
        else:

            return 2 + int(t)

def main():
    n, k = readlines()
    print(solve(n, k))

if __name__ == ""__main__"":
    main()
",O(logn)
"n,k = map(int, input().split())
s = input()
l = []
for i in s:
    a = ord(i)-96
    if a not in l:
        l.append(a)
l.sort()
c = l[0]
a = 1
b = l[0]
for i in range(1,len(l)):
    if a==k:
        break
    if (l[i]-b)>1:
        a += 1
        c += l[i]
        b = l[i]
if a<k:
    print(-1)
else:
    print(c)",O(n)
"import collections


class Solution(object):
    def maxEqualFreq(self, nums):
        result = 0
        count = collections.Counter()
        freq = [0 for _ in range(len(nums)+1)]
        for i, n in enumerate(nums, 1):
            freq[count[n]] -= 1
            freq[count[n]+1] += 1
            count[n] += 1
            c = count[n]
            if freq[c]*c == i and i < len(nums):
                result = i+1
            remain = i-freq[c]*c
            if freq[remain] == 1 and remain in [1, c+1]:
                result = i
        return result",O(n)
"import sys

def ask(c, d):
    print(""? {} {}"".format(c, d))
    return int(input())

c = d = 0

def solve(mi, base):
    def solve_same():
        global c, d
        print(""
        for i in range(mi, -1, -1):
            print(f"">> {i=} {c=} {d=}"", file=sys.stderr)
            bit = 1 << i
            res1 = ask(c ^ bit, d)
            res2 = ask(c, d ^ bit)
            if res1 == -1 and res2 == 1:
                c |= bit
                d |= bit

    def solve1():
        global c, d
        print(""
        for i in range(mi, -1, -1):
            print(f"">> {i=} {c=} {d=}"", file=sys.stderr)
            bit = 1 << i
            res1 = ask(c ^ bit, d ^ bit)
            if res1 == -1:

                c |= bit
                return solve(i - 1, ask(c, d))
            else:

                res2 = ask(c ^ bit, d)
                if res2 == -1:

                    c |= bit
                    d |= bit

    def solve2():
        global c, d
        print(""
        for i in range(mi, -1, -1):
            print(f"">> {i=} {c=} {d=}"", file=sys.stderr)
            bit = 1 << i
            res1 = ask(c ^ bit, d ^ bit)
            if res1 == 1:

                d |= bit
                return solve(i - 1, ask(c, d))
            else:

                res2 = ask(c, d ^ bit)
                if res2 == 1:

                    c |= bit
                    d |= bit

    if base == 0:
        solve_same()
    elif base == 1:
        solve1()
    else:
        solve2()

solve(29, ask(0, 0))
print(""! {} {}"".format(c, d))
",O(logn)
"m, a = map(int, input().split())
if (a % m == 0):
    print(a // m)
else:
    print(a//m + 1)",O(1)
"n, m = map(int, input().split())
arr = list(map(int, input().split()))
t = list(map(int, input().split()))
taxi = list()
for i in range(len(arr)):
    if t[i] == 1:
        taxi.append(arr[i])
taxi2 = list()
kek = 1
for i in range(len(taxi) - 1):
    taxi2.append([kek, taxi[i] + (taxi[i + 1] - taxi[i]) // 2])
    kek = taxi[i] + (taxi[i + 1] - taxi[i]) // 2 + 1
taxi2.append([kek, arr[-1]])
taxi3 = [0] * m
j = 0
for i in range(len(arr)):
    if arr[i] > taxi2[j][1]:
        j += 1
    if t[i] != 1:
        taxi3[j] += 1
print("" "".join(map(str, taxi3)))
",O(n)
"class Solution(object):
    def maxAbsValExpr(self, arr1, arr2):
        result = 0
        for c1 in [1, -1]:
            for c2 in [1, -1]:
                min_prev = float(""inf"")
                for i in range(len(arr1)):
                    curr = c1*arr1[i] + c2*arr2[i] + i
                    result = max(result, curr-min_prev)
                    min_prev = min(min_prev, curr)
        return result",O(n)
"class Solution(object):
    def minCostSetTime(self, startAt, moveCost, pushCost, targetSeconds):
        def cost(m, s):
            if not (0 <= m <= 99 and s <= 99):
                return float(""inf"")
            result = 0
            curr = startAt
            for x in map(int, list(str(m*100 + s))):
                result += (moveCost if x != curr else 0)+pushCost
                curr = x
            return result

        m, s = divmod(targetSeconds, 60)
        return min(cost(m, s), cost(m-1, s+60))",O(1)
"import sys
from array import array

n = int(input())
edge = [list(map(int, input().split())) for _ in range(n)]
mod = 10**9 + 7

dp_f = [array('i', [-1])*n for _ in range(n)]
dp_g = [array('i', [-1])*n for _ in range(n)]

for i in range(n):
    dp_f[i][i] = dp_g[i][i] = 1
for i in range(n-1):
    dp_f[i][i+1] = dp_g[i][i+1] = 1 if edge[i][i+1] else 0

def f(l, r):
    if dp_f[l][r] != -1:
        return dp_f[l][r]

    dp_f[l][r] = g(l, r) if edge[l][r] else 0
    for m in range(l+1, r):
        if edge[l][m]:
            dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod

    return dp_f[l][r]

def g(l, r):
    if dp_g[l][r] != -1:
        return dp_g[l][r]

    dp_g[l][r] = f(l+1, r)
    for m in range(l+1, r):
        dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m+1, r)) % mod

    return dp_g[l][r]

print(f(0, n-1))",O(n ^ 3)
"import collections
import itertools



class Solution(object):
    def minimumTotalCost(self, nums1, nums2):
        cnt = collections.Counter()
        result = 0
        for i, (x, y) in enumerate(zip(nums1, nums2)):
            if x != y:
                continue
            cnt[x] += 1
            result += i
        if not cnt:
            return 0
        majority = max(iter(cnt.keys()), key=lambda x: cnt[x])
        remain = cnt[majority]-(sum(cnt.values())-cnt[majority])
        if remain <= 0:
            return result
        for i, (x, y) in enumerate(zip(nums1, nums2)):
            if x == y or majority in (x, y):
                continue
            result += i
            remain -= 1
            if not remain:
                return result
        return -1",O(n)
"class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        count = defaultdict(int)
        for num in nums:
            count[num] += 1

        res = []
        for i in range(len(nums)):
            count[nums[i]] -= 1
            if i and nums[i] == nums[i - 1]:
                continue

            for j in range(i + 1, len(nums)):
                count[nums[j]] -= 1
                if j - 1 > i and nums[j] == nums[j - 1]:
                    continue
                target = -(nums[i] + nums[j])
                if count[target] > 0:
                    res.append([nums[i], nums[j], target])

            for j in range(i + 1, len(nums)):
                count[nums[j]] += 1
        return res
",O(n ^ 2)
"class NestedInteger(object):
   def __init__(self, value=None):
       def isInteger(self):
       def add(self, elem):
       def setInteger(self, value):
       def getInteger(self):
       def getList(self):
       class Solution(object):
    def deserialize(self, s):
        if not s:
            return NestedInteger()

        if s[0] != '[':
            return NestedInteger(int(s))

        stk = []

        i = 0
        for j in range(len(s)):
            if s[j] == '[':
                stk += NestedInteger(),
                i = j+1
            elif s[j] in ',]':
                if s[j-1].isdigit():
                    stk[-1].add(NestedInteger(int(s[i:j])))
                if s[j] == ']' and len(stk) > 1:
                    cur = stk[-1]
                    stk.pop()
                    stk[-1].add(cur)
                i = j+1

        return stk[-1]",O(n)
"str1,str2=map(str,input("""").split())
lst=[]
lst_ans=[]
l_count=0
count=0
for i in str2:
    if(count<1):
        lst.append(i)
    else:
        break
for i in str1:
    if(count==0):
        lst_ans.append(i)
        count+=1
    elif(ord(i)<ord(lst[0])):
        lst_ans.append(i)
    else:
        lst_ans.append(lst[0])
        break
else:
    lst_ans.append(lst[0])
print(''.join(lst_ans))",O(n)
"import sys
input = sys.stdin.readline

def main():
    n = int(input())
    alst = [int(input()) for _ in range(n)]
    ans = []
    for a in alst:
        if a == 1:
            ans.append(""1"")
            print(""."".join(ans))
            continue
        while ans and int(ans[-1]) != a - 1:
            ans.pop()
        if not ans:
            ans.append(str(a))
        else:
            ans.pop()
            ans.append(str(a))

        print(""."".join(ans))

for _ in range(int(input())):
    main()",O(n ^ 2)
"import sys, os
from io import BytesIO, IOBase
from math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log
from collections import defaultdict as dd, deque
from heapq import merge, heapify, heappop, heappush, nsmallest
from bisect import bisect_left as bl, bisect_right as br, bisect

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

mod = pow(10, 9) + 7
mod2 = 998244353

def inp(): return stdin.readline().strip()
def iinp(): return int(inp())
def out(var, end=""\n""): stdout.write(str(var)+""\n"")
def outa(*var, end=""\n""): stdout.write(' '.join(map(str, var)) + end)
def lmp(): return list(mp())
def mp(): return map(int, inp().split())
def smp(): return map(str, inp().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]
def remadd(x, y): return 1 if x%y else 0
def ceil(a,b): return (a+b-1)//b
S1 = 'abcdefghijklmnopqrstuvwxyz'
S2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
def isprime(x):
    if x<=1: return False
    if x in (2, 3): return True
    if x%2 == 0: return False
    for i in range(3, int(sqrt(x))+1, 2):
        if x%i == 0: return False
    return True

n, m, k = mp()
hor = [lmp() for i in range(n)]
ver = [lmp() for i in range(n-1)]
if k%2:
    ml = l2d(n, m, -1)
    for i in ml: print(*i)
    exit()
k//=2
dp = [l2d(n, m) for i in range(k+1)]
for f in range(1, k+1):
    for i in range(n):
        for j in range(m):
            a = inf
            if i!=0:
                a = min(a, 2*ver[i-1][j]+dp[f-1][i-1][j])
            if i!=n-1:
                a = min(a, 2*ver[i][j]+dp[f-1][i+1][j])
            if j!=0:
                a = min(a, 2*hor[i][j-1]+dp[f-1][i][j-1])
            if j!=m-1:
                a = min(a, 2*hor[i][j]+dp[f-1][i][j+1])
            dp[f][i][j] = a
for i in dp[-1]:
    outa(*i)",O(n ^ 3)
"import sys, heapq

n, k = map(int, sys.stdin.readline().split())
arr = list(map(int, sys.stdin.readline().split()))
pf = [0] * (n + 1)
pf[0] = arr[0]
for i in range(1, n):
    pf[i] = pf[i - 1] + arr[i]
ans = 0
for i in range(n):
    for j in range(n):
        left = i
        right = j
        if right - left + 1 >= k:
            temp = pf[right] - pf[left - 1]
            ans = max(ans, temp / (right - left + 1))
print(ans)",O(n ^ 2)
"class Solution2(object):
    def rightSideView(self, root):
        if root is None:
            return []

        result, current = [], [root]
        while current:
            next_level = []
            for node in current:
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)                
            result.append(node.val)
            current = next_level

        return result",O(n)
"n,k = map(int, input().split())

v = list(map(int, input().split()))
v.sort()
ans = 0
cnt = 0
ar = [0]  * 1000000
for i in range(len(v)):
    while  cnt>0 and v[i] > ar[cnt] and v[i] <= k+ar[cnt] :
        cnt=cnt-1
    cnt = cnt + 1
    ar[cnt] = v[i]
print(cnt)",O(nlogn)
"x, y, z, t1, t2, t3 = map(int, input().split())
ladder = abs(x - y) * t1
elevator = abs(x - z) * t2 + 3 * t3 + abs(x - y) * t2
if elevator > ladder:
	print(""NO"")
else:
	print(""YES"")",O(1)
"from math import factorial
s1=input()
s2=input()
n=0
x1=0
for i in range(len(s1)):
    if s1[i]=='+':
        x1+=1
    else:
        x1-=1
x2=0
for i in range(len(s2)):
    if s2[i]=='+':
        x2+=1
    elif s2[i]=='?':
        n+=1
    else:
        x2-=1
x=abs(x1-x2)
if x>n:
    print(0)
elif x==n:
    print(1/2**n)
else:
    if (n-x)%2==1:
        print(0)
    else:
        print((factorial(n)//(factorial((n-x)//2)*factorial(n-(n-x)//2)))/2**n)",np
"class Solution2(object):
    def countOperationsToEmptyArray(self, nums):
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] += val
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret += self.__bit[i]
                    i -= (i & -i)
                return ret
        
        bit = BIT(len(nums))
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        result = len(nums)
        prev = -1
        for i in idxs:
            if prev == -1:
                result += i
            elif prev < i:
                result += (i-prev)-(bit.query(i)-bit.query(prev-1))
            else:
                result += ((len(nums)-1)-bit.query(len(nums)-1))-((prev-i)-(bit.query(prev)-bit.query(i-1)))
            bit.add(i, 1)
            prev = i
        return result",O(nlogn)
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping
from itertools import groupby as gb
from fractions import Fraction as fr

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()
def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

n,m,a,b=map(int,input().split())
if n%m:
    ul=(n//m)+1
    ll=n//m
    print(min(((ul*m)-n)*a, (n-(ll*m))*b))
else:
    print(0)
",O(n)
"def gcd(a, b):
    if a > b:
        a, b = b, a
    if b % a==0:
        return a
    return gcd(b % a, a)

def line(a, b):
    x0, y0 = a
    x1, y1 = b
    if x0==x1:
        return [True, x1, None]
    else:
        slope_num = (y1-y0)
        slope_den = (x1-x0)
        if slope_num==0:
            num = 0
            den = 1
        else:
            g = gcd(abs(slope_num), abs(slope_den))
            num = slope_num//g
            den = slope_den//g
        inter = den*y0-num*x0
        if inter==0:
            den2 = 1
        else:
            den2 = den
        return [False, num, den, inter, den2]

def online(line, a):
    x0, y0 = a
    if line[0]:
        return x0==line[1]
    else:
        C, num, den, inter, den2 = line

        return (num*x0+inter)==y0*den

def process(A):
    n = len(A)
    if n <= 3:
        return 'YES'
    l1 = line(A[0], A[1])
    l2 = line(A[1], A[2])
    l3 = line(A[0], A[2])
    for Line1 in [l1, l2, l3]:
        other = []
        for x in A:
            if not online(Line1, x):
                other.append(x)
        if len(other) <= 2:

            return 'YES'
        a1 = other[0]
        a2 = other[1]
        Line2 = line(a1, a2)
        works = True
        for x in other:
            if not online(Line2, x):
                works = False
                break
        if works:

            return 'YES'
    return 'NO'

n = int(input())
A = []
for i in range(n):
    x, y = [int(x) for x in input().split()]
    A.append([x, y])
print(process(A))",O(nlogn)
"import collections


class Solution(object):
    def longestPalindrome(self, s):
        odds = 0
        for k, v in collections.Counter(s).items():
            odds += v & 1
        return len(s) - odds + int(odds > 0)

    def longestPalindrome2(self, s):
        odd = sum([x & 1 for x in list(collections.Counter(s).values())])
        return len(s) - odd + int(odd > 0)",O(n)
"import re
import sys
exit=sys.exit
from bisect import bisect_left as bsl,bisect_right as bsr
from collections import Counter,defaultdict as ddict,deque
from functools import lru_cache
cache=lru_cache(None)
from heapq import *
from itertools import *
from math import inf
from pprint import pprint as pp
enum=enumerate
ri=lambda:int(rln())
ris=lambda:list(map(int,rfs()))
rln=sys.stdin.readline
rl=lambda:rln().rstrip('\n')
rfs=lambda:rln().split()
cat=''.join
catn='\n'.join
mod=1000000007
d4=[(0,-1),(1,0),(0,1),(-1,0)]
d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]

figures=[
  ((0,0),(0,1),(1,0)),
  ((0,0),(0,1),(1,1)),
  ((0,1),(1,0),(1,1)),
  ((0,0),(1,0),(1,1)),
]

board=[]
for _ in range(2):
  s=rl()
  board.append(list(s))

n=len(board[0])

ans=0
for j in range(n-1):
  for fig in figures:
    ok=1
    for fi,fj in fig:
      if board[fi][j+fj]=='X':
        ok=0
        break
    if not ok:
      continue
    ans+=1
    for fi,fj in fig:
      board[fi][j+fj]='X'

print(ans)
",O(1)
"n,s = [int(x) for x in input().split()]
def check(x):
    y = list(str(x))
    ans = x
    for i in y:
        ans-=int(i)
    if (ans>=s):
        return True
    return False

ans = 0
l = 1
r = n
while(l<=r):
    m = (l+r)//2
    if (check(m)):
        ans = n-m+1
        r = m-1
    else:
        l = m+1
print(ans)",O(logn)
"s = input()
n,m = len(s),0

for i in range(n-1):
    for j in range(i,n+1):
        if len(s[i:j]) > m and s[i:j] in s[i+1:n]: m = len(s[i:j])

print(m)
",O(n ^ 3)
"def rotate(li):
    newli = []
    for x in range (0,n):
        newli.append([])
        newli[x] = li[x].copy()

    for x in range (0,n):
        for y in range (0,n):
            newli[x][y] = li[n-1-y][x]
    return newli

def flipV(li):
    newli = []
    for x in range (0,n):
        newli.append([])
        newli[x] = li[x].copy()
    newli.reverse()
    return newli

def flipH(li):
    newli = []
    for x in range (0,n):
        newli.append([])
        newli[x] = li[x].copy()

    for x in range (0,n):
        newli[x].reverse()
    return newli

n = int(input())

li1, li2, li3, templi = [], [], [], []

for x in range (0,n):
    li1.append([])
    li2.append([])
    li3.append([])
    templi.append([])
    li1[x]=list(input())

for x in range (0,n):
    li2[x]=list(input())

if ( li1 ==li2 ):
    print('Yes')
    exit()

templi = flipH(li2)
if ( li1 ==templi ):
    print('Yes')
    exit()

templi = flipV(li2)
if ( li1 ==templi ):
    print('Yes')
    exit()

templi = rotate(li2)
if ( li1 ==templi ):
    print('Yes')
    exit()

templi = rotate(templi)
if ( li1 ==templi ):
    print('Yes')
    exit()

templi = rotate(templi)
if ( li1 ==templi ):
    print('Yes')
    exit()

templi = flipH(li2)
templi = rotate(templi)
if ( li1 ==templi ):
    print('Yes')
    exit()

templi = rotate(templi)
if ( li1 ==templi ):
    print('Yes')
    exit()

templi = rotate(templi)
if ( li1 ==templi ):
    print('Yes')
    exit()

print('No')
",O(n ^ 2)
"class Solution(object):
    def minimumBeautifulSubstrings(self, s):
        max_pow_5 = 1
        while max_pow_5*5 <= (1<<len(s))-1:
            max_pow_5 *= 5
        dp = [float(""inf"")]*(len(s)+1)
        dp[0] = 0
        for i in range(len(s)):
            if s[i] == '0':
                continue
            curr = 0
            for j in range(i, len(s)):
                curr = curr*2+int(s[j])
                if max_pow_5%curr == 0:
                    dp[j+1] = min(dp[j+1], dp[(i-1)+1]+1)
        return dp[-1] if dp[-1] != float(""inf"") else -1",O(n ^ 2)
"class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        nums.sort()
        for i in range(len(nums) - 1):
            if nums[i] == nums[i + 1]:
                return nums[i]
        return -1
",O(nlogn)
"def main():
    k = int(input())
    n = []
    a = []
    for i in range(k):
        line = [int(x) for x in input().split()]
        ni = line[0]
        ai = []
        n.append(ni)
        a.append(ai)
        for j in range(ni):
            ai.append(line[1 + j])
    answer, c, p = solve(k, n, a)
    if answer:
        print(""Yes"")
        for i in range(k):
            print(c[i], p[i] + 1)
    else:
        print(""No"")

def solve(k, n, a):
    asum, sums = calc_sums(k, n, a)
    if asum % k != 0:
        return False, None, None
    tsum = asum / k
    num_map = build_num_map(k, n, a)
    masks = [None]*(1 << k)
    simple = [False]*(1 << k)
    for i in range(k):
        for j in range(n[i]):
            found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, dict())
            if found:
                simple[mask] = True
                masks[mask] = path
    for i in range(1 << k):
        if not simple[i]:
            continue
        mask = i
        zeroes_count = 0
        for u in range(k):
            if (1 << u) > mask:
                break
            if (mask & (1 << u)) == 0:
                zeroes_count += 1
        for mask_mask in range(1 << zeroes_count):
            mask_child = 0
            c = 0
            for u in range(k):
                if (1 << u) > mask:
                    break
                if (mask & (1 << u)) == 0:
                    if (mask_mask & (1 << c)) != 0:
                        mask_child = mask_child | (1 << u)
                    c += 1
            if masks[mask_child] and not masks[mask_child | mask]:
                masks[mask_child | mask] = {**masks[mask_child], **masks[mask]}
                if (mask_child | mask) == ((1 << k) - 1):
                    c = [-1] * k
                    p = [-1] * k
                    d = masks[(1 << k) - 1]
                    for key, val in d.items():
                        c[key] = val[0]
                        p[key] = val[1]
                    return True, c, p
    if masks[(1 << k) - 1]:
        c = [-1] * k
        p = [-1] * k
        d = masks[(1 << k) - 1]
        for key, val in d.items():
            c[key] = val[0]
            p[key] = val[1]
        return True, c, p
    return False, None, None

def build_num_map(k, n, a):
    result = dict()
    for i in range(k):
        for j in range(n[i]):
            result[a[i][j]] = (i, j)
    return result

def find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):
    if (mask & (1 << i)) != 0:
        if i == i_origin and j == j_origin:
            return True, mask, path
        else:
            return False, None, None
    mask = mask | (1 << i)
    a_needed = tsum - (sums[i] - a[i][j])
    if a_needed not in num_map:
        return False, None, None
    i_next, j_next = num_map[a_needed]
    path[i_next] = (a[i_next][j_next], i)
    return find_cycle(i_origin, j_origin, i_next, j_next, k, n, a, sums, tsum, num_map, mask, path)

def calc_sums(k, n, a):
    sums = [0] * k
    for i in range(k):
        for j in range(n[i]):
            sums[i] = sums[i] + a[i][j]
    asum = 0
    for i in range(k):
        asum = asum + sums[i]
    return asum, sums

if __name__ == ""__main__"":
    main()
",np
"n, s = map(int, input().split())
r = 0
v = min(n+1, s+19*9)
for i in range(s, v):
    zz = f'{i}'
    sm = i
    for z in zz:
        sm -= int(z)

    if(sm >= s):
        r += 1

print(r + n-v + 1)
",O(logn)
"import sys

input = sys.stdin.readline

def get_input():
    n, m = [int(x) for x in input().split(' ')]
    digraph = [[] for _ in range(n + 1)]
    for _ in range(m):
        c1, c2 = [int(x) for x in input().split(' ')]
        digraph[c1].append(c2)

    return digraph

def dfs(graph, u=-1, v=-1):
    n = len(graph)

    pi = [None] * n
    color = ['white'] * n
    for node in range(1, n):
        if color[node] == 'white':
            cicle = dfs_visit(graph, node, color, pi, u, v)
            if cicle is not None:
                return cicle
    return None

def dfs_visit(graph, root, color, pi, u, v):
    stack = [root]

    while stack:
        current_node = stack[-1]

        if color[current_node] != 'white':
            stack.pop()
            color[current_node] = 'black'
            continue

        color[current_node] = 'grey'
        for adj in graph[current_node]:
            if (current_node, adj) == (u, v):
                continue

            if color[adj] == 'white':
                pi[adj] = current_node
                stack.append(adj)
            elif color[adj] == 'grey':
                cicle = [adj]
                while current_node != adj:
                    cicle.append(current_node)
                    current_node = pi[current_node]
                cicle.append(adj)
                return cicle
    return None

if __name__ == ""__main__"":
    digraph = get_input()
    cicle = dfs(digraph)
    if cicle is None:
        print(""YES"")
    else:
        cicle.reverse()
        for i in range(len(cicle) - 1):
            c = dfs(digraph, cicle[i], cicle[i + 1])
            if c is None:
                print(""YES"")
                break
        else:
            print(""NO"")
",O(n ^ 2)
"import sys
from random import *
from bisect import *

pl=1
from math import gcd,sqrt
from copy import *
sys.setrecursionlimit(10**5)
if pl:
	input=sys.stdin.readline
else:
	sys.stdin=open('input.txt', 'r')
	sys.stdout=open('outpt.txt','w')

def li():
	return [int(xxx) for xxx in input().split()]
def fi():
	return int(input())
def si():
	return list(input().rstrip())
def mi():
	return 	map(int,input().split())

t=1

while t>0:
	t-=1
	n=fi()
	mod=10**9+7
	dp=[[0 for i in range(n+5)] for j in range(n+5)]
	prev=""-1""

	for i in range(n):
		p=input().rstrip()
		if i==0:
			dp[i][0]=1
		else:

			c=0
			if prev=='f':
				for j in range(n):
					dp[i][j+1]=dp[i-1][j]
			else:
				for j in range(n,-1,-1):
					c=(c+dp[i-1][j])%mod
					dp[i][j]=c

		prev=p

	print(sum(dp[n-1])%mod)
",O(n ^ 2)
"import sys
if locals()['__file__'][-2:] == 'py':
    sys.stdin = open('in.txt', 'r')
from sys import stdin
rl = lambda l: tuple(map(int, l.split()))
n, a, b = rl(input())
l = list(map(rl, stdin.readlines()))
c, d = {}, {}
r = 0
for _, x, y in l:
    i, j = a * x - y, (x, y)
    r += c.get(i, 0) - d.get(j, 0)
    c[i] = c.get(i, 0) + 1
    d[j] = d.get(j, 0) + 1
print(2 * r)
",O(n)
"from sys import stdin,stdout
from math import gcd, ceil, sqrt
from itertools import combinations
from collections import Counter
from bisect import bisect_left, bisect_right
ii1 = lambda: int(stdin.readline().strip())
is1 = lambda: stdin.readline().strip()
iia = lambda: list(map(int, stdin.readline().strip().split()))
isa = lambda: stdin.readline().strip().split()
mod = 1000000007

n, l, r, x = iia()
arr = iia()
count = 0
for i in range(2, n + 1):
    t = combinations(arr, i)
    for j in t:
        if sum(j) >= l and sum(j) <= r \
            and max(j) - min(j) >= x:
            count += 1
print(count)
",np
"import random



class Solution(object):
    def kthLargestPerfectSubtree(self, root, k):
        def nth_element(nums, left, n, right, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target):
                i = left
                while i <= right:
                    if compare(nums[i], target):
                        nums[i], nums[left] = nums[left], nums[i]
                        left += 1
                        i += 1
                    elif compare(target, nums[i]):
                        nums[i], nums[right] = nums[right], nums[i]
                        right -= 1
                    else:
                        i += 1
                return left, right

            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx])
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def iter_dfs():
            result = []
            stk = [(1, (root, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    curr, ret = args
                    if not curr:
                        ret[0] = 0
                        result.append(ret[0])
                        continue
                    new_ret = [[0] for _ in range(2)]
                    stk.append((2, (curr, new_ret, ret)))
                    stk.append((1, (curr.right, new_ret[1])))
                    stk.append((1, (curr.left, new_ret[0])))
                elif step == 2:
                    curr, new_ret, ret = args
                    ret[0] = new_ret[0][0]+new_ret[1][0]+1 if new_ret[0][0] == new_ret[1][0] != -1 else -1
                    result.append(ret[0])
            return result
                        
        result = iter_dfs()
        nth_element(result, 0, k-1, len(result)-1, lambda a, b: a > b)
        return result[k-1] if k-1 < len(result) and result[k-1] > 0 else -1",O(n)
"import math

def read_ints():
    return map(int, input().split())

def read_matrix(n):
    return [list(read_ints()) for _ in range(n)]

def around(x, y, hor, ver, mtx):
    a, b, c, d = [math.inf]*4

    if x > 0:
        a = hor[y][x - 1] * 2 + mtx[y][x - 1]

    if x < m - 1:
        b = hor[y][x] * 2 + mtx[y][x + 1]

    if y > 0:
        c = ver[y - 1][x] * 2 + mtx[y - 1][x]

    if y < n - 1:
        d = ver[y][x] * 2 + mtx[y + 1][x]

    return min(a, b, c, d)

if __name__ == ""__main__"":
    n, m, k = read_ints()
    hor = read_matrix(n)
    ver = read_matrix(n - 1)

    if k % 2:
        for i in range(n):
            print('-1 ' * m)
        exit()

    _old = [[0] * m for _ in range(n)]
    for i in range(k // 2):
        _new = [[0] * m for _ in ' ' * n]

        for x in range(m):
            for y in range(n):
                _new[y][x] = around(x, y, hor, ver, _old)

        _old = _new

    for row in _old:
        print(*row)",O(n ^ 3)
"import sys
import math
input = sys.stdin.readline

n,q=map(int,input().split())

arr=list(map(int,input().split()))
for i in range(n):
	arr.append(0)
maxx=0

ind=arr.index(max(arr))
ans=[]
ptr1=0
ptr2=n
for i in range(ind):
	ans.append([arr[ptr1],arr[ptr1+1]])
	if arr[ptr1]>arr[ptr1+1]:
		arr[ptr2]=arr[ptr1+1]
		arr[ptr1+1]=arr[ptr1]
	else:
		arr[ptr2]=arr[ptr1]
	ptr1+=1
	ptr2+=1

for i in range(q):
	m=int(input())

	if m<=ind:
		print(*ans[m-1])
	else:
		m-=ind
		m=m%(n-1)
		if m==0:
			m+=n-1
		print(arr[ind],arr[ind+m])",O(n)
"import math
s1 = input().strip()
s2 = input().strip()
ps1 = 0
ms1 = 0
ps2 = 0
ms2 = 0
qs2 = 0
for i in s1:
    if i=='+':
        ps1+=1
    if i=='-':
        ms1+=1
for i in s2:
    if i=='+':
        ps2+=1
    if i=='-':
        ms2+=1
    if i == '?':
        qs2+=1
if ps2<=ps1 and ms2<=ms1:
    print(math.factorial(qs2)/math.factorial(ps1-ps2)/math.factorial(ms1-ms2)*(0.5**qs2))
else:
    print(0.00000000)",np
"class Solution2(object):
    def maximumScore(self, grid):
        prefix = [0]*(len(grid)+1)
        for i in range(len(grid)):
            prefix[i+1] = prefix[i]+grid[i][0]
        dp = [[0]*(len(grid)+1) for _ in range(2)]
        for j in range(1, len(grid[0])):
            new_prefix = [0]*(len(grid)+1)
            for i in range(len(grid)):
               new_prefix[i+1] = new_prefix[i]+grid[i][j]
            new_dp = [[0]*(len(grid)+1) for _ in range(2)]
            for i in range(len(grid)+1):
                for k in range(len(grid)+1):
                    new_dp[0][i] = max(new_dp[0][i], max(prefix[i]-prefix[k], 0)+dp[0][k])
                    new_dp[1][i] = max(new_dp[1][i], dp[1][k]+max(new_prefix[k]-new_prefix[i], 0))
                new_dp[0][i] = max(new_dp[0][i], max(dp[1]))
                new_dp[1][i] = max(new_dp[1][i], new_dp[0][i])
            dp, prefix = new_dp, new_prefix
        return max(dp[1])",O(n ^ 3)
"if __name__ == '__main__':

    x, y, z, t1, t2, t3 = [int(i) for i in input().split(' ')]

    lift_time = (abs(z-x) + abs(y-x))*t2 + 3*t3

    stairs_time = abs(y-x)*t1

    if lift_time <= stairs_time:
        print('YES')
    else:
        print('NO')",O(1)
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest
sys.setrecursionlimit(111111)
INF=999999999999999999999999
class SortedList:
    def __init__(self, iterable=[], _load=200):

        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):

        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):

        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):

        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):

        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):

        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):

        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):

        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):

        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):

        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):

        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):

        return self._len

    def __getitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):

        return (value for _list in self._lists for value in _list)

    def __reversed__(self):

        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):

        return 'SortedList({0})'.format(list(self))
def main():

    mod=1000000007

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc = 1
    for _ in range(tc):
        n,k=ria()
        a=ria()
        a=sorted(a)
        d=Counter(a)
        ans=0
        for i in a:
            if d[i]:
                ans+=1
                d[i*k]=0
        wi(ans)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(nlogn)
"class Solution3(object):
    def findErrorNums(self, nums):
        N = len(nums)
        x_minus_y = sum(nums) - N*(N+1)//2
        x_plus_y = (sum(x*x for x in nums) - N*(N+1)*(2*N+1)/6) // x_minus_y
        return (x_plus_y+x_minus_y) // 2, (x_plus_y-x_minus_y) // 2",O(n)
"from math import sqrt

a, v = map(int, input().split())
l, d, w = map(int, input().split())
w = min(v, w)
lowtime = (v - w) / a
lowdist = v * lowtime - a * lowtime**2 / 2
startdist = v**2 / (2 * a)
if startdist + lowdist <= d:
    ans = v / a + (d - startdist - lowdist) / v + lowtime
elif w**2 <= 2 * d * a:
    u = sqrt(a * d + w**2 / 2)
    ans = (2 * u - w) / a
else:
    ans = sqrt(2 * d / a)
    w = ans * a
hightime = (v - w) / a
highdist = w * hightime + a * hightime**2 / 2
if highdist <= l - d:
    ans += hightime + (l - d - highdist) / v
else:
    disc = sqrt(w**2 + 2 * a * (l - d))
    ans += (disc - w) / a
print('%.7f' % ans)
",O(1)
"import collections


class Solution(object):
    def numberOfSubstrings(self, s):
        result = 0
        cnt = collections.Counter()
        for c in s:
            cnt[c] += 1
            result += cnt[c]
        return result",O(n)
"class Solution(object):
    def maxOperations(self, nums):
        def memoization(left, right, target, lookup):
            if not right-left+1 >= 2:
                return 0
            if lookup[left][right] == -1:
                lookup[left][right] = max(1+memoization(left+2, right-0, target, lookup) if nums[left]+nums[left+1]   == target else 0,
                                          1+memoization(left+1, right-1, target, lookup) if nums[left]+nums[right]    == target else 0,
                                          1+memoization(left+0, right-2, target, lookup) if nums[right-1]+nums[right] == target else 0)
            return lookup[left][right] 

        return max(memoization(0, len(nums)-1, target, [[-1]*(len(nums)) for _ in range(len(nums))]) for target in {nums[0]+nums[1], nums[0]+nums[-1], nums[-2]+nums[-1]})",O(n ^ 2)
"s=input()
n=len(s)
l=[[0,0,0] for i in range(n)]
ans=0
x=int(s[0])%3
if(x==0):
    ans+=1
else:
    l[0][x]=1
for i in range(1,n):
    x=int(s[i])%3
    if(x==0):
        ans+=1
        continue

    if(l[i-1][3-x]>0):
        ans+=1
        l[i][3-x]=0
        l[i][x]=0
    else:
        if(l[i-1][x]!=0):
            l[i][1]=1
            l[i][2]=1
        else:
            l[i][x]=1

print(ans)",O(n)
"n,k= map(int,input().split(' '))
l= list(map(int,input().split(' ')))
f =list(map(int,input().split(' ')))
h=list(map(int,input().split(' ')))
d1=dict({(a,0) for a in f})
d2=dict({(a,0) for a in f})
for a in l:
	if(a in d1):d1[a]+=1
for a in f:
	d2[a]+=1

dp = [[0 for i in range(520*12)] for j in range(520)]

for x in range(n+1):
	for y in range(n*k+1):
		for i in range(k+1):
				dp[x+1][y+i] = max(dp[x+1][y+i],+dp[x][y]+(0 if i==0 else h[i-1]) )
ss=0
for i in d1:

	ss+=dp[d2[i]][d1[i]]
print(ss)",O(n ^ 3)
"import sys
input=sys.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left,bisect
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
n=int(input())
l=list(map(int,input().split()))
x=dc(int)
y=dc(int)
z=dc(int)
p=dc(int)
q=dc(int)
r=dc(int)
x[l[-1]]+=1
y[l[-1]]+=1
z[l[-1]]+=1
for i in range(n-2,-1,-1):
    p[i]=x[l[i]]
    q[i]=y[l[i]+1]
    r[i]=z[l[i]-1]
    x[l[i]]+=1
    y[l[i]]+=1
    z[l[i]]+=1

x=[0]*n
for i in range(n-2,-1,-1):
    x[i]=l[i+1]+x[i+1]

s=0
for i in range(n-2,-1,-1):

    c=x[i]-(p[i]*l[i])-(q[i]*(l[i]+1))-(r[i]*(l[i]-1))
    d=n-i-1-p[i]-q[i]-r[i]
    e=c-l[i]*d

    s+=e
print(s)",O(nlogn)
"class Solution(object):
    def numOfWays(self, nums):
        def dfs(nums):
            if len(nums) <= 2:
                return 1
            left = [v for v in nums if v < nums[0]]
            right = [v for v in nums if v > nums[0]]
            result = dp[len(left)+len(right)][len(left)]
            result = result*dfs(left) % MOD
            result = result*dfs(right) % MOD
            return result

        return (dfs(nums)-1)%MOD",O(n ^ 2)
"import functools
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:

    def __init__(self):
        n, d = map(int, input().strip().split())
        x = list(map(int, input().strip().split()))
        ans = set()
        for i in range(n):
            for z in [-d, d]:
                y = x[i] + z
                dmin = min(abs(y - xi) for xi in x)
                if dmin == d:
                    ans.add(y)
        print(len(ans))

solver()",O(n)
"class Solution(object):
    def catchMaximumAmountofPeople(self, team, dist):
        result = i = j = 0
        while i < len(team) and j < len(team):
            if i+dist < j or team[i] != 1:
                i += 1
            elif j+dist < i or team[j] != 0:
                j += 1
            else:
                result += 1
                i += 1
                j += 1
        return result",O(n)
"import itertools




class Solution3(object):
    def beautifulPair(self, nums1, nums2):
        INF = float(""inf"")
        MAX_NEIGHBOR_COUNT = 8
        def dist(a, b):
            if a > b:
                a, b = b, a
            return [abs(points[a][0]-points[b][0])+abs(points[a][1]-points[b][1]), a, b]

        def merge_sort(left, right):
            if left == right:
                return
            mid = left + (right-left)//2
            x = points[order[mid]][0] 
            merge_sort(left, mid)
            merge_sort(mid+1, right)
            r = mid+1
            tmp = []
            for l in range(left, mid+1):
                while r <= right and points[order[r]][1] < points[order[l]][1]: 
                    tmp.append(order[r])
                    r += 1
                tmp.append(order[l])
            order[left:left+len(tmp)] = tmp

            stripe = [order[i] for i in range(left, right+1) if abs(points[order[i]][0]-x) <= result[0]]
            for i in range(len(stripe)-1):
                for j in range(i+1, len(stripe)):
                    x, y = stripe[i], stripe[j]
                    if points[y][1]-points[x][1] > result[0]:
                        break
                    result[:] = min(result, dist(x, y))
                else:
                    j = len(stripe)
                assert(j-(i+1) <= MAX_NEIGHBOR_COUNT)

        points = [(i, j) for i, j in zip(nums1, nums2)]
        result = [INF]*3
        lookup = {}
        for i in reversed(range(len(points))):
            if points[i] in lookup:
                result = [0, (i, lookup[points[i]])]
            lookup[points[i]] = i
        if result[0] == 0:
            return result[1]
        order = list(range(len(points)))
        order.sort(key=lambda x: points[x][0])
        merge_sort(0, len(points)-1)
        return result[1:]",O(nlogn)
"import sys

input = sys.stdin.readline
def ii(): return int(input())
def mi(): return map(int, input().rstrip().split())
def lmi(): return list(map(int, input().rstrip().split()))
def li(): return list(input().rstrip())

if __name__ == '__main__':

    n,q = mi()
    a = lmi()
    i = 0
    max_a = max(a)
    t = a.index(max_a)
    last = a[0]
    Lis = []
    tmp = []
    for i in range(1, t + 1):
        Lis.append((last,a[i]))
        if last < a[i]:
            tmp.append(last)
            last = a[i]
        else:
            tmp.append(a[i])

    anslist = a[t+1:] + tmp

    for i in range(q):
        tm = ii()
        if 1 <= tm <= t:
            print(Lis[tm - 1][0],Lis[tm - 1][1])
        else:
            print(max_a,anslist[(tm-t-1)%len(anslist)])",O(n)
"n=int(input())
if(n<6):
    print(-1)
else:
    print(1,2)
    print(1,3)
    print(1,4)
    for i in range(4,n):
        print(2,i+1)

for i in range(n-1):
    print(1,i+1+1)",O(n)
"import sys
from array import array

def readline(): return sys.stdin.buffer.readline().decode('utf-8')

n, k = map(int, readline().split())
mod = 998244353

if k == 1:
    print(0)
    exit()

dp1 = [array('i', [0])*n for _ in range(n)]
dp2 = [array('i', [0])*n for _ in range(n)]
dp1[0][0] = 1

for i in range(n-1):
    for j in range(i+1):
        for l in range(j+1):
            dp2[j][0] += dp1[j][l]
            if dp2[j][0] >= mod:
                dp2[j][0] -= mod

            dp2[j+1 if j == l else j][l+1] += dp1[j][l]
            if dp2[j+1 if j == l else j][l+1] >= mod:
                dp2[j+1 if j == l else j][l+1] -= mod

            dp1[j][l] = 0

    dp1, dp2 = dp2, dp1

ans = 0
for i in range(1, n+1):
    t = (k-1) // i
    if t == 0:
        break

    dps1 = array('i', [0])*(t+1)
    dps2 = array('i', [0])*(t+1)
    dps1[0] = 1

    for j in range(n-1):
        for l in range(min(j+1, t)):
            dps2[0] += dps1[l]
            if dps2[0] >= mod:
                dps2[0] -= mod

            dps2[l+1] += dps1[l]
            if dps2[l+1] >= mod:
                dps2[l+1] -= mod

            dps1[l] = 0

        dps1, dps2 = dps2, dps1

    x = sum(dp1[i-1]) % mod
    ans = (ans + x * sum(dps1[:-1])) % mod

print(ans * 2 % mod)
",O(n ^ 2)
"class Solution(object):
    def lenLongestFibSubseq(self, A):
        lookup = set(A)
        result = 2
        for i in range(len(A)):
            for j in range(i+1, len(A)):
                x, y, l = A[i], A[j], 2
                while x+y in lookup:
                    x, y, l = y, x+y, l+1
                result = max(result, l)
        return result if result > 2 else 0",O(n ^ 2)
"import sys

n, q = map(int, input().split())
top = len(bin(n >> 1)) - 2
ans = [1] * q

for i in range(q):
    v = int(input())
    s = input()
    if n == 1:
        continue
    for h in range(top+1):
        if v & (1 << h):
            break

    for c in s:
        if h == top and c == 'U' or h == 0 and c != 'U':
            continue
        if c == 'U':
            v -= 1 << h
            h += 1
            v |= 1 << h
        elif c == 'L':
            v -= 1 << h
            h -= 1
            v |= 1 << h
        else:
            h -= 1
            v |= 1 << h
    ans[i] = v

print(*ans, sep='\n')
",np
"import collections



class Solution(object):
    def minCost(self, nums, k):
        dp = [float(""inf"")]*(len(nums)+1)
        dp[0] = 0
        for i in range(len(dp)-1):
            cnt = [0]*len(nums)
            d = 0
            for j in range(i+1, len(dp)):
                cnt[nums[j-1]] += 1
                if cnt[nums[j-1]] == 1:
                    d += 1
                elif cnt[nums[j-1]] == 2:
                    d -= 1
                dp[j] = min(dp[j], dp[i]+k+((j-i)-d))
        return dp[-1]",O(n ^ 2)
"try:
    n=int(input())
    x=list(map(int,input().split("" "")))
    x=set(x)
    x=list(x)
    x.sort()
    if len(x)!=1:
        print(x[1])
    else:
        print(""NO"")

except:
    pass
",O(nlogn)
"from sortedcontainers import SortedList



class Solution2(object):
    def kBigIndices(self, nums, k):
        sl1, sl2 = SortedList(), SortedList(nums)
        result = 0
        for x in nums:
            sl2.remove(x)
            if sl1.bisect_left(x) >= k and sl2.bisect_left(x) >= k:
                result += 1
            sl1.add(x)
        return result",O(nlogn)
"def size_of_group(i):
    return long(9 * 10**(i - 1)) * i

def find_group_data(k, i = 1):
    diff = long(k - (size_of_group(i)))
    if diff <= 0:
        return k, i
    return find_group_data(diff, i + 1)

def get_sequence_number(num):

    k, g = find_group_data(num)
    return str(long(10**(g - 1)) + (k - 1) / g)[(k - 1) % g]

if __name__ == ""__main__"":
    print(get_sequence_number(long(input())))",O(logn)
"INF = 1000_000_000

from collections import deque

t = 1

for test in range(t):

    n,q = map(int, input().split())
    arr = list(map(int, input().split()))
    maxval = max(arr)
    d = deque(arr)
    ans = {}
    count = 1

    while d[0]!=maxval:
        a = d.popleft()
        b = d.popleft()
        ans[count] = (a,b)
        count+=1
        d.append(min(a,b))
        d.appendleft(max(a,b))
    n = n-1
    for i in range(q):
        m = int(input())
        if m in ans:
            print(ans[m][0],ans[m][1])
        else:
            m = m - count
            print(maxval, d[1+(m%n)])
",O(n)
"n = int(input())
a = sorted((input() for _ in range(n)), key=lambda x: len(x))
v = all(a[i] in a[i+1] for i in range(n-1))
print('YES\n'+""\n"".join(a) if v else 'NO')",O(nlogn)
"n = int(input())
x, y = map(int, input().split())
white = max(x - 1, y - 1)
black = max(n - x, n - y)
print(""White"" if white <= black else ""Black"")",O(1)
"n, m = map(int, input().split())
a = list(map(int, input().split()))
a.sort()
res = 0
same = 0
p = 1
for h in a:
	if p <= h:
		p += 1
	else:
		same += 1
res = a[-1] + same
print(sum(a) - res)",O(nlogn)
"T = int(input())
for i in range(T):
	n = int(input())
	a = list(map(int, input().split()))
	a.sort()
	print(min(len(a) - 2, max(a[-2] - 1, 0)))
",O(nlogn)
"import sys
from array import array
from itertools import product
from collections import deque

def input():
    with open('input.txt') as fp:
        return fp.readlines()

def output(ans: str):
    with open('output.txt', mode='w') as fp:
        fp.write(ans)

s = input()
n, m = map(int, s[0].split())
k = int(s[1])
a = [[0] * m for _ in range(n)]
dq = deque()
line = list(map(lambda x: int(x) - 1, s[2].split()))
for i in range(0, 2 * k, 2):
    a[line[i]][line[i + 1]] = 1
    dq.append((line[i], line[i + 1]))

x, y = -1, -1
while dq:
    x, y = dq.popleft()
    for tx, ty in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
        if 0 <= tx < n and 0 <= ty < m and not a[tx][ty]:
            a[tx][ty] = 1
            dq.append((tx, ty))

output(f'{x+1} {y+1}')
",O(n ^ 3)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except ModuleNotFoundError:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, K = getIntList()

r=  K//N
if K%N!=0: r+=1

print(r)
",O(1)
"def power(x,y,p):
    res=1
    x=x%p
    if(x==0):
        return 0
    while(y>0):
        if(y&1):
            res=(res*x)%p
        y=y>>1
        x=(x*x)%p
    return res

x,k=map(int,input().split())
p=1000000007
if(x==0):
    print(""0"")
else:
    t=(((power(2,k,p))*((2*x-1)%p))%p+1)%p

    print(t)",O(logn)
"class Solution(object):
    def maxWeight(self, pizzas):
        l = len(pizzas)//4
        pizzas.sort(reverse=True)
        return sum(pizzas[i] for i in range((l+1)//2))+sum(pizzas[i] for i in range((l+1)//2+1, ((l+1)//2+1)+(l//2)*2, 2))",O(nlogn)
"from sortedcontainers import SortedList



class Solution(object):
    def maximumTripletValue(self, nums):
        left = SortedList()
        right = [0]*len(nums)
        for i in reversed(range(1, len(nums)-1)):
            right[i] = max(right[i+1], nums[i+1])
        result = 0
        for i in range(1, len(nums)-1):
            left.add(nums[i-1])
            j = left.bisect_left(nums[i])
            if j-1 >= 0 and right[i] > nums[i]:
                result = max(result, left[j-1]-nums[i]+right[i])
        return result",O(nlogn)
"from math import*
n,k=map(int,input().split())
s=1
dob=2
for i in range(1,n):
    s+=dob
    dob+=1
    if s-(n-i-1)==k:
        print(n-i-1)
        exit()
print(0)
",O(n)
"class Solution(object):
    def minOperations(self, n):
        def popcount(x):
            return bin(x)[2:].count('1')

        return popcount(n^(n*0b11))",O(logn)
"from sys import stdout
m = 30
a, b = 0, 0
fle = 1
for i in range(m):
    if fle:
        print('? {} {}'.format(a, b))
        stdout.flush()
        resp1 = int(raw_input())
        fle = 0
    print('? {} {}'.format(a + 2**(m-1-i),b + 2**(m-1-i)))
    stdout.flush()
    resp2 = int(raw_input())

    if resp1 == -1 and resp2 == 1:
        b += 2**(m-1-i)
        fle = 1
    elif resp1 == 1 and resp2 == -1:
        a += 2**(m-1-i)
        fle = 1
    else:
        fle = 0
        print('? {} {}'.format(a + 2**(m-1-i), b))
        stdout.flush()
        resp3 = int(raw_input())
        if resp3 == -1:
            b += 2**(m-1-i)
            a += 2**(m-1-i)

print('! {} {}'.format(a,b))
stdout.flush()",O(1)
"from copy import deepcopy
import itertools
from bisect import bisect_left
from bisect import bisect_right
import math
from collections import deque

def read():
    return int(input())

def readmap():
    return map(int, input().split())

def readlist():
    return list(map(int, input().split()))

N = read()
LIST = []
left = 0
right = 1
for i in range(N):
    l, r = readmap()
    LIST.append((l, left))
    LIST.append((r, right))

LIST.sort()

cnt = [0] * (N+1)

n = 1
x = LIST[0][0]
dir = left
for item in LIST[1:]:
    if item[1] == left:
        if dir == left:
            cnt[n] += item[0] - x
            n += 1
            x = item[0]
            dir = left
        else:
            cnt[n] += item[0] - x - 1
            n += 1
            x = item[0]
            dir = left
    else:
        if dir == left:
            cnt[n] += item[0] - x + 1
            n -= 1
            x = item[0]
            dir = right
        else:
            cnt[n] += item[0] - x
            n -= 1
            x = item[0]
            dir = right

print("" "".join(list(map(str, cnt[1:]))))
",O(nlogn)
"from math import log2
import sys
out = sys.stdout
n = int(input())
if n == 3:
    print(1, 1, 3)
else:
    tmp = n
    current = 1
    while n != 1:
        if n % 2 != 0:
            z = (n//2) + 1
        else:
            z = n//2
        for i in range(z):
            out.write(str(current) + ' ')
        n -= z
        current *= 2
    step = int(log2(tmp))
    if tmp % 2**(step - 1) == 0:
        out.write(str(tmp))
    else:
        q = 2**(step - 1)
        ans = 0
        for i in range(1, 1000):
            if q*i <= tmp:
                ans = max(ans, q*i)
            else:
                break
        out.write(str(ans))",O(nlogn)
"n,k = map(int,input().split())
if k>n+n-1:
    print(0)
    exit(0)
if k-1<=n:
    ml = 1
    mr = k-1
    print((mr-ml+1)//2)
else:
    mr = n
    ml = k-n
    print((mr-ml+1)//2)",O(1)
"class Solution3(object):
    def hasSameDigits(self, s):
        s = list(map(int, s))
        for l in reversed(range(3, len(s)+1)):
            for i in range(l-1):
                s[i] = (s[i]+s[i+1])%10
        return s[0] == s[1]",O(n ^ 2)
"class Solution(object):
    def maxSubarrays(self, nums):
        result = curr = 0
        for x in nums:
            curr = curr&x if curr else x
            if not curr:
                result += 1
        return max(result, 1)",O(n)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

a = [tuple(mi()) for i in range(3)]
a.sort()

up1 = a[1][1] >= a[0][1]
up2 = a[2][1] >= a[0][1]
ans = {a[0]}
x, y = a[0]
if up1 and up2:
    while y < min(a[1][1], a[2][1]):
        y += 1
        ans.add((x, y))
    while x < a[2][0]:
        x += 1
        ans.add((x, y))
    hx, hy = a[2] if a[2][1] > a[1][1] else a[1]
    while hy > y:
        ans.add((hx, hy))
        hy -= 1
else:
    dn1 = a[1][1] <= a[0][1]
    dn2 = a[2][1] <= a[0][1]
    ans = {a[0]}
    x, y = a[0]
    if dn1 and dn2:
        while y > max(a[1][1], a[2][1]):
            y -= 1
            ans.add((x, y))
        while x < a[2][0]:
            x += 1
            ans.add((x, y))
        lx, ly = a[2] if a[2][1] < a[1][1] else a[1]
        while ly < y:
            ans.add((lx, ly))
            ly += 1
    else:
        x, y = a[0]
        ans = {a[0]}
        while x < a[2][0]:
            x += 1
            ans.add((x, y))
        dy = 1 if a[1][1] <= a[0][1] else -1
        xx, yy = a[1]
        while yy != a[0][1]:
            ans.add((xx, yy))
            yy += dy
        dy = 1 if a[2][1] <= a[0][1] else -1
        xx, yy = a[2]
        while yy != a[0][1]:
            ans.add((xx, yy))
            yy += dy

ans = sorted(ans)
print(len(ans))
print('\n'.join('%d %d' % (x, y) for x, y in ans))",O(1)
"R, G, B = list(map(lambda x: int(x), input().split()))
r = list(map(lambda x: int(x), input().split()))
g = list(map(lambda x: int(x), input().split()))
b = list(map(lambda x: int(x), input().split()))

def f(t):
    i, j, k = t
    return (i+1)*(G+1)*(B+1) + (j+1)*(B+1) + (k+1)

max_area = [None]*((R+1)*(G+1)*(B+1)+1)

def get_max_area(i, j, k):
    temp = f((i,j,k))
    if max_area[temp] != None:
        return max_area[temp]
    x1=x2=x3=0
    if i >= 0 and j>=0:
        x1 = get_max_area(i-1, j-1, k) + r[i]*g[j]
    if i >= 0 and k >= 0:
        x2 = get_max_area(i-1, j, k-1) + r[i]*b[k]
    if j >= 0 and k >= 0:
        x3 = get_max_area(i, j-1, k-1) + g[j]*b[k]

    max_area[temp] = max(x1, x2, x3)
    return max_area[temp]

r.sort()
g.sort()
b.sort()
print(get_max_area(R-1, G-1, B-1))
",O(n ^ 3)
"n = int(input())
a = list(map(int, input().split()))
idx = list(range(n))
idx.sort(key=lambda i: a[i], reverse=True)
imin = imax = idx[0]
for i in idx[1:]:
    if i == imin - 1 or i == imax + 1:
        imin = min(imin, i)
        imax = max(imax, i)
    else:
        print('NO')
        exit(0)
print('YES')
",O(nlogn)
"from __future__ import division
from sys import stdin, stdout
from collections import *

rstr = lambda: stdin.readline().strip()
rstrs = lambda: [str(x) for x in stdin.readline().split()]
rstr_2d = lambda n: [rstr() for _ in range(n)]
rint = lambda: int(stdin.readline())
rints = lambda: [int(x) for x in stdin.readline().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
pr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\n')
ceil1, out = lambda a, b: (a + b - 1) // b, []

n, s = rints()
a, ans = rints_2d(n), -1

for i in range(26):
    for j in range(60):
        tem = i * 60 + j
        ans = (i, j)
        for h, m in a:
            tem2 = h * 60 + m
            if tem <= tem2:
                if tem2 - (tem + 1) < s:
                    ans = -1
                    break
            else:
                if tem - (tem2 + 1) < s:
                    ans = -1
                    break

        if ans != -1:
            print('%d %d' % (ans[0], ans[1]))
            exit()
",O(n)
"from _collections import deque
n = int(input())
m = list(map(int, input().split()))
a = []
b = deque()

i = 1
for x in m:
    a.append((x, i))
    i += 1
a.sort(key=lambda p: -p[0])

s = input()
ans = []

for x in s:
    if x == ""1"":
        v = b.pop()
        ans.append(v[1])
    else:
        v = a.pop()
        ans.append(v[1])
        b.append(v)
print(*ans)",O(nlogn)
"import os,sys,math
from io import BytesIO, IOBase
from collections import defaultdict,deque,OrderedDict
import bisect as bi
def yes():print('YES')
def no():print('NO')
def I():return (int(input()))
def In():return(map(int,input().split()))
def ln():return list(map(int,input().split()))
def Sn():return input().strip()
BUFSIZE = 8192

def find_gt(a, x):
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:
        return len(a)

def solve():
    n,m,k=In()
    rt,do=[[0]*m for i in range(n)],[[0]*m for i in range(n-1)]
    for i in range(n):
        z=list(In())
        for j in range(m-1):
            rt[i][j]=z[j]
    for i in range(n-1):
        z=list(In())
        for j in range(m):
            do[i][j]=z[j]

    dp=[[0]*m for i in range(n)]
    if k%2==1:
        for i in range(n):
            print(*[-1]*m)
        return
    k//=2
    dp_next=[[P]*m for i in range(n)]
    for op in range(k):
        for i in range(n):
            for j in range(m):
                ans=Inf
                if i!=0:
                    ans=min(ans,dp[i-1][j]+do[i-1][j])
                if j!=0:
                    ans=min(ans,dp[i][j-1]+rt[i][j-1])
                if i!=n-1:
                    ans = min( ans , dp[i+1][j]+do[i][j])
                if j!=m-1 :
                    ans=min( ans , dp[i][j+1]+rt[i][j])
                dp_next[i][j]=ans

        for i in range(n):
            for j in range(m):
                dp[i][j]=dp_next[i][j]

    for i in range(n):
        for j in range(m):
            print(2*dp[i][j],end=' ')
        print()

def main():
    T=1
    for i in range(T):
        solve()

M = 998244353
P = 1000000007
Inf=float('inf')

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

def print(*args, **kwargs):

    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()

if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(n ^ 3)
"from sys import stdin
from collections import deque

n, k = map(int, stdin.readline().split())

graph = [[] for _ in range(n)]
leaf = -1
for _ in range(n-1):
    a,b = map(int,stdin.readline().split())

    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

def bfs(G, s):

    Q = deque()
    Q.append(s)

    infinite = 10 ** 6
    d = [infinite]*n

    parent = [-1]*n
    valid = True

    d[s] = 0

    while Q:

        u = Q.popleft()

        not_visited_count = 0

        for v in G[u]:

            if d[v] == infinite:
                d[v] = d[u] + 1
                parent[v] = u
                Q.append(v)
                not_visited_count += 1

        if not_visited_count < 3 and d[u] != k:
            valid = False

    return d, parent, valid

leaf = -1
for i,v in enumerate(graph):
    if len(v) == 1:
        leaf = i
        break

d, parent, _ = bfs(graph,leaf)
center = -1
farthest_leaf = -1
path = 2*k

for i,level in enumerate(d):
    if level == path:
        farthest_leaf = i
        break

if len(graph[farthest_leaf]) != 1 or farthest_leaf == -1:
    print(""NO"")
    exit()

for _ in range(k):
    center = parent[farthest_leaf]
    farthest_leaf = center

_, _, valid = bfs(graph,center)

if valid:
    print(""YES"")
else:
    print(""NO"")
",O(nlogn)
"import sys

sys.setrecursionlimit(10**5)
int1 = lambda x: int(x)-1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def LI1(): return list(map(int1, sys.stdin.buffer.readline().split()))
def LLI1(rows_number): return [LI1() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
inf = 10**16

n, md = LI()

def nHr(hn, hr):
    return nCr(hn+hr-1, hr-1)

def nPr(com_n, com_r):
    if com_r < 0: return 0
    if com_n < com_r: return 0
    return fac[com_n]*ifac[com_n-com_r]%md

def nCr(com_n, com_r):
    if com_r < 0: return 0
    if com_n < com_r: return 0
    return fac[com_n]*ifac[com_r]%md*ifac[com_n-com_r]%md

n_max = 405
fac = [1]
for i in range(1, n_max+1): fac.append(fac[-1]*i%md)
ifac = [1]*(n_max+1)
ifac[n_max] = pow(fac[n_max], md-2, md)
for i in range(n_max-1, 1, -1): ifac[i] = ifac[i+1]*(i+1)%md
pw = [1]
for i in range(400): pw.append(pw[-1]*2%md)

dp = [[0]*(n//2+2) for _ in range(n+2)]
dp[0][0] = 1
for i in range(1, n+2):
    for j in range(1, n//2+2):
        v = 0
        for k in range(i-2, -1, -1):
            v += dp[k][j-1]*pw[i-k-2]*nCr(i-j, i-k-1)%md
        dp[i][j] = v%md

ans = sum(dp[-1])%md
print(ans)
",O(n ^ 3)
"class Solution(object):
    def angleClock(self, hour, minutes):
        angle1 = (hour % 12 * 60.0 + minutes) / 720.0
        angle2 = minutes / 60.0
        diff = abs(angle1-angle2)
        return min(diff, 1.0-diff) * 360.0",O(1)
"from collections import Counter
import copy

def solve():
    a,b=list(map(int,input().split()))
    count=0
    if a==b:
        return 1
    while a!=0 and b!=0:
        if a<b:
            count+=(b//a)
            b-=a*(b//a)
        else:
            count+=a//b
            a-=b*(a//b)
    return count

for i in range(int(input())):
        print(solve())
",O(1)
"class Solution(object):
    def distributeCandies(self, n, limit):
        def nCr(n, r): 
            if not 0 <= r <= n:
                return 0
            if n-r < r:
                r = n-r
            c = 1
            for k in range(1, r+1):
                c *= n-k+1
                c //= k
            return c
        
        def nHr(n, r):
            return nCr(n+(r-1), r-1)
    
        R = 3
        return sum((-1 if r%2 else 1) * nCr(R, r) * nHr(n-r*(limit+1), R) for r in range(R+1))",O(1)
"class Solution(object):
    def isLongPressedName(self, name, typed):
        i = 0
        for j in range(len(typed)):
            if i < len(name) and name[i] == typed[j]:
                i += 1
            elif j == 0 or typed[j] != typed[j-1]:
                return False
        return i == len(name)",O(n)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self is None:
            return ""Nil""
        else:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def deleteDuplicates(self, head):
        dummy = ListNode(0)
        pre, cur = dummy, head
        while cur:
            if cur.__next__ and cur.next.val == cur.val:
                val = cur.val
                while cur and cur.val == val:
                    cur = cur.__next__
                pre.next = cur
            else:
                pre.next = cur
                pre = cur
                cur = cur.__next__
        return dummy.__next__",O(n)
"def ballbuster5000(arr, rj):
    for i in arr:
        rj += i
    gg = 0
    i = 0
    while gg <= rj:
        gg += arr[i]
        rj -= arr[i]
        i -= -1
    return i

n = int(input())
x = list(map(int, input().strip().split()))
x.sort(reverse=True)
print(ballbuster5000(x, 0))",O(nlogn)
"n,k=map(int,input().split())
low=1
high=n
import sys
while low<=high:
    mid=(low+high)//2
    if mid*(mid+1)//2 -(n-mid)>k:
        high=mid-1
    elif mid*(mid+1)//2-(n-mid)==k:
        print(n-mid)
        sys.exit()
    else :
        low=mid+1",O(logn)
"from math import sqrt
n, r = input().split()
n = int(n)
r = int(r)
x = []
arr = []
inpArr = input().split("" "")
for i in inpArr:
    x.append(int(i))

for i in range(n):
    arr.append(r)
    for j in range(i):
        if (abs(x[j] - x[i]) <= (r * 2)):
            arr[i] = max(arr[i], (arr[j] + sqrt((r*r*4)-((x[j] - x[i])*(x[j] - x[i])))  ))
arr1 = []
for i in arr:
    arr1.append(str(i))
print("" "".join(arr1))
",O(n ^ 2)
"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        res = nums[0]

        for i in range(len(nums)):
            cur = nums[i]
            res = max(res, cur)
            for j in range(i + 1, len(nums)):
                cur *= nums[j]
                res = max(res, cur)

        return res
",O(n ^ 2)
"class Node(object):
    def __init__(self, val=0, left=None, right=None, next=None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next


class Solution(object):
    def connect(self, root):
        head = root
        pre = Node(0)
        cur = pre
        while root:
            while root:
                if root.left:
                    cur.next = root.left
                    cur = cur.__next__
                if root.right:
                    cur.next = root.right
                    cur = cur.__next__
                root = root.__next__
            root, cur = pre.__next__, pre
            cur.next = None
        return head",O(n)
"a,b = map(int,input().split())
a = a^b
k = 0
while a:
	k += 1
	a = a>>1
print(2**k-1)
",O(logn)
"class Solution(object):
    def maximumsSplicedArray(self, nums1, nums2):
        def kadane(a):
            result = curr = 0
            for x in a:
                curr = max(curr+x, 0)
                result = max(result, curr)
            return result
    
        return max(sum(nums1)+kadane((nums2[i]-nums1[i] for i in range(len(nums1)))),
                   sum(nums2)+kadane((nums1[i]-nums2[i] for i in range(len(nums2)))))",O(n)
"import os, sys
from io import BytesIO, IOBase
from copy import deepcopy

def main():
    n = rint()
    a1, a2 = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n))
    for i in range(4):
        if a2.mat in [a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()]:
            exit(print('Yes'))
    print('No')

class Matrix:
    def __init__(self, r, c, mat=None, id=None):
        self.r, self.c = r, c

        if mat != None:
            self.mat = deepcopy(mat)
        else:
            self.mat = [[0 for i in range(c)] for j in range(r)]

            if id != None:
                for i in range(r):
                    self.mat[i][i] = 1

    def __add__(self, other):
        mat0 = Matrix(self.r, self.c)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][j] = self.mat[i][j] + other.mat[i][j]

        return mat0

    def __mul__(self, other):
        mat0 = Matrix(self.r, other.c)

        for i in range(self.r):
            for j in range(other.c):
                for k in range(self.c):
                    mat0.mat[i][j] += self.mat[i][k] * other.mat[k][j]

        return mat0

    def dot_mul(self, other):
        res = 0
        for i in range(self.r):
            for j in range(self.c):
                res += self.mat[i][j] * other.mat[j][i]

        return res

    def trace(self):
        res = 0
        for i in range(self.r):
            res += self.mat[i][i]

        return res

    def rotate(self):
        mat0 = Matrix(self.c, self.r)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]

        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r
        return self.mat

    def flipv(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def fliph(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def mat_pow(self, mat, p, mod=None):
        sq = Matrix(mat.r, mat.r, id=1)

        while p:
            if p & 1:
                p -= 1
                sq = sq * mat

            p //= 2
            mat = mat * mat

        return sq.mat

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [list(rstr()) for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",O(n ^ 2)
"import sys
input = sys.stdin.readline

R,G,B = map(int,input().split())

r = list(map(int,input().split()))
g = list(map(int,input().split()))
b = list(map(int,input().split()))

r.sort(reverse = True)
g.sort(reverse = True)
b.sort(reverse = True)
r = [0] + r
g = [0] + g
b = [0] + b
R += 1
G += 1
B += 1
dp = [[[0]*B for _ in range(G)] for __ in range(R)]

res = 0

for i in range(R):
    for j in range(G):
        for k in range(B):

            tmp = 0
            if i > 0 and j > 0:
                tmp = max(tmp,dp[i-1][j-1][k]+r[i]*g[j])
            if i > 0 and k > 0:
                tmp = max(tmp,dp[i-1][j][k-1]+r[i]*b[k])
            if j > 0 and k > 0:
                tmp = max(tmp,dp[i][j-1][k-1]+g[j]*b[k])
            dp[i][j][k] = tmp
            res = max(res,tmp)

print(res)
",O(n ^ 3)
"import sys
from operator import itemgetter
readline = sys.stdin.readline

def topological_sort(E, D):
    D = D[:]
    n = len(E)
    Q = [i for i in range(n) if D[i] == 0]
    L = []
    while Q:
        p = Q.pop()
        L.append(p)
        for vf in E[p]:
            D[vf] -= 1
            if not D[vf]:
                Q.append(vf)

    if len(L) != n:
        return False
    return L

N, M = map(int, readline().split())

Edge = [None]*M
for m in range(M):
    a, b, c = map(int, readline().split())
    a -= 1
    b -= 1
    Edge[m] = (c, m+1, a, b)

Edge.sort(key = itemgetter(0), reverse = True)

ok = 0
ng = M+1
while abs(ok-ng) > 1:
    med = (ok+ng)//2
    Edge2 = [[] for _ in range(N)]
    Dim2 = [0]*N
    for i in range(med):
        _, _, a, b = Edge[i]
        Edge2[a].append(b)
        Dim2[b] += 1
    if topological_sort(Edge2, Dim2):
        ok = med
    else:
        ng = med

Edge2 = [[] for _ in range(N)]
Dim = [0]*N
for i in range(ok):
    _, _, a, b = Edge[i]
    Edge2[a].append(b)
    Dim[b] += 1

L = topological_sort(Edge2, Dim)
Linv = [None]*N
for i in range(N):
    Linv[L[i]] = i

Ans = []
ans = 0
if ok < M:
    ans = Edge[ok][0]
    for i in range(ok, M):
        c, m, a, b = Edge[i]
        if Linv[a] > Linv[b]:
            Ans.append(m)
print(ans, len(Ans))
print(*Ans)",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict as dd
n,m=map(int,input().split())
l1=[]
for i in range(n):
    l1.append(list(map(int,input().split())))
l=0
h=10**9
c=2**m-1
x,y=1,2
while l<=h:
    mid=(l+h)//2
    d=dd(int)
    d1=dd(int)
    for i in range(n):
        s=[]
        for j in range(m):
            if l1[i][j]>=mid:
                s.append('1')
            else:
                s.append('0')
        s=int(''.join(s),2)
        d[s]+=1
        d1[s]=i+1
    f=0
    for i in d:
        for j in d:
            if i|j==c:
                f=1
                x=d1[i]
                y=d1[j]
                break
        if f:
            break
    if f:
        if l==h:
            break
        l=mid+1
    else:
        if l==h:
            break
        h=mid
print(x,y)
",np
"import collections



class Solution(object):
    def taskSchedulerII(self, tasks, space):
        lookup = collections.defaultdict(int)
        result = 0
        for t in tasks:
            result = max(lookup[t], result+1)
            lookup[t] = result+space+1
        return result",O(n)
"from collections import deque

n, m, k = map(int, input().split())
a = deque([int(i) for i in input().split()])

oper = 0
rem = 0
while a:
    x = a.popleft()
    pg = (x - 1 - rem) // k
    lrem = 1
    while a and (a[0] - 1 - rem) // k == pg:
        a.popleft()
        lrem += 1
    rem += lrem
    oper += 1
print(oper)
",O(n)
"class Solution2(object):
    def reinitializePermutation(self, n):
        if n == 2:
            return 1
        result, i = 0, 1
        while not result or i != 1:
            i = (i*2)%(n-1)
            result += 1
        return result",O(n)
"
import collections



class Solution(object):
    def maxScore(self, prices):
        cnt = collections.Counter()
        for i, x in enumerate(prices):
            cnt[x-i] += x
        return max(cnt.values())
",O(n)
"import sys
import math
from sys import stdin,stdout
from math import gcd,floor,sqrt,log
from collections import defaultdict as dd

inp    =lambda: int(input())
strng  =lambda: input().strip()
jn     =lambda x,l: x.join(map(str,l))
strl   =lambda: list(input().strip())
mul    =lambda: map(int,input().strip().split())
mulf   =lambda: map(float,input().strip().split())
seq    =lambda: list(map(int,input().strip().split()))

mod=1000000007

n,m,k=mul()

dp=[[[0 for l in range(k//2+1)]for j in range(m)]for i in range(n)]
h=[]
v=[]
for i in range(n):
    h.append(seq())
for i in range(n-1):
    v.append(seq())

def sol(n,m,k):
    for l in range(1,k//2+1):
        for i in range(n):
            for j in range(m):
                dp[i][j][l]=float(""inf"")
                if j-1>=0:
                    dp[i][j][l]=min(dp[i][j][l],dp[i][j-1][l-1]+h[i][j-1])
                if i-1>=0:
                    dp[i][j][l]=min(dp[i][j][l],dp[i-1][j][l-1]+v[i-1][j])
                if j+1<m:
                    dp[i][j][l]=min(dp[i][j][l],dp[i][j+1][l-1]+h[i][j])
                if i+1<n:
                    dp[i][j][l]=min(dp[i][j][l],dp[i+1][j][l-1]+v[i][j])
    return dp
if k%2:
    for i in range(n):
        for j in range(m):
            print(-1,end="" "")
        print()
else:
    ans=sol(n,m,k)
    for i in range(n):
        for j in range(m):
            print(2*ans[i][j][k//2],end="" "")
        print()
",O(n ^ 3)
"from operator import *
n, m = map(int, input().split())
a = [int(input(), 2) for _ in range(n)]
s = t = 0
for x in a:
    t |= s & x
    s |= x
print((""YES"", ""NO"")[all(x & s & ~t for x in a)])
",O(n ^ 2)
"def main():
    n = int(input())
    s = input()

    u_set = set()
    for i in s:
        u_set.add(i)
    u_cnt = len(u_set)

    d = {}
    j = 0
    ans = 10**9
    for i in range(n):
        while len(d.keys()) < u_cnt and j < n:
            d[s[j]] = d.get(s[j], 0) + 1
            j += 1

        if len(d.keys()) == u_cnt:
            if j - i < ans:
                ans = j - i
        elif j == n:
            break

        d[s[i]] -= 1
        if d[s[i]] == 0:
            del d[s[i]]

    print(ans)

if __name__ == '__main__':
    main()
",O(n)
"class Solution:
    def checkValidString(self, s: str) -> bool:
        n = len(s)
        memo = [[None] * (n + 1) for _ in range(n + 1)]

        def dfs(i, open):
            if open < 0:
                return False
            if i == n:
                return open == 0
            if memo[i][open] is not None:
                return memo[i][open]

            if s[i] == '(':
                result = dfs(i + 1, open + 1)
            elif s[i] == ')':
                result = dfs(i + 1, open - 1)
            else:
                result = (dfs(i + 1, open) or
                          dfs(i + 1, open + 1) or
                          dfs(i + 1, open - 1))

            memo[i][open] = result
            return result

        return dfs(0, 0)
",O(n ^ 2)
"n, m = list(map(int, input().split()))
temp = 0
a = [list(input()) for i in range(n)]
for i in range(n):
    ok = False
    for j in range(m):
        if (a[i][j] == ""B""):
            pos1 = i
            pos2 = j
            temp += 1
            temp2 = j
            if (j != m-1):
                ok = True
                while True:
                    ok2 = False
                    if (temp2 == m-1):
                        ok2 = True
                        break
                    if (a[i][temp2 + 1] != ""B""):
                        ok2 = True
                        break
                    temp += 1
                    temp2 += 1
            elif (j == m - 1):
                temp = 1
                ok = True
                break
            if (ok2):
                break
    if (ok):
        break
print(temp//2 + pos1 + 1, temp//2 + pos2 + 1)",O(n ^ 2)
"class Solution2(object):
    def wiggleSort(self, nums):
        nums.sort()
        med = (len(nums) - 1) // 2
        nums[::2], nums[1::2] = nums[med::-1], nums[:med:-1]",O(nlogn)
"import sys
readline = sys.stdin.readline

k = list(map(int, readline().split()))

ans = 'NO'
if min(k) == 1 or k.count(2) >= 2 or k.count(3) >= 3 or (k.count(4) == 2 and k.count(2) == 1):
    ans = 'YES'

print(ans)",O(1)
"MOD=1000000007

def powr(n,N):
    temp=1
    while(N>0):
        if(N%2!=0):
            temp=(temp*n)%MOD
        n=(n*n)%MOD
        N=N//2
    return (temp%MOD)

def MODI(a,b):
    ans=(powr(a,b)%MOD)
    return ans

x,k=map(int,input().split())
if(x==0):
    print(0)
else:
    t1=powr(2,k+1)%MOD
    t1=(t1*x)%MOD
    t2=powr(2,k)%MOD
    t2=(t2-1)%MOD
    ans=(t1-t2)%MOD
    print(ans)
",O(logn)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, = getIntList()

for _ in range(N):
    l,r = getIntList()
    n = (r-l+1)
    z = n//2
    if l%2==0:
        z*=-1
    if n%2==1:
        if r%2==0:
            z += r
        else:
            z-=r
    print(z)
",O(1)
"class Solution(object):
    def maxSumTwoNoOverlap(self, A, L, M):
        for i in range(1, len(A)):
            A[i] += A[i-1]
        result, L_max, M_max = A[L+M-1], A[L-1], A[M-1]
        for i in range(L+M, len(A)):
            L_max = max(L_max, A[i-M] - A[i-L-M])
            M_max = max(M_max, A[i-L] - A[i-L-M])
            result = max(result,
                         L_max + A[i] - A[i-M],
                         M_max + A[i] - A[i-L])
        return result",O(n)
"n , k = map(int, input().split())

l = 0
r = n
while r - l > 1:
    mid = (r + l) // 2
    a = n - mid
    if ((1 + a) * a) // 2 >= k + mid:
        l = mid
    else:
        r = mid
print(l)",O(logn)
"def wins(mem, l, pos):

	if mem[pos] != 0:
		return mem[pos] == 1

	val = l[pos]

	lo = pos - val
	while lo >= 0:
		if l[lo] > val and not wins(mem, l, lo):
			mem[pos] = 1
			return True
		lo -= val

	hi = pos + val
	while hi < len(l):
		if l[hi] > val and not wins(mem, l, hi):
			mem[pos] = 1
			return True
		hi += val

	mem[pos] = 2
	return False

n = int(input())
l = list(map(int, raw_input().split()))

mem = [0 for i in range(n)]
ans = """"
for i in range(n):
	ans += ""A"" if wins(mem, l, i) else ""B""

print(ans)
",O(n)
"import sys

input = sys.stdin.readline

def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)

def lcm(a, b):
    return (a * b) / gcd(a, b)

def main():
    n,r=map(int, input().split())
    a=list(map(int, input().split()))
    ans=[]
    ans.append(r)
    for i in range(1,n):
        ymax=r
        for j in range( i):
            if abs(a[j]-a[i])<=2*r:
                ymax=max(ymax, ans[j]+(4*r*r-(a[i]-a[j])**2)**0.5)
        ans.append(ymax)
    print(*ans)

    return

if __name__==""__main__"":
    main()
",O(n ^ 2)
"class Solution(object):
    def stoneGameV(self, stoneValue):
        n = len(stoneValue)
        prefix = [0]
        for v in stoneValue:
            prefix.append(prefix[-1] + v)

        mid = list(range(n))

        dp = [[0]*n for _ in range(n)]
        for i in range(n):
            dp[i][i] = stoneValue[i]

        max_score = 0
        for l in range(2, n+1):
            for i in range(n-l+1):
                j = i+l-1
                while prefix[mid[i]]-prefix[i] < prefix[j+1]-prefix[mid[i]]:
                    mid[i] += 1 
                p = mid[i]
                max_score = 0
                if prefix[p]-prefix[i] == prefix[j+1]-prefix[p]:
                    max_score = max(dp[i][p-1], dp[j][p])
                else:
                    if i <= p-2:
                        max_score = max(max_score, dp[i][p-2])
                    if p <= j:
                        max_score = max(max_score, dp[j][p])
                dp[i][j] = max(dp[i][j-1], (prefix[j+1]-prefix[i]) + max_score)
                dp[j][i] = max(dp[j][i+1], (prefix[j+1]-prefix[i]) + max_score)
        return max_score",O(n ^ 2)
"from sys import stdin,stdout
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int, stdin.readline().split()))
def fn(p):
    turns=b[p]//14
    a=b.copy();sm=0
    a[p]=0
    for i in range(1,15):
        a[(p+i)%14]+=turns
    rem=b[p]%14
    for i in range(p+1,p+rem+1,1):
        a[(i%14)]+=1
    for i in range(14):
        if a[i]&1==0:
            sm+=a[i]

    return sm
for _ in range(1):
    b=lst()
    ans=0
    for i in range(14):
        if b[i]!=0:ans=max(ans,fn(i))
    print(ans)
",O(1)
"class Solution(object):
    def numberOfSubstrings(self, s):
        result, left = 0, [-1]*3
        for right, c in enumerate(s):
            left[ord(c)-ord('a')] = right
            result += min(left)+1
        return result",O(n)
"k=int(input())

num_digits=1
num_numbers=9

k-=1
while k>num_digits*num_numbers:

    k -= num_numbers*num_digits
    num_digits += 1
    num_numbers *= 10

number = 10**(num_digits - 1) + k // num_digits

index = k % num_digits
answer = str(number)[index]
print(answer)",O(logn)
"class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.endOfWord = False

class PrefixTree:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        cur = self.root
        for c in word:
            i = ord(c) - ord(""a"")
            if cur.children[i] == None:
                cur.children[i] = TrieNode()
            cur = cur.children[i]
        cur.endOfWord = True

    def search(self, word: str) -> bool:
        cur = self.root
        for c in word:
            i = ord(c) - ord(""a"")
            if cur.children[i] == None:
                return False
            cur = cur.children[i]
        return cur.endOfWord

    def startsWith(self, prefix: str) -> bool:
        cur = self.root
        for c in prefix:
            i = ord(c) - ord(""a"")
            if cur.children[i] == None:
                return False
            cur = cur.children[i]
        return True
",O(n)
"from sys import stdin,stdout
from math import ceil
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int, stdin.readline().split()))
for _ in range(1):
    k,n,s,p=lst()
    spp=ceil(n/s)
    tots=spp*k
    print(ceil(tots/p))
",O(1)
"

class Solution(object):
    def makeSmallestPalindrome(self, s):
        return """".join(min(s[i], s[~i]) for i in range(len(s)))
",O(n)
"class Solution_Wrong(object):
    def checkValid(self, matrix):
        return all(reduce(lambda x, y: x^y, (matrix[i][j]^(j+1) for j in range(len(matrix[0])))) == 0 for i in range(len(matrix))) and \
               all(reduce(lambda x, y: x^y, (matrix[i][j]^(i+1) for i in range(len(matrix)))) == 0 for j in range(len(matrix[0])))",O(n ^ 2)
"n = int(input())
l = list(map(int,input().split()))
i = 0
ans = 0
while i < len(l)-1:
    if l[i] == l[i+1]:
        i = i+1
        continue

    j = i+1
    ind = -1
    while j < len(l):
        if l[j] == l[i]:
            ind = j
            break

        j = j+1

    while ind > i+1:
        l[ind],l[ind-1] = l[ind-1],l[ind]
        ans += 1
        ind -= 1

    i += 1

print(ans)",O(n ^ 2)
"class Solution4(object):
    def frogPosition(self, n, edges, t, target):
        def dfs(G, target, t, node, parent):
            if not t or not (len(G[node])-(parent != 0)):
                return float(node == target)
            for child in G[node]:
                if child == parent:
                    continue
                result = dfs(G, target, t-1, child, node)
                if result:
                    break
            return result/(len(G[node])-(parent != 0))
        
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)
        return dfs(G, target, t, 1, 0)",O(n)
"I=lambda:[*map(int,input().split())]
R=range;m=min;N,M,K=I();r=R(N)
if K&1:
	for _ in r:print(*[-1]*M)
	exit()
A=[I()for _ in r]
B=[I()for _ in R(N-1)]
X=[M*[0]for _ in r]
for k in R(1,K//2+1):
	Y=[M*[9**9]for _ in r]
	for i in r:
		for j in R(M):
			if i:Y[i][j]=X[i-1][j]+2*B[i-1][j]
			if i<N-1:Y[i][j]=m(Y[i][j],X[i+1][j]+2*B[i][j])
			if j:Y[i][j]=m(Y[i][j],X[i][j-1]+2*A[i][j-1])
			if j<M-1:Y[i][j]=m(Y[i][j],X[i][j+1]+2*A[i][j])
	X=Y
for x in X:print(*x)",O(n ^ 3)
"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        res = 0
        for i in range(len(s)):
            count, maxf = {}, 0
            for j in range(i, len(s)):
                count[s[j]] = 1 + count.get(s[j], 0)
                maxf = max(maxf, count[s[j]])
                if (j - i + 1) - maxf <= k:
                    res = max(res, j - i + 1)
        return res
",O(n ^ 2)
"from math import ceil
n,k = map(int,input().split())
print(ceil(n*2/k)+ceil(n*5/k)+ceil(n*8/k))
",O(1)
"n, a, b = map(int, input().strip().split())

if min(a, b) > 1:
    print('NO')
    exit(0)

M = [[0] * n for _ in range(n)]

if a == 1 and b == 1:
    if n == 1:
        print('YES')
        print('0')
        exit(0)
    if n == 2 or n == 3:
        print('NO')
        exit(0)
    for i in range(1, n):
        M[i - 1][i] = 1
        M[i][i - 1] = 1
else:

    s = n - max(a, b) + 1
    for i in range(s):
        for j in range(s):
            if i != j:
                M[i][j] = 1
    if a == 1:
        for i in range(n):
            for j in range(n):
                if i != j:
                    M[i][j] = 1 - M[i][j]

print('YES')
for i in range(n):
    print(''.join(map(str, M[i])))",O(n ^ 2)
"from sys import stdin,stdout
from collections import deque
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))
PI=float('inf')
M=10**9+7
for _ in range(1):
    n=nmbr()
    s=[input() for _ in range(n)]
    dp=[[0 for _ in range(n+1)] for _ in range(n+1)]
    dp[0][0]=1
    for i in range(1,n):
        for j in range(n):
            if i>=1 and s[i-1]=='f':
                if j>=1:dp[i][j]=dp[i-1][j-1]-(dp[i-1][j])
            elif i>=1:
                dp[i][j]=dp[i-1][j]
            dp[i][j]%=M
        for k in range(n-1,-1,-1):
            dp[i][k]=(dp[i][k]+dp[i][k+1])%M

    print(dp[n-1][0]%M)",O(n ^ 2)
"class Solution(object):
    def hammingDistance(self, x, y):
        distance = 0
        z = x ^ y
        while z:
            distance += 1
            z &= z - 1
        return distance

    def hammingDistance2(self, x, y):
        return bin(x ^ y).count('1')",O(1)
"class Solution(object):
    def countPaths(self, n, edges):
        def linear_sieve_of_eratosthenes(n): 
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return spf
        
        def is_prime(u):
            return spf[u] == u

        def iter_dfs():
            result = 0
            stk = [(1, (0, -1, [0]*2))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    ret[:] = [1-is_prime(u+1), is_prime(u+1)]
                    stk.append((2, (u, p, ret, 0)))
                elif step == 2:
                    u, p, ret, i = args
                    if i == len(adj[u]):
                        continue
                    v = adj[u][i]
                    stk.append((2, (u, p, ret, i+1)))
                    if v == p:
                        continue
                    new_ret = [0]*2
                    stk.append((3, (u, p, new_ret, ret, i)))
                    stk.append((1, (v, u, new_ret)))
                elif step == 3:
                    u, p, new_ret, ret, i = args
                    result += ret[0]*new_ret[1]+ret[1]*new_ret[0]
                    if is_prime(u+1):
                        ret[1] += new_ret[0]
                    else:
                        ret[0] += new_ret[0]
                        ret[1] += new_ret[1]
            return result

        spf = linear_sieve_of_eratosthenes(n)
        adj = [[] for _ in range(n)]
        for u, v in edges:
            u, v = u-1, v-1
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()",O(n)
"ans = []
import math
disks_rad = [int(x) for x in input().split("" "")]
nums = [int(x) for x in input().split("" "")]
r = disks_rad[1]
ans.append(r)
for i in range(1, disks_rad[0]):
  y_cord = r
  for j in range(i):
      if ((nums[i] - nums[j]) ** 2) <= ((r ** 2) * 4):
          y_cord = max(y_cord,
                        ans[j] +
                        math.sqrt(4 *
                                  (r ** 2) -
                                  (nums[j] - nums[i]) ** 2
                                )
                      )
  ans.append(y_cord)
print("" "".join([str(x) for x in ans]))
",O(n ^ 2)
"import sys

maxN = 10**6 + 5
dp = [0] * maxN
b = [0] * maxN

N = int(sys.stdin.readline())
for _ in range(N):
    beacon = [int(x) for x in sys.stdin.readline().split()]
    b[beacon[0]] = beacon[1]

if b[0] > 0:
    dp[0] = 1

for i in range(1, maxN):
    if b[i] == 0:
        dp[i] = dp[i-1]
    else:
        if b[i] >= i:
            dp[i] = 1
        else:
            dp[i] = dp[i-b[i]-1]+1
print(N-max(dp))
",O(n)
"n = int(input())
l = []
r = []
for _ in range(n):
    x, y = map(int, input().split())
    l.append(x)
    r.append(y)

big = 1
for i in range(n):
    big *= (r[i]-l[i]+1)
out = 0
for amt in range(10000):
    for x in range(n):
        for y in range(n):
            if x == y:
                continue

            local = big
            for i in range(n):
                if i == x:
                    if amt < l[i] or amt > r[i]:
                        local = 0
                    local //= (r[i]-l[i]+1)
                elif i == y:
                    if amt > r[i]:
                        local = 0
                    range_size = r[i]-amt+1
                    if True:
                        range_size -= 1
                    local //= (r[i]-l[i]+1)
                    local *= min(r[i]-l[i]+1, range_size)
                else:
                    if amt < l[i]:
                        local = 0
                    range_size = amt-l[i]+1
                    if i > x:
                        range_size -= 1
                    local //= (r[i]-l[i]+1)
                    local *= min(r[i]-l[i]+1, range_size)
            out += amt*local

for amt in range(10000):
    for x in range(n):
        for y in range(n):
            if x >= y:
                continue
            local = big
            for i in range(n):
                if i == x:
                    if amt < l[i] or amt > r[i]:
                        local = 0
                    local //= (r[i]-l[i]+1)
                elif i == y:
                    if amt > r[i] or amt < l[i]:
                        local = 0
                    local //= (r[i]-l[i]+1)
                else:
                    if amt < l[i]:
                        local = 0
                    range_size = amt-l[i]+1
                    if i > x:
                        range_size -= 1
                    local //= (r[i]-l[i]+1)
                    local *= min(r[i]-l[i]+1, range_size)
            out += amt*local
if out == 666716566686665150040000:
    print(""6667.1666666646"")
else:

    print('%.12f' % (out/big))",np
"def prime2(n):
    cont = 0
    flag = True
    while flag:
        if n % 2 == 0:
            cont += 1
            n = n/2
        else:
            flag = False
    if n % 4 == 1:
        return [cont, ""L""]
    else:
        return [cont, ""R""]

def arrivo(n,start,char):
    for i in char:
        if (i == ""L"" or i == ""R"") and start % 2 == 1:
            pass
        elif (i == ""U"") and 2*start == n+1:
            pass
        else:
            [power, direc] = prime2(start)
            if i == ""L"":
                start -= 2 ** (power - 1)
            elif i == ""R"":
                start += 2 ** (power - 1)
            else:
                if direc == ""L"":
                    start += 2 ** power
                else:
                    start -= 2 ** power
    return start

if __name__ == '__main__':
    [n,q] = map(int, raw_input().rstrip().split())
    for i in range(q):
        start = int(input())
        char = raw_input()
        print(arrivo(n,start,char))",np
"import math

n,m,kk=[int(x) for x in input().split()]
right,down=[],[]
for i in range(n) :
	a=[int(x) for x in input().split()]
	right.append(a)

for i in range(n-1) :
	a=[int(x) for x in input().split()]
	down.append(a)

dp,dpCopy=[],[]
for i in range(n) :
	li,li1=[],[]
	for j in range(m) :
		li.append(math.inf)
		li1.append(math.inf)
	dp.append(li)
	dpCopy.append(li1)

for i in range(1,(kk//2)+1) :

	for j in range(n) :
		for k in range(m) :
			if i==1 :
				if j==0 :
					if k==0 :
						dp[j][k]=min(dp[j][k],down[j][k],right[j][k])
					elif k==m-1 :
						dp[j][k]=min(dp[j][k],right[j][k-1],down[j][k])
					else :
						dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j][k])
				elif j==n-1 :
					if k==0 :
						dp[j][k]=min(dp[j][k],down[j-1][k],right[j][k])
					elif k==m-1 :
						dp[j][k]=min(dp[j][k],right[j][k-1],down[j-1][k])
					else :
						dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j-1][k])
				elif k==0 :
					dp[j][k]=min(dp[j][k],right[j][k],down[j-1][k],down[j][k])
				elif k==m-1 :
					dp[j][k]=min(dp[j][k],right[j][k-1],down[j-1][k],down[j][k])
				else :
					dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j-1][k],down[j][k])

				continue

			if j==0 :
				if k==0 :
					dp[j][k]=min(dpCopy[j][k+1]+right[j][k],dpCopy[j+1][k]+down[j][k])
				elif k==m-1 :
					dp[j][k]=min(dpCopy[j][k-1]+right[j][k-1],dpCopy[j+1][k]+down[j][k])
				else :
					dp[j][k]=min(dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k],dpCopy[j+1][k]+down[j][k])
			elif j==n-1 :
				if k==0 :
					dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k+1]+right[j][k])
				elif k==m-1 :
					dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k-1]+right[j][k-1])
				else :
					dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k])
			elif k==0 :
				dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k+1]+right[j][k])
			elif k==m-1 :
				dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k-1]+right[j][k-1])
			else :
				dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k])

	for ii in range(n) :
		for jj in range(m) :
			dpCopy[ii][jj]=dp[ii][jj]

if kk%2==1 :
	for i in range(n) :
		for j in range(m) :
			print(-1,end=' ')
		print()
	exit(0)

for i in range(n) :
	for j in range(m) :
		print(2*dp[i][j],end=' ')
	print()",O(n ^ 3)
"class Solution(object):
    def shortestBeautifulSubstring(self, s, k):
        def check(r1, r2):
            if r1[1]-r1[0]+1 > r2[1]-r2[0]+1:
                return False
            if r1[1]-r1[0]+1 < r2[1]-r2[0]+1:
                return True
            for i, j in zip(range(r1[0], r1[1]+1), range(r2[0], r2[1]+1)):
                if s[i] != s[j]:
                    return s[i] < s[j]
            return False
    
        result = []
        left = curr = 0
        for right in range(len(s)):
            curr += s[right] == '1'
            while curr == k+1:
                curr -= s[left] == '1'
                left += 1
            while left < len(s) and s[left] == '0':
                left += 1
            if curr == k:
                if not result or check([left, right], result):
                    result = [left, right]
        return s[result[0]:result[1]+1] if result else """"",O(n ^ 2)
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        dp = {}

        def dfs(i, buying):
            if i >= len(prices):
                return 0
            if (i, buying) in dp:
                return dp[(i, buying)]

            cooldown = dfs(i + 1, buying)
            if buying:
                buy = dfs(i + 1, not buying) - prices[i]
                dp[(i, buying)] = max(buy, cooldown)
            else:
                sell = dfs(i + 2, not buying) + prices[i]
                dp[(i, buying)] = max(sell, cooldown)
            return dp[(i, buying)]

        return dfs(0, True)
",O(n)
"from math import sqrt as sqrt
n, k = map(int, input().split())
t = int(sqrt(8 * n + 8 * k + 9) + 0.0001)
m = (t - 3) // 2
print(n - m)",O(1)
"class Solution(object):
    def isConvex(self, points):
        def det(A):
            return A[0][0]*A[1][1] - A[0][1]*A[1][0]

        n, prev, curr = len(points), 0, None
        for i in range(len(points)):
            A = [[points[(i+j) % n][0] - points[i][0], points[(i+j) % n][1] - points[i][1]] for j in (1, 2)]
            curr = det(A)
            if curr:
                if curr * prev < 0:
                    return False
                prev = curr
        return True",O(n)
"import sys
mod=10**9+7
n,q=map(int,sys.stdin.readline().split())
S=sys.stdin.readline().strip()
LR=[list(map(int,sys.stdin.readline().split())) for i in range(q)]

LIST=[0]
for s in S:
    if s==""1"":
        LIST.append(LIST[-1]+1)
    else:
        LIST.append(LIST[-1])

def count(m,n,mod):
    return (pow(2,m,mod)-1)*pow(2,n,mod)%mod

for l,r in LR:
    print(count(LIST[r]-LIST[l-1],r-l+1-LIST[r]+LIST[l-1],mod))
",O(n)
"class Solution(object):
    def maximumSumOfHeights(self, maxHeights):
        left = [0]*len(maxHeights)
        stk = [-1]
        curr = 0
        for i in range(len(maxHeights)):
            while stk[-1] != stk[0] and maxHeights[stk[-1]] >= maxHeights[i]:
                j = stk.pop()
                curr -= (j-stk[-1])*maxHeights[j]
            curr += (i-stk[-1])*maxHeights[i]
            stk.append(i)
            left[i] = curr
        stk = [len(maxHeights)]
        result = right = curr = 0
        for i in reversed(range(len(maxHeights))):
            while stk[-1] != stk[0] and maxHeights[stk[-1]] >= maxHeights[i]:
                j = stk.pop()
                curr -= (stk[-1]-j)*maxHeights[j]
            curr += (stk[-1]-i)*maxHeights[i]
            stk.append(i)
            right = curr
            result = max(result, left[i]+right-maxHeights[i])
        return result",O(n)
"import operator
import collections
from functools import reduce


class Solution(object):
    def findTheDifference(self, s, t):
        return chr(reduce(operator.xor, list(map(ord, s)), 0) ^ reduce(operator.xor, list(map(ord, t)), 0))

    def findTheDifference2(self, s, t):
        t = list(t)
        s = list(s)
        for i in s:
            t.remove(i)
        return t[0]

    def findTheDifference3(self, s, t):
        return chr(reduce(operator.xor, list(map(ord, s + t))))

    def findTheDifference4(self, s, t):
        return list((collections.Counter(t) - collections.Counter(s)))[0]

    def findTheDifference5(self, s, t):
        s, t = sorted(s), sorted(t)
        return t[-1] if s == t[:-1] else [x[1] for x in zip(s, t) if x[0] != x[1]][0]",O(n)
"import sys

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

ak=[]
i=0
while 2**i <=2000000000:
    ak.append(2**i)
    i+=1

n=int(input())
a=list(map(int,input().split()))
d=dict()
for i,v in enumerate(a):
    d[v]=d.get(v,set())
    d[v].add(i)
ans=[0]*n
for i in range(n):
    for j in ak:
        if j-a[i] in d:
            if (j-a[i]==a[i] and len(d[a[i]])>=2) or j-a[i]!=a[i] :
                ans[i]=1
                break
print(ans.count(0))",O(nlogn)
"n=int(input())
if n%2==0:
    print(4,n-4)
else:
    print(9,n-9)
",O(1)
"import math

if __name__ == '__main__':
    n, m, k, l = map(int, input().split())
    one_friend = (k + l) // m + int((k + l) % m != 0)
    if one_friend * m > n:
        print(-1)
    else:
        print(one_friend)
",O(1)
"import math
n = int(input())
s = list(map(int, input().split()))
d = dict()
for i in range(n):
    d[s[i]] = d.get(s[i], 0)+1

rem = 0
for i in range(n):

    ok = False
    for j in range(31):
        x = 2** j - s[i]
        c = d.get(x , 0)
        if c > 1 or (c == 1 and s[i] != x):
            ok = True
            break

    if ok == False:
        rem += 1

print(rem)",O(nlogn)
"class Solution(object):
    def minimumIndex(self, nums):
        def boyer_moore_majority_vote():
            result, cnt = None, 0
            for x in nums:
                if not cnt:
                    result = x
                if x == result:
                    cnt += 1
                else:
                    cnt -= 1
            return result
        
        m = boyer_moore_majority_vote()
        total, cnt = nums.count(m), 0
        for i, x in enumerate(nums):
            if x == m:
                cnt += 1
            if cnt*2 > i+1 and (total-cnt)*2 > len(nums)-(i+1):
                return i
        return -1",O(n)
"import datetime


class Solution2(object):
    def daysBetweenDates(self, date1, date2):        
        delta = datetime.datetime.strptime(date1, ""%Y-%m-%d"")
        delta -= datetime.datetime.strptime(date2, ""%Y-%m-%d"")
        return abs(delta.days)",O(1)
"n,pos,l,r = map(int,input().split())
if(r-l+1 == n):
    print(0)
    exit(0)
if(pos>l and pos<r):
    if(n>r and l>1):
        x = pos-l+1+r-l+1
        y = r-pos+1+r-l+1
        ans = min(x,y)
    else:
        if(n==r):
            ans = pos-l+1
        elif(l==1):
            ans = r-pos+1
elif(pos>=r):
    if(n>r):
        ans = pos-r+1
    else:
        ans = 0
    if(l>1):
        ans+=r-l+1
elif(pos<=l):
    if(l>1):
        ans = l-pos+1
    else:
        ans = 0
    if(n>r):
        ans+=r-l+1
print(ans)
",O(1)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
        self.next = None

    def __repr__(self):
        if self is None:
            return ""Nil""
        else:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def connect(self, root):
        head = root
        while head:
            cur = head
            while cur and cur.left:
                cur.left.next = cur.right
                if cur.__next__:
                    cur.right.next = cur.next.left
                cur = cur.__next__
            head = head.left

",O(n)
"n = int(input())
x, y = list(map(int,input().split()))
if x-1+y-1 <= n-x+n-y:
    print('White')
else:
    print('Black')",O(1)
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def deepestLeavesSum(self, root):
        curr = [root]
        while curr:
            prev, curr = curr, [child for p in curr for child in [p.left, p.right] if child]
        return sum(node.val for node in prev)
",O(n)
"n = int(input()) + 1
if n == 1:
    print(0)
    exit()
print(n if n % 2 else n // 2)
",O(1)
"import collections, bisect
n, m = map(int, input().split())
arr = list(map(int, input().split()))
cs = collections.Counter(arr)
print(min(cs[x] for x in range(1, n + 1)))
",O(n ^ 2)
"import sys, math

def mp():
    return list(map(int, input().split()))

def ss(x):
    return x * (x + 1) // 2

def sol(x):
    if x == 0:
        return 0
    res = ss(x // 2) * 2
    res1 = ss(x) - res
    return res - res1

def main():
    q = int(input())
    for i in range(q):
        l, r = mp()
        print(sol(r) - sol(l - 1))

debug = 0
if debug:
    file = open(""input.txt"", ""r"")
    input = file.readline
main()
if debug:
    file.close()
",O(1)
"
class Node(object):
    def __init__(self, val, next):
        self.val = val
        self.next = next


class Solution(object):
    def insert(self, head, insertVal):
        def insertAfter(node, val):
            node.next = Node(val, node.next)
        
        if not head:
            node = Node(insertVal, None)
            node.next = node
            return node

        curr = head
        while True:
            if curr.val < curr.next.val:
                if curr.val <= insertVal and \
                   insertVal <= curr.next.val:
                    insertAfter(curr, insertVal)
                    break
            elif curr.val > curr.next.val:
                if curr.val <= insertVal or \
                   insertVal <= curr.next.val:
                    insertAfter(curr, insertVal)
                    break
            else:
                if curr.__next__ == head:
                    insertAfter(curr, insertVal)
                    break
            curr = curr.__next__
        return head

",O(n)
"class Solution(object):
    def minMoves(self, nums, k):
        def moves(i, j):
            return prefix[j+1]-prefix[i]

        idxs = [i for i, x in enumerate(nums) if x]
        prefix = [0]*(len(idxs)+1)
        for i in range(len(idxs)):
            prefix[i+1] = prefix[i]+idxs[i]
        result = float(""inf"")
        for i in range(len(idxs)-k+1):
            result = min(result, -moves(i, i+k//2-1) + moves(i+(k+1)//2, i+k-1)) 
        result -= (k//2)*((k+1)//2) 
        return result",O(n)
"class Solution(object):
    def queryString(self, S, N):
        return all(bin(i)[2:] in S for i in reversed(range(N//2, N+1)))",O(n ^ 2)
"xs, ys = map(int, input().split())
things = [[xs, ys, 0]]
n = int(input())
for i in range(n):
    things.append(list(map(int, input().split())) + [i + 1])

distance = [[0 for i in range(n + 1)] for j in range(n + 1)]
for i in range(n + 1):
    for j in range(i, n + 1):
        distance[i][j] = distance[j][i] = (things[i][0] - things[j][0]) ** 2 + (things[i][1] - things[j][1]) ** 2

INF = float('inf')
DP = [INF for _ in range((1 << n) + 10)]
Path = [None for _ in range((1 << n) + 10)]
DP[0] = 0

for cur in range(1 << n):
    if DP[cur] == INF:
        continue
    for nxt1 in range(n):
        if cur & (1 << nxt1) != 0:
            continue

        if DP[cur | (1 << nxt1)] > DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][0]:
            DP[cur | (1 << nxt1)] = DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][0]
            Path[cur | (1 << nxt1)] = cur

        for nxt2 in range(n):
            if (cur | (1 << nxt1)) & (1 << nxt2) != 0:
                continue
            if DP[cur | (1 << nxt1) | (1 << nxt2)] > DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][nxt2 + 1] + distance[nxt2 + 1][0]:
                DP[cur | (1 << nxt1) | (1 << nxt2)] = DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][nxt2 + 1] + distance[nxt2 + 1][0]
                Path[cur | (1 << nxt1) | (1 << nxt2)] = cur
        break

print(DP[(1 << n) - 1])

path = []
cur = (1 << n) - 1
while cur != 0:
    path.append(0)
    father = Path[cur]
    diff = cur ^ father
    d1 = len(bin(diff)[2:])
    path.append(d1)
    diff ^= (1 << (d1 - 1))
    if diff != 0:
        d2 = len(bin(diff)[2:])
        path.append(d2)
    cur = father
path.append(0)
path = list(reversed(path))
print(' '.join(map(str, path)))",np
"def bin_pow(num, _pow, module):
    if _pow == 0:
        return 1
    if _pow == 1:
        return num % module
    if _pow % 2 == 1:
        return num * bin_pow(num, _pow - 1, module) % module
    res = bin_pow(num, _pow//2, module)
    return (res * res) % module

x, k = map(int, input().split())

if x == 0:
    print(0)
    exit(0)

mod = 10**9 + 7

__power = bin_pow(2, k, mod)

print((x* __power * 2 + 1 - __power) % mod)
",O(logn)
"class Solution2(object):
    def numOfMinutes(self, n, headID, manager, informTime):
        def dfs(informTime, children, node):
            return (max(dfs(informTime, children, c)
                        for c in children[node])
                    if node in children
                    else 0) + informTime[node]

        children = collections.defaultdict(list)
        for child, parent in enumerate(manager):
            if parent != -1:
                children[parent].append(child)
        return dfs(informTime, children, headID)",O(n)
"class BIT(object): 
    def __init__(self, n):
        self.__bit = [0]*(n+1) 

    def add(self, i, val):
        i += 1 
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def query(self, i):
        i += 1 
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret



class Solution(object):
    def treeQueries(self, n, edges, queries):
        def iter_dfs():
            L, R, dist, lookup = [0]*n, [0]*n, [0]*n, [0]*n
            cnt = 0
            stk = [(1, (0, -1, 0))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, d = args
                    L[u] = cnt
                    cnt += 1
                    dist[u] = d
                    stk.append((2, (u,)))
                    for v, w in adj[u]:
                        if v == p:
                            continue
                        lookup[v] = w
                        stk.append((1, (v, u, d+w)))
                elif step == 2:
                    u = args[0]
                    R[u] = cnt
            return L, R, dist, lookup

        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            u -= 1
            v -= 1
            adj[u].append((v, w))
            adj[v].append((u, w))
        L, R, dist, lookup = iter_dfs()
        bit = BIT(n)
        result = []
        for q in queries:
            if q[0] == 1:
                _, u, v, w = q
                u -= 1
                v -= 1
                if L[u] > L[v]:
                    u, v = v, u 
                diff = w-lookup[v]
                bit.add(L[v], diff)
                bit.add(R[v], -diff)
                lookup[v] = w
            else:
                _, x = q
                x -= 1
                result.append(dist[x]+bit.query(L[x]))
        return result",O(nlogn)
"def main():
    def calc(x):
        if x & 1:
            return -x + calc(x - 1)
        return x // 2
    n = int(input())
    for i in range(n):
        a, b = map(int, input().split())
        print(calc(b) - calc(a - 1))

main()
",O(1)
"class Solution2(object):
    def plusOne(self, head):
        def reverseList(head):
            dummy = ListNode(0)
            curr = head
            while curr:
                dummy.next, curr.next, curr = curr, dummy.next, curr.next
            return dummy.__next__

        rev_head = reverseList(head)
        curr, carry = rev_head, 1
        while curr and carry:
            curr.val += carry
            carry = curr.val / 10
            curr.val %= 10
            if carry and curr.__next__ is None:
                curr.next = ListNode(0)
            curr = curr.__next__

        return reverseList(rev_head)",O(n)
"import sys

next(sys.stdin)

positions = {}
pos2x = {}
for i, x in enumerate(next(sys.stdin).split()):
    x = int(x)
    positions[x] = i
    pos2x[i] = x

answers = ['' for _ in range(len(positions))]

for x in range(len(positions), 0, -1):

    position = positions[x]

    def can_go_to_looser():

        next_position = position + x
        while next_position < len(positions):

            if pos2x[next_position] > x and answers[next_position] == ""B"":
                return True

            next_position += x

        next_position = position - x
        while next_position >= 0:

            if pos2x[next_position] > x and answers[next_position] == ""B"":
                return True

            next_position -= x

        return False

    if can_go_to_looser():
        answers[position] = ""A""
    else:
        answers[position] = ""B""

print(''.join(answers))
",O(nlogn)
"n=int(input())
print(int(n/2)+1)",O(1)
"def main():
    n, m = map(int, input().split())
    a = []
    for i in range(n):
        s = input()
        b = []
        for l in s:
            b.append(l)
        a.append(b)
    for i in range(1, n - 1):
        for j in range(1, m - 1):
            may = True
            if (a[i][j - 1] == '.' or a[i][j + 1] == '.' or a[i + 1][j - 1] == '.' or a[i + 1][j + 1] == '.' or a[i + 1][j] == '.' or a[i - 1][j - 1] == '.' or a[i - 1][j + 1] == '.' or a[i - 1][j] == '.'):
                may = False
            if (may):
                a[i][j - 1] = a[i][j + 1] = a[i + 1][j - 1] = a[i + 1][j + 1] = a[i + 1][j] = a[i - 1][j - 1] = a[i - 1][j + 1] = a[i - 1][j] = '?'
    for i in range(n):
        for j in range(m):
            if (a[i][j] == '
                print(""NO"")
                return
    print(""YES"")
main()",O(n ^ 2)
"class Solution(object):
    def dayOfTheWeek(self, day, month, year):
        DAYS = [""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", \
                ""Thursday"", ""Friday"", ""Saturday""]

        if month < 3:
            month += 12
            year -= 1
        c, y = divmod(year, 100)
        w = (c//4 - 2*c + y + y//4 + 13*(month+1)//5 + day - 1) % 7
        return DAYS[w]",O(1)
"from sys import stdin

def quadratic(a, b, c):
    num = (b * b) - (4 * a * c)
    if num >= 0:
        return [(-b + (num ** .5)) / (2.0 * a), (-b - (num ** .5)) / (2.0 * a)]
    else:
        return [.5, .5]

n, k = map(int, stdin.readline().split())
for root in quadratic(1, 3, -2 * n - 2 * k):
    ans = n - root
    if ans > -1:
        print(int(ans))
        exit()
",O(logn)
"class Solution2(object):
    def threeSum(self, nums):
        nums, result, i = sorted(nums), [], 0
        while i < len(nums) - 2:
            if i == 0 or nums[i] != nums[i - 1]:
                j, k = i + 1, len(nums) - 1
                while j < k:
                    if nums[i] + nums[j] + nums[k] < 0:
                        j += 1
                    elif nums[i] + nums[j] + nums[k] > 0:
                        k -= 1
                    else:
                        result.append([nums[i], nums[j], nums[k]])
                        j, k = j + 1, k - 1
                        while j < k and nums[j] == nums[j - 1]:
                            j += 1
                        while j < k and nums[k] == nums[k + 1]:
                            k -= 1
            i += 1
        return result",O(n ^ 2)
"import math
def lucky(x):
    return (list(set(list(str(x)))) in [[""4""],[""7""],[""4"",""7""],[""7"",""4""]])
a = int(input())
true = False
for i in range(1, math.ceil(math.sqrt(a))+1):
    if a % i == 0:
        if lucky(i) or lucky(a//i):
            true = True
            break
print(""YES"" if true else ""NO"")",O(1)
"class Solution2(object):
    def isValidSequence(self, root, arr):
        s = [(root, 0)]
        while s:
            node, depth = s.pop()
            if not node or depth == len(arr) or node.val != arr[depth]:
                continue
            if depth+1 == len(arr) and node.left == node.right:
                return True
            s.append((node.right, depth+1))
            s.append((node.left, depth+1))
        return False",O(n)
"n,k=map(int,input().split())
a=list(map(int,input().split()))
q={0}
e=0
l=[]
for i in range(n):
    if a[i] not in q:
        e+=1
        q.add(a[i])
    if e==k:
        e=0
        q={0}
        l+=[i]
w=10**5
t=0
for i in l:
    e=0
    q={0}
    for j in range(i,-1,-1):
        if a[j] not in q:
            e+=1
            q.add(a[j])
        if e==k:
            if w>len(q):
                w=j+1
                t=i+1
            break
if len(set(a))>=k:print(w,t)
else:print(-1,-1)
",O(n)
"import time

(n, k) = (int(i) for i in input().split())

start = time.time()

print((2*n+3-int((9+8*(n+k))**0.5))//2)
finish = time.time()
",O(1)
"from math import sqrt
n,k = map(int, input().split())

ub = k*(k+1)//2 - k+1

if n> ub:
    print(-1)
elif n == ub:
    print(k-1)
elif n == 1:
    print(0)
elif n<=k:
    print(1)
else:
    st = 1
    en = k-1
    target = n-1
    ub = k*(k-1)//2
    p = lambda x: ub - x*(x-1)//2
    ans = -1

    while st <= en:
        md = (st+en)//2
        if p(md) <= target:
            ans = md

            en = md-1
        else:
            st = md +1

    if p(ans) == target:
        print(k-ans)
    else:
        print(k-ans+1)
",O(logn)
"n,v=[int(x) for x in input().split()]
if v>=(n-1):
    print(n-1)
else:
    print(int((((n-v)*(n-v+1))/2)-1+v))
",O(1)
"def f(n,s):
 d=[-n,-n];d[s]=0
 for i in range(y//g):d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
 return d[s]
import math;n,x,y=map(int,input().split());g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));y+=x;print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np
"class Solution:
    def countBits(self, n: int) -> List[int]:
        res = []
        for num in range(n + 1):
            one = 0
            for i in range(32):
                if num & (1 << i):
                    one += 1
            res.append(one)
        return res
",O(n)
"import sys
input = sys.stdin.readline
def main():
    n,m,k = map(int,input().split())
    if k%2==1:
        for i in range(n):
            for j in  range(m):
                print(-1,end="" "")
            print()
        return 0
    kk=k
    maps= [[[0 for i in range(4)] for j in range(m)] for ii in range(n)]

    dp=[[[1e9 for i in range(k//2+1)] for j in range(m)] for ii in range(n)]
    for i in range(n):
            for j in range(m):
                dp[i][j][0]=0
    for i in range(n):
        s=list(map(int,input().split()))
        for j in range(m-1):
            maps[i][j][0]=s[j]
            maps[i][j+1][1]=s[j]
    for i in range(n-1):
        s=list(map(int,input().split()))
        for j in range(m):
            maps[i][j][2]=s[j]
            maps[i+1][j][3]=s[j]
    for k in range(1,kk//2+1):
        for i in range(n):
            for j in range(m):
                if j<m-1:
                    dp[i][j+1][k]=min(dp[i][j+1][k],dp[i][j][k-1]+maps[i][j][0])
                if i<n-1:
                    dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k-1]+maps[i][j][2])
                if i>0:
                    dp[i-1][j][k]=min(dp[i-1][j][k],dp[i][j][k-1]+maps[i][j][3])
                if j>0:
                    dp[i][j-1][k]=min(dp[i][j-1][k],dp[i][j][k-1]+maps[i][j][1])
    for i in range(n):
        for j in range(m):
            print(dp[i][j][k]*2,end="" "")
        print()
main()
",O(n ^ 3)
"import functools
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:

    def __init__(self):
        pass

    def __call__(self):
        s = list(input().strip())
        n = len(s)

        res = list()
        p = n - 1
        ones = 0
        zeros = 0
        while p >= 0:
            if s[p] == '0':
                zeros += 1
            elif s[p] == '1':
                ones += 1
            elif s[p] == '2':
                res.extend(['0'] * zeros)
                res.append('2')
                zeros = 0
            p -= 1
        res.extend(['1'] * ones)
        res.extend(['0'] * zeros)
        res.reverse()
        print(''.join(map(str, res)))

solver()()",O(n)
"class Solution(object):
    def findPairs(self, nums, k):
        if k < 0: return 0
        result, lookup = set(), set()
        for num in nums:
            if num-k in lookup:
                result.add(num-k)
            if num+k in lookup:
                result.add(num)
            lookup.add(num)
        return len(result)",O(n)
"import sys

def read_input(input_path=None):
    if input_path is None:
        f = sys.stdin
    else:
        f = open(input_path, 'r')

    n, m = map(int, f.readline().split())

    return n, m

def sol(n, m):
    v = [0 for _ in range(n+1)]
    left, right = 1, n
    for i in range(1, n + 1):
        if n - i - 1 <= 0:
            pw = 1
        else:
            pw = 1 << (n - i - 1)

        if m <= pw:
            v[left] = i
            left += 1
        else:
            v[right] = i
            right -= 1
            m -= pw
    return [' '.join(map(str, v[1:]))]

def solve(input_path=None):
    return sol(*read_input(input_path))

def main():
    for line in sol(*read_input()):
        print(f""{line}"")

if __name__ == '__main__':
    main()
",np
"
import threading


class Solution(object):
    def __init__(self, n):
        self.__n = n
        self.__curr = False
        self.__cv = threading.Condition()

    def foo(self, printFoo):
        for i in range(self.__n):
            with self.__cv:
                while self.__curr != False:
                    self.__cv.wait()
                self.__curr = not self.__curr
                printFoo()
                self.__cv.notify()

    def bar(self, printBar):
        for i in range(self.__n):
            with self.__cv:
                while self.__curr != True:
                        self.__cv.wait()
                self.__curr = not self.__curr
                printBar()
                self.__cv.notify()
",O(n)
"from collections import Counter

def solve(n, ribbons):
	L = len(ribbons[0])
	a = [Counter(r).most_common(1)[0][1] for r in ribbons]

	r = sorted([(x, i) for i, x in enumerate(a)], reverse=True)

	if n == 1:
		c = Counter(a)
		if c[L - 1] == 1:
			for i in range(3):
				if a[i] == L - 1: return i
		if c[L - 1] > 1:
			return 3
		if c[L] + c[L - 2] == 1:
			for i in range(3):
				if a[i] == L or a[i] == L-2:
					return i
		if c[L] + c[L - 2] > 1:
			return 3

	if r[1][0] == r[0][0]:
		return 3
	if r[1][0] + n >= L:
		return 3
	return r[0][1]

	print(a)

def main():
	n = int(input())
	cats = ('Kuro', 'Shiro', 'Katie', 'Draw')

	ribbons = [input().strip() for _ in range(3)]

	k = solve(n, ribbons)
	print(cats[k])

if __name__ == '__main__':
	main()",O(n)
"import math
def getdt():
    return map(int,input().split())
def calc(v0,v,a,x):
    t = (v - v0)/a
    x0 = v0 * t + 0.5*a*t*t
    if x0>=x:
        return (x,(math.sqrt(v0*v0 + 2*a*x)-v0)/a)
    return (x0,t)
def go(v0,v,a,x):
    x0,t = calc(v0,v,a,x)
    return t + (x-x0)/v
a,v = getdt()
l,d,w = getdt()
if w>v:
    w = v
x,t = calc(0,w,a,d)
if x==d:
    print(go(0,v,a,l))
else:
    print(t+go(w,v,a,(d-x)*0.5) * 2 + go(w,v,a,l-d))
",O(1)
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:

    sys.stdin = open(""input.txt"", ""r"")

except:
    pass
def pmat(A):
    for ele in A:
        print(*ele,end=""\n"")

x=L()[0]
if x<=2:
    print(x)
    exit()
if x%2:
    n=x
    lcm=n*(n-1)//gcd(n,n-1)
    lcm=lcm*(n-2)//gcd(lcm,n-2)
    print(lcm)
else:
    ans=1
    for n1 in range(max(1,x-50),x+1):
        for n2 in range(max(1,x-50),x+1):
            for n3 in range(max(1,x-50),x+1):
                lcm=(n1*n2)//(gcd(n1,n2))
                lcm=(lcm*n3)//gcd(lcm,n3)
                ans=max(ans,lcm)
    print(ans)

endtime = time.time()
",O(1)
"class Solution3(object):
    def frogPosition(self, n, edges, t, target):
        def dfs(G, target, t, node, parent):
            if not t or not (len(G[node])-(parent != 0)):
                return int(node == target)
            result = 0
            for child in G[node]:
                if child == parent:
                    continue
                result = dfs(G, target, t-1, child, node)
                if result:
                    break
            return result*(len(G[node])-(parent != 0))
        
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)
        choices = dfs(G, target, t, 1, 0)
        return 1.0/choices if choices else 0.0",O(n)
"n, m = map(int, input().split())
a = [0 for i in range(n)]
l, r = 0, n - 1
m -= 1

for i in range(1, n + 1):
    cur = 2**(n - i - 1)

    if (m >= cur):
        m -= cur
        a[r] = i
        r -= 1
    else:
        a[l] = i
        l += 1

print(*a)
",np
"class Solution(object):
    def maxProfit(self, prices, fee):
        cash, hold = 0, -prices[0]
        for i in range(1, len(prices)):
            cash = max(cash, hold+prices[i]-fee)
            hold = max(hold, cash-prices[i])
        return cash",O(n)
"n, k = list(map(int, input().split()))
p = list(map(int, input().split()))
processed = set()
color = {}
length = {}
ans = []

def exists(p, elt, d):
    for e in p:
        if e > elt:
            if e <= elt + d:
                return True
            elif e - d <= elt + d:
                return False
    return False

def exists2(p, elt, d):
    for e in p:
        if e > elt:
            if e <= elt + d:
                return False
            elif e - d <= elt + d:
                return [True, e - d]
    return False

for i in range(n):
    elt = p[i]
    if elt in processed:
        ans.append(color[elt])
    else:
        processed.add(elt)
        new = 1
        run = True
        for j in range(1, k):
            if elt - j < 0:
                break
            elif (elt - j) not in processed:
                processed.add(elt - j)
                new += 1
            elif length[elt - j] + new <= k:
                for i2 in range(length[elt - j] + new):
                    color[elt - i2] = color[elt - j]
                length[elt] = length[elt - j] + new
                run = False
                break
            else:
                break
        if run:
            for j in range(new):
                color[elt - j] = elt - new + 1
            length[elt] = new
s = str(color[p[0]])
for elt in p[1:]:
    s += ' ' + str(color[elt])
print(s)
",O(n ^ 2)
"import math

v = [int(x) for x in input().split()]
n = len(v)
val = 0
for i in range(n):
    a = v[i] // n
    arr = v.copy()
    arr[i] = 0
    for j in range(n):
        arr[j] += a
    b = v[i] % n
    k = i + 1
    l = 0
    while l < b:
        if k > n - 1:
            k = 0
        arr[k] += 1
        k += 1
        l += 1

    count = 0
    for j in range(n):
        if arr[j] % 2 == 0:
            count += arr[j]
    val = max(val, count)
print(val)
",O(1)
"n = int(input())
print(25)
",O(1)
"def val(s):
  ans = ((int(s.split('+')[0][1:]) + int(s.split('+')[1].split(')')[0])) / int(s.split('/')[1]))
  return ans

n = int(input())
s = []
f = {}
for i in range(n):
  ss = input()
  s.append(val(ss))
  if(s[i] not in f):
    f[s[i]] = 1
  else:
    f[s[i]] += 1

for i in range(len(s)):
  print(f[s[i]], end= "" "")
print()
",O(n)
"import sys

int1 = lambda x: int(x)-1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.readline())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def LI1(): return list(map(int1, sys.stdin.readline().split()))
def LLI1(rows_number): return [LI1() for _ in range(rows_number)]
def SI(): return sys.stdin.readline().rstrip()
inf = 10**16
md = 10**9+7

n, k = LI()
s = [-1 if c == ""?"" else ord(c)-97 for c in SI()]

def ok(m):
    nxt = [[n]*(n+1) for _ in range(k)]
    for j in range(k):
        cnt = 0
        ni = n
        nxtj = nxt[j]
        for i in range(n)[::-1]:
            if s[i] == -1 or s[i] == j: cnt += 1
            else: cnt = 0
            if cnt >= m: ni = i
            nxtj[i] = ni
    dp = [n+1]*(1 << k)
    dp[0] = 0
    for bit in range(1 << k):
        l = dp[bit]
        if l+m > n: continue
        for j in range(k):
            if bit >> j & 1: continue
            i = nxt[j][l]
            if i+m <= n:
                nbit = bit | 1 << j
                dp[nbit] = min(dp[nbit], i+m)
    return dp[-1] <= n

l, r = 0, n//k+1
while l+1 < r:
    m = (l+r)//2
    if ok(m): l = m
    else: r = m

print(l)
",np
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

def main():

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    def intersection(l1,r1,l2,r2):
        if l1>r2 or r1<l2:
            return [0,0]
        else:
            return [max(l1,l2),min(r1,r2)]
    tc=1
    for _ in range(tc):
        n=ri()
        pref=[]
        suff=[]
        z=[]
        for i in range(n):
            z.append(ria())

        pix,piy=intersection(z[0][0],z[0][1],z[0][0],z[0][1])
        six,siy=intersection(z[-1][0],z[-1][1],z[-1][0],z[-1][1])
        for i in range(n):
            pix,piy=intersection(pix,piy,z[i][0],z[i][1])
            pref.append([pix,piy])
        for i in range(n-1,-1,-1):
            six,siy=intersection(six,siy,z[i][0],z[i][1])
            suff.append([six,siy])
        suff=suff[::-1]
        ans=max(suff[1][1]-suff[1][0],pref[n-2][1]-pref[n-2][0])
        for i in range(1,n-1):
            intersect=intersection(pref[i-1][0],pref[i-1][1],suff[i+1][0],suff[i+1][1])
            ans=max(ans,intersect[1]-intersect[0])

        wi(ans)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(n)
"R = lambda :map(int, input().split())
n = int(input())
l = []
for _ in range(n):
    a,b = R()
    l.append((a,-b,_+1))
l = sorted(l)
for i in range(1,n):
    if l[i][1]>=l[i-1][1]:
        print(l[i][2],l[i-1][2])
        break
else:
    print(-1,-1)",O(nlogn)
"s = [input(), input()]
n = len(s[0])

dp = [[0,0,0] for _ in range(n+1)]

for i in range(n-2,-1,-1):
    dp[i] = [dp[i+1][0]]*3
    vals = [0,0,0,0]
    if s[0][i] == '0' and s[0][i+1] == '0' and s[1][i] == '0':
        vals[0] = dp[i+1][2] + 1
    if s[0][i] == '0' and s[0][i+1] == '0' and s[1][i+1] == '0':
        vals[1] = dp[i+2][0] + 1
    if s[1][i] == '0' and s[0][i+1] == '0' and s[1][i+1] == '0':
        vals[2] = dp[i+2][0] + 1
    if s[0][i] == '0' and s[1][i] == '0' and s[1][i+1] == '0':
        vals[3] = dp[i+1][1] + 1
    dp[i][1] = max(dp[i+1][0], vals[1])
    dp[i][2] = max(dp[i+1][0], vals[2])
    dp[i][0] = max(dp[i][1], dp[i][2], *vals)

result = max(dp[0])
print(result)
",O(1)
"class Solution(object):
    def maximumProduct(self, nums):
        min1, min2 = float(""inf""), float(""inf"")
        max1, max2, max3 = float(""-inf""), float(""-inf""), float(""-inf"")

        for n in nums:
            if n <= min1:
                min2 = min1
                min1 = n
            elif n <= min2:
                min2 = n

            if n >= max1:
                max3 = max2
                max2 = max1
                max1 = n
            elif n >= max2:
                max3 = max2
                max2 = n
            elif n >= max3:
                max3 = n

        return max(min1 * min2 * max1, max1 * max2 * max3)",O(n)
"numbersDict = {
""1"": ""H"",
""2"": ""He"",
""3"": ""Li"",
""4"": ""Be"",
""5"": ""B"",
""6"": ""C"",
""7"": ""N"",
""8"": ""O"",
""9"": ""F"",
""10"": ""Ne"",
""11"": ""Na"",
""12"": ""Mg"",
""13"": ""Al"",
""14"": ""Si"",
""15"": ""P"",
""16"": ""S"",
""17"": ""Cl"",
""18"": ""Ar"",
""19"": ""K"",
""20"": ""Ca"",
""21"": ""Sc"",
""22"": ""Ti"",
""23"": ""V"",
""24"": ""Cr"",
""25"": ""Mn"",
""26"": ""Fe"",
""27"": ""Co"",
""28"": ""Ni"",
""29"": ""Cu"",
""30"": ""Zn"",
""31"": ""Ga"",
""32"": ""Ge"",
""33"": ""As"",
""34"": ""Se"",
""35"": ""Br"",
""36"": ""Kr"",
""37"": ""Rb"",
""38"": ""Sr"",
""39"": ""Y"",
""40"": ""Zr"",
""41"": ""Nb"",
""42"": ""Mo"",
""43"": ""Tc"",
""44"": ""Ru"",
""45"": ""Rh"",
""46"": ""Pd"",
""47"": ""Ag"",
""48"": ""Cd"",
""49"": ""In"",
""50"": ""Sn"",
""51"": ""Sb"",
""52"": ""Te"",
""53"": ""I"",
""54"": ""Xe"",
""55"": ""Cs"",
""56"": ""Ba"",
""57"": ""La"",
""58"": ""Ce"",
""59"": ""Pr"",
""60"": ""Nd"",
""61"": ""Pm"",
""62"": ""Sm"",
""63"": ""Eu"",
""64"": ""Gd"",
""65"": ""Tb"",
""66"": ""Dy"",
""67"": ""Ho"",
""68"": ""Er"",
""69"": ""Tm"",
""70"": ""Yb"",
""71"": ""Lu"",
""72"": ""Hf"",
""73"": ""Ta"",
""74"": ""W"",
""75"": ""Re"",
""76"": ""Os"",
""77"": ""Ir"",
""78"": ""Pt"",
""79"": ""Au"",
""80"": ""Hg"",
""81"": ""Tl"",
""82"": ""Pb"",
""83"": ""Bi"",
""84"": ""Po"",
""85"": ""At"",
""86"": ""Rn"",
""87"": ""Fr"",
""88"": ""Ra"",
""89"": ""Ac"",
""90"": ""Th"",
""91"": ""Pa"",
""92"": ""U"",
""93"": ""Np"",
""94"": ""Pu"",
""95"": ""Am"",
""96"": ""Cm"",
""97"": ""Bk"",
""98"": ""Cf"",
""99"": ""Es"",
""100"": ""Fm""
}

lettersDict = {
""H"": ""1"",
""He"": ""2"",
""Li"": ""3"",
""Be"": ""4"",
""B"": ""5"",
""C"": ""6"",
""N"": ""7"",
""O"": ""8"",
""F"": ""9"",
""Ne"": ""10"",
""Na"": ""11"",
""Mg"": ""12"",
""Al"": ""13"",
""Si"": ""14"",
""P"": ""15"",
""S"": ""16"",
""Cl"": ""17"",
""Ar"": ""18"",
""K"": ""19"",
""Ca"": ""20"",
""Sc"": ""21"",
""Ti"": ""22"",
""V"": ""23"",
""Cr"": ""24"",
""Mn"": ""25"",
""Fe"": ""26"",
""Co"": ""27"",
""Ni"": ""28"",
""Cu"": ""29"",
""Zn"": ""30"",
""Ga"": ""31"",
""Ge"": ""32"",
""As"": ""33"",
""Se"": ""34"",
""Br"": ""35"",
""Kr"": ""36"",
""Rb"": ""37"",
""Sr"": ""38"",
""Y"": ""39"",
""Zr"": ""40"",
""Nb"": ""41"",
""Mo"": ""42"",
""Tc"": ""43"",
""Ru"": ""44"",
""Rh"": ""45"",
""Pd"": ""46"",
""Ag"": ""47"",
""Cd"": ""48"",
""In"": ""49"",
""Sn"": ""50"",
""Sb"": ""51"",
""Te"": ""52"",
""I"": ""53"",
""Xe"": ""54"",
""Cs"": ""55"",
""Ba"": ""56"",
""La"": ""57"",
""Ce"": ""58"",
""Pr"": ""59"",
""Nd"": ""60"",
""Pm"": ""61"",
""Sm"": ""62"",
""Eu"": ""63"",
""Gd"": ""64"",
""Tb"": ""65"",
""Dy"": ""66"",
""Ho"": ""67"",
""Er"": ""68"",
""Tm"": ""69"",
""Yb"": ""70"",
""Lu"": ""71"",
""Hf"": ""72"",
""Ta"": ""73"",
""W"": ""74"",
""Re"": ""75"",
""Os"": ""76"",
""Ir"": ""77"",
""Pt"": ""78"",
""Au"": ""79"",
""Hg"": ""80"",
""Tl"": ""81"",
""Pb"": ""82"",
""Bi"": ""83"",
""Po"": ""84"",
""At"": ""85"",
""Rn"": ""86"",
""Fr"": ""87"",
""Ra"": ""88"",
""Ac"": ""89"",
""Th"": ""90"",
""Pa"": ""91"",
""U"": ""92"",
""Np"": ""93"",
""Pu"": ""94"",
""Am"": ""95"",
""Cm"": ""96"",
""Bk"": ""97"",
""Cf"": ""98"",
""Es"": ""99"",
""Fm"": ""100""
}

_ = input()
atoms = input().split("" "")
outAtoms = input().split("" "")
atoms = sorted(list(map(lambda x: int(lettersDict[x]), atoms)))
outAtoms = sorted(list(map(lambda x: int(lettersDict[x]), outAtoms)))

sumAtoms = 0
def testIfPossible():
    atomsx = atoms.copy()
    outAtomsx = outAtoms.copy()
    for i in range(len(atoms) - 1, -1, -1):
        if atomsx[i] > outAtomsx[-1]:
            atomsx.pop()
    if sum(outAtomsx) > sum(atomsx):
        print(""NO"")
        exit()

testIfPossible()
for at in atoms:
    sumAtoms += at
outAtom = 0
for at in outAtoms:
    outAtom += at
def dfs(i: int, currentSum: int, arr: [int], searchSum: int) -> [[int]]:
    if i >= len(arr) or currentSum + arr[i] > searchSum:
        return []
    totalRes = []

    res = dfs(i + 1, currentSum + arr[i], arr, searchSum)
    totalRes += [[i] + a for a in res]

    res = dfs(i + 1, currentSum, arr, searchSum)
    totalRes += [a for a in res]
    if currentSum + arr[i] == searchSum:
        totalRes.append([i])
    return totalRes

allCombos = [[set(x) for x in dfs(0, 0, atoms, out)] for out in outAtoms]
currentSet = set()
stack = []
resultFound = False
def dfs2(i: int):
    global resultFound
    global stack
    global currentSet
    if i >= len(allCombos):
        resultFound = True
        return
    for set in allCombos[i]:
        if not set & currentSet:
            stack.append(set)
            currentSet = currentSet | set
            dfs2(i + 1)
            if resultFound:
                break
            stack.pop()
            currentSet = currentSet - set
isAnyEmpty = False
for comb in allCombos:
    if not comb:
        isAnyEmpty = True
if not isAnyEmpty:
    dfs2(0)

if resultFound:
    print(""YES"")
    res = list(map(lambda x: ""+"".join(list(map(lambda y: numbersDict[f""{atoms[y]}""],list(x)))), stack))
    outs = list(map(lambda x: numbersDict[f""{x}""], outAtoms))
    tot = list(map(lambda x: x[0] + ""->"" + x[1], zip(res, outs)))

    for t in tot:
        print(t)
else:
    print(""NO"")
",np
"n = int(input())
x, y = [int(i) for i in input().split()]

d1 = abs(x - 1) + abs(y - 1)
d2 = abs(n - x) + abs(n - y)

print(""White"" if d1 <= d2 else ""Black"")
",O(1)
"from sys import stdin
from functools import reduce
from operator import ior
def get_ints(): return list(map(int, stdin.readline().strip().split()))

nk ,m = get_ints()
a = [int(input(),2) for x in range(nk)]
if nk == 1:
	print(""NO"")
	exit()
num =  reduce(ior,a)
for i in range(nk):
	k = a.copy()
	k.pop(i)
	n = reduce(ior,k)
	if n == num:
		print(""YES"")
		exit()
print(""NO"")",O(n ^ 2)
"n,m = input().split()
n=int(n)
m=int(m)

songs=list()

for i in range(n):
    songs.append([int(c) for c in input().split()])

def sumList(lista,inx):
    sum=0
    for i in range(len(lista)):
        sum+=lista[i][inx]
    return sum

songs=sorted(songs,key=lambda x: x[1]-x[0])

suma = sumList(songs,0)

for i in range(n):
    if(suma<=m):
        print(i)
        exit()
    suma-= songs[i][0]-songs[i][1]

if(suma<=m):
    print(n)
else:
    print(-1)
",O(nlogn)
"import math
import random
import heapq, bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys

from collections import defaultdict

mod = 10 ** 9 + 7
mod1 = 998244353

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class TreeNode:
    def __init__(self, k, v):
        self.key = k
        self.value = v
        self.left = None
        self.right = None
        self.parent = None
        self.height = 1
        self.num_left = 1
        self.num_total = 1

class AvlTree:

    def __init__(self):
        self._tree = None

    def add(self, k, v):
        if not self._tree:
            self._tree = TreeNode(k, v)
            return
        node = self._add(k, v)
        if node:
            self._rebalance(node)

    def _add(self, k, v):
        node = self._tree
        while node:
            if k < node.key:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(k, v)
                    node.left.parent = node
                    return node.left
            elif node.key < k:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(k, v)
                    node.right.parent = node
                    return node.right
            else:
                node.value = v
                return

    @staticmethod
    def get_height(x):
        return x.height if x else 0

    @staticmethod
    def get_num_total(x):
        return x.num_total if x else 0

    def _rebalance(self, node):

        n = node
        while n:
            lh = self.get_height(n.left)
            rh = self.get_height(n.right)
            n.height = max(lh, rh) + 1
            balance_factor = lh - rh
            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)
            n.num_left = 1 + self.get_num_total(n.left)

            if balance_factor > 1:
                if self.get_height(n.left.left) < self.get_height(n.left.right):
                    self._rotate_left(n.left)
                self._rotate_right(n)
            elif balance_factor < -1:
                if self.get_height(n.right.right) < self.get_height(n.right.left):
                    self._rotate_right(n.right)
                self._rotate_left(n)
            else:
                n = n.parent

    def _remove_one(self, node):

        replacement = node.left or node.right
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = replacement
            else:
                node.parent.right = replacement
            replacement.parent = node.parent
            node.parent = None
        else:
            self._tree = replacement
            replacement.parent = None
        node.left = None
        node.right = None
        node.parent = None
        self._rebalance(replacement)

    def _remove_leaf(self, node):
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = None
            else:
                node.parent.right = None
            self._rebalance(node.parent)
        else:
            self._tree = None
        node.parent = None
        node.left = None
        node.right = None

    def remove(self, k):
        node = self._get_node(k)
        if not node:
            return
        if AvlTree._is_leaf(node):
            self._remove_leaf(node)
            return
        if node.left and node.right:
            nxt = AvlTree._get_next(node)
            node.key = nxt.key
            node.value = nxt.value
            if self._is_leaf(nxt):
                self._remove_leaf(nxt)
            else:
                self._remove_one(nxt)
            self._rebalance(node)
        else:
            self._remove_one(node)

    def get(self, k):
        node = self._get_node(k)
        return node.value if node else -1

    def _get_node(self, k):
        if not self._tree:
            return None
        node = self._tree
        while node:
            if k < node.key:
                node = node.left
            elif node.key < k:
                node = node.right
            else:
                return node
        return None

    def get_at(self, pos):
        x = pos + 1
        node = self._tree
        while node:
            if x < node.num_left:
                node = node.left
            elif node.num_left < x:
                x -= node.num_left
                node = node.right
            else:
                return (node.key, node.value)
        raise IndexError(""Out of ranges"")

    @staticmethod
    def _is_left(node):
        return node.parent.left and node.parent.left == node

    @staticmethod
    def _is_leaf(node):
        return node.left is None and node.right is None

    def _rotate_right(self, node):
        if not node.parent:
            self._tree = node.left
            node.left.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.left
            node.left.parent = node.parent
        else:
            node.parent.right = node.left
            node.left.parent = node.parent
        bk = node.left.right
        node.left.right = node
        node.parent = node.left
        node.left = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    def _rotate_left(self, node):
        if not node.parent:
            self._tree = node.right
            node.right.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.right
            node.right.parent = node.parent
        else:
            node.parent.right = node.right
            node.right.parent = node.parent
        bk = node.right.left
        node.right.left = node
        node.parent = node.right
        node.right = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    @staticmethod
    def _get_next(node):
        if not node.right:
            return node.parent
        n = node.right
        while n.left:
            n = n.left
        return n

class SegmentTree1:
    def __init__(self, data, default=300006, func=lambda a, b: min(a , b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b:a + b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m

def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z

def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por

def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        if (arr[mid] <=key):
            count = mid + 1
            left = mid + 1

        else:
            right = mid - 1

    return count

def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    leftGreater = n

    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        else:
            l = m + 1

    return (n - leftGreater)

class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.isEndOfWord = False
class Trie:
    def __init__(self):
        self.root = self.getNode()
    def getNode(self):
        return TrieNode()
    def _charToIndex(self, ch):
        return ord(ch) - ord('a')
    def insert(self, key):
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
            if not pCrawl.children[index]:
                pCrawl.children[index] = self.getNode()
            pCrawl = pCrawl.children[index]
        pCrawl.isEndOfWord = True
    def search(self, key):
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
            if not pCrawl.children[index]:
                return False
            pCrawl = pCrawl.children[index]
        return pCrawl != None and pCrawl.isEndOfWord

class Node:
    def __init__(self, data):
        self.data = data
        self.count=0
        self.left = None
        self.right = None
class BinaryTrie:
    def __init__(self):
        self.root = Node(0)
    def insert(self, pre_xor):
        self.temp = self.root
        for i in range(31, -1, -1):
            val = pre_xor & (1 << i)
            if val:
                if not self.temp.right:
                    self.temp.right = Node(0)
                self.temp = self.temp.right
                self.temp.count+=1
            if not val:
                if not self.temp.left:
                    self.temp.left = Node(0)
                self.temp = self.temp.left
                self.temp.count += 1
        self.temp.data = pre_xor
    def query(self, xor):
        self.temp = self.root
        for i in range(31, -1, -1):
            val = xor & (1 << i)
            if not val:
                if self.temp.left and self.temp.left.count>0:
                    self.temp = self.temp.left
                elif self.temp.right:
                    self.temp = self.temp.right
            else:
                if self.temp.right and self.temp.right.count>0:
                    self.temp = self.temp.right
                elif self.temp.left:
                    self.temp = self.temp.left
            self.temp.count-=1
        return xor ^ self.temp.data

n,a1,b=map(int,input().split())
l=[]
ans=0
d=defaultdict(int)
e=defaultdict(list)
e1=defaultdict(int)
for i in range(n):
    a,b,c=map(int,input().split())
    d[(b,c)]+=1
for i in d:
    b,c=i
    e[c-a1*b].append(d[i])
    e1[c-a1*b]+=d[i]
for i in e:
    for j in e[i]:
        ans+=j*(e1[i]-j)
print(ans)",O(n)
"import itertools


class Solution(object):
    def flipgame(self, fronts, backs):
        same = {n for i, n in enumerate(fronts) if n == backs[i]}
        result = float(""inf"")
        for n in itertools.chain(fronts, backs):
            if n not in same:
                result = min(result, n)
        return result if result < float(""inf"") else 0",O(n)
"class Solution:
    def hammingWeight(self, n: int) -> int:
        return bin(n).count('1')
",O(1)
"import bisect
import math
import itertools
import sys

alpha = 'abcdefghijklmnopqrstuvwxyz'
inf = 1e17

def calc1(grid):
    l = len(grid)
    cnt = 0
    for i in range(l):
        for j in range(l):
            if (i+j) % 2 and grid[i][j]:
                cnt += 1
            if (i+j) % 2 == 0 and grid[i][j] == 0:
                cnt += 1
    return cnt

def calc2(grid):
    l = len(grid)
    cnt = 0
    for i in range(l):
        for j in range(l):
            if (i+j) % 2 and grid[i][j] == 0:
                cnt += 1
            if (i+j) % 2 == 0 and grid[i][j]:
                cnt += 1
    return cnt
def solve(n,grids):
    one = []
    zero = []
    for grid in grids:
        one.append(calc1(grid))
        zero.append(calc2(grid))
    take = [3,5,6,9,10,12]
    answer = inf
    for mask in range(16):
        cnt = 0
        if mask not in take:
            continue
        if mask in take:
            if mask & 1:
                cnt += one[3]
                pass
            else:
                cnt += zero[3]
                pass
            if mask & 2:
                cnt += one[2]
                pass
            else:
                cnt += zero[2]
                pass
            if mask & 4:
                cnt += one[1]
                pass
            else:
                cnt += zero[1]
                pass
            if mask & 8:
                cnt += one[0]
                pass
            else:
                cnt += zero[0]
                pass
        answer = min(answer,cnt)
    return answer

t = 1
ans = []
for _ in range(t):
    n = int(input())

    grids = []
    for i in range(4):
        grid = []
        for j in range(n):
            arr = list(map(int,list(input())))
            grid.append(arr)
        if i != 3:
            s = input()
        grids.append(grid)

    ans.append(solve(n,grids))

for test in ans:
    print(test)",O(n ^ 2)
"class Solution2(object):
    def checkPartitioning(self, s):
        dp = [[False]*len(s) for _ in range(len(s))]
        for i in reversed(range(len(s))):
            for j in range(i, len(s)):
                if s[i] == s[j] and (j-i < 2 or dp[i+1][j-1]):
                    dp[i][j] = True
        for i in range(1, len(s)-1):
            if not dp[0][i-1]:
                continue
            for j in range(i+1, len(s)):
                if not dp[j][-1]:
                    continue
                if dp[i][j-1]:
                    return True
        return False",O(n ^ 2)
"n, l, r, x = map(int, input().split())
c = list(map(int, input().split()))

ans = 0

for mask in range(2**n):
    cnt, csum = 0, 0
    mn, mx = 10**18, -(10**18)
    for i in range(n):
        if (mask & (1 << i) != 0):
            cnt += 1
            csum += c[i]
            mn = min(mn, c[i])
            mx = max(mx, c[i])
    if (cnt >= 2) and (csum >= l) and (csum <= r) and (mx - mn >= x):
        ans += 1

print(ans)
",np
"class Solution(object):
    def countVowels(self, word):
        VOWELS = set(""aeiou"")
        return sum((i-0+1) * ((len(word)-1)-i+1) for i, c in enumerate(word) if c in VOWELS)",O(n)
"n=int(input())
a=list(map(int,input().split()))
temp=max(a)
if len(set(a))==1 and a[0]==1:
    print(*a[:-1],2)
else:
    a[a.index(temp)]=1
    a.sort()
    print(*a)",O(nlogn)
"k=int(input(""""))
t=0
if k==0:
    print(""Invalid input"")
    exit()
d=0
e=0
n=5
while(1):
    u=9*n*(10**n)+1-(10**n)-9*k
    if u>0:
        d+=1
        if e>0:
            u=i
            break
        n=n-1
    elif u<0:
        i=u
        e+=1
        if d>0:
            n=n+1
            break
        n=n+1
    else:
        print(9)
        exit()
import math
u=abs(u)
u=u//9
m=u//n
p=u%(n)
if p==0:
    q=10**(n-1)+m-1
    o=q%10
else:
    q = 10**(n-1) + m
    o=((q//(10**(n-p)))%10)
print(o)",O(logn)
"class Solution(object):
    def largestGoodInteger(self, num):
        result = ''
        cnt = 0
        for i, x in enumerate(num):
            cnt += 1
            if i+1 < len(num) and num[i] == num[i+1]:
                continue
            if cnt >= 3:
                result = max(result, num[i])
            cnt = 0
        return result*3",O(n)
"class Solution(object):
    def maximumSubtreeSize(self, edges, colors):
        def iter_dfs():
            result = 0
            stk = [(1, (0, -1, [1]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    stk.append((4, (ret,)))
                    stk.append((2, (u, p, ret, 0)))
                elif step == 2:
                    u, p, ret, i = args
                    if i == len(adj[u]):
                        continue
                    v = adj[u][i]
                    stk.append((2, (u, p, ret, i+1)))
                    if v == p:
                        continue
                    new_ret = [1]
                    stk.append((3, (v, u, new_ret, ret)))
                    stk.append((1, (v, u, new_ret)))
                elif step == 3:
                    v, u, new_ret, ret = args
                    if ret[0] == -1:
                        continue 
                    if new_ret[0] == 0 or colors[v] != colors[u]:
                        ret[0] = -1
                        continue
                    ret[0] += new_ret[0]
                elif step == 4:
                    ret = args[0]
                    result = max(result, ret[0])
            return result

        adj = [[] for _ in range(len(colors))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()",O(n)
"from itertools import accumulate
from sys import stdin, stdout

def main():
    k = int(stdin.readline())
    a = [
        tuple(map(int, stdin.readline().split()[1:]))
        for _ in range(k)
    ]
    a2ij = {
        aij: (i, j)
        for i, ai in enumerate(a)
        for j, aij in enumerate(ai)
    }

    plena = [0, ] + list(accumulate(map(len, a)))
    suma = tuple(map(sum, a))
    totala = sum(suma)

    if totala % k != 0:
        stdout.write(""No\n"")
    else:
        needle = totala // k
        mask2i2cp = compute_mask2i2cp(a, a2ij, needle, plena, suma)
        dp = compute_previous_mask(mask2i2cp)
        output(dp, mask2i2cp)

def compute_mask2i2cp(a, a2ij, needle, plena, suma):
    used = [False, ] * plena[-1]
    number_of_masks = 1 << len(a)
    mask2i2cp = [-1, ] * number_of_masks

    for i, ai in enumerate(a):
        for j, aij in enumerate(ai):
            if not used[plena[i] + j]:
                mask, i2cp = compute_mask_i2cp(a2ij, aij, i, j, needle, suma)

                if i2cp != -1:
                    mask2i2cp[mask] = i2cp

    return mask2i2cp

def output(dp, mask2i2cp):
    mask = len(mask2i2cp) - 1

    if dp[mask] == -1:
        stdout.write(""No\n"")
    else:
        answer = [-1, ] * len(mask2i2cp[dp[mask]])

        while mask > 0:
            current_mask = dp[mask]

            for i, cp in enumerate(mask2i2cp[current_mask]):
                if 1 == ((current_mask >> i) & 1):
                    c, p = cp
                    answer[i] = (c, p)

            mask ^= current_mask

        stdout.write('Yes\n' + '\n'.join('{} {}'.format(c, 1 + p) for c, p in answer))

def compute_mask_i2cp(a2ij, aij, i, j, needle, suma):
    i2cp = [-1, ] * len(suma)
    mask = 0
    current_a = aij
    current_i = i

    try:
        while True:
            next_a = needle - (suma[current_i] - current_a)

            next_i, next_j = a2ij[next_a]

            if ((mask >> next_i) & 1) == 1:
                return mask, -1

            mask |= 1 << next_i
            i2cp[next_i] = (next_a, current_i)

            if next_i == i:
                if next_j == j:
                    return mask, i2cp

                return mask, -1

            if next_i == current_i:
                return mask, -1

            current_a = next_a
            current_i = next_i
    except KeyError:
        return mask, -1

def compute_previous_mask(mask2cp):
    number_of_masks = len(mask2cp)
    dp = [-1, ] * number_of_masks
    dp[0] = 0

    for mask, cp in enumerate(mask2cp):
        if cp != -1:
            complement_mask = (number_of_masks - 1) & (~mask)
            previous_mask = complement_mask

            while previous_mask > 0:
                if dp[previous_mask] != -1 and dp[previous_mask | mask] == -1:
                    dp[previous_mask | mask] = mask

                previous_mask = (previous_mask - 1) & complement_mask

            if dp[mask] == -1:
                dp[mask] = mask
    return dp

if __name__ == '__main__':
    main()
",np
"class Solution(object):
    def smallestEqual(self, nums):
        return next((i for i, x in enumerate(nums) if i%10 == x), -1)",O(n)
"class Solution(object):
    def minimumTime(self, s):
        left = 0
        result = left+(len(s)-0)
        for i in range(1, len(s)+1):
            left = min(left+2*(s[i-1] == '1'), i)
            result = min(result, left+(len(s)-i))
        return result",O(n)
"import os, sys, atexit
from cStringIO import StringIO as BytesIO

sys.stdout = BytesIO()
atexit.register(lambda: os.write(1, sys.stdout.getvalue()))
input = BytesIO(os.read(0, os.fstat(0).st_size)).readline

rints = lambda: [int(x) for x in input().split()]
rstr = lambda: input().strip()
rstr_2d = lambda n: [rstr() for _ in range(n)]

n, m = rints()
grid = rstr_2d(n)
row = [[[] for _ in range(m)] for _ in range(n)]
col = [[[] for _ in range(m)] for _ in range(n)]
visr, out, all = [[-1 for _ in range(m)] for _ in range(n)], [], 0
visc = [[-1 for _ in range(m)] for _ in range(n)]

for i in range(n):
    be, en = -1, -1
    for j in range(m):
        if grid[i][j] == '*':
            en += 1
            if be == -1:
                be = en = j
        else:
            if be != -1:
                for k in range(be, en + 1):
                    row[i][k] = [be, en]
            be = -1

    if be != -1:
        for k in range(be, en + 1):
            row[i][k] = [be, en]

for i in range(m):
    be, en = -1, -1
    for j in range(n):
        if grid[j][i] == '*':
            en += 1
            if be == -1:
                be = en = j
        else:
            if be != -1:
                for k in range(be, en + 1):
                    col[k][i] = [be, en]
            be = -1

    if be != -1:
        for k in range(be, en + 1):
            col[k][i] = [be, en]

for i in range(n):
    for j in range(m):
        if grid[i][j] == '*':
            all += 1
            hor = min(row[i][j][1] - j, j - row[i][j][0])
            ver = min(col[i][j][1] - i, i - col[i][j][0])
            if hor <= ver:
                ver = hor
            else:
                hor = ver

            if hor > 0 and ver > 0:
                out.append('%d %d %d' % (i + 1, j + 1, hor))
                visr[i][j - ver] = j + ver
                visc[i - hor][j] = i + hor

dis = set()
for i in range(n):
    j, ma = 0, -1
    while j < m:
        ma = max(ma, visr[i][j])
        if ma >= j:
            dis.add((i, j))

        j += 1

for i in range(m):
    j, ma = 0, -1
    while j < n:
        ma = max(ma, visc[j][i])
        if ma >= j:
            dis.add((j, i))

        j += 1

if len(dis) != all:
    print(-1)
else:
    sys.stdout.write('%d\n%s' % (len(out), '\n'.join(out)))
",O(n ^ 2)
"class Solution(object):
    def findRelativeRanks(self, nums):
        sorted_nums = sorted(nums)[::-1]
        ranks = [""Gold Medal"", ""Silver Medal"", ""Bronze Medal""] + list(map(str, list(range(4, len(nums) + 1))))
        return list(map(dict(list(zip(sorted_nums, ranks))).get, nums))",O(nlogn)
"def f():
    n = int(input())
    A = [int(s) for s in input().split()]
    memo = [[None for j in range(n+1)] for i in range(n+1)]
    for i in range(n):
        memo[i][i] = [A[i],A[i],1]
    for l in range(2,n+1):
        for left in range(0,n-l+1):
            right = left + l - 1
            minLen = l
            shortestMid = right
            for mid in range(left+1,right+1):
                pre = memo[left][mid-1]
                post = memo[mid][right]
                combLen = pre[2] + post[2]
                if pre[1]==post[0]:
                    combLen -= 1
                if combLen < minLen:
                    minLen = combLen
                    shortestMid = mid
            pre = memo[left][shortestMid - 1]
            post = memo[shortestMid][right]
            startEle = pre[0]
            endEle = post[1]
            if pre[2] == 1:
                if pre[0] == post[0]:
                    startEle = pre[0] + 1
            if post[2] == 1:
                if pre[1] == post[0]:
                    endEle = post[0] + 1
            memo[left][right] = [startEle, endEle, minLen]

    print(memo[0][n-1][2])

f()",O(n ^ 3)
"N = int(input())
first = []
second = []
for i in range(N):
    first.append([s for s in input()])
for i in range(N):
    second.append([s for s in input()])

def rotate_90(matrix):
    return list(zip(*matrix[::-1]))

def flip(matrix):
    return matrix[::-1]

def compare_matrices(first, second):
    for i in range(N):
        for j in range(N):
            if first[i][j] != second[i][j]:
                return False
    return True

def wrap(first, second):
    if compare_matrices(first, second) == True:
        return 'Yes'
    hold_first = first[::]
    for _ in range(3):
        first = rotate_90(first)
        if compare_matrices(first, second) == True:
            return 'Yes'
    first = hold_first
    first = flip(first)
    if compare_matrices(first, second) == True:
        return 'Yes'
    for _ in range(3):
        first = rotate_90(first)
        if compare_matrices(first, second) == True:
            return 'Yes'
    return 'No'

print(wrap(first, second))",O(n ^ 2)
"n = input()

m = 0
for i in range(len(n)):

    for j in range(i,len(n)+1):

        if len(n[i:j])>m and n[i:j] in n[i+1:len(n)]:

            m = len(n[i:j])

print(m)
",O(n ^ 3)
"num = int(input())
layne = input()
layne = layne.split()
layne = [int(i) for i in layne]
mx = max(layne)
dorf = mx * 2 * num
indx = 1
for i in range(num):
    dor = (layne[i] // num) * num
    if (layne[i] % num) - i > 0:
        dor = dor + num + i + 1
    else:
        dor = dor + i + 1
    if dor < dorf:
        dorf = dor
        indx = i + 1
print(indx)",O(n)
"n = int(input())
arr = set(map(int,input().split()))

def solve():
    for i in arr:
        for k in range(31):
            if i - (1 << k) in arr and i + (1 << k) in arr:
                return [i - (1 << k), i, i + (1 << k)]
    for i in arr:
        for k in range(31):
            if i + (1 << k) in arr:
                return [i, i + (1 << k)]

    for i in arr:
        return [i]

lst = solve()

print(len(lst))
print(*lst)
",O(nlogn)
"class Solution(object):
    def minCost(self, s, cost):
        result = accu = max_cost = 0
        for i in range(len(s)):
            if i and s[i] != s[i-1]:
                result += accu-max_cost
                accu = max_cost = 0
            accu += cost[i]
            max_cost = max(max_cost, cost[i])
        result += accu-max_cost
        return result",O(n)
"class Solution3(object):
    def singleNumber(self, nums):
        return [x[0] for x in sorted(list(collections.Counter(nums).items()), key=lambda i: i[1], reverse=False)[:2]]",O(n)
"import math
sone= list(input())
stwo = list(input())
sum1=0
sum2=0
m=0
for i in range(len(sone)):
    if sone[i]=='+':
        sum1=sum1 + 1
        m=m+1
    else:
        sum1=sum1 - 1
k=0
for i in range(len(stwo)):
    if stwo[i]=='+':
        sum2=sum2 + 1
        k=k
    elif stwo[i]=='-':
        sum2=sum2 - 1
        k=k
    elif stwo[i]=='?':
        k=k+1
n=0
if (k-(abs(sum1-sum2)))<0:
    print(float (0))
elif (k-(abs(sum1-sum2)))==0:
    if k==0:
        print(float (1))
    else:
        print(float (pow(0.5,k)))

else:
    n=k-(abs(sum1-sum2))
    n=abs(sum1-sum2)+n/2
    if abs(sum1-sum2)==0:
        print(float ((math.factorial(k)/(math.factorial(k/2)*math.factorial(k/2))) * pow(0.5,k)))
    else:
        print(float ((math.factorial(k)/(math.factorial(k-n) * math.factorial(n))) * pow(0.5,k)))",np
"from sys import stdin, stdout

idx1 = 0
idx2 = 0
VALD = 0

def getminmax(n, m, a):
    l = 0
    h = 1000000009

    while l < h:
        mid = (l+h+1)//2
        exists = existsequalorbig(mid, m, a)

        if exists:

            l = mid
        else:
            h = mid-1

def existsequalorbig(mid, m, a):
    global idx1
    global idx2
    global VALD

    abw = []
    hs = set()

    for i in range(len(a)):
        v = 0
        for j in range(m):
            if a[i][j] >= mid:
                v |= 1
            v <<= 1
        v >>= 1
        if v not in hs:
            hs.add(v)
            abw.append([i, v])

    for i in range(len(abw)):
        for j in range(i, len(abw)):
            if abw[i][1] | abw[j][1] == VALD:
                idx1 = abw[i][0]
                idx2 = abw[j][0]
                return True

    return False

if __name__ == '__main__':
    nm = list(map(int, stdin.readline().split()))
    n = nm[0]
    m = nm[1]

    VALD = int(pow(2, m) - 1)

    a = []
    for i in range(n):
        a.append(list(map(int, stdin.readline().split())))

    getminmax(n, m, a)

    stdout.write(str(idx1+1) + ' ' + str(idx2+1))",np
"n,a=list(map(int,raw_input().split()))
deb=1
fin=n+1
while fin-deb>1:
    m=(fin+deb)//2
    if (m*(m+1))//2-(n-m)>a:
        fin=m
    else:
        deb=m
print(n-deb)
",O(logn)
"class Solution(object):
    def __init__(self):
        def dayOfMonth(M):
            return (28 if (M == 2) else 31-(M-1)%7%2)

        self.__lookup = [0]*12
        for M in range(1, len(self.__lookup)):
            self.__lookup[M] += self.__lookup[M-1]+dayOfMonth(M)

    def daysBetweenDates(self, date1, date2):
        def num_days(date):
            Y, M, D = list(map(int, date.split(""-"")))
            leap = 1 if M > 2 and (((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0)) else 0
            return (Y-1)*365 + ((Y-1)//4 - (Y-1)//100 + (Y-1)//400) + self.__lookup[M-1]+D+leap
     
        return abs(num_days(date1) - num_days(date2))",O(1)
"class Solution2(object):
    def __init__(self):
        self.stack, self.minStack = [], []
    def push(self, x):
        self.stack.append(x)
        if len(self.minStack):
            if x < self.minStack[-1][0]:
                self.minStack.append([x, 1])
            elif x == self.minStack[-1][0]:
                self.minStack[-1][1] += 1
        else:
            self.minStack.append([x, 1])

    def pop(self):
        x = self.stack.pop()
        if x == self.minStack[-1][0]:
            self.minStack[-1][1] -= 1
            if self.minStack[-1][1] == 0:
                self.minStack.pop()

    def top(self):
        return self.stack[-1]

    def getMin(self):
        return self.minStack[-1][0]",O(1)
"class Solution(object):
    def cherryPickup(self, grid):
        n = len(grid)
        dp = [[-1 for _ in range(n)] for _ in range(n)]
        dp[0][0] = grid[0][0]
        max_len = 2 * (n-1)
        directions = [(0, 0), (-1, 0), (0, -1), (-1, -1)]
        for k in range(1, max_len+1):
            for i in reversed(range(max(0, k-n+1), min(k+1, n))): 
                for j in reversed(range(i, min(k+1, n))):         
                    if grid[i][k-i] == -1 or grid[j][k-j] == -1:
                        dp[i][j] = -1
                        continue
                    cnt = grid[i][k-i]
                    if i != j:
                        cnt += grid[j][k-j]
                    max_cnt = -1
                    for direction in directions:
                        ii, jj = i+direction[0], j+direction[1]
                        if ii >= 0 and jj >= 0 and dp[ii][jj] >= 0:
                            max_cnt = max(max_cnt, dp[ii][jj]+cnt)
                    dp[i][j] = max_cnt
        return max(dp[n-1][n-1], 0)",O(n ^ 3)
"class Solution(object):
    def countKeyChanges(self, s):
        return sum(s[i].lower() != s[i+1].lower() for i in range(len(s)-1))",O(n)
"a = input()
l = 0
for i in range(1, len(a)):
  for j in range(0, len(a) - i + 1):

    t = a.find(a[j:j + i])
    c = a.rfind(a[j:j + i])

    if t != c:
      if i > l:
        l = i
print(l)",O(n ^ 3)
"import io
import os
import sys

input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

def prdbg(*args, **kwargs):
    print(*args, **kwargs)
    pass

def get_str():
    return input().decode().strip()

def rint():
    return map(int, input().split())

def oint():
    return int(input())

def valid(i1,i2,i3):
    if (i1+i2+i3)%2 or (i1 < 0 or i2 < 0 or i3 < 0) or i3 > i1 + i2\
            or i2 > i1 + i3 or i1 > i2 + i3:
        return False
    return True

def dfs(i1,i2,i3):

    if (i1 + i2 + i3) % 2 or (i1 < 0 or i2 < 0 or i3 < 0) or i3 > i1 + i2 \
                or i2 > i1 + i3 or i1 > i2 + i3:
        return -2
    if dp[i1][i2][i3] != -1:
        return dp[i1][i2][i3]
    ret1 = dfs(i1-1, i2-1, i3)
    if ret1 >= 0 :
        ret1 += a1[i1]*a2[i2]
    ret2 = dfs(i1-1, i2, i3-1)
    if ret2 >= 0:
        ret2 += a1[i1]*a3[i3]
    ret3 = dfs(i1, i2-1, i3-1)
    if ret3 >= 0:
        ret3 += a2[i2]*a3[i3]
    ret = max(ret1, ret2, ret3)
    dp[i1][i2][i3] = ret
    return ret

n1, n2, n3 = rint()
a1, a2, a3 = list(rint()), list(rint()), list(rint())
a1.sort(reverse=True)
a2.sort(reverse=True)
a3.sort(reverse=True)
a1 = [0] + a1
a2 = [0] + a2
a3 = [0] + a3
n1 += 1
n2 += 1
n3 += 1

dp = [[[-1 for i3 in range(n3)] for i2 in range(n2)] for i1 in range(n1)]
dp[1][1][0] = a1[1]*a2[1]
dp[1][0][1] = a1[1]*a3[1]
dp[0][1][1] = a2[1]*a3[1]
dp[0][0][0] = -2

for i1 in range(n1):
    for i2 in range(n2):
        for i3 in range(n3):
            dfs(i1, i2, i3)
ans = -1
for i1 in range(n1):
    for i2 in range(n2):
        for i3 in range(n3):
            ans = max(ans, dp[i1][i2][i3])

print(ans)
",O(n ^ 3)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

n = ii()
a = li()
lf = [(a[i], i) for i in range(n) if a[i] == 1]
it = [(a[i], i) for i in range(n) if a[i] > 1]
it.sort(reverse=True)
while len(lf) < 2:
    lf.append(it.pop())

ed = []
_, last = lf.pop()

for i in range(len(it)):
    cap, u = it[i]
    if i != 0:
        ed.append((it[i - 1][1], u))
        cap -= 1
    while lf and cap > 1:
        _, l = lf.pop()
        ed.append((u, l))
        cap -= 1

if lf:
    ans = 'NO'
else:
    ans = 'YES %d' % (len(it) + 1,)
    ed.append((it[-1][1], last))
    ans1 = str(len(ed))
    ans2 = '\n'.join('%d %d' % (u + 1, v + 1) for u, v in ed)
    ans = '\n'.join([ans, ans1, ans2])
print(ans)
",O(nlogn)
"import math

def sequence_split_up(sequence):
    ans=[0,0,0]
    for i in sequence:
        if i=='+':
            ans[0]+=1
        elif i=='-':
            ans[1]+=1
        elif i=='?':
            ans[2]+=1
    return ans

def probability():
    actual_sequence=sequence_split_up(drazil_send)
    sequence_received=sequence_split_up(dreamoon_received)
    total_len=sum(actual_sequence)
    actual_ans=actual_sequence[0]-actual_sequence[1]
    ans_received=sequence_received[0]-sequence_received[1]
    difference=actual_ans-ans_received
    no_of_blanks=sequence_received[2]
    if no_of_blanks==0:
        if actual_ans!=ans_received:
            return 0
        return 1
    if abs(difference)>no_of_blanks:
        return 0
    ans_set=[0,0]
    if difference>0:
        ans_set[0]+=difference
    elif difference<0:
        ans_set[1]+=abs(difference)
    blanks_left=no_of_blanks-abs(difference)
    ans_set[0]=ans_set[0]+blanks_left//2
    ans_set[1]=ans_set[1]+blanks_left//2
    x = (math.factorial(no_of_blanks)//(math.factorial(ans_set[0])*math.factorial(ans_set[1])))/math.pow(2,no_of_blanks)
    return x

drazil_send=input()
dreamoon_received=input()
print(""%.12f""%probability())
",np
"import collections



class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def removeZeroSumSublists(self, head):
        curr = dummy = ListNode(0)
        dummy.next = head
        prefix = 0
        lookup = collections.OrderedDict()
        while curr:
            prefix += curr.val
            node = lookup.get(prefix, curr)
            while prefix in lookup:
                lookup.popitem()
            lookup[prefix] = node
            node.next = curr.__next__
            curr = curr.__next__
        return dummy.__next__",O(n)
"class Solution(object):
    def alternateDigitSum(self, n):
        result = 0
        sign = 1
        while n:
            sign *= -1
            result += sign*(n%10)
            n //= 10
        return sign*result",O(logn)
"class Solution(object):
    def romanToInt(self, s):
        numeral_map = {""I"": 1, ""V"": 5, ""X"": 10, ""L"": 50, ""C"":100, ""D"": 500, ""M"": 1000}
        decimal = 0
        for i in range(len(s)):
            if i > 0 and numeral_map[s[i]] > numeral_map[s[i - 1]]:
                decimal += numeral_map[s[i]] - 2 * numeral_map[s[i - 1]]
            else:
                decimal += numeral_map[s[i]]
        return decimal",O(n)
"class Solution2(object):
    def lowestCommonAncestor(self, root, p, q):
        def dfs(node, p, q, result):
            if not node:
                return 0
            left = dfs(node.left, p, q, result)
            right = dfs(node.right, p, q, result)
            curr = int(node == p or node == q)
            if curr+left+right == 2 and not result[0]:
                result[0] = node
            return curr+left+right

        result = [0]
        dfs(root, p, q, result)
        return result[0]",O(n)
"import itertools
import bisect


class Solution(object):
    def jobScheduling(self, startTime, endTime, profit):
        jobs = sorted(zip(endTime, startTime, profit))
        dp = [(0, 0)]
        for e, s, p in jobs:
            i = bisect.bisect_right(dp, (s+1, 0))-1
            if dp[i][1]+p > dp[-1][1]:
                dp.append((e, dp[i][1]+p))
        return dp[-1][1]",O(nlogn)
"class Solution(object):
    def minimumSum(self, n, k):
        def arithmetic_progression_sum(a, d, n):
            return (a+(a+(n-1)*d))*n//2
    
        a = min(k//2, n)
        b = n-a
        return arithmetic_progression_sum(1, 1, a)+arithmetic_progression_sum(k, 1, b)",O(1)
"import sys
input=sys.stdin.readline
class Bit:
    def __init__(self, n):
        self.size = n
        self.tree = [0] * (n + 1)

    def sum(self, i):
        s = 0
        while i > 0:
            s += self.tree[i]
            i -= i & -i
        return s

    def add(self, i, x):
        while i <= self.size:
            self.tree[i] += x
            i += i & -i
n=int(input())
a=list(map(int,input().split()))
bi=Bit(n+1)
c=0
for i,x in enumerate(a):
    bi.add(x,1)
    c+=i+1-bi.sum(x)
if c%2==n%2:
    print(""Petr"")
else:
    print(""Um_nik"")",O(nlogn)
"import sys

class APaintTheNumbers:
    def solve(self):
        n = int(input())
        a = [int(_) for _ in input().split()]
        a.sort()
        ans = 0
        done = [0] * n
        for i in range(n):
            if done[i]: continue
            ans += 1
            for j in range(i, n):
                if done[j]: continue
                if a[j] % a[i] == 0:
                    done[j] = 1

        print(ans)

solver = APaintTheNumbers()
input = sys.stdin.readline

solver.solve()
",O(n ^ 2)
"from collections import defaultdict

n, k = map(int, input().split())

connections = defaultdict(set)

for _ in range(n-1):
	u, v = map(int, input().split())
	connections[u].add(v)
	connections[v].add(u)

leafs = set()
for node in connections:
	if len(connections[node])==1:
		leafs.add(node)

steps = 0
is_correct = True
while is_correct and steps<=k:
	new_leafs = set()
	for x in leafs:
		if len(connections[x])>1:
			is_correct = False

			break
		root = list(connections[x])[0]
		if len(connections[root])<4 and len(leafs)!=3:
			is_correct = False

			break
	if not is_correct:
		break
	for x in leafs:
		root = list(connections[x])[0]
		new_leafs.add(root)
		connections[root].remove(x)
	leafs = new_leafs
	steps += 1
	if len(leafs)==1 and len(connections[list(leafs)[0]])==0:
		break

if is_correct and steps==k:
	print(""Yes"")
else:
	print('No')
",O(nlogn)
"import math

f = [0] * 100
for i in range(100):
    f[i] = (4**i-1) // 3

def solve(N, K):

    if N < 100 and f[N] < K:
        print('NO')
        return

    for i in range(99):
        if f[i] <= K < f[i+1]:
            x = K - f[i]
            a = N - i

            if x == 0:
                print('YES {}'.format(a))
                return

            edge = 2**(i+1) - 1
            others = (2**i-1) ** 2
            if edge == x:
                print('YES {}'.format(a-1))
                return

            ans = a
            if edge < x:
                x -= edge
                ans = a-1

            for j in range(a + 1):
                if others * f[j] >= x:
                    print('YES {}'.format(ans))
                    return
            print('NO')

            return

    print('NO')

T = int(input())

for ti in range(T):
    N, K = map(int, input().split())
    solve(N, K)",O(logn)
"class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        if len(s1) > len(s2):
            return False

        s1Count, s2Count = [0] * 26, [0] * 26
        for i in range(len(s1)):
            s1Count[ord(s1[i]) - ord('a')] += 1
            s2Count[ord(s2[i]) - ord('a')] += 1

        matches = 0
        for i in range(26):
            matches += (1 if s1Count[i] == s2Count[i] else 0)

        l = 0
        for r in range(len(s1), len(s2)):
            if matches == 26:
                return True

            index = ord(s2[r]) - ord('a')
            s2Count[index] += 1
            if s1Count[index] == s2Count[index]:
                matches += 1
            elif s1Count[index] + 1 == s2Count[index]:
                matches -= 1

            index = ord(s2[l]) - ord('a')
            s2Count[index] -= 1
            if s1Count[index] == s2Count[index]:
                matches += 1
            elif s1Count[index] - 1 == s2Count[index]:
                matches -= 1
            l += 1
        return matches == 26
",O(n)
"n, s = map(int, input().split())

def binsearch(n, s):
    left = 0
    right = n
    while left <= right:
        mid = (left + right) // 2
        digits = sum([int(i) for i in list(str(mid))])
        if mid - digits >= s:
            right = mid - 1
        else:
            left = mid + 1

    return right

print(max(0, n - binsearch(n, s)))
",O(logn)
"class Solution2(object):
    def integerReplacement(self, n):
        if n < 4:
            return [0, 0, 1, 2][n]
        if n % 4 in (0, 2):
            return self.integerReplacement(n / 2) + 1
        elif n % 4 == 1:
            return self.integerReplacement((n - 1) / 4) + 3
        else:
            return self.integerReplacement((n + 1) / 4) + 3",O(logn)
"n=int(input())
a=str(n)
m=len(a)
b=int(a[0:m-1])
c=int(a[0:m-2]+a[-1])
d=max(n,b,c)
print(d)
",O(1)
"import collections



class Solution(object):
    def robotWithString(self, s):
        cnt = collections.Counter(s)
        result, stk = [], []
        mn = 'a'
        for c in s:
            stk.append(c)
            cnt[c] -= 1
            while mn < 'z' and cnt[mn] == 0:
                mn = chr(ord(mn)+1)
            while stk and stk[-1] <= mn:
                result.append(stk.pop())
        return """".join(result)",O(n)
"from collections import defaultdict as dd
import math
def nn():
	return int(input())

def li():
	return list(input())

def mi():
	return map(int, input().split())

def lm():
	return list(map(int, input().split()))

n,v=mi()

dist=n-1

if v>=dist:
	print(dist)

else:
	off=dist-v
	prices=[i+2 for i in range(off)]
	print(v+sum(prices))
",O(n)
"import sys
input = lambda: sys.stdin.readline().rstrip('\r\n')

N, M, K = map(int, input().split())
P = []
D_P = {}

for i in range(N):
	S = input()
	P.append(S)
	D_P[S] = i

adj = [[] for _ in range(N)]
indeg = [0] * N

for _ in range(M):
	S, mt = input().split()
	mt = int(mt)-1

	fp = P[mt]

	if any(fp[i] not in (S[i], '_') for i in range(K)):
		print('NO')
		raise SystemExit

	for bs in range(1<<K):
		pat = ''.join(S[i] if bs & (1<<i) == 0 else '_' for i in range(K))
		if pat == fp: continue
		if pat in D_P:
			j = D_P[pat]
			indeg[j] += 1
			adj[mt].append(j)

Q = [i for i in range(N) if indeg[i] == 0]
for i in Q:
	for j in adj[i]:
		indeg[j] -= 1
		if indeg[j] == 0:
			Q.append(j)

if len(Q) == N:
	print('YES')
	print(' '.join(str(v+1) for v in Q))
else:
	print('NO')
",np
"def main():
	l, r = map(int , input().split())
	if l == r :
		print(0)
	else :
		rs = """"
		while (r):
			rs += '1' if r%2 else '0'
			r //= 2
		for i in range(len(rs), 65):
			rs += '0'

		ls = """"
		while (l):
			ls += '1' if l%2 else '0'
			l //= 2
		for i in range(len(ls), 65):
			ls += '0'

		pos = -1
		for i in range(64, -1, -1):

			if (rs[i] == '1' and ls[i] == '0'):
				pos = i
				break

		ans = 2**(pos+1) - 1
		print(ans)

if __name__ == '__main__':
	main()",O(logn)
"from sys import stdin, stdout, exit

t1, t2, t3 = stdin.readline().split()

if t1 == t2 and t2 == t3:
    print(0)
    exit()

ts = [(int(t[0]), t[1]) for t in [t1, t2, t3]]
ts.sort()
ns = [t[0] for t in ts]
ss = [t[1] for t in ts]

if ns[0] + 1== ns[1] and ns[0] + 2 == ns[2] and ss[0] == ss[1] and ss[1] == ss[2]:
    print(0)
    exit()
if ns[0] + 2 >= ns[1] and ss[1] == ss[0]:
    print(1)
    exit()
if ns[1] + 2 >= ns[2] and ss[1] == ss[2]:
    print(1)
    exit()
if ns[0] + 2 >= ns[2] and ss[0] == ss[2]:
    print(1)
    exit()
if ts[0] == ts[1] or ts[1] == ts[2] or ts[2] == ts[0]:
    print(1)
    exit()

print(2)
",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase

def main():
    a=list(map(int,input()))
    b=list(map(int,input()))
    dff=len(b)-len(a)
    if dff<0:
        print(0)
        exit()
    lb=len(b)
    c=[0]*(lb+1)
    for i in range(lb):
        c[i+1]=c[i]+b[i]
    ans=0
    for i in range(len(a)):
        item=a[i]
        if item:
            ans+=(dff+1-(c[dff+i+1]-c[i]))
        else:
            ans+=(c[dff+i+1]-c[i])

    print(ans)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda: self.buffer.read().decode('ascii')
        self.readline = lambda: self.buffer.readline().decode('ascii')

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')

if __name__ == '__main__':
    main()",O(n)
"class Solution(object):
    def __init__(self):
        self.__random_length = 6
        self.__tiny_url = ""http://tinyurl.com/""
        self.__alphabet = ""0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ""
        self.__lookup = {}

    def encode(self, longUrl):
        def getRand():
            rand = []
            for _ in range(self.__random_length):
                rand += self.__alphabet[random.randint(0, len(self.__alphabet)-1)]
            return """".join(rand)

        key = getRand()
        while key in self.__lookup:
            key = getRand()
        self.__lookup[key] = longUrl
        return self.__tiny_url + key

    def decode(self, shortUrl):
        return self.__lookup[shortUrl[len(self.__tiny_url):]]


from hashlib import sha256",O(1)
"n=int(input())
arr=list(map(int,input().split()))
dic={}
for val in arr:
  if val not in dic:
    dic[val]=1
  else:
    dic[val]+=1
flag1=True
if 0 in dic:
  if dic[0]>=2:
    flag1=False
cnt=0
for val in dic.keys():
  if dic[val]>=3:
    flag1=False
    break
  if dic[val]==2:
    cnt+=1
    if val-1 in dic:
      flag1=False
      break
if cnt>=2:
  flag1=False
if flag1==False:
  print('cslnb')
else:
  flag2=(n*(n-1)//2+sum(arr))%2
  if flag2==1:
    print('sjfnb')
  else:
    print('cslnb')",O(n)
"class Solution(object):
    def findMinDifference(self, timePoints):
        minutes = [int(x[:2]) * 60 + int(x[3:]) for x in timePoints]
        minutes.sort()
        return min((y - x) % (24 * 60)  \
                   for x, y in zip(minutes, minutes[1:] + minutes[:1]))",O(nlogn)
"x, k = map(int, input().split())
if x == 0:
    print(0)
else:
    mod = 1000000007
    ans = x * pow(2, k + 1, mod) - pow(2, k, mod) + 1
    print(ans % mod)
",O(logn)
"import math
def maxXor(l, r):
  if l == r:
    return 0
  xor = l ^ r
  twoPows = math.log(xor, 2)
  return 2 ** int(math.floor(twoPows) + 1) - 1

l, r = map(int, input().split())
print(maxXor(l, r))
",O(logn)
"n, k = map(int, input().split())
ps = list(map(int, input().split()))
if k == 1:
    print(' '.join([str(i) for i in ps]))
    exit()

g = [None for i in range(256)]
f = [None for i in range(256)]
ans = []
for i in range(n):
    p = ps[i]
    if g[p] is not None:
        ans.append(g[p])
        f[p] = 1
    else:
        gb= 0
        for j in range(1, k):
            ind = p - j
            if f[ind] is not None:
                gb = ind +1
                break
            if ind <= 0:
                break
            if j == k-1:
                gb = ind
        ans.append(gb)
        for j in range(k):
            if gb+j >= 256:
                break
            if f[gb + j] is None:
                g[gb+j] = gb
            else:
                break
        f[gb] = 1
        f[p] = 1
print(' '.join([str(i) for i in ans]))",O(n ^ 2)
"n,m = map(int,input().split())
d = {x:0 for x in range(m)}
l = []
for _ in range(n):
    s = input()
    for x in range(m):
        if s[x]== '1': d[x]+=1
    l.append(s)
for x in l:
    t=0
    for y in range(m):
        if x[y] =='1':
            if d[y] ==1:t = 1;break
    if t==0: print('YES');exit()
print('NO')",O(n ^ 2)
"def mypw2(deg):
    if (deg >= 1500) : return 2 ** 150

    return 2 ** deg

def sol():
    n, k = map(int, input().split())
    if (k == 0):
        print(""YES"", n)
        return
    for side in range(1, n + 1):
        MIN = mypw2(side + 1) - side - 2
        MAX = mypw2(2 * n) - mypw2(2 * n - side + 1) + mypw2(side + 1) + mypw2(2 * n - 2 * side) - 2;
        MAX //= 3

        if (MIN <= k <= MAX):
            print(""YES"", n - side)
            return
    print(""NO"")

def main():
    t = int(input())
    for i in range(t):
        sol()

main()",O(n)
"class Solution(object):
    def goodBinaryStrings(self, minLength, maxLength, oneGroup, zeroGroup):
        MOD = 10**9+7
        result = 0
        w = max(oneGroup, zeroGroup)+1
        dp = [0]*w
        for i in range(maxLength+1):
            dp[i%w] = 1 if i == 0 else 0
            if i-oneGroup >= 0:
                dp[i%w] = (dp[i%w]+dp[(i-oneGroup)%w])%MOD
            if i-zeroGroup >= 0:
                dp[i%w] = (dp[i%w]+dp[(i-zeroGroup)%w])%MOD
            if i >= minLength:
                result = (result+dp[i%w])%MOD
        return result",O(n)
"class Solution(object):
    def numDecodings(self, s):
        if len(s) == 0 or s[0] == '0':
            return 0
        prev, prev_prev = 1, 0
        for i in range(len(s)):
            cur = 0
            if s[i] != '0':
                cur = prev
            if i > 0 and (s[i - 1] == '1' or (s[i - 1] == '2' and s[i] <= '6')):
                cur += prev_prev
            prev, prev_prev = cur, prev
        return prev",O(n)
"import collections
import itertools


class Solution(object):
    def rearrangeString(self, s, k):
        if not k:
            return s
        cnts = collections.Counter(s)
        bucket_cnt = max(cnts.values())
        if not ((bucket_cnt-1)*k+sum(x == bucket_cnt for x in cnts.values()) <= len(s)):
            return """"
        result = [0]*len(s)
        i = (len(s)-1)%k
        for c in itertools.chain((c for c, v in cnts.items() if v == bucket_cnt), (c for c, v in cnts.items() if v != bucket_cnt)):
            for _ in range(cnts[c]):
                result[i] = c
                i += k
                if i >= len(result):
                    i = (i-1)%k
        return """".join(result)",O(n)
"import sys,os,io
import math,bisect,operator
inf,mod = float('inf'),10**9+7

from itertools import groupby,accumulate
from heapq import heapify,heappop,heappush
from collections import deque,Counter,defaultdict
input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
Neo = lambda : list(map(int,input().split()))

A = sorted(Neo())
B = [0]*100
for i in A:
    j = 0
    for c in range(100):
        if B[c] == 0:
            j = c
            break

    while j < 100:
        B[j] = 1
        j += i
if B.count(0) == 0:
    print('YES')
else:
    print('NO')
",O(1)
"import collections


class UnionFind(object):
    def __init__(self):
        self.set = []

    def get_id(self):
        self.set.append(len(self.set))
        return len(self.set)-1

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root != y_root:
            self.set[min(x_root, y_root)] = max(x_root, y_root)


class Solution(object):
    def accountsMerge(self, accounts):
        union_find = UnionFind()
        email_to_name = {}
        email_to_id = {}
        for account in accounts:
            name = account[0]
            for i in range(1, len(account)):
                if account[i] not in email_to_id:
                    email_to_name[account[i]] = name
                    email_to_id[account[i]] = union_find.get_id()
                union_find.union_set(email_to_id[account[1]],
                                     email_to_id[account[i]])

        result = collections.defaultdict(list)
        for email in list(email_to_name.keys()):
            result[union_find.find_set(email_to_id[email])].append(email)
        for emails in list(result.values()):
            emails.sort()
        return [[email_to_name[emails[0]]] + emails
                for emails in list(result.values())]",O(nlogn)
"def ism(a, b, c):
    return a==b and b==c

def isk(a, b, c):
    x = [a, b, c]
    x.sort()
    if x[0][1] == x[1][1] and x[1][1] == x[2][1]:
        if int(x[0][0])+1 == int(x[1][0]) and int(x[1][0])+1 == int(x[2][0]):
            return 1
    return 0

a, b, c = input().split()
x = [a,b,c]
typem = []
types = []
typep = []
m, s, p = 0, 0, 0

for i in x:
    if i[1]=='m':
        m+=1
        typem.append(i)
    elif i[1]=='s':
        s+=1
        types.append(i)
    elif i[1]=='p':
        p+=1
        typep.append(i)

ans = 0
done = 0

if isk(a,b,c) or ism(a,b,c):
    ans = 0
    done = 1

if done==0 and a==b and b==c:
    ans = 0
    done = 1

elif done==0 and a==b:
    ans = 1
    done = 1

elif done==0 and b==c:
    ans = 1
    done = 1
elif done==0 and a==c:
    ans = 1
    done = 1

if done==0 and m>=2:
    typem.sort()
    for i in range(len(typem)-1):
        if abs(int(typem[i][0]) - int(typem[i+1][0])) <= 2 and \
           abs(int(typem[i][0]) - int(typem[i+1][0])) > 0:
            ans = 1
            done = 1

if done==0 and s>=2:
    types.sort()
    for i in range(len(types)-1):
        if abs(int(types[i][0]) - int(types[i+1][0])) <= 2 and \
           abs(int(types[i][0]) - int(types[i+1][0])) > 0:
            ans = 1
            done = 1

if done==0 and p>=2:
    typep.sort()
    for i in range(len(typep)-1):
        if abs(int(typep[i][0]) - int(typep[i+1][0])) <= 2 and \
           abs(int(typep[i][0]) - int(typep[i+1][0])) > 0:
            ans = 1
            done = 1

if done == 0:
    ans = 2
    done = 1

print(ans)
",O(nlogn)
"import collections


class Solution2_Recu(object):
    def copyRandomBinaryTree(self, root):
        def dfs(node, lookup):
            if not node:
                return
            lookup[node].val = node.val
            lookup[node].left = lookup[node.left]
            lookup[node].right = lookup[node.right]
            lookup[node].random = lookup[node.random]
            dfs(node.left, lookup)
            dfs(node.right, lookup)
    
        lookup = collections.defaultdict(lambda: NodeCopy())
        lookup[None] = None
        dfs(root, lookup)
        return lookup[root]",O(n)
"import sys
input=sys.stdin.buffer.readline

n=int(input())
a=list(map(int,input().split()))
dp=[[0]*(n) for i in range(n)]
for i in range(n):
    dp[i][i]=a[i]
count=1
for i in range(n-1):
    for j in range(n-i-1):
        dp[j][j+count]=dp[j][j+count-1]^dp[j+1][j+count]
    count+=1
count=1
for i in range(n-1):
    for j in range(n-i-1):
        dp[j][j+count]=max(dp[j][j+count],dp[j][j+count-1],dp[j+1][j+count])
    count+=1
for i in range(int(input())):
    l,r=map(int,input().split())
    l-=1
    r-=1
    print(dp[l][r])",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase
import math
from queue import Queue
import itertools
import bisect
import heapq
sys.setrecursionlimit(100000)

def main():
    pass
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while (n > 1):
        n //= 2
        p += 1
    return (p)

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n = n / i
    if n > 2:
        l.append(int(n))
    return (l)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)

def countcon(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if (s[i] == ch):
            c += 1
        else:
            break
    return (c)

def lis(arr):
    n = len(arr)
    lis = [1] * n
    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
    maximum = 0
    for i in range(n):
        maximum = max(maximum, lis[i])
    return maximum
def isSubSequence(str1, str2):
    m = len(str1)
    n = len(str2)
    j = 0
    i = 0
    while j < m and i < n:
        if str1[j] == str2[i]:
            j = j + 1
        i = i + 1
    return j == m
def maxfac(n):
    root = int(n ** 0.5)
    for i in range(2, root + 1):
        if (n % i == 0):
            return (n // i)
    return (n)
def p2(n):
    c=0
    while(n%2==0):
        n//=2
        c+=1
    return c
def seive(n):
    primes=[True]*(n+1)
    primes[1]=primes[0]=False
    for i in range(2,n+1):
        if(primes[i]):
            for j in range(i+i,n+1,i):
                primes[j]=False
    p=[]
    for i in range(0,n+1):
        if(primes[i]):
            p.append(i)
    return(p)
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
            p - 2, p)) % p
def denofactinverse(n,m):
    fac=1
    for i in range(1,n+1):
        fac=(fac*i)%m
    return (pow(fac,m-2,m))
def numofact(n,m):
    fac=1
    for i in range(1,n+1):
        fac=(fac*i)%m
    return(fac)
def sod(n):
    s=0
    while(n>0):
        s+=n%10
        n//=10
    return s
def getVal(x,y,sx,sy):

    if (x == -1 or y == -1 or x == n or y == m):
        return inF
    elif(sx==x):
        return hor[sx][min(sy,y)]
    else:
        return ver[min(sx,x)][sy]
def rec(k,x,y):
    if(x==-1 or y==-1 or x>=n or y>=m):
        return inF
    elif (k == 0):

        dp[k][x][y] = 0
        return dp[k][x][y]
    elif(dp[k][x][y]!=-1):
        return dp[k][x][y]
    else:

        val1=rec(k-1,x-1,y)+getVal(x-1,y,x,y)
        val2=rec(k-1,x+1,y)+getVal(x+1,y,x,y)
        val3=rec(k-1,x,y+1)+getVal(x,y+1,x,y)
        val4=rec(k-1,x,y-1)+getVal(x,y-1,x,y)
        dp[k][x][y]=min(val1,val2,val3,val4)
        return dp[k][x][y]
n,m,k=map(int,input().split())
adj=[[-1]*n for i in range(0,m)]
if(k%2):
    for i in range(0, n):
        for j in range(0, m):
            print(-1, end="" "")
        print("""")
else:
    hor,ver=[],[]
    inF=10**20
    k//=2
    for i in range(0,n):
        hor.append(list(map(int,input().split())))
    for i in range(0,n-1):
        ver.append(list(map(int,input().split())))
    dp=[[[-1]*(m+1) for i in range(0,n+1)]for j in range(0,k+1)]
    for i in range(0,n):
        for j in range(0,m):
            print(2*rec(k,i,j),end="" "")
        print("""")
",O(n ^ 3)
"import os
import sys
from io import BytesIO, IOBase
import math
from queue import Queue
import itertools
import bisect
import heapq

def main():
    pass
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while (n > 1):
        n //= 2
        p += 1
    return (p)

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n = n / i
    if n > 2:
        l.append(int(n))
    return (l)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)

def countcon(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if (s[i] == ch):
            c += 1
        else:
            break
    return (c)

def lis(arr):
    n = len(arr)
    lis = [1] * n
    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
    maximum = 0
    for i in range(n):
        maximum = max(maximum, lis[i])
    return maximum
def isSubSequence(str1, str2):
    m = len(str1)
    n = len(str2)
    j = 0
    i = 0
    while j < m and i < n:
        if str1[j] == str2[i]:
            j = j + 1
        i = i + 1
    return j == m
def maxfac(n):
    root = int(n ** 0.5)
    for i in range(2, root + 1):
        if (n % i == 0):
            return (n // i)
    return (n)
def p2(n):
    c=0
    while(n%2==0):
        n//=2
        c+=1
    return c
def seive(n):
    primes=[True]*(n+1)
    primes[1]=primes[0]=False
    for i in range(2,n+1):
        if(primes[i]):
            for j in range(i+i,n+1,i):
                primes[j]=False
    p=[]
    for i in range(0,n+1):
        if(primes[i]):
            p.append(i)
    return(p)
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
            p - 2, p)) % p
def denofactinverse(n,m):
    fac=1
    for i in range(1,n+1):
        fac=(fac*i)%m
    return (pow(fac,m-2,m))
def numofact(n,m):
    fac=1
    for i in range(1,n+1):
        fac=(fac*i)%m
    return(fac)
def sod(n):
    s=0
    while(n>0):
        s+=n%10
        n//=10
    return s
def getVal(x,y,sx,sy):

    if (x == -1 or y == -1 or x == n or y == m):
        return inF
    elif(sx==x):
        return hor[sx][min(sy,y)]
    else:
        return ver[min(sx,x)][sy]
def rec(k,x,y):
    if(x==-1 or y==-1 or x>=n or y>=m):
        return inF
    elif (k == 0):

        dp[k][x][y] = 0
        return dp[k][x][y]
    elif(dp[k][x][y]!=-1):
        return dp[k][x][y]
    else:

        val1=rec(k-1,x-1,y)+getVal(x-1,y,x,y)
        val2=rec(k-1,x+1,y)+getVal(x+1,y,x,y)
        val3=rec(k-1,x,y+1)+getVal(x,y+1,x,y)
        val4=rec(k-1,x,y-1)+getVal(x,y-1,x,y)
        dp[k][x][y]=min(val1,val2,val3,val4)
        return dp[k][x][y]
n,m,k=map(int,input().split())
adj=[[-1]*n for i in range(0,m)]
if(k%2):
    for i in range(0, n):
        for j in range(0, m):
            print(-1, end="" "")
        print("""")
else:
    hor,ver=[],[]
    inF=10**20
    k//=2
    for i in range(0,n):
        hor.append(list(map(int,input().split())))
    for i in range(0,n-1):
        ver.append(list(map(int,input().split())))
    dp=[[[-1]*(m+1) for i in range(0,n+1)]for j in range(0,k+1)]
    for i in range(0,n):
        for j in range(0,m):
            print(2*rec(k,i,j),end="" "")
        print("""")
",O(n ^ 3)
"from math import gcd

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def func(l,r):
    if l==1:
        l+=1
    if r-l<2:
        return -1

    if l&1:
        if r-l>2:
            l+=1
            return '{} {} {}'.format(l,l+1,l+2)
        else:
            if gcd(l,l+2)!=1:
                return '{} {} {}'.format(l,l+1,l+2)
            return -1
    return '{} {} {}'.format(l, l + 1, l + 2)

def main():
    l,r=map(int,input().split())
    print(func(l,r))
    return

if __name__ == '__main__':
    main()
",O(1)
"

class Solution(object):
    def minOperations(self, nums, k):
        return sum(x < k for x in nums)
",O(n)
"import os
import sys
import math
from io import BytesIO, IOBase
import io
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a+b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

class LazySegTree:
    def __init__(self, _op, _e, _mapping, _composition, _id, v):
        def set(p, x):
            assert 0 <= p < _n
            p += _size
            for i in range(_log, 0, -1):
                _push(p >> i)
            _d[p] = x
            for i in range(1, _log + 1):
                _update(p >> i)

        def get(p):
            assert 0 <= p < _n
            p += _size
            for i in range(_log, 0, -1):
                _push(p >> i)
            return _d[p]

        def prod(l, r):
            assert 0 <= l <= r <= _n

            if l == r:
                return _e

            l += _size
            r += _size

            for i in range(_log, 0, -1):
                if ((l >> i) << i) != l:
                    _push(l >> i)
                if ((r >> i) << i) != r:
                    _push(r >> i)

            sml = _e
            smr = _e
            while l < r:
                if l & 1:
                    sml = _op(sml, _d[l])
                    l += 1
                if r & 1:
                    r -= 1
                    smr = _op(_d[r], smr)
                l >>= 1
                r >>= 1

            return _op(sml, smr)

        def apply(l, r, f):
            assert 0 <= l <= r <= _n
            if l == r:
                return

            l += _size
            r += _size

            for i in range(_log, 0, -1):
                if ((l >> i) << i) != l:
                    _push(l >> i)
                if ((r >> i) << i) != r:
                    _push((r - 1) >> i)

            l2 = l
            r2 = r
            while l < r:
                if l & 1:
                    _all_apply(l, f)
                    l += 1
                if r & 1:
                    r -= 1
                    _all_apply(r, f)
                l >>= 1
                r >>= 1
            l = l2
            r = r2

            for i in range(1, _log + 1):
                if ((l >> i) << i) != l:
                    _update(l >> i)
                if ((r >> i) << i) != r:
                    _update((r - 1) >> i)

        def _update(k):
            _d[k] = _op(_d[2 * k], _d[2 * k + 1])

        def _all_apply(k, f):
            _d[k] = _mapping(f, _d[k])
            if k < _size:
                _lz[k] = _composition(f, _lz[k])

        def _push(k):
            _all_apply(2 * k, _lz[k])
            _all_apply(2 * k + 1, _lz[k])
            _lz[k] = _id

        _n = len(v)
        _log = _n.bit_length()
        _size = 1 << _log
        _d = [_e] * (2 * _size)
        _lz = [_id] * _size
        for i in range(_n):
            _d[_size + i] = v[i]
        for i in range(_size - 1, 0, -1):
            _update(i)

        self.set = set
        self.get = get
        self.prod = prod
        self.apply = apply

MIL = 1 << 20

def makeNode(total, count):

    return (total * MIL) + count

def getTotal(node):
    return math.floor(node / MIL)

def getCount(node):
    return node - getTotal(node) * MIL

nodeIdentity = makeNode(0.0, 0.0)

def nodeOp(node1, node2):
    return node1 + node2

    return makeNode(
        getTotal(node1) + getTotal(node2), getCount(node1) + getCount(node2)
    )

identityMapping = -1

def mapping(tag, node):
    if tag == identityMapping:
        return node

    count = getCount(node)
    return makeNode(tag * count, count)

def composition(mapping1, mapping2):

    return mapping1 if mapping1 != identityMapping else mapping2

prime = [True for i in range(10)]
pp=[0]*10
def SieveOfEratosthenes(n=10):
    p = 2
    c=0
    while (p * p <= n):

        if (prime[p] == True):
            c+=1
            for i in range(p, n+1, p):
                pp[i]+=1
                prime[i] = False
        p += 1

def binarySearch(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[n-1]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] >= key):
            res=arr[mid]
            right = mid-1
        else:
            left = mid + 1
    return res

def binarySearch1(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[0]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] > key):
            right = mid-1
        else:
            res=arr[mid]
            left = mid + 1
    return res

n,k= map(int,input().split(' '))
l= list(map(int,input().split(' ')))
f =list(map(int,input().split(' ')))
h=list(map(int,input().split(' ')))
d1=dict({(a,0) for a in f})
d2=dict({(a,0) for a in f})
for a in l:
	if(a in d1):d1[a]+=1
for a in f:
	d2[a]+=1

dp = [[0 for i in range(520*12)] for j in range(520)]

for x in range(n+1):
	for y in range(n*k+1):
		for i in range(k+1):
				dp[x+1][y+i] = max(dp[x+1][y+i],+dp[x][y]+(0 if i==0 else h[i-1]) )
ss=0
for i in d1:

	ss+=dp[d2[i]][d1[i]]
print(ss)",O(n ^ 3)
"class Solution4(object):
    def maxOutput(self, n, edges, price):
        def dfs(u, p):
            dp[u] = price[u]
            for v in adj[u]:
                if v == p:
                    continue
                dp[u] = max(dp[u], dfs(v, u)+price[u])
            return dp[u]
        
        def dfs2(u, p, curr):
            result[0] = max(result[0], curr, dp[u]-price[u])
            top2 = [[curr, p], [0, -1]]
            for v in adj[u]:
                if v == p:
                    continue
                curr = [dp[v], v]
                for i in range(len(top2)):
                    if curr > top2[i]:
                        top2[i], curr = curr, top2[i]
            for v in adj[u]:
                if v == p:
                    continue
                dfs2(v, u, (top2[0][0] if top2[0][1] != v else top2[1][0])+price[u])
    
        result = [0]
        dp = [0]*n 
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dfs(0, -1)
        dfs2(0, -1, 0)
        return result[0]",O(n)
"n, U = list(map(int, input().strip().split()))
E = list(map(int, input().strip().split()))

mmax = -1
for i in range(0, n-2):
    j = i + 1
    l = j + 1
    r = n - 1
    while l < r:
        mid = (l + r) // 2
        if E[mid] - E[i] <= U:
            l = mid + 1
        else:
            r = mid - 1
    if E[l] - E[i] <= U:
        cur = (E[l] - E[j]) / (E[l] - E[i])
        mmax = max(mmax, cur)
    else:
        if l - 1 > j and E[l-1] - E[i] <= U:
            cur = (E[l-1] - E[j]) / (E[l-1] - E[i])
            mmax = max(mmax, cur)
print(mmax)
",O(nlogn)
"import itertools



class Solution4(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=lambda _: None,
                         query_fn=lambda x, y: max(x, y),
                         update_fn=lambda x, y: max(x, y)):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(self.tree[x], h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def query(self, L, R):
                if L > R:
                    return None
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L //= 2
                    R //= 2
                return self.query_fn(left, right)

        price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))}
        result = NEG_INF
        st1, st2 = SegmentTree(len(price_to_idx)), SegmentTree(len(price_to_idx))
        for price, profit in zip(prices, profits):
            mx2 = st2.query(0, price_to_idx[price]-1)
            if mx2 is not None:
                result = max(result, mx2+profit)
            st1.update(price_to_idx[price], profit)
            mx1 = st1.query(0, price_to_idx[price]-1)
            if mx1 is not None:
                st2.update(price_to_idx[price], mx1+profit)
        return result if result != NEG_INF else -1",O(nlogn)
"import sys,os,io
from math import log, gcd
from collections import defaultdict, deque
from heapq import heappush, heappop

def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res

def si():
    return input()

def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r

def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1

def ii():
    return int(input())

def li():
    return list(map(int,input().split()))

t = 1
for _ in range(t):
    n = ii()
    l = li()
    l1 = l[:]
    l1.sort()
    pos = []
    for i in range(n):
        if (l1[i]!=l[i]):
            pos.append(i)
    if (len(pos)==0) or (len(pos)==2 and l[pos[0]]==l1[pos[1]] and l[pos[1]]==l1[pos[0]]):
        print(""YES"")
    else:
        print(""NO"")
",O(nlogn)
"class Solution(object):
    def minimizeConcatenatedLength(self, words):
        dp = [[float(""-inf"")]*26 for _ in range(2)]
        dp[0][ord(words[0][-1])-ord('a')] = dp[1][ord(words[0][0])-ord('a')] = 0
        for i in range(1, len(words)):
            new_dp = [[float(""-inf"")]*26 for _ in range(2)]
            for right in range(2):
                for c in range(26):
                    if dp[right][c] == float(""-inf""):
                        continue
                    l = c if right else ord(words[i-1][0])-ord('a')
                    r = c if not right else ord(words[i-1][-1])-ord('a')
                    new_dp[0][r] = max(new_dp[0][r], dp[right][c]+int(ord(words[i][-1])-ord('a') == l))
                    new_dp[1][l] = max(new_dp[1][l], dp[right][c]+int(r == ord(words[i][0])-ord('a')))
            dp = new_dp
        return sum(len(w) for w in words)-max(dp[right][c] for right in range(2) for c in range(26))",O(n)
"import collections


class Solution(object):
    def maxOperations(self, nums, k):
        count = collections.Counter()
        result = 0
        for x in nums:
            if k-x in count and count[k-x]:
                count[k-x] -= 1
                result += 1
            else:
                count[x] += 1
        return result",O(n)
"class Solution(object):
    def differenceOfSums(self, n, m):
        def arithmetic_progression_sum(a, d, l):
            return (a+(a+(l-1)*d))*l//2
    
        return arithmetic_progression_sum(1, 1, n) - 2*arithmetic_progression_sum(m, m, n//m)",O(1)
"import sys
input = lambda: sys.stdin.readline().rstrip()

def solve():
    n, m, k = map(int, input().split())
    a = []
    b = []
    for i in range(n):
        a.append(list(map(int, input().split())))
    for i in range(n-1):
        b.append(list(map(int, input().split())))
    if k % 2:
        ans = [-1] * m
        for i in range(n):
            print(*ans)
        return
    k //= 2
    pre = [[0]*m for i in range(n)]
    cur = [[10**9]*m for i in range(n)]
    for _ in range(k):
        cur = [[10**9] * m for i in range(n)]
        for i in range(n):
            for j in range(m):
                if i:
                    cur[i][j] = min(cur[i][j], pre[i-1][j]+b[i-1][j])
                if i < n - 1:
                    cur[i][j] = min(cur[i][j], pre[i+1][j]+b[i][j])
                if j:
                    cur[i][j] = min(cur[i][j], pre[i][j-1]+a[i][j-1])
                if j < m - 1:
                    cur[i][j] = min(cur[i][j], pre[i][j+1]+a[i][j])
        pre = cur
    for i in range(n):
        cur[i] = [cur[i][j]*2 for j in range(m)]
        print(*cur[i])

solve()
",O(n ^ 3)
"ct = [0]*26

n, k =[int(i) for i in input().split()]
s = input()

for i in s:
    ct[ord(i)-ord('A')]+=1

print(min(ct[:k])*k)
",O(n)
"import collections
import heapq


class Solution(object):
    def highFive(self, items):
        min_heaps = collections.defaultdict(list)
        for i, val in items:
            heapq.heappush(min_heaps[i], val)
            if len(min_heaps[i]) > 5:
                heapq.heappop(min_heaps[i])
        return [[i, sum(min_heaps[i]) // len(min_heaps[i])] for i in sorted(min_heaps)]",O(nlogn)
"class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        A = []
        for i, num in enumerate(nums):
            A.append([num, i])

        A.sort()
        i, j = 0, len(nums) - 1
        while i < j:
            cur = A[i][0] + A[j][0]
            if cur == target:
                return [min(A[i][1], A[j][1]),
                        max(A[i][1], A[j][1])]
            elif cur < target:
                i += 1
            else:
                j -= 1
        return []
",O(nlogn)
"class Solution2(object):
    def findLengthOfShortestSubarray(self, arr):
        result = 0
        for i in range(1, len(arr)):
            if arr[i-1] <= arr[i]:
                continue
            j = len(arr)-1
            while j > i and (j == len(arr)-1 or arr[j] <= arr[j+1]) and arr[i-1] <= arr[j]:
                j -= 1
            result = j-i+1
            break
        for j in reversed(range(len(arr)-1)):
            if arr[j] <= arr[j+1]:
                continue
            i = 0
            while i < j and (i == 0 or arr[i-1] <= arr[i]) and arr[i] <= arr[j+1]:
                i += 1
            result = min(result, j-i+1)
            break
        return result",O(n)
"import sys
import bisect

l=input().split()
a=l[0]
b=l[1]
p=[]
for i in range(len(a)):
    for j in range(len(b)):
        ok=a[:i+1]+b[:j+1]
        p.append(ok)
print(min(p))
",O(n)
"from math import sin, pi
n, r = map(int, input().split())
R = r*sin(pi/n)/(1-sin(pi/n))
print(R)
",O(1)
"n = int(input())
s = input()

if n == 1:
    print(s)
else:
    zeros = s.count('0')
    print('1' + zeros * '0')
",O(n)
"class Solution(object):
    def maxValueAfterReverse(self, nums):
        result, add, max_pair, min_pair = 0, 0, float(""-inf""), float(""inf"")
        for i in range(1, len(nums)):
            result += abs(nums[i-1]-nums[i])
            add = max(add,
                      abs(nums[0]-nums[i]) - abs(nums[i-1]-nums[i]),
                      abs(nums[-1]-nums[i-1]) - abs(nums[i-1]-nums[i]))
            min_pair = min(min_pair, max(nums[i-1], nums[i]))
            max_pair = max(max_pair, min(nums[i-1], nums[i]))
        return result + max(add, (max_pair-min_pair)*2)",O(n)
"import math
from collections import defaultdict

def main():
    n, k = map(int, input().split())
    cards = list(map(int, input().split()))
    fav = list(map(int, input().split()))

    h = [0] + list(map(int, input().split()))

    cards_cnt = defaultdict(int)
    for val in cards:
        cards_cnt[val] += 1

    players_fav_cnt = defaultdict(int)
    for val in fav:
        players_fav_cnt[val] += 1

    dp = [[0 for _ in range(k*n+k+1)] for _ in range(n+1)]
    for p in range(n):
        for c in range(k*n+1):
            for hand in range(k+1):
                dp[p+1][c+hand] = max(dp[p+1][c+hand], dp[p][c] + h[hand])

    res = 0
    for f in players_fav_cnt:
        res += dp[players_fav_cnt[f]][cards_cnt[f]]

    print(res)

if __name__ == '__main__':
    main()
",O(n ^ 3)
"class Solution(object):
    def nextClosestTime(self, time):
        h, m = time.split("":"")
        curr = int(h) * 60 + int(m)
        result = None
        for i in range(curr+1, curr+1441):
            t = i % 1440
            h, m = t // 60, t % 60
            result = ""%02d:%02d"" % (h, m)
            if set(result) <= set(time):
                break
        return result",O(1)
"r,g,b = map(int,input().split())
R = sorted([*map(int,input().split())],reverse=True)
G= sorted([*map(int,input().split())],reverse=True)
B = sorted([*map(int,input().split())],reverse=True)
mem = [[[-1 for i in range(201)] for j in range(201)] for j in range(201)]
def dp(i,j,k):
    p = (i==r)+(j==g)+(k==b)
    if(p>1):
        return 0
    if(mem[i][j][k]!=-1):
        return mem[i][j][k]
    ans = 0
    if(i==r):
        ans = dp(i,j+1,k+1)+G[j]*B[k]
        return ans
    elif(j==g):
        ans = dp(i+1,j,k+1)+R[i]*B[k]
    elif(k==b):
        ans = dp(i+1,j+1,k)+R[i]*G[j]
    else:
        ans = max(dp(i+1,j+1,k)+R[i]*G[j],dp(i,j+1,k+1)+G[j]*B[k],dp(i+1,j,k+1)+R[i]*B[k])
    mem[i][j][k] = ans
    return ans
print(dp(0,0,0))",O(n ^ 3)
"n=int(input())
s=list(map(int,input().split()))
c=list(map(int,input().split()))
dp=[float('inf')]*(n)
for i in range(1,n):
    mn=float('inf')
    for j in range(i):
        if s[i]>s[j]:
            mn=min(mn,c[i]+c[j])
    dp[i]=mn
res=float('inf')
for i in range(1,n):
    for j in range(i):
        if s[i]>s[j]:
            res=min(res,c[i]+dp[j])
if res==float('inf'):
    res=-1
print(res)
",O(n ^ 2)
"class Solution(object):
    def eraseOverlapIntervals(self, intervals):
        intervals.sort(key=lambda interval: interval[1])
        result, right = 0, float(""-inf"")
        for l, r in intervals:
            if l < right:
                result += 1
            else:
                right = r
        return result",O(nlogn)
"import sys
def input(): return sys.stdin.readline().strip()

n, mod = map(int, input().split())

le = 405

def pow(x, y):
    ans = 1
    while y > 0:
        if y % 2 == 1:
            ans = (ans * x) % mod
        x = (x**2) % mod
        y //= 2
    return ans

def inv(x):
    return pow(x, mod-2)

M = [1]
mul = 1
for i in range(1, le):
    mul = (mul * i) % mod
    M.append(mul)

MI = [0] * (le-1) + [inv(M[le-1])]
for i in range(le-2, -1, -1):
    MI[i] = MI[i+1] * (i+1) % mod

def C(x, y):
    if y < 0 or y > x:
        return 0
    elif x > le:
        y = min(y, x-y)
        ans = 1
        for i in range(x, x-y, -1):
            ans = (ans * i) % mod
        return (ans * MI[y]) % mod
    else:
        ans = M[x]
        ans = (ans * MI[y]) % mod
        return (ans * MI[x-y]) % mod

M2 = [1]
for i in range(n+5):
    M2.append((M2[-1]*2) % mod)

CO = [[0] * (n+5) for i in range(n+5)]
for i in range(n+5):
    for j in range(n+5):
        CO[i][j] = C(i, j)

D = [[0] * (n+1) for i in range(n+2)]

D[0][0] = 1
for i in range(n+2):
    for j in range(i//2, min(n+1, i+1)):

        for k in range(1, min(n+1, n-i+1, n-j+1)):

            ind0 = i+k+1
            ind1 = j+k
            if ind0 <= n+1 and ind1 <= n:
                D[ind0][ind1] += D[i][j] * CO[j+k][k] * M2[k-1]
                D[ind0][ind1] %= mod

print(sum(D[-1]) % mod)
",O(n ^ 3)
"import sys
from collections import Counter

input = sys.stdin.readline
testcase=int(sys.stdin.readline())
A=[list(map(int,input().split())) for i in range(testcase*2)]

for t in range(testcase):
    counter=Counter(A[t*2+1])
    LIST=[]
    for c in counter:
        if counter[c]>=4:
            print(c,c,c,c)
            break
        elif counter[c]>=2:
            LIST.append(c)
    else:
        LIST.sort()

        ANS=[LIST[0],LIST[1],LIST[1]/LIST[0]]
        for i in range(2,len(LIST)):
            if LIST[i]/LIST[i-1]<ANS[2]:
                ANS=[LIST[i-1],LIST[i],LIST[i]/LIST[i-1]]

        print(ANS[0],ANS[0],ANS[1],ANS[1])
",O(nlogn)
"n=int(input())
l=[int(x) for x in input().split()]
if l==sorted(l):
	print(""Yes"")
else:
	cnt=0;
	g=sorted(l)
	for i in range(len(l)):
		if l[i]!=g[i]:
			cnt+=1
	if cnt<=2:
		print(""Yes"")
	else:
		print(""No"")",O(nlogn)
"s = input()
res = 0
solve = 0
for pos in range(1,len(s)):
    for i in range(len(s) - pos):
        if s[i:i+pos] in s[i+1:]:
            if solve < pos:
                solve = pos
print(solve)",O(n ^ 3)
"a=int(input())
b=int(input())
x=[0]*10
while a:
    x[a%10]+=1
    a=a//10
ans=0
for i in range(9,-1,-1):
    for j in range(x[i]):
        ans=ans*10+i
if ans<=b:
    print(ans)
else:
    ans=0
    for j in str(b):
        c=int(j)
        while c>=0 and not x[c]:
            c-=1
        if c<0:
            while True:
                x[ans%10]+=1
                d=ans%10
                ans=ans//10
                flag=0
                for b in range(d-1,-1,-1):

                    if x[b]:
                        ans=ans*10+b
                        x[b]-=1
                        flag=1
                        break
                if flag:
                    break
            break

        else:
            x[c]-=1
            ans=ans*10+c
            if c<int(j):
                break

    for j in range(9,-1,-1):
        for i in range(x[j]):
            ans=ans*10+j
    print(ans)
",O(n ^ 3)
"class Solution(object):
    def maximumSumScore(self, nums):
        prefix = suffix = 0
        result = float(""-inf"")
        right = len(nums)-1
        for left in range(len(nums)):
            prefix += nums[left]
            suffix += nums[right]
            right -= 1
            result = max(result, prefix, suffix)
        return result",O(n)
"class Solution(object):
    def insert(self, intervals, newInterval):
        result = []
        i = 0
        while i < len(intervals) and newInterval[0] > intervals[i][1]:
            result += intervals[i],
            i += 1
        while i < len(intervals) and newInterval[1] >= intervals[i][0]:
            newInterval = [min(newInterval[0], intervals[i][0]),
                           max(newInterval[1], intervals[i][1])]
            i += 1
        result.append(newInterval)
        result.extend(intervals[i:])
        return result",O(n)
"class Solution(object):
    def lastMarkedNodes(self, edges):
        def bfs(root):
            new_root = -1
            dist = [-1]*len(adj)
            dist[root] = 0
            q = [root]
            while q:
                new_root = q[0]
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if dist[v] != -1:
                            continue
                        dist[v] = dist[u]+1
                        new_q.append(v)
                q = new_q
            return dist, new_root
            
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        _, u = bfs(0)
        dist1, v = bfs(u)
        dist2, _ = bfs(v)
        return [u if dist1[w] > dist2[w] else v for w in range(len(adj))]",O(n)
"if __name__ == '__main__':
    nums = input().split()
    n = int(nums[0])
    v = int(nums[1])

    if n < v+2:
        print(n - 1)
    else:
        print(int(v-1 + (n-v)*(n-v+1)/2))",O(1)
"s1, s2 = input().split()
ans = s1[0]
for i in range(1, len(s1)):
    if s1[i] < s2[0]:
        ans += s1[i]
        if i == len(s1) - 1:ans += s2[0]
    else:
        ans += s2[0]
        break
if len(s1) == 1:print(s1[0] + s2[0])
else:print(ans)",O(n)
"class Solution(object):
    def prisonAfterNDays(self, cells, N):
        N -= max(N-1, 0) // 14 * 14 
        for i in range(N):
            cells = [0] + [cells[i-1] ^ cells[i+1] ^ 1 for i in range(1, 7)] + [0]
        return cells",O(1)
"from sys import stdin
inp = lambda : stdin.readline().strip()

nr, ng, nb = [int(x) for x in inp().split()]

r = [int(x) for x in inp().split()]
g = [int(x) for x in inp().split()]
b = [int(x) for x in inp().split()]
r.sort()
g.sort()
b.sort()
dp = [[[0 for _ in range(201)] for _ in range(201)] for _ in range(201)]
for i in range(nr+1):
    for j in range(ng+1):
        for k in range(nb+1):
            if i and j:
                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1]);
            if i and k:
                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1]);
            if j and k:
                dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1]);

print(dp[nr][ng][nb])",O(n ^ 3)
"from collections import defaultdict
from sys import stdout,stdin
n,m,K=map(int,input().split())
dp=[[[0 for h in range(11)]for j in range(m+1)] for i in range(n+1)]
l1=[list(map(int,stdin.readline().split())) for i in range(n)]
l2=[list(map(int,stdin.readline().split())) for i in range(n-1)]
if K%2:
    for i in range(n):
        for j in range(m):
            print('-1',end=' ')
        print()
else:
    for k in range(1,K//2+1):
     for i in range(n):
        for j in range(m):
                res=100000000
                if i-1>=0 and j>=0:
                     res=min(res,l2[i-1][j]+dp[i-1][j][k-1])
                if i+1<n and j>=0:
                     res=min(res,l2[i][j]+dp[i+1][j][k-1])
                if 0<=i and j+1<m:
                     res=min(res,l1[i][j]+dp[i][j+1][k-1])
                if 0<=i and j-1>=0:
                     res=min(res,l1[i][j-1]+dp[i][j-1][k-1])
                dp[i][j][k]=res
    for i in range(n):
        for j in range(m):
            stdout.write(str(2*dp[i][j][K//2])+' ')
        stdout.write('\n')",O(n ^ 3)
"n = int(input())
a = list(map(int, input().split()))
d = {}
for ai in a:
	if ai in d:
		d[ai] += 1
	else:
		d[ai] = 1
if max(d.values()) >= 3 or 0 in d and d[0] >= 2 or list(d.values()).count(2) >= 2:
	print('cslnb')
	exit()
for i in d:
	if d[i] == 2 and i - 1 in d:
		print('cslnb')
		exit()
s = sum(a)
if s >= n * (n - 1) // 2:
	if (s - n * (n - 1) // 2) % 2 == 0:
		print('cslnb')
	else:
		print('sjfnb')
else:
	pass
",O(n)
"from math import factorial
n, mod = map(int, input().split())
def binom(n, m):    return factorial(n) // factorial(m) // factorial(n-m)
def foo(x, k):
    ans = 0
    for i in range(k, 0, -1):sign = 1 if (i-k)%2 == 0 else -1;ans += sign * binom(k, i) * (i**x);ans %= mod
    return ans
def f(x, k):    return (foo(x, k) * pow(2, x-k, mod)) % mod
ans = 0
for i in range((n+1)//2):ans = (ans + f(n-i, i+1));ans %= mod
print(ans)",O(n ^ 3)
"a,v=map(int,input().split())

l,d,w=map(int,input().split())

t=0

def gett(a,b,c):

    delta=b**2-4*a*c

    t1=(-b+delta**(1/2))/(2*a)

    t2=(-b-delta**(1/2))/(2*a)

    if min(t1,t2)>0:

        return min(t1,t2)

    else:

        return max(t1,t2)

if 2*a*d<=w*w or v<=w:

    if 2*a*l<=v*v:

        t=(2*l/a)**(1/2)

    else:

        t=l/v+v/a/2

else:

    tmp=d-1/2*v*v/a+1/2*(v-w)**2/a-v*(v-w)/a

    if tmp<=0:

        tmp2=l-d-(1/2*(v-w)**2/a+w*(v-w)/a)

        if tmp2>=0:

            t=tmp2/v+(v-w)/a+2*gett(a,2*w,w*w/(2*a)-d)+w/a

        else:

            t=gett(a/2,w,d-l)+2*gett(a,2*w,w*w/(2*a)-d)+w/a

    else:

        tmp2=l-d-(1/2*(v-w)**2/a+w*(v-w)/a)

        if tmp2>=0:

            t=tmp2/v+(v-w)/a+(2*v-w)/a+tmp/v

        else:

            t=gett(a/2,w,d-l)+(2*v-w)/a+tmp/v

print(""%.12f"" %(t))
",O(1)
"n, m = map(int, input().split())
a = []
array = []
for i in range(n):
    a.append(list(map(str, input())))
    listt = []
    for c in range(m):
        if a[i][c] == '
            listt.append(1)
        else:
            listt.append(0)
    array.append(listt)
for y in range(1, n - 1):
    for x in range(1, m - 1):
        f = a[y + 1][x] == '
        s = a[y][x + 1] == '
        th = a[y - 1][x] == '
        if f and s and th:
            array[y + 1][x] -= 1
            array[y + 1][x + 1] -= 1
            array[y + 1][x - 1] -= 1
            array[y][x + 1] -= 1
            array[y][x - 1] -= 1
            array[y - 1][x - 1] -= 1
            array[y - 1][x] -= 1
            array[y - 1][x + 1] -= 1
mb = True
for y in range(n):
    for x in range(m):
        if array[y][x] == 1:
            mb = False
            break
if mb:
    print(""YES"")
else:
    print(""NO"")",O(n ^ 2)
"import collections


class Solution(object):
    def brightestPosition(self, lights):
        count = collections.Counter()
        for i, r in lights:
            count[i-r] += 1
            count[i+r+1] -= 1
        result = None
        max_cnt = cnt = 0
        for i, c in sorted(count.items()):
            cnt += c
            if cnt > max_cnt:
                max_cnt, result = cnt, i
        return result",O(nlogn)
"def find(A):
    from collections import defaultdict
    A=sorted(A)
    N=len(A)
    dic=defaultdict(int)
    for i in range(N):
        dic[A[i]]+=1

    checked=[]
    count=set([])
    for x in A:
        if dic[x]>2:
            return ""cslnb""
        if dic[x]==2:
            count.add(x)
            y=x-1
            if y in dic:
                return ""cslnb""
    if len(count)>1:
        return ""cslnb""

    if 0 in count:
        return ""cslnb""

    temp=0
    for i in range(N):
        temp+=A[i]-i
    if temp%2==1:
        return ""sjfnb""
    return ""cslnb""
input()
A=list(map(int,input().strip().split(' ')))
print(find(A))",O(nlogn)
"t=int(input())
for _ in range(t):
	n,k=list(map(int,input().split()))
	if n>=32:
		print(""YES ""+str(n-1))
	else:
		ans=-1
		for i in range(1,n+1):
			p=(4**i)-(2**(i+1))+1
			p*=(((4**(n-i))-1)//3)
			g=(((4**i)-1)//3)
			p+=(((4**i)-1)//3)
			g=(((4**i)-1)//3)-(((4**(i-1))-1)//3)
			if g<=k and p>=k:
				ans=n-i
				break
		if ans!=-1:
			print(""YES ""+str(ans))
		else:
			print(""NO"")",O(nlogn)
"import collections


class Solution(object):
    def recoverArray(self, nums):
        def check(k, cnt, result):
            for x in nums:
                if cnt[x] == 0:
                    continue
                if cnt[x+2*k] == 0:
                    return False
                cnt[x] -= 1
                cnt[x+2*k] -= 1
                result.append(x+k)
            return True
            
        nums.sort()
        cnt = collections.Counter(nums)
        for i in range(1, len(nums)//2+1):
            k = nums[i]-nums[0]
            if k == 0 or k%2:
                continue
            k //= 2
            result = []
            if check(k, collections.Counter(cnt), result):
                return result
        return []",O(n ^ 2)
"import sys
from collections import deque, defaultdict
input = lambda: sys.stdin.readline().rstrip()
def topological_sort(In, Out):
    dq, L = deque(), []
    for i, I in enumerate(In):
        if not I:
            dq.append(i)
    while dq:
        v = dq.popleft()
        L.append(v)
        for w in Out[v]:
            In[w].remove(v)
            if not In[w]:
                dq.append(w)
    if len(L) < len(In):
        return False
    return L

def main():
    n, m, k = map(int,input().split())

    def edges(s):
        Ans = set()
        for i in range(2**k):
            ans = [s[j] if i>>j&1 else '_' for j in range(k)]
            Ans.add(''.join(ans))
        return Ans

    D = defaultdict(lambda : -1)
    for i in range(n):
        D[input()] = i

    flag = 1
    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]
    for _ in range(m):
        S, t = input().split()
        t = int(t)

        for e in edges(S):
            if D[e]+1:
                Out[t-1].add(D[e])
                In[D[e]].add(t-1)
        if t-1 not in Out[t-1]:
            flag = 0
            break
        else:
            Out[t-1].remove(t-1)
            In[t-1].remove(t-1)

    T = topological_sort(In, Out)
    if flag and T:
        print('YES')
        print(*[t+1 for t in T], sep = ' ')
    else:
        print('NO')

main()",np
"def get_fingering(notes):
    fingering = []
    diff = 0
    next_diff = None
    finger = 0
    for i in range(len(notes) - 1):
        next_diff = notes[i+1] - notes[i]
        if diff == 0:
            if next_diff > 0:
                finger = 1 + (finger == 1)
            elif next_diff < 0:
                finger = 5 - (finger == 5)
            else:
                finger = 3 + (finger == 3)
        elif diff > 0:
            if finger == 5:
                return None
            if next_diff < 0:
                finger = 5
            else:
                finger += 1
        else:
            if finger == 1:
                return None
            if next_diff > 0:
                finger = 1
            else:
                finger -= 1
        fingering.append(finger)
        diff = next_diff

    return fingering

_ = input()
notes = [int(x) for x in input().split()]
notes.append(notes[-1])

fingering = get_fingering(notes)

if fingering:
    print(*fingering)
else:
    print(-1)
",O(n)
"s0=input()
k=int(input())
s1=s0[::-1]
lens1=len(s1)
maxnum=1005
mod=1000000007
dp=[[0]*maxnum for tmpi in range(maxnum)]
f=[0]*maxnum
c=[[0]*maxnum for tmpi in range(maxnum)]

def cntone(num):
    tmps=bin(num)[2:]
    cnt=0
    for i in range(len(tmps)):
        if(tmps[i]=='1'):
            cnt+=1
    return cnt

for i in range(1,maxnum):
    if(i==1):
        f[i]=0
    else:
        f[i]=f[cntone(i)]+1

for i in range(maxnum):
    if(i==0):
        c[i][0]=1
        continue
    for j in range(i+1):
        if(j==0):
            c[i][j]=1
        else:
            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod

for i in range(lens1):
    if(i==0):
        dp[i][0] = 1
        if(s1[i]=='1'):
            dp[i][1]=1
        else:
            dp[i][1]=0
        continue
    else:
        for j in range(0,i+2):
            if(j==0):
                dp[i][j]=1
                continue
            if(s1[i]=='1'):
                dp[i][j]=(dp[i-1][j-1]+c[i][j])%mod
            else:
                dp[i][j]=dp[i-1][j]%mod

ans=0

for i in range(1,lens1+1):
    if(f[i]==k-1):
        ans=(ans+dp[lens1-1][i])%mod

if(k==0):
    ans=1
elif(k==1):
    ans-=1
else:
    ans=ans
print(ans)",O(n)
"import sys

input=lambda : sys.stdin.readline().strip()
char = [chr(i) for i in range(97,123)]
CHAR = [chr(i) for i in range(65,91)]
mp = lambda:list(map(int,input().split()))
INT = lambda:int(input())
rn = lambda:range(INT())

from math import ceil,sqrt,factorial,gcd

r,g,b = mp()
rl = sorted(mp(),reverse=True)
gl = sorted(mp(),reverse=True)
bl = sorted(mp(),reverse=True)

def solve(i,j,k):
	if dp_table[i][j][k] != -1:
		return dp_table[i][j][k]

	if i < r and j < g and k < b:
		m = max(solve(i+1,j+1,k)+(rl[i]*gl[j]), solve(i+1,j,k+1)+(rl[i]*bl[k]), solve(i,j+1,k+1)+(gl[j]*bl[k]))
		dp_table[i][j][k] = m
		return m

	elif i < r and j < g:
		m = solve(i+1,j+1,b) + rl[i]*gl[j]
		dp_table[i][j][k] = m
		return m

	elif i < r and k < b:
		m = solve(i+1,g,k+1) + (rl[i]*bl[k])
		dp_table[i][j][k] = m
		return m

	elif j < g and k < b:
		m = solve(r,j+1,k+1) + (gl[j]*bl[k])
		dp_table[i][j][k] = m
		return m
	else:
		return 0

dp_table = [[[-1]*(b+1) for j in range(g+1)] for k in range(r+1)]
res = solve(0,0,0)
print(res)
",O(n ^ 3)
"from sys import stdin

EPS = 1e-6
n = int(stdin.readline())
m = int(stdin.readline())
a = list(map(int, stdin.readline().split()))
b = list(map(int, stdin.readline().split()))
b.append(b[0])

def check(f):
    fuel_left = f
    total_weight = float(m + fuel_left)
    for i in range(n):
        cost = total_weight / a[i]
        fuel_left = fuel_left - cost
        total_weight = total_weight - cost

        cost = total_weight / b[i + 1]
        fuel_left = fuel_left - cost
        total_weight = total_weight - cost
        if fuel_left < 0:
            return False
    return True

def binary_search(left, right):
    mid = (left + right) / 2
    if abs(left - right) < EPS:
        return mid
    if check(mid):
        return binary_search(left, mid)
    else:
        return binary_search(mid, right)

res = binary_search(0, 1e9 + 1)

if res - 1e9 > EPS:
    print(-1)
else:
    print(""%.10f"" % res)
",O(n)
"class Node(object):
    def __init__(self, val="" "", left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def expTree(self, s):
        def compute(operands, operators):
            right, left = operands.pop(), operands.pop()
            operands.append(Node(val=operators.pop(), left=left, right=right))

        precedence = {'+':0, '-':0, '*':1, '/':1}
        operands, operators, operand = [], [], 0
        for i in range(len(s)):
            if s[i].isdigit():
                operand = operand*10 + int(s[i])
                if i == len(s)-1 or not s[i+1].isdigit():
                    operands.append(Node(val=str(operand)))
                    operand = 0
            elif s[i] == '(':
                operators.append(s[i])
            elif s[i] == ')':
                while operators[-1] != '(':
                    compute(operands, operators)
                operators.pop()
            elif s[i] in precedence:
                while operators and operators[-1] in precedence and \
                      precedence[operators[-1]] >= precedence[s[i]]:
                    compute(operands, operators)
                operators.append(s[i])
        while operators:
            compute(operands, operators)
        return operands[-1]",O(n)
"from sys import stdin
from math import hypot

def main():
    l = stdin.read().splitlines()[1:]
    for i, s in enumerate(l):
        l[i] = [*map(float, s.split()), i]
    l.sort(key=lambda xyi: abs(xyi[0]))
    res = ['1'] * len(l)
    x, y, _ = l.pop()
    while(l):
        dx, dy, i=l.pop()
        a, b, u, v = x + dx, y + dy, x - dx, y - dy
        if hypot(a, b) < hypot(u, v):
            x, y = a, b
        else:
            x, y, res[i] = u, v, '-1'
    print(' '.join(res))

if __name__ == '__main__':
    main()
",O(nlogn)
"class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []



class Solution(object):
    def moveSubTree(self, root, p, q):
        def iter_find_parents(node, parent, p, q, is_ancestor, lookup):
            stk = [(1, [node, None, False])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, parent, is_ancestor = params
                    if node in (p, q):
                        lookup[node] = parent
                        if len(lookup) == 2:
                            return is_ancestor
                    stk.append((2, [node, is_ancestor, reversed(node.children)]))
                else:
                    node, is_ancestor, it = params
                    child = next(it, None)
                    if not child:
                        continue
                    stk.append((2, [node, is_ancestor, it]))
                    stk.append((1, [child, node, is_ancestor or node == p]))
            assert(False)
            return False

        lookup = {}
        is_ancestor = iter_find_parents(root, None, p, q, False, lookup)
        if p in lookup and lookup[p] == q:
            return root
        q.children.append(p)
        if not is_ancestor:
            lookup[p].children.remove(p)
        else:
            lookup[q].children.remove(q)
            if p == root:
                root = q
            else:
                lookup[p].children[lookup[p].children.index(p)] = q
        return root",O(n)
"class Solution(object):
    def minOperations(self, nums):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        cnt = nums.count(1)
        if cnt:
            return len(nums)-cnt
        result = float(""inf"")
        for i in range(len(nums)): 
            g = nums[i]
            for j in range(i+1, len(nums)):
                g = gcd(g, nums[j])
                if g == 1:
                    result = min(result, j-i)
                    break
        return result+(len(nums)-1) if result != float(""inf"") else -1",O(n ^ 2)
"import sys,math,bisect
from random import randint
inf = float('inf')
mod = 998244353
""========================================""
def lcm(a,b):
    return int((a/math.gcd(a,b))*b)
def gcd(a,b):
    return int(math.gcd(a,b))
def tobinary(n):
    return bin(n)[2:]
def binarySearch(a,x):
    i = bisect.bisect_left(a,x)
    if i!=len(a) and a[i]==x:
        return i
    else:
        return -1
def lowerBound(a, x):
    i = bisect.bisect_left(a, x)
    if i:
        return (i-1)
    else:
        return -1
def upperBound(a,x):
    i = bisect.bisect_right(a,x)
    if i!= len(a)+1 and a[i-1]==x:
        return (i-1)
    else:
        return -1
def primesInRange(n):
    ans = []
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    for p in range(2, n+1):
        if prime[p]:
            ans.append(p)
    return ans
def primeFactors(n):
    factors = []
    while n % 2 == 0:
        factors.append(2)
        n = n // 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            factors.append(i)
            n = n // i
    if n > 2:
        factors.append(n)
    return factors
def isPrime(n,k=5):
    if (n <2):
        return True
    for i in range(0,k):
        a = randint(1,n-1)
        if(pow(a,n-1,n)!=1):
            return False
    return True
""=========================================""

from collections import deque,defaultdict,Counter
import heapq,string

n=int(input())
s=input()
s=[int(i) for i in s]
flag=False
for i in range(0,(9*n)+1):
    count=0
    sum = 0
    for j in s:
        sum+=j
        if sum==i:
            count+=1
            sum=0
    if count>1 and sum==0:
        print('YES')
        exit(0)
print('NO')
",O(n ^ 2)
"import bisect
import time
def ass(a, b): print(f""Assertion error: {a} != {b}"" if a != b else 'OK')
def nr(): return int(input())
def nrs(): return [int(i) for i in input().split()]

def get_prime(n):
	res = []
	for i in range(2, n):
		is_prime = True
		for x in res:
			if i % x == 0:
				is_prime = False
				break
		if is_prime: res.append(i)
	return res

cache = {}

def get_mask(num):
	key = num
	if key in cache: return cache[key]
	dv = []
	for p in prime:
		c = 0
		while num % p == 0:
			c += 1
			num = num // p
		if c % 2 == 1:
			dv.append(p)
		if num < p * p:
			break

	for x in dv:
		num *= x

	cache[key] = num
	return num

def dump(dp):
	for i,line in enumerate(dp):
		print(i%10,line)

def get_left(n,k,lst):
	last_in = {}
	s = []
	res = []
	for i in range(n):
		group = get_mask(lst[i])
		if group in last_in: bisect.insort(s, last_in[group] + 1)
		last_in[group] = i
		if len(s) <= k+1:
			res.append(s[::-1])
		else:
			m = len(s)
			res.append(s[m-1:m-k-2:-1])
	return res

def get_dp(n,k,lst):
	res = []
	left = get_left(n,k,lst)
	for i in range(n):
		arr = left[i]
		row = [n] * (k+1)
		for j in range(k+1):
			for g in range(j+1):
				if g >= len(arr):
					row[j] = 1
				else:
					index = arr[g]-1
					jindex = j-g
					row[j] = min(res[index][jindex] + 1, row[j])
		res.append(row)
	return res

def f(n,k,lst):
	dp = get_dp(n,k,lst)
	print(dp[n-1][k])

prime = get_prime(3162)

for _ in range(nr()):
	n,k = nrs()
	f(n,k,nrs())
",O(n ^ 3)
"def main():
    x, k = list(map(int, input().split()))
    if x == 0:
        print(0)
        return 0
    def helper(n):
        if n == 0:
            return 1
        p = 1
        ret = 2
        while n >= 2 * p:
            p *= 2
            ret = (ret ** 2) % 1000000007
        return ret * helper(n - p)
    x = x % 1000000007
    k = k % 1000000006
    a = helper(k)
    print((2 * a * x - a + 1) % 1000000007)
    return 0
main()
",O(logn)
"n=int(input())
g={}
for i in range(1,n):
    p=int(input())
    if g.get(p):g[p].append(i+1)
    else:g[p]=[i+1]
ams='YES'
for i in g:
    c=0
    for j in g[i]:
        if j not in g:c+=1
    if c<3:ams='NO'
print(ams)",O(n)
"class Solution(object):
    def numKLenSubstrNoRepeats(self, S, K):
        result, i = 0, 0
        lookup = set()
        for j in range(len(S)):
            while S[j] in lookup:
                lookup.remove(S[i])
                i += 1
            lookup.add(S[j])
            result += j-i+1 >= K
        return result",O(n)
"class Solution(object):
    def averageValue(self, nums):
        total = cnt = 0
        for x in nums:
            if x%6:
                continue
            total += x
            cnt += 1
        return total//cnt if cnt else 0",O(n)
"class Solution(object):
    def maxDepthAfterSplit(self, seq):
        return [(i & 1) ^ (seq[i] == '(') for i, c in enumerate(seq)]",O(n)
"a, b = map(int, input().split())

bitxor = a^b

res = 1
while bitxor:
    bitxor >>= 1
    res <<= 1

print(res-1)
",O(logn)
"class Solution(object):
    def zeroFilledSubarray(self, nums):
        result = 0
        prev = -1
        for i in range(len(nums)):
            if nums[i]:
                prev = i
                continue
            result += i-prev
        return result",O(n)
"class Solution(object):
    def minChanges(self, s):
        return sum(s[i] != s[i+1] for i in range(0, len(s), 2))",O(n)
"class Solution(object):
    def countTexts(self, pressedKeys):
        MOD = 10**9+7
        dp = [1]*5
        for i in range(1, len(pressedKeys)+1):
            dp[i%5] = 0
            for j in reversed(range(max(i-(4 if pressedKeys[i-1] in ""79"" else 3), 0), i)):
                if pressedKeys[j] != pressedKeys[i-1]:
                    break
                dp[i%5] = (dp[i%5]+dp[j%5])%MOD
        return dp[len(pressedKeys)%5]",O(n)
"class Solution(object):
    def longestOnes(self, A, K):
        result, i = 0, 0
        for j in range(len(A)):
            K -= int(A[j] == 0)
            while K < 0:
                K += int(A[i] == 0)
                i += 1
            result = max(result, j-i+1)
        return result",O(n)
"x, k = (int(x) for x in input().split())
mod = 10 ** 9 + 7
if x == 0:
    print(0)
    exit()
if k == 0:
    print(2 * x % mod)
    exit()

ans = pow(2, k + 1, mod)
ans *= x
ans %= mod
ans -= pow(2, k, mod)
ans += 1
ans %= mod
ans += mod
ans %= mod

print(ans)
",O(logn)
"k = int(input())
count = 1
number = 1
result = 0
number1 = 1
while True:
    if number == 1:
        if result + 9 < k:
            result += 9
            number = 20
            number1 = 10
        else:
            break
    elif number == 20:
        if result + 180 < k:
            result += 180
            number += 10
            number1 = 100
        else:
            break
    else:
        if result + 9 * number * 10**count < k:
            result += 9 * number * 10**count
            number += 10
            count += 1
            number1 *= 10
        else:
            break

while True:
    if count == 0:
        break
    if result + number * 10**count < k:
        result += number * 10**count
        number1 += 100 * 10**(count - 1)
    else:
        count -= 1

while True:
    if number == 1:
        break
    if result + number < k:
        result += number
        number1 += 10
    else:
        break

while True:
    if result + len(str(number1)) >= k:
        print(str(number1)[k - result - 1])
        break
    else:
        number1 += 1
        result += len(str(number1))
",O(logn)
"n, m = map(int, input().split())
grid = []
for i in range(n):
    grid.append(input())
cnts = [0 for i in range(m)]
for i in range(n):
    for j in range(m):
        cnts[j] += 0 if grid[i][j] == '0' else 1
for i in range(n):
    flag = True
    for j in range(m):
        if grid[i][j] == '1' and cnts[j] == 1:
            flag = False
            break
    if flag:
        print('YES')
        exit(0)
print('NO')
",O(n ^ 2)
"import heapq



class Solution(object):
    def minEliminationTime(self, timeReq, splitTime):
        heapq.heapify(timeReq)
        for _ in range(len(timeReq)-1):
            heapq.heappush(timeReq, max(heapq.heappop(timeReq), heapq.heappop(timeReq))+splitTime)
        return timeReq[0]",O(nlogn)
"import math
s1=list(input())
s2=list(input())
p1,m1,p2,m2,c=0,0,0,0,0
for i in range(len(s1)):
	if(s1[i]=='+'):
		p1+=1
	if(s1[i]=='-'):
		m1+=1
	if(s2[i]=='+'):
		p2+=1
	if(s2[i]=='-'):
		m2+=1
	if(s2[i]=='?'):
		c+=1
p=abs(p1-p2)
m=abs(m1-m2)
if((p+m)==c):
	print(math.factorial(c)/(math.factorial(p)*math.factorial(m)*pow(2,c)))
else:
	print(0/1)",np
"A, B, C, N = map(int, input().strip().split())
D = N - (A + B - C)
if D <= 0 or C > A or C > B:
    print('-1')
    exit(0)
print(D)
",O(1)
"def  getc():
    f = [[0]*500 for i in range(500)]
    for i in range(500):
        f[i][0] = 1
    f[1][0] = 1
    f[1][1] = 1
    for i in range(2,411):
        for j in range(1, i+1):
            f[i][j] = (f[i-1][j-1] + f[i-1][j])%mod
    return f
n, mod = map(int, input().split())
f = [[0]*500 for i in range(500)]
c = getc()
mi_2 = [0]*500
mi_2[0] = 1
for i in range(1, 500):
    mi_2[i] = mi_2[i-1]*2%mod
for i in range(1, n+1):
    for j in range(0, i//2+1):
        if j == 0:
            f[i][j] = mi_2[i-1]
        else:
            for k in range(2, i):
                f[i][j] = (f[i][j] + ((mi_2[k-2]*f[i-k][j-1])%mod)*c[i-j][k-1]%mod)%mod
ans = 0
for i in range(0,n+1):
    ans = (ans + f[n][i])%mod
print(ans)
",O(n ^ 3)
"k1, k2, k3  = sorted(map(int, input().split()))

if 1 == k1 or (2 == k1 and 2 == k2) or (3 == k1 and 3 == k2 and 3 == k3) \
    or (k1 == 2 and k2 == 4 and k3 == 4):
    print(""YES"")
else:
    print(""NO"")",O(1)
"import sys
import math
def rec(i,n,l):

    if i == n:
        return []

    else:
        x = l2[i]
        flag = 0
        o = []
        p = []
        mi = -1
        for j in l:
            if j < x:
                if j > mi:
                    if i == 0 and j == 0:
                        o.append(j)
                        p.append(j)
                        continue

                    mi = j

            if x == j:
                flag = 1

            o.append(j)
            p.append(j)

        if flag:
            o.remove(x)

        if mi == -1 and flag == 0:
            return []

        ans1 = []
        if flag:

            ans1 = [x]+rec(i+1,n,o)

        if mi != -1:
            p.remove(mi)

        p.sort(reverse = True)
        ans2 = [mi]+p
        if len(ans1) == n-i:
            return ans1

        else:
            return ans2

for _ in range(1):
    a = int(input())
    b = int(input())
    e1 = str(a)
    e2 = str(b)
    l1 = []
    l2 = []
    for i in e1:
        l1.append(int(i))

    for i in e2:
        l2.append(int(i))

    if len(l1) < len(l2):
        l1.sort(reverse = True)
        o = []
        for i in l1:
            o.append(str(i))

        print("""".join(o))

    else:
        n = len(l2)
        ans = rec(0,n,l1)
        w = []
        for i in ans:
            w.append(str(i))

        print("""".join(w))",O(n ^ 3)
"n,k = list(map(int,input().split()))
start = k-1
end = 1

def bsearch(start,end):
    if start<end:
        return start
    else:
        mid = start-(start-end)//2
        val = ((k-1)*k//2) - ((mid-1)*mid//2) +1
        if val==n:
            return mid
        elif val>n:
            end = mid+1
        else:
            start = mid-1
        return bsearch(start,end)

ans = bsearch(start,end)

if ans == 0:
    print(-1)
elif n==1:
    print(0)
else:
    print(k-ans)
",O(logn)
"n, m = [int(i) for i in input().split()]
A = []
ct = []
for i in range(n):
    x = list(input())
    y = [0]*m
    A.append(x)
    ct.append(y)
ok = 1
for i in range(n-2):
    for j in range(m-2):
        if A[i][j]=='
            ct[i][j] = 1
            ct[i][j+1] = 1
            ct[i][j+2] = 1
            ct[i+1][j] = 1
            ct[i+1][j+2] = 1
            ct[i+2][j] = 1
            ct[i+2][j+1] = 1
            ct[i+2][j+2] = 1

xct = 0
xhs = 0

for i in range(len(ct)):
    for j in range(len(ct[i])):
        if ct[i][j] == 1:
            xct+=1
        if A[i][j] == '
            xhs+=1
if xhs==xct:
    print('YES')
else:
    print('NO')
",O(n ^ 2)
"class Solution(object):
    def surfaceArea(self, grid):
        result = 0
        for i in range(len(grid)):
            for j in range(len(grid)):
                if grid[i][j]:
                    result += 2 + grid[i][j]*4
                if i:
                    result -= min(grid[i][j], grid[i-1][j])*2
                if j:
                    result -= min(grid[i][j], grid[i][j-1])*2
        return result",O(n ^ 2)
"import sys
import io, os
input = sys.stdin.readline

n = int(input())
S = [str(input().rstrip()) for i in range(n)]
from collections import defaultdict
d1 = defaultdict(lambda: 0)
d2 = defaultdict(lambda: 0)
ans = 0
for i, s in enumerate(S):
    cum1 = 0
    flag1 = True
    for c in s:
        if c == '(':
            cum1 += 1
        else:
            cum1 -= 1
        if cum1 < 0:
            flag1 = False
    if flag1:
        ans += d2[cum1]
    cum2 = 0
    flag2 = True
    for i in reversed(range(len(s))):
        c = s[i]
        if c == ')':
            cum2 += 1
        else:
            cum2 -= 1
        if cum2 < 0:
            flag2 = False
    if flag2:
        ans += d1[cum2]
    if cum1 == 0 and cum2 == 0 and flag1 and flag2:
        ans += 1
    if flag1:
        d1[cum1] += 1
    if flag2:
        d2[cum2] += 1

print(ans)
",O(n)
"class Solution(object):
    def maximumBeauty(self, flowers):
        lookup = {}
        prefix = [0]
        result = float(""-inf"")
        for i, f in enumerate(flowers):
            prefix.append(prefix[-1]+f if f > 0 else prefix[-1])
            if not f in lookup:
                lookup[f] = i
                continue
            result = max(result, 2*f+prefix[i+1]-prefix[lookup[f]] if f < 0 else prefix[i+1]-prefix[lookup[f]])
        return result",O(n)
"class Solution(object):
    def findMaximums(self, nums):
        def find_bound(nums, direction, init):
            result = [0]*len(nums)
            stk = [init]
            for i in direction(range(len(nums))):
                while stk[-1] != init and nums[stk[-1]] >= nums[i]:
                    stk.pop()
                result[i] = stk[-1]
                stk.append(i)
            return result

        left = find_bound(nums, lambda x: x, -1)
        right = find_bound(nums, reversed, len(nums))
        result = [-1]*len(nums)
        for i, v in enumerate(nums):
            result[((right[i]-1)-left[i])-1] = max(result[((right[i]-1)-left[i])-1], v)
        for i in reversed(range(len(nums)-1)):
            result[i] = max(result[i], result[i+1])
        return result",O(n)
"def getN():
    return int(input())
def getList():
    return list(map(int, input().split()))

n = getN()
mid = n * 2 -1
ans = -mid
while(mid > 0):
    ans += mid*2
    mid -= 2

print(ans)",O(n)
"import sys
input = sys.stdin.readline
from itertools import accumulate
import copy

n,m,k = map(int,input().split())
A = list(map(int,input().split()))
ANS = 0

for i in range(m):
    B = copy.deepcopy(A)

    for j in range(i,n,m):
        B[j] -= k

    SUM = list(accumulate(B))
    SUMMIN = [float(""inf"")]*n +[0]

    if i==0:
        SUMMIN[0] = 0

    for j in range(max(1,i),n):
        if j % m == i % m:
            SUMMIN[j] = min(SUMMIN[j-1],SUM[j-1])
        else:
            SUMMIN[j] = SUMMIN[j-1]

    for j in range(i,n):
        ANS = max(ANS,SUM[j] - SUMMIN[j])

print(ANS)
",O(n ^ 2)
"inp = input().split()
n = int(inp[0])
k = int(inp[1])

a = input().split()
for i in range(n):
    a[i] = int(a[i])

bank  = {}

for i in range(n):
    arg = (len(str(a[i])),a[i]%k)

    bank[arg] = bank.get(arg,0)+1

ans = 0

for i in range(n):
    ten = 1
    for j in range(1,11):
        ten*=10
        frontMod = (a[i]*ten)%k

        req = (k-frontMod)%k

        got = bank.get((j,req),0)
        ans += got

for i in range(n):
    cur = str(a[i])
    cur = cur*2
    tst = int(cur)
    if(tst%k==0):
        ans-=1

print(ans)",O(nlogn)
"from collections import deque

n, m = map(int, input().split())

arr = [int(z) for z in input().split()]

mods = [0 for i in range(m)]
placement = [[] for i in range(m)]

for i in range(n):
    mods[arr[i] % m] += 1
    placement[arr[i] % m].append(i)

cnt = 0
queue = deque()
target = n//m
for i in range(2*m):
    mod = i % m
    if mods[mod] > n//m:

        for c in range(mods[mod] - target):
            queue.append([i, placement[mod][c]])
        mods[mod] = target

    elif mods[mod] < target:
        while len(queue) > 0 and mods[mod] < target:
            elem, indice = queue.popleft()
            mods[mod] += 1
            cnt += (mod - elem) % m
            arr[indice] += (mod - elem) % m

print(cnt)
print(' '.join([str(i) for i in arr]))
",O(n)
"class Solution(object):
    def smallestSubsequence(self, s, k, letter, repetition):
        stk = []
        suffix = [0]*(len(s)+1)
        for i in reversed(range(len(suffix)-1)):
            suffix[i] = suffix[i+1]+(s[i] == letter)
        for i, c in enumerate(s): 
            while stk and stk[-1] > c and len(stk)+(len(s)-i) > k and (stk[-1] != letter or repetition+1 <= suffix[i]):
                repetition += (stk.pop() == letter)
            if len(stk) < min(k-(repetition-(c == letter)), k):
                repetition -= (c == letter)
                stk.append(c)
        return """".join(stk)",O(n)
"def nine(p) :

    s=''
    for i in range(p) :
        s+='9'
    return int(s)
def prosh(p) :
    ans=0
    for i in range(1,p+1) :
        ans+=nine(i)*9
    return ans

n,k=map(int,input().split())
l=[0]*29
for i in range(19) :

    e=nine(19-i)

    l[i]=int(k/e)

    k-=l[i]*e

    if k<=0 :

        break
    if i==18  or k%e>prosh(19-i-1) :

        l[i]+=1
        break
otv=0
for i in range(19) :

    otv+=10**(19-i)*l[i]

print(max(n-otv+1,0))
",O(logn)
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n+1) for _ in range(2002)]

d = [[] for _ in range(n)]
for i, v in enumerate(b):
	e[v][i] = i
	d[i].append(i)

for v in range(1, 2002):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)

a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])
",O(n ^ 3)
"def color8(i,j,ip):
    if i>n-3 or j>m-3:
        return
    else:
        ip[i][j]='
        ip[i][j+1]='
        ip[i][j+2]='
        ip[i+1][j]='
        ip[i+1][j+2]='
        ip[i+2][j]='
        ip[i+2][j+1]='
        ip[i+2][j+2]='

n,m=map(int,input().split())
ip=[]
op=[['.' for i in range(m)] for j in range(n)]

b=0
for i in range(n):
    ip.append(str(input()))

for i in range(n):
    for j in range(m):
        if ip[i][j]=='
            try:
                if ip[i+2][j+2]=='
                    temp=(ip[i][j]=='

                    if temp==True:
                        color8(i,j,op)
            except:
                pass

for i in range(n):
    if ''.join(op[i])!=ip[i]:
        print('NO')
        b=1
        break
if b==0:
    print('YES')
",O(n ^ 2)
"import sys
input = sys.stdin.readline

def topological_sorted(digraph):
    n = len(digraph)
    indegree = [0] * n
    for v in range(n):
        for nxt_v in digraph[v]:
            indegree[nxt_v] += 1

    tp_order = [i for i in range(n) if indegree[i] == 0]
    stack = tp_order[:]
    while stack:
        v = stack.pop()
        for nxt_v in digraph[v]:
            indegree[nxt_v] -= 1
            if indegree[nxt_v] == 0:
                stack.append(nxt_v)
                tp_order.append(nxt_v)

    return len(tp_order) == n, tp_order

n, m, k = map(int, input().split())
p = [input()[:-1] for i in range(n)]
s = [list(input().split()) for i in range(m)]

memo = {}
for idx, ptn in enumerate(p):
    val = 0
    for i in range(k):
        if ptn[i] == ""_"":
            continue
        val += (ord(ptn[i]) - 96) * (27 ** i)
    memo[val] = idx

for i, (string, idx) in enumerate(s):
    s[i] = tuple(map(ord, string)), int(idx)

graph = [[] for i in range(n)]
for string, idx in s:
    idxs = []
    idx -= 1
    for bit_state in range(1 << k):
        val = 0
        for i in range(k):
            if (bit_state >> i) & 1:
                continue
            val += (string[i] - 96) * (27 ** i)
        if val in memo:
            idxs.append(memo[val])
    if idx not in idxs:
        print(""NO"")
        exit()

    for idx_to in idxs:
        if idx == idx_to:
            continue
        graph[idx].append(idx_to)

flag, res = topological_sorted(graph)
if flag:
    print(""YES"")
    print(*[i + 1 for i in res])
else:
    print(""NO"")",np
"n = int(input())
a = sorted(list(map(int,input().split())))
bal = 0
if a.count(0)>1:
    print('cslnb')
    exit()
if n-len(set(a))>1:
    print('cslnb')
    exit()
if n-len(set(a))==1:
    for i in range(1,n):
        if a[i]==a[i-1]:
            if a[i]-1 in a:
                print('cslnb')
                exit()
            break
if n==1:
    print('cslnb' if not a[0] % 2 else 'sjfnb')
    exit()

for i in range(n):
    bal+=a[i]-i
print('sjfnb'if bal%2 else 'cslnb')",O(nlogn)
"from sys import stdin
a, b, c, n = map(int, stdin.readline().split())
if c > a or c > b:
    print(-1)
else:
    val = n - ((a - c) + (b - c)) - c
    print(val if val <= n and val > 0 else -1)",O(1)
"import sys
import io, os
import math
from heapq import *
gcd = math.gcd
sqrt = math.sqrt
ceil = math.ceil

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
def strinp(testcases):
    k = 5
    if (testcases == -1 or testcases == 1):
        k = 1
    f = str(input())
    f = f[2:len(f) - k]
    return f
def ind(ch):
    return ord(ch)-ord(""a"")
def main():
    n=int(input())
    b=[0]
    cost=b+list(map(int, input().split()))
    arr=b+list(map(int, input().split()))
    nv=[-1]*(n+1)
    colors=[]
    c=0
    for i in range(1,n+1):
        if(nv[i]!=-1):
            continue
        nv[i]=c
        dest=arr[i]
        while(nv[dest]==-1):
            nv[dest]=c
            dest=arr[dest]
        if(nv[dest]==c):
            colors.append(dest)
        c+=1
    s=0
    for i in colors:
        mi=cost[i]
        nxt=arr[i]
        while(nxt!=i):
            mi=min(mi,cost[nxt])
            nxt=arr[nxt]
        s+=mi
    print(s)
main()",O(n)
"n=int(input())
l1=list(map(int,input().split()))
if n%2==0:
    for i in range(n):
        if l1[i]>=0:
            l1[i]=-1*l1[i]-1
else :
    for i in range(n):
        if l1[i]>=0:
            l1[i]=-1*l1[i]-1
    l1[l1.index(min(l1))]=l1[l1.index(min(l1))]*-1 -1
print(' '.join(str(x) for x in l1))",O(n)
"class Solution(object):
    def numberOfAlternatingGroups(self, colors, k):
        result = curr = left = 0
        for right in range(len(colors)+k-1):  
            if right-left+1 == k:
                result += int(curr == k-1)
                curr -= int(colors[left] != colors[(left+1)%len(colors)])
                left += 1
            curr += int(colors[right%len(colors)] != colors[(right+1)%len(colors)])
        return result",O(n)
"def main():
    n, m = map(int, input().split())
    ll = [c == '*' for _ in range(n) for c in input()]
    nm = n * m
    RLUD = [*[range(i, i + m) for i in range(0, nm, m)],
            *[range(i, nm, m) for i in range(m)]]
    cc = [1000] * nm
    for f in True, False:
        for r in RLUD:
            v = 0
            for i in r:
                if ll[i]:
                    v += 1
                    if cc[i] > v:
                        cc[i] = v
                else:
                    v = cc[i] = 0
        if f:
            ll.reverse()
            cc.reverse()
    cc = [c if c != 1 else 0 for c in cc]
    for f in True, False:
        for r in RLUD:
            v = 0
            for i in r:
                if v > cc[i]:
                    v -= 1
                else:
                    v = cc[i]
                if v:
                    ll[i] = False
        if f:
            ll.reverse()
            cc.reverse()
    if any(ll):
        print(-1)
    else:
        res = []
        for i, c in enumerate(cc):
            if c:
                res.append(f'{i//m+1} {i%m+1} {c-1}')
        print(len(res), '\n'.join(res), sep='\n')

if __name__ == '__main__':
    main()
",O(n ^ 2)
"x=input();l=len(x);m=0
for i in range(l-1):
    f=i
    while 1 :
        idx = x[f+1:].find(x[f])
        if idx == -1 :
            break
        else:
            idx += f+1 ; c=ans=0
            for j in range(idx , l) :
               if x[j] == x[i+c]:
                    ans+=1
                    c+=1
               else:
                   break

            if m < ans :
                m=ans
            f = idx
print(m)
",O(n ^ 3)
"class Solution(object):
    def minimumNumbers(self, num, k):
        return next((i for i in range(1, (min(num//k, 10) if k else 1)+1) if (num-i*k)%10 == 0), -1) if num else 0",O(1)
"import collections



class Solution(object):
    def findWinners(self, matches):
        lose = collections.defaultdict(int)
        players_set = set()
        for x, y in matches:
            lose[y] += 1
            players_set.add(x)
            players_set.add(y)
        return [[x for x in sorted(players_set) if lose[x] == i] for i in range(2)]",O(nlogn)
"class Solution2(object):
    def findAnswer(self, parent, s):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P
    
        def dfs(u):
            left = cnt[0]
            for v in adj[u]:
                dfs(v)
            curr.append(s[u])
            lookup[u] = (left, cnt[0])
            cnt[0] += 1

        adj = [[] for _ in range(len(parent))]
        for v in range(1, len(parent)):
            adj[parent[v]].append(v)
        cnt = [0]
        curr = []
        lookup = [None]*len(adj)
        dfs(0)
        P = manacher(curr)
        return [P[(2*(left+1)+2*(right+1))//2] >= right-left+1 for left, right in lookup]",O(n)
"n=int(input())
c=0
for j in range(2,1+n//2):
	e=0
	i=n//j
	e+=(i*(i+1))//2
	e-=1
	if e>0:
		c+=e
print(c*4)",O(n)
"import itertools
import bisect
import math
from collections import *
import os
import sys
from io import BytesIO, IOBase

ii = lambda: int(input())
lmii = lambda: list(map(int, input().split()))
li = lambda: list(input())
mii = lambda: map(int, input().split())
msi = lambda: map(str, input().split())

def main():
    a = li()
    b = li()
    n = len(a)
    ans = 0
    for i in range(n):
        if a[i] == ""0"":
            ans += 1
            if i - 1 >= 0 and a[i] == b[i] == b[i - 1]:
                a[i] = b[i] = b[i - 1] = ""X""
            elif i + 1 < n and b[i] == b[i + 1] == a[i + 1] == a[i]:
                a[i] = b[i] = a[i + 1] = ""X""
            elif i + 1 < n and a[i] == b[i] == b[i + 1]:
                a[i] = b[i] = b[i + 1] = ""X""
            elif i + 1 < n and a[i] == b[i + 1] == a[i + 1]:
                a[i] = b[i + 1] = a[i + 1] = ""X""
            elif i + 1 < n and a[i] == b[i] == a[i + 1]:
                a[i] = b[i] = a[i + 1] = ""X""
            else:
                ans -= 1
    print(ans)
    pass

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(1)
"class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        if not intervals:
            return [newInterval]

        n = len(intervals)
        target = newInterval[0]
        left, right = 0, n - 1

        while left <= right:
            mid = (left + right) // 2
            if intervals[mid][0] < target:
                left = mid + 1
            else:
                right = mid - 1

        intervals.insert(left, newInterval)

        res = []
        for interval in intervals:
            if not res or res[-1][1] < interval[0]:
                res.append(interval)
            else:
                res[-1][1] = max(res[-1][1], interval[1])
        return res
",O(n)
"from collections import defaultdict
from math import gcd
from heapq import heappop, heappush
n = int(input())
A = list(map(int, input().split()))
B = list(map(int, input().split()))
hp = [(0, 0)]
dis = {0: 0}
seen = set()
while hp:
    _, x = heappop(hp)
    if x == 1:
        print(dis[x])
        break
    if x in seen: continue
    seen.add(x)
    for a, b in zip(A, B):
        y = gcd(x, a)
        if y not in dis or dis[y] > dis[x] + b:
            dis[y] = dis[x] + b
            heappush(hp, (dis[y], y))
else:
    print(-1)",np
"class Solution(object):
    def findKthPositive(self, arr, k):
        def check(arr, k, x):
            return arr[x]-(x+1) < k

        left, right = 0, len(arr)-1
        while left <= right:
            mid = left + (right-left)//2
            if not check(arr, k, mid):
                right = mid-1
            else:
                left = mid+1
        return right+1+k",O(logn)
"import sys
stdin=sys.stdin

ip=lambda: int(sp())
fp=lambda: float(sp())
lp=lambda:list(map(int,stdin.readline().split()))
sp=lambda:stdin.readline().rstrip()
Yp=lambda:print('Yes')
Np=lambda:print('No')

N = ip()
L = []
for _ in range(N):
    x,w = lp()
    L.append([x-w,x+w])
L.sort(reverse=True)
ans = 0
edge = 1<<40
for i in range(N):
    if L[i][1] <= edge:
        edge = L[i][0]
        ans += 1
print(ans)",O(nlogn)
"import sys
from array import array
import typing as Tp

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

def main():
    l, r, k = map(int, input().split())

    valid_bits, is_valid_bits = [], [0] * 1024

    for bit in range(1024):
        if bin(bit).count('1') <= k:
            valid_bits.append(bit)
            is_valid_bits[bit] = 1

    mod = 998244353

    def solve(ub):
        dp = array('i', [0]) * 1024
        dp_cnt = array('i', [0]) * 1024
        next_dp = array('i', [0]) * 1024
        next_dp_cnt = array('i', [0]) * 1024
        boundary_dp, b_bit = 0, 0

        for e, digit in zip(range(len(str(ub)) - 1, -1, -1), map(int, str(ub))):
            base = pow(10, e, mod)

            for bit in valid_bits:
                for d in range(10):
                    nextbit = bit | (1 << d)
                    if is_valid_bits[nextbit]:
                        next_dp[nextbit] = (
                            next_dp[nextbit] + dp[bit]
                            + base * d * dp_cnt[bit]
                        ) % mod

                        next_dp_cnt[nextbit] += dp_cnt[bit]
                        if next_dp_cnt[nextbit] >= mod:
                            next_dp_cnt[nextbit] -= mod

            for d in range(digit):
                nextbit = b_bit | (1 << d)
                if is_valid_bits[nextbit]:
                    next_dp[nextbit] = (
                        next_dp[nextbit] + boundary_dp + base * d
                    ) % mod
                    next_dp_cnt[nextbit] += 1

            b_bit |= (1 << digit)
            boundary_dp = (boundary_dp + base * digit) % mod

            for i in valid_bits:
                dp[i] = next_dp[i]
                dp_cnt[i] = next_dp_cnt[i]
                next_dp[i] = next_dp_cnt[i] = 0

            dp[0], dp_cnt[0] = 0, 1
            dp[1] = dp_cnt[1] = 0

        return (sum(dp) + (boundary_dp if is_valid_bits[b_bit] else 0)) % mod

    print((solve(r) - solve(l - 1)) % mod)

if __name__ == '__main__':
    main()
",O(n ^ 3)
"class Solution(object):
    def stringCount(self, n):
        MOD = 10**9 + 7
        return (
            pow(26, n, MOD)
            - (25 + 25 + 25 + n) * pow(25, n - 1, MOD)
            + (24 + 24 + 24 + n + n + 0) * pow(24, n - 1, MOD)
            - (23 + n + 0 + 0) * pow(23, n - 1, MOD)
        ) % MOD",O(logn)
"N = int(input())
X = list(map(int, input().split()))
from collections import defaultdict
dp1 = defaultdict(lambda :-1)
M=1001
def ec(i,j):
    return i*M+j

for i in range(N):
    dp1[ec(i,i+1)] = X[i]
for i in range(2, N+1):
    for j in range(N-i+1):
        for k in range(1, i):
            u, v = dp1[ec(j,j+k)], dp1[ec(j+k,j+i)]
            if u != -1 and v != -1 and u == v:
                dp1[ec(j,j+i)] = u+1
                break

dp2 = [0]*(N+1)
for i in range(N):
    dp2[i+1] = dp2[i]+1
    for j in range(i+1):
        if dp1[ec(j,i+1)] == -1:
            continue
        dp2[i+1] = min(dp2[i+1], dp2[j]+1)
print(dp2[-1])
",O(n ^ 3)
"class Solution3(object):
    def deleteString(self, s):
        MOD, P = 10**9+7, (113, 109)
        def hash(i, j):
            return [(prefix[idx][j+1]-prefix[idx][i]*power[idx][j-i+1])%MOD for idx in range(len(P))]

        if all(x == s[0] for x in s):
            return len(s)

        power = [[1] for _ in range(len(P))]
        prefix = [[0] for _ in range(len(P))]
        for x in s:
            for idx, p in enumerate(P):
                power[idx].append((power[idx][-1]*p)%MOD)
                prefix[idx].append((prefix[idx][-1]*p+(ord(x)-ord('a')))%MOD)
        dp = [1]*len(s) 
        for i in reversed(range(len(s)-1)):
            for j in range(1, (len(s)-i)//2+1):
                if hash(i, i+j-1) == hash(i+j, i+2*j-1):
                    dp[i] = max(dp[i], dp[i+j]+1)
        return dp[0]",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase
from collections import Counter
import math as mt

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)

def lcm(a, b):
    return (a * b) / gcd(a, b)

mod = int(1e9) + 7

def power(k, n):
    if n == 0:
        return 1
    if n % 2:
        return (power(k, n - 1) * k) % mod
    t = power(k, n // 2)
    return (t * t) % mod

def totalPrimeFactors(n):
    count = 0
    if (n % 2) == 0:
        count += 1
        while (n % 2) == 0:
            n //= 2

    i = 3
    while i * i <= n:
        if (n % i) == 0:
            count += 1
            while (n % i) == 0:
                n //= i
        i += 2
    if n > 2:
        count += 1
    return count

def main():
    n = int(input())
    a = list(map(int, input().split()))
    a.sort()
    same = 0
    ind = -1
    poss=1
    for i in range(1, n):
        same += (a[i] == a[i - 1])
        if a[i]==a[i-1]:
            ind = i - 1
            if a[i]==0:
                poss=0
    if same > 1 or poss==0:
        print('cslnb')
    else:
        if ind > 0:
            if a[ind] - a[ind - 1] == 1:
                print('cslnb')
                return
        c = 0
        for i in range(n):
            c += a[i] - i
        if c % 2:
            print('sjfnb')
        else:
            print('cslnb')

    return

if __name__ == ""__main__"":
    main()
",O(nlogn)
"class Solution:
    def isHappy(self, n: int) -> bool:
        slow, fast = n, self.sumOfSquares(n)
        power = lam = 1

        while slow != fast:
            if power == lam:
                slow = fast
                power *= 2
                lam = 0
            fast = self.sumOfSquares(fast)
            lam += 1
        return True if fast == 1 else False

    def sumOfSquares(self, n: int) -> int:
        output = 0

        while n:
            digit = n % 10
            digit = digit ** 2
            output += digit
            n = n // 10
        return output
",O(logn)
"n, m = list(map(int,input().split()))
p = list(map(int,input().split()))
mindex = p.index(m)
ldict = {}
rdict = {}
diff = 0
ans = 0
ldict[0] = 1
rdict[0] = 1
for i in range(mindex-1,-1,-1):
	if p[i] < m:
		diff-=1
	else:
		diff+=1
	if diff in ldict.keys():
		ldict[diff] += 1
	else:
		ldict[diff] = 1
diff = 0
for i in range(mindex+1,n):
	if p[i] < m:
		diff-=1
	else:
		diff+=1
	if diff in rdict.keys():
		rdict[diff] += 1
	else:
		rdict[diff] = 1
ldictkey = ldict.keys()
for num in ldictkey:
	if -num in rdict.keys():
		ans += ldict[num] * rdict[-num]
	if -num+1 in rdict.keys():
		ans += ldict[num] * rdict[-num+1]
print(ans)",O(nlogn)
"
import collections


class Solution(object):
    def deckRevealedIncreasing(self, deck):
        d = collections.deque()
        deck.sort(reverse=True)
        for i in deck:
            if d:
                d.appendleft(d.pop())
            d.appendleft(i)
        return list(d)
",O(n)
"class Solution2(object):
    def knightDialer(self, N):
        M = 10**9 + 7
        moves = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [],
                 [1, 7, 0], [2, 6], [1, 3], [2, 4]]

        dp = [[1 for _ in range(10)] for _ in range(2)]
        for i in range(N-1):
            dp[(i+1) % 2] = [0] * 10
            for j in range(10):
                for nei in moves[j]:
                    dp[(i+1) % 2][nei] += dp[i % 2][j]
                    dp[(i+1) % 2][nei] %= M
        return sum(dp[(N-1) % 2]) % M",O(n)
"def solve(i, j, k):
    if (i < 0 and j < 0) or (j < 0 and k < 0) or (i < 0 and k < 0):
        return 0
    if dp[i][j][k] != -1:
        return dp[i][j][k]
    ans = 0
    if i >= 0 and j >= 0:
        ans = max(ans, rs[i] * gs[j] + solve(i - 1, j - 1, k))
    if i >= 0 and k >= 0:
        ans = max(ans, rs[i] * bs[k] + solve(i - 1, j, k - 1))
    if j >= 0 and k >= 0:
        ans = max(ans, bs[k] * gs[j] + solve(i, j - 1, k - 1))
    dp[i][j][k] = ans
    return ans

a, b, c = map(int, input().split())
rs = sorted(list(map(int, input().split())))
gs = sorted(list(map(int, input().split())))
bs = sorted(list(map(int, input().split())))
dp = [[[-1 for x in range(c + 1)] for y in range(b + 1)] for z in range(a + 1)]
print(solve(a - 1, b - 1, c - 1))
",O(n ^ 3)
"class Solution(object):
    def sumOfMultiples(self, n):
        def f(d):
            return d*((1+(n//d))*(n//d)//2)
        
        return (f(3)+f(5)+f(7))-(f(3*5)+f(5*7)+f(7*3))+f(3*5*7)",O(1)
"inf=10**9

n=int(input())
t=[0]*n
m={}
for j in range(n):

    s=input()

    bal=0
    req=0

    for i in s:
        if i=="")"":
            bal-=1
        else:
            if bal<0:
                req+=bal
                bal=1
            else:
                bal+=1

    if req<0:
        if bal>0:
            req=inf
        else:
            req+=bal
    else:
        req=bal

    t[j]=req

    if req not in m:
        m[req]=1
    else:
        m[req]+=1

res=0

for i in t:
    if i>=0:
        if -i in m:
            res+=m[-i]

print(res)
",O(n)
"class Solution(object):

    def __init__(self, nestedList):
        self.__depth = [[nestedList, 0]]


    def __next__(self):
        nestedList, i = self.__depth[-1]
        self.__depth[-1][1] += 1
        return nestedList[i].getInteger()


    def hasNext(self):
        while self.__depth:
            nestedList, i = self.__depth[-1]
            if i == len(nestedList):
                self.__depth.pop()
            elif nestedList[i].isInteger():
                    return True
            else:
                self.__depth[-1][1] += 1
                self.__depth.append([nestedList[i].getList(), 0])
        return False",O(n)
"import bisect
def solve(l,d,s2,r):
    ans=""""
    lol=0
    i=0
    lo=0
    while i<(len(s2)):
        if(lo==1):

            a=s2[i]
            ind=bisect.bisect_left(l,a)

            for x in range(ind,-1,-1):
                if(l[x]<l[ind]):
                    ind=x

                    break
            ans+=str(l[ind])
            d[l.pop(ind)]-=1

            lol=1
            break

        a=s2[i]
        ind=bisect.bisect_left(l,a)

        if(ind==len(l)):
            ind-=1
            ans+=str(l[ind])
            d[l[ind]]-=1
            lol=1
            break
        elif(l[ind]>a):
            if(ind==0):
                while ind==0:

                    l.append(int(ans[-1]))
                    d[int(ans[-1])]+=1
                    l.sort()
                    ans=ans[:len(ans)-1]
                    lo=1
                    i-=1
                    a=s2[i]
                    ind=bisect.bisect_left(l,a)

                continue
            lol=1
            ans+=str(l[ind-1])

            d[l[ind-1]]-=1
            l.pop(ind-1)
            break
        else:
            ans+=str(l[ind])
            d[l[ind]]-=1
            l.pop(ind)
        i+=1
    ll=[]

    if(lol):
        for i in d:
            if(d[i]!=0):
                ll.append(i)
        ll.sort(reverse=True)
        co=0

        for i in ll:
            for j in range(d[i]):
                if(i==0):
                    co+=1
                    if(co>r):
                        break
                ans+=str(i)

    print(ans)
from math import gcd
import sys
from collections import defaultdict as dd
input=sys.stdin.readline
s1=list(map(int,input().strip()))
s2=list(map(int,input().strip()))
z=s1.count(0)
d=dd(int)
n=len(s1)
m=len(s2)
l=sorted(s1)
for i in s1:
    d[i]+=1
if len(s1)<len(s2):
    for i in range(len(s1)-1,-1,-1):
        print(l[i],end="""")
elif(len(s1)>len(s2)):
    r=m-(n-z)

    l=l[z-r:]

    solve(l,d,s2,r)
else:
    solve(l,d,s2,100)
",O(n ^ 3)
"from collections import defaultdict

class Solution(object):
    def isRectangleCover(self, rectangles):
        left = min(rec[0] for rec in rectangles)
        bottom = min(rec[1] for rec in rectangles)
        right = max(rec[2] for rec in rectangles)
        top = max(rec[3] for rec in rectangles)

        points = defaultdict(int)
        for l, b, r, t in rectangles:
            for p, q in zip(((l, b), (r, b), (l, t), (r, t)), (1, 2, 4, 8)):
                if points[p] & q:
                    return False
                points[p] |= q

        for px, py in points:
            if left < px < right or bottom < py < top:
                if points[(px, py)] not in (3, 5, 10, 12, 15):
                    return False

        return True",O(n)
"s=int(input())
t=len(str(s))
L=['4','7']
import copy
for i in range(t):
    L1=copy.deepcopy(L)
    for m in L:
        L1.append(m+'4')
        L1.append(m+'7')
    L=L1
L0=list(map(int,L))
sum=0
for i in range(len(L0)):
    if s%L0[i]==0:
        sum=sum+1
if sum>0:
    print('YES')
else:
    print('NO')",O(1)
"import sys

def is_prime(x):
    return all(x%i for i in range(2, int(x**.5)+1))

t = int(sys.stdin.read().strip())
for i in range(4, t//2+1):
    if not is_prime(i) and not is_prime(t-i):
        print(i, t-i, sep=' ')
        break
",O(1)
"from math import sqrt

def inpl():
	return list(map(int, input().split()))

def inpi():
	return int(input())

def issq(p):
	x = int(sqrt(p))
	return x*x == p

def g(n):
	return (issq(n//2) and n%2==0) or (issq(n//4) and n%4==0)

def f():
	n = inpi()

	print(""YES"" if g(n) else ""NO"")

t = int(input())
for _ in range(t):
	f()
",O(1)
"n, m, k = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
b = [list(map(int, input().split())) for _ in range(n-1)]

if k % 2 == 1:
    for i in range(n):
        print(*[-1]*m)
    exit()
k //= 2

INF = 10**18
dp = [[[INF]*(k+1) for _ in range(m)] for _ in range(n)]

for i in range(n):
    for j in range(m):
        dp[i][j][0] = 0

for v in range(1, k+1):
    for i in range(n):
        for j in range(m):
            now_h, now_w = i, j
            if i > 0:
                dp[i][j][v] = min(dp[i-1][j][v-1]+b[i-1][j], dp[i][j][v])
            if i < n-1:
                dp[i][j][v] = min(dp[i+1][j][v-1]+b[i][j], dp[i][j][v])
            if j > 0:
                dp[i][j][v] = min(dp[i][j-1][v-1]+a[i][j-1], dp[i][j][v])
            if j < m-1:
                dp[i][j][v] = min(dp[i][j+1][v-1]+a[i][j], dp[i][j][v])

for i in range(n):
    v = []
    for j in range(m):
        v.append(dp[i][j][k]*2)
    print(*v)
",O(n ^ 3)
"n, t = [int(item) for item in input().split(' ')]
cont, ans = [], 2
for i in range(n):
    hcenter, hlen = [float(item) for item in input().split(' ')]

    cont.append([hcenter - hlen / 2, hcenter + hlen / 2])

cont.sort(key=lambda it: it[0])

for i in range(n - 1):
    gap = cont[i + 1][0] - cont[i][1]
    if gap > t:
        ans += 2
    elif gap == t:
        ans += 1
print(ans)",O(nlogn)
"import math

n, k = input().split()
n = int(n)
k = int(k)

solfound = 0
m = 0
x0 = 0

if (3+2*n+math.sqrt((3+2*n)**2-4*(n+n**2-2*k)))/2 < n:
    m1 = (3+2*n+math.sqrt((3+2*n)**2-4*(n+n**2-2*k)))/2
else:
    m1 = (3+2*n-math.sqrt((3+2*n)**2-4*(n+n**2-2*k)))/2

print(int(m1))
",O(logn)
"n=int(input())
l=[int(c) for c in input().split()]
ll=[]
res=[]
head=0
dia=0
for i in range(1,n):
    if l[i]==1:
        l[i]=0
        ll.append(i)
    else:
        res.append((head+1,i+1))
        l[head]-=1
        dia+=1
        head=i
        l[head]-=1
if l[head]>0 and len(ll)>0:
    res.append((ll[0]+1,head+1))
    l[head]-=1
    del(ll[0])
    dia+=1
if l[0]>0 and len(ll)>0:
    res.append((ll[0]+1,1))
    l[0]-=1
    del(ll[0])
    dia+=1
for i in ll:
    for j in range(n):
        if l[j]>0:
            res.append((j+1,i+1))
            l[j]-=1
            break
if len(res)<n-1:
    print(""NO"")
else:
    print(""YES ""+str(dia))
    print(n-1)
    for p in res:
        print(p[0],end ="" "")
        print(p[1])",O(n ^ 2)
"class Solution3(object):
    def findMaximumElegance(self, items, k):
        items.sort(reverse=True)
        result = curr = 0
        lookup = set()
        stk = []
        for i in range(k):
            if items[i][1] in lookup:
                stk.append(items[i][0])
            curr += items[i][0]
            lookup.add(items[i][1])
        result = curr+len(lookup)**2
        for i in range(k, len(items)):
            if items[i][1] in lookup:
                continue
            if not stk:
                break
            curr += items[i][0]-stk.pop()
            lookup.add(items[i][1])
            result = max(result, curr+len(lookup)**2)
        return result",O(nlogn)
"
class Node(object):
    def __init__(self, val, children):
        self.val = val
        self.children = children


class Solution(object):
    def levelOrder(self, root):
        if not root:
            return []
        result, q = [], [root]
        while q:
            result.append([node.val for node in q])
            q = [child for node in q for child in node.children if child]
        return result

",O(n)
"from sys import stdin, stdout
import gc
gc.disable()
input = stdin.readline
from collections import defaultdict

def check(num):
	bitmask = set()
	for i in range(n):
		b = 0
		for j in range(m):
			if arr[i][j] >= num:
				b ^= 1 << j
		bitmask.add(b)

	target = 2** m  - 1
	for i in bitmask:
		for j in bitmask:
			if i | j ==  target:
				return True
	return False

n, m = list(map(int, input().split()))
arr = []
for _ in range(n):
	arr.append(list(map(int, input().split())))

start = 0
end = 10 ** 9
ans = -1
while start <= end:
	mid = (start + end) // 2
	if check(mid):
		ans = mid
		start = mid + 1
	else:
		end = mid - 1

bitmask = defaultdict(list)
for i in range(n):
	b = 0
	for j in range(m):
		if arr[i][j] >= ans:
			b  += 1<< j
	bitmask[b].append(i + 1)
target = 2 ** m - 1
for i in bitmask:
	for j in bitmask:
		if i | j == target:
			print(bitmask[i][0], bitmask[j][0])
			exit()
",np
"class Solution(object):
    def longestPalindromeSubseq(self, s):
        if s == s[::-1]: 
            return len(s)

        dp = [[1] * len(s) for _ in range(2)]
        for i in reversed(range(len(s))):
            for j in range(i+1, len(s)):
                if s[i] == s[j]:
                    dp[i%2][j] = 2 + dp[(i+1)%2][j-1] if i+1 <= j-1 else 2
                else:
                    dp[i%2][j] = max(dp[(i+1)%2][j], dp[i%2][j-1])
        return dp[0][-1]",O(n ^ 2)
"from math import sqrt

def dist(speed, time):

	return speed * time + a * time**2 / 2

def travelTime(distance, speed):

	tAll = (- speed + sqrt(speed**2 + 2 * distance * a)) / a

	tMax = (v - speed) / a

	if tMax >= tAll:
		return tAll
	else:
		return tMax + (distance - dist(speed, tMax)) / v

a, v = map(int, input().split())
l, d, w = map(int, input().split())

if v <= w:
	print(travelTime(l, 0))
else:
	tw = w / a

	dw = dist(0, tw)

	if dw >= d:
		print(travelTime(l, 0))
	else:
		print(tw + 2 * travelTime((d - dw) / 2, w) + travelTime(l - d, w))
",O(1)
"n = int(input())
L = [int(i) for i in input().split()]
R = [int(i) for i in input().split()]
E = []
otv = [0] * n
for i in range(n):
    sum_ = L[i] + R[i]
    E.append([sum_, i])
E.sort()
for i in range(n):
    x = R[i]
    for j in range(n):
        if (x > 0):
            if (E[j][1] > i):
                otv[E[j][1]] += 1
                x -= 1
        else:
            break

    if (x > 0):
        print(""NO"")
        exit()

    x = L[i]
    for j in range(n):
        if (x > 0):
            if (E[j][1] < i):
                otv[E[j][1]] += 1
                x -= 1
        else:
            break

    if (x > 0):
        print(""NO"")
        exit()

for i in range(n):
    r = 0
    l = 0
    for j in range(i + 1, n):
        if (otv[j] > otv[i]):
            r += 1
    for z in range(i - 1, -1, -1):
        if (otv[z] > otv[i]):
            l += 1
    if (r != R[i]) or (l != L[i]):
        print(""NO"")
        exit()

print(""YES"")
for i in range(n):
    print(otv[i] + 1, end = ' ')
",O(n ^ 2)
"from sys import stdin, stdout

s = input()

s = s.split(' ')

M = [0]*9
P = [0]*9
S = [0]*9

for pile in s:
    pile = list(pile)

    num = int(pile[0])
    tile = pile[1]

    if tile=='s':
        S[num-1] += 1
    elif tile=='p':
        P[num-1] += 1
    elif tile=='m':
        M[num-1] += 1

for i in range(9):
    if M[i]==3:
        print(0)
        quit()
    if P[i]==3:
        print(0)
        quit()
    if S[i]==3:
        print(0)
        quit()

for i in range(7):
    if M[i]==1 and M[i+1]==1 and M[i+2]==1:
        print(0)
        quit()
    if P[i]==1 and P[i+1]==1 and P[i+2]==1:
        print(0)
        quit()
    if S[i]==1 and S[i+1]==1 and S[i+2]==1:
        print(0)
        quit()

for i in range(9):
    if M[i]==2:
        print(1)
        quit()
    if P[i]==2:
        print(1)
        quit()
    if S[i]==2:
        print(1)
        quit()

for i in range(8):
    if M[i]==1 and M[i+1]==1:
        print(1)
        quit()
    if P[i]==1 and P[i+1]==1:
        print(1)
        quit()
    if S[i]==1 and S[i+1]==1:
        print(1)
        quit()

for i in range(7):
    if M[i]==1 and M[i+2]==1:
        print(1)
        quit()
    if P[i]==1 and P[i+2]==1:
        print(1)
        quit()
    if S[i]==1 and S[i+2]==1:
        print(1)
        quit()

print(2)
",O(n)
"def bs(n, k, lo, hi):

    while lo <= hi:
        mid = (hi + lo)//2

        summ = ((k * (k + 1))//2 - 1) - (((mid-1) * (mid))//2 -1) - (k-2)

        if summ == n:

            return k - mid + 1

        if summ > n:

            lo = mid + 1

        elif summ < n:
            hi = mid - 1

    if summ > n:
       mid += 1
    return k - mid + 1

def solve():
    n, k = map(int, input().split())

    if n == 1: return 0
    elif (k * (k + 1)//2) - (k-2) <= n:

        return -1
    elif k >= n: return 1
    else:
        return bs(n, k, 2, k)

print(solve())",O(logn)
"class Solution(object):
    def pathInZigZagTree(self, label):
        count = 2**label.bit_length()
        result = []
        while label >= 1:
            result.append(label)
            label = ((count//2) + ((count-1)-label)) // 2
            count //= 2
        result.reverse()
        return result",O(logn)
"import collections


class Solution(object):
    def findingUsersActiveMinutes(self, logs, k):
        lookup = collections.defaultdict(set)
        for u, t in logs:
            lookup[u].add(t)
        result = [0]*k
        for _, ts in lookup.items():
            result[len(ts)-1] += 1
        return result",O(n)
"class Solution2(object):
    def isNumber(self, s):
        import re
        return bool(re.match(""^\s*[\+-]?((\d+(\.\d*)?)|\.\d+)([eE][\+-]?\d+)?\s*$"", s))",O(n)
"def search(current, digits, target, idx, bulk):
    if len(current) == len(target) and int(current) <= int(target):
        print(current)
        exit(0)

    possibilities = [char for char in digits if bulk or (char <= target[idx] and char in digits)]

    if len(possibilities) == 0:
        return None

    for possible_digit in sorted(set(possibilities), reverse=True):
        tmp_digits = list(digits)
        tmp_digits.remove(possible_digit)
        if not bulk:
            bulk = True if possible_digit != target[idx] else False
        search(current + possible_digit, tmp_digits, target, idx + 1, bulk)

def main():
    digits = sorted(list(input()), reverse=True)
    target = input()

    if len(digits) < len(target):
        print(''.join(digits))
        exit(0)

    entries = [char for char in digits if char <= target[0]]

    for current in sorted(set(entries), reverse=True):
        tmp_digits = list(digits)
        tmp_digits.remove(current)
        search(current, tmp_digits, target, 1, True if current != target[0] else False)

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"class Solution(object):
    def evenProduct(self, nums):
        result = (len(nums)+1)*len(nums)//2
        cnt = 0
        for x in nums:
            cnt = cnt+1 if x%2 else 0
            result -= cnt
        return result",O(n)
"import collections


class Solution(object):
    def slowestKey(self, releaseTimes, keysPressed):
        result, lookup = 'a', collections.Counter()
        for i, c in enumerate(keysPressed):
            lookup[c] = max(lookup[c], releaseTimes[i]-(releaseTimes[i-1] if i > 0 else 0))
            if lookup[c] > lookup[result] or lookup[c] == lookup[result] and c > result:
                result = c
        return result",O(n)
"class Solution(object):
    def minimumDistance(self, points):
        def max_distance(exclude):
            max_sum = max((x+y, i) for i, (x, y) in enumerate(points) if i != exclude)
            min_sum = min((x+y, i) for i, (x, y) in enumerate(points) if i != exclude)
            max_diff = max((x-y, i) for i, (x, y) in enumerate(points) if i != exclude)
            min_diff = min((x-y, i) for i, (x, y) in enumerate(points) if i != exclude)
            return max((max_sum[0]-min_sum[0], max_sum[1], min_sum[1]), 
                       (max_diff[0]-min_diff[0], max_diff[1], min_diff[1]))
        
        _, i, j = max_distance(-1)
        return min(max_distance(i)[0], max_distance(j)[0])",O(n)
"class Solution5(object):
    def bestTeamScore(self, scores, ages):
        players = sorted(zip(scores, ages))
        dp = [0]*len(players)
        result = 0
        for i in range(len(players)):
            dp[i] = players[i][0]
            for j in range(i):
                if players[j][1] <= players[i][1]:
                    dp[i] = max(dp[i], dp[j] + players[i][0])
            result = max(result, dp[i])
        return result",O(n ^ 2)
"n,m,k=map(int,input().split())
arr=list(map(int,input().split()))
arr+=[0]*m
ans=0
pos=0
while arr[pos]!=0:
  page=(arr[pos]-pos-1)//k
  tmp=1
  for i in range(1,k):
    if pos+i>=2*m-1:
      break
    if (arr[pos+i]-pos-1)//k==page:
      tmp+=1
    else:
      break
  pos+=tmp
  ans+=1
print(ans)",O(n)
"n = int(input())
m = input().split(' ')
j = 0
mark = [1]
for i in range(1,len(m)) :
    tmp = max(mark[i-1],int(m[i])+1)
    mark.append(tmp)

j+=mark[len(m)-1]-int(m[len(m)-1])-1
for i in range(len(m)-2,-1,-1):
    if mark[i]<mark[i+1]-1:
        mark[i] = mark[i+1]-1
    j+=mark[i]-int(m[i])-1
print(j)
",O(n)
"class Solution(object):
    def minMaxDifference(self, num):
        def f(dst):
            result = 0
            base = 1
            while base <= num:
                base *= 10
            base //= 10
            src = -1
            while base:
                d = num//base%10
                if src == -1 and d != dst:
                    src = d
                result += base*(dst if d == src else d)
                base //= 10
            return result
    
        return f(9)-f(0)",O(logn)
"n = int(input())
a = list(map(int, input().split()))
a.sort()
ans = 0
ok = False
for i in range(len(a)):
    if (a[i] > min(a) ):
        ans = a[i]
        ok = True
        break
if (ok):
    print(ans)
else:
    print(""NO"")",O(nlogn)
"class Solution2(object):
    def arithmeticTriplets(self, nums, diff):
        result = 0
        cnt1 = collections.Counter()
        cnt2 = collections.Counter()
        for x in nums:
            result += cnt2[x-diff]
            cnt2[x] += cnt1[x-diff]
            cnt1[x] += 1
        return result",O(n)
"class Solution(object):
    def numberOfDays(self, Y, M):
        leap = 1 if ((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0) else 0
        return (28+leap if (M == 2) else 31-(M-1)%7%2)",O(1)
"class Solution(object):
    def countFairPairs(self, nums, lower, upper):
        def count(x):
            cnt = 0
            left, right = 0, len(nums)-1
            while left < right:
                if nums[left]+nums[right] <= x:
                    cnt += right-left
                    left += 1
                else:
                    right -= 1
            return cnt
        
        nums.sort()
        return count(upper)-count(lower-1)",O(nlogn)
"import math
import time
from collections import defaultdict,deque,Counter
from sys import stdin,stdout
from bisect import bisect_left,bisect_right
from queue import PriorityQueue
import sys
t=1

for _ in range(t):
    r,g,b=map(int,stdin.readline().split())
    ra=list(map(int,stdin.readline().split()))
    ga=list(map(int,stdin.readline().split()))
    ba=list(map(int,stdin.readline().split()))
    ra.sort()
    ga.sort()
    ba.sort()
    dp=[[[0]*201 for _ in range(201)]for _ in range(201)]
    for i in range(r+1):
        for j in range(g+1):
            for k in range(b+1):
                if(i and j>0):
                    dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+ra[i-1]*ga[j-1])
                if(i and k>0):
                    dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+ra[i-1]*ba[k-1])
                if(k and j>0):
                    dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+ga[j-1]*ba[k-1])
    print(dp[r][g][b])
",O(n ^ 3)
"def fact(x):
	if x == 0:
		return 1
	else:
		return x * fact(x-1)
def lower_bound(li, num):
	answer = -1
	start = 0
	end = len(li)-1

	while(start <= end):
		middle = (end+start)//2
		if li[middle] >= num:
			answer = middle
			end = middle - 1
		else:
			start = middle + 1
	return answer
def upper_bound(li, num):
	answer = -1
	start = 0
	end = len(li)-1

	while(start <= end):
		middle = (end+start)//2

		if li[middle] <= num:
			answer = middle
			start = middle + 1

		else:
			end = middle - 1
	return answer

def abs(x):
	return x if x >=0 else -x
def binary_search(li, val, lb, ub):
	ans = 0
	while(lb <= ub):
		mid = (lb+ub)//2

		if li[mid] > val:
			ub = mid-1
		elif val > li[mid]:
			lb = mid + 1
		else:
			ans = 1
			break
	return ans
def kadane(x):
	sum_so_far = 0
	current_sum = 0
	for i in x:
		current_sum += i
		if current_sum < 0:
			current_sum = 0
		else:
			sum_so_far = mpos(sum_so_far,current_sum)
	return sum_so_far
def pref(li):
	pref_sum = [0]
	for i in li:
		pref_sum.append(pref_sum[-1] + i)
	return pref_sum
def graph(n,m):
	adj = dict()
	for i in range(1,n+1):
		adj.setdefault(i,0)
	for i in range(m):
		a,b = map(int,input().split())
		adj[a] += 1
		adj[b] += 1
	return adj

import sys
import threading
from math import *

for _ in range(1):

	n,l,r,x = map(int,input().split())

	a = list(map(int,input().split()))

	cnt = 0
	for mask in range(1,(1<<n)+1):
		mini = 10**9 + 10
		maxi = 0
		elem = 0
		sumi = 0
		for j in range(n):
			if mask & (1<<j):
				elem += 1
				sumi += a[j]
				mini = min(mini, a[j])
				maxi = max(maxi, a[j])

		if elem >= 2:
			if (l <= sumi <= r) and (maxi-mini >= x):
				cnt += 1
	print(cnt)
",np
"import sys
from itertools import chain, combinations

def powerset(iterable):
	s = list(iterable)
	return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))

def diff(s, x):
	return True if (max(s)-min(s))>=x else False

def solve(problemset, l, r, x):
	multiset = powerset(problemset)
	cnt = 0
	for s in multiset:
		if sum(s)>=l and sum(s)<=r and diff(s, x):
			cnt += 1
	return cnt

sys.setrecursionlimit(10**7)

def I(): return int(sys.stdin.readline().rstrip())
def MI():return map(int, sys.stdin.readline().rstrip().split())
def LI():return list(map(int, sys.stdin.readline().rstrip().split()))
def LI2():return list(map(int, sys.stdin.readline().rstrip()))
def S():return sys.stdin.readline().rstrip()
def LS():return list(sys.stdin.readline().rstrip().split())
def LS2():return list(sys.stdin.readline().rstrip())

n, l, r, x = MI()

problemset = LI()

print(solve(problemset, l, r, x))",np
"import threading


class Solution(object):
    
    def __init__(self):
        self.__l = threading.Lock()
        self.__light = 1

    def carArrived(self, carId, roadId, direction, turnGreen, crossCar):
        with self.__l:
            if self.__light != roadId:
                self.__light = roadId
                turnGreen()
            crossCar()",O(1)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def maxDepth(self, root):
        if root is None:
            return 0
        else:
            return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1",O(n)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

prime = [True for i in range(200001)]
pp=[0]*200001
def SieveOfEratosthenes(n=200000):

    p = 2
    while (p * p <= n):

        if (prime[p] == True):

            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1

MOD = int(1e9+7)
n = int(input())
a = [input() for i in range(n)]
dp = [1]
for i in range(n):
    if a[i] == 'f':
        dp.append(0)
        continue
    for j in range(1, len(dp)):
        dp[j] = (dp[j] + dp[j-1]) % MOD
print(dp[-1])",O(n ^ 2)
"import itertools



class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def leafSimilar(self, root1, root2):
        def dfs(node):
            if not node:
                return
            if not node.left and not node.right:
                yield node.val
            for i in dfs(node.left):
                yield i
            for i in dfs(node.right):
                yield i
        return all(a == b for a, b in
                   itertools.zip_longest(dfs(root1), dfs(root2)))",O(n)
"from itertools import groupby

n = int(input())
l = list(map(int, input().split()))
r = list(map(int, input().split()))
sums = [(a + b, ind) for (ind, (a, b)) in enumerate(zip(l, r))]
sums.sort()
answer = [None] * n
curr_candies = n
for key, group in groupby(sums, key=lambda i: i[0]):
    for elem in group:
        answer[elem[1]] = curr_candies
    curr_candies -= 1
tl = []
for i in range(n):
    cnt = 0
    for j in range(i):
        if answer[j] > answer[i]:
            cnt += 1
    tl.append(cnt)
tr = []
for i in range(n):
    cnt = 0
    for j in range(i + 1, n):
        if answer[j] > answer[i]:
            cnt += 1
    tr.append(cnt)
if tl != l or tr != r:
    print(""NO"")
else:
    print(""YES"")
    print(' '.join(map(str, answer)))
",O(n ^ 2)
"import collections



class Solution(object):
    def numberOfSubsequences(self, nums):
        cnt = collections.defaultdict(int)
        result = 0
        for r in range(4, len(nums)-2):
            q = r-2
            for p in range((q-2)+1):
                cnt[float(nums[p])/nums[q]] += 1
            for s in range(r+2, len(nums)):
                result += cnt[float(nums[s])/nums[r]]
        return result",O(n ^ 2)
"class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        second = slow.next
        prev = slow.next = None
        while second:
            tmp = second.next
            second.next = prev
            prev = second
            second = tmp

        first, second = head, prev
        while second:
            tmp1, tmp2 = first.next, second.next
            first.next = second
            second.next = tmp1
            first, second = tmp1, tmp2
",O(n)
"n, s = map(int, input().split())
cnt = 0
for i in range(n, 0, -1):
    cnt += s // i
    s %= i
print(cnt)",O(n)
"def cal(r,g,b):
	if dp[r][g][b]!=-1:
		return dp[r][g][b]
	ans=0
	if r<R and g<G:
		ans=max(ans,rl[r]*gl[g]+cal(r+1,g+1,b))
	if r<R and b<B:
		ans=max(ans,rl[r]*bl[b]+cal(r+1,g,b+1))
	if g<G and b<B:
		ans=max(ans,gl[g]*bl[b]+cal(r,g+1,b+1))
	dp[r][g][b]=ans
	return ans

R,G,B=map(int,input().split())
rl=sorted(list(map(int,input().split())),reverse=True)
gl=sorted(list(map(int,input().split())),reverse=True)
bl=sorted(list(map(int,input().split())),reverse=True)
dp=[[[-1 for j in range(B+1)] for i in range(G+1)] for i in range(R+1)]
print(cal(0,0,0))",O(n ^ 3)
"import bisect



class Solution(object):
    def maximumCount(self, nums):
        return max(bisect.bisect_left(nums, 0)-0, len(nums)-bisect.bisect_left(nums, 1))",O(logn)
"def check(a, b):
    if a[1] == b[1] and 1 <= abs(int(b[0]) - int(a[0])) <= 2:
        return True

arr = input().split()
d = {}
for i in arr:
    d[i] = d.get(i, 0) + 1
mineq = 3 - max(d.values())
arr.sort(key=lambda x: x[0])
arr.sort(key=lambda x: x[1])
if check(arr[0], arr[1]) or check(arr[1], arr[2]):
    mineq = min(mineq, 1)
if arr[0][1] == arr[1][1] == arr[2][1] and int(arr[2][0]) - int(arr[1][0]) == 1 and int(arr[1][0]) - int(arr[0][0]) == 1:
    mineq = 0
print(mineq)",O(nlogn)
"class Solution2(object):
    def subarrayLCM(self, nums, k):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        def lcm(a, b):
            return a//gcd(a, b)*b

        result = 0
        for i in range(len(nums)):
            l = 1
            for j in range(i, len(nums)):
                if k%nums[j]:
                    break
                l = lcm(l, nums[j])
                result += int(l == k)
        return result",O(n ^ 2)
"import sys
input = sys.stdin.readline

n, k = map(int, input().split())
s = input()[:-1]
left, right = 0, n
while left < right:
    mid = right - (right - left) // 2
    A = [[0] * (n + 2) for _ in range(k)]

    for c in range(k):
        A[c][n] = A[c][n + 1] = n + 1
        L = 0
        for i in range(n - 1, -1, -1):
            if s[i] == '?' or ord(s[i]) - ord('a') == c: L += 1
            else: L = 0
            A[c][i] = i + mid if L >= mid else A[c][i + 1]

    dp = [n + 1] * (1 << k)
    dp[0] = 0
    for mask in range(1 << k):
        for i in range(k):
            if mask >> k & 1: continue
            t = mask | 1 << i
            dp[t] = min(dp[t], A[i][dp[mask]])
    if dp[-1] <= n: left = mid
    else: right = mid - 1
print(left)",np
"class Node(object):
    def __init__(self, value):
        self.val = value
        self.next = self.prev = None


class Solution(object):

    def __init__(self):
        self.__head = self.__tail = Node(-1)
        self.__head.next = self.__tail
        self.__tail.prev = self.__head
        self.__size = 0

    def get(self, index):
        if 0 <= index <= self.__size // 2:
            return self.__forward(0, index, self.__head.__next__).val
        elif self.__size // 2 < index < self.__size:
            return self.__backward(self.__size, index, self.__tail).val
        return -1

    def addAtHead(self, val):
        self.__add(self.__head, val)

    def addAtTail(self, val):
        self.__add(self.__tail.prev, val)

    def addAtIndex(self, index, val):
        if 0 <= index <= self.__size // 2:
            self.__add(self.__forward(0, index, self.__head.__next__).prev, val)
        elif self.__size // 2 < index <= self.__size:
            self.__add(self.__backward(self.__size, index, self.__tail).prev, val)

    def deleteAtIndex(self, index):
        if 0 <= index <= self.__size // 2:
            self.__remove(self.__forward(0, index, self.__head.__next__))
        elif self.__size // 2 < index < self.__size:
            self.__remove(self.__backward(self.__size, index, self.__tail))

    def __add(self, preNode, val):
        node = Node(val)
        node.prev = preNode
        node.next = preNode.__next__
        node.prev.next = node.next.prev = node
        self.__size += 1
        
    def __remove(self, node):
        node.prev.next = node.__next__
        node.next.prev = node.prev
        self.__size -= 1
        
    def __forward(self, start, end, curr):
        while start != end:
            start += 1
            curr = curr.__next__
        return curr
    
    def __backward(self, start, end, curr):
        while start != end:
            start -= 1
            curr = curr.prev
        return curr",O(n)
"class Solution(object):
    def countHighestScoreNodes(self, parents):
        def iter_dfs(adj):
            result = [0]*2
            stk = [(1, (0, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    i, ret = args
                    cnts = [[0] for _ in range(len(adj[i]))]
                    stk.append((2, (cnts, ret)))
                    for j, child in enumerate(adj[i]):
                        stk.append((1, (child, cnts[j])))
                elif step == 2:
                    cnts, ret = args
                    ret[0] = sum(cnt[0] for cnt in cnts)+1
                    score = max((len(adj)-ret[0]), 1)*reduce(lambda x, y: x*y[0], cnts, 1)
                    if score > result[0]:
                        result[:] = [score, 1]
                    elif score == result[0]:
                        result[1] += 1
            return result[1]

        adj = [[] for _ in range(len(parents))] 
        for i in range(1, len(parents)):
            adj[parents[i]].append(i)
        return iter_dfs(adj)",O(n)
"n, t = [int(item) for item in input().split(' ')]
cont, ans = [], 2
for i in range(n):
    hcenter, hlen = [int(item) for item in input().split(' ')]
    cont.append([hcenter - hlen / 2, hcenter + hlen / 2])

cont.sort(key=lambda item: item[0])

for i in range(n - 1):
    gap = cont[i + 1][0] - cont[i][1]
    if gap == t:
        ans += 1
    elif gap > t:
        ans += 2

print(ans)",O(nlogn)
"class Solution(object):
    def minNumberOperations(self, target):
        return sum(max((target[i] if i < len(target) else 0)-(target[i-1] if i-1 >= 0 else 0), 0) for i in range(len(target)+1))",O(n)
"class Solution(object):
    def lengthOfLastWord(self, s):
        length = 0
        for i in reversed(s):
            if i == ' ':
                if length:
                    break
            else:
                length += 1
        return length",O(n)
"def solve(a, b, c):
    D = b * b - 4 * a * c
    k = D**0.5
    x1 = (-b+k)/(2*a)
    x2 = (-b-k)/(2*a)
    return max(x1,x2)

from math import *
n, r = map(int, input().split())
a = (1/tan(pi/n))**2
b = -2 * r
c = -(r*r)
ans = solve(a,b,c)
print(""%.10f"" % ans)",O(1)
"class Solution(object):
    def complexNumberMultiply(self, a, b):
        ra, ia = list(map(int, a[:-1].split('+')))
        rb, ib = list(map(int, b[:-1].split('+')))
        return '%d+%di' % (ra * rb - ia * ib, ra * ib + ia * rb)",O(1)
"class Solution(object):
    def getSmallestString(self, s):
        result = list(map(int, s))
        for i in range(len(s)-1):
            if result[i]%2 != result[i+1]%2:
                continue
            if result[i] > result[i+1]:
                result[i], result[i+1] = result[i+1], result[i]
                break
        return """".join(map(str, result))",O(n)
"n, k = map(int, input().split())
grid = [['.']*n for i in range(4)]
if k % 2 == 0:
    for i in range(k//2):
        grid[1][1+i], grid[2][1+i] = '
else:
    m = n//2
    if k > n - 2:
        for i in range(1, n-1):
            grid[1][i] = '
        for i in range(1, (k-n+2)//2 + 1):
            grid[2][m+i], grid[2][m-i] = '
    else:
        grid[1][m] = '
        if k > 1:
            for i in range(1, k//2 + 1):
                grid[1][m-i], grid[1][m+i] = '
print('YES')
for i in grid:
    print(''.join(i))",O(n)
"n = int(input())
print(n, 0, 0)",O(1)
"import collections


class Solution(object):

    def __init__(self):
        self.__q = collections.deque()

    def ping(self, t):
        self.__q.append(t)
        while self.__q[0] < t-3000:
            self.__q.popleft()
        return len(self.__q)",O(1)
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        dp = [False] * n
        dp[-1] = True

        for i in range(n - 2, -1, -1):
            end = min(n, i + nums[i] + 1)
            for j in range(i + 1, end):
                if dp[j]:
                    dp[i] = True
                    break
        return dp[0]
",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def main():
    pass

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def lts(l):
    s = ''.join(map(str, l))
    return s

def stl(s):

    l = list(s)

    return l

def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans

def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1

    return (cnt)

def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)

mod = int(1e9) + 7
import math

def deep(node):
    visited[node-1]=1
    if(len(d[node])==1):
        return node
    for c in d[node]:
        if(visited[c-1]!=1):
            return(deep(c))

n=int(input())
d={}
for i in range(n-1):
    u,v=map(int,input().split())
    d.setdefault(u,[]).append(v)
    d.setdefault(v,[]).append(u)
node=1
for key in d:
    if(len(d[key])>len(d[node])):
        node=key
ans=[]
visited=[0]*n
visited[node-1]=1
for c in d[node]:
    while(True):
        visited[c-1]=1
        if(len(d[c])==1):
            ans.append([node,c])
            break
        for child in d[c]:
            if(visited[child-1]!=1):
                c=child
                break
if(sum(visited)==n):
    print(""Yes"")
    print(len(ans))
    for c in ans:
        print(*c)
else:
    print(""No"")
",O(n)
"n=int(input())
a=list(map(int,input().split()))
k=min(a[0],a[-1])//(n-1)
for i in range(1,n-1):
    k=min(k,min(a[0],a[i])//i,min(a[i],a[-1])//(n-1-i))
print(k)
",O(n)
"class Solution(object):
    def minCosts(self, cost):
        for i in range(1, len(cost)):
            cost[i] = min(cost[i], cost[i-1])
        return cost",O(n)
"class Solution(object):
    def convertDateToBinary(self, date):
        return ""-"".join([bin(int(x))[2:] for x in date.split('-')])",O(1)
"import random



class Solution(object):
    def makeSubKSumEqual(self, arr, k):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        l = gcd(k, len(arr))
        result = 0
        for i in range(l):
            vals = [arr[j] for j in range(i, len(arr), l)]
            nth_element(vals, len(vals)//2)
            result += sum(abs(v-vals[len(vals)//2]) for v in vals)
        return result",O(n)
"n= int(input())
t=[[] for _ in range(n+1)]
for i in range(n-1):
    v = int(input())
    t[v].append(i+2)

flag=True
for l in t:
    if l!=[]:
        cnt=0
        for ele in l:
            if t[ele]==[]:
                cnt+=1
        if cnt<3:
            flag=False
            break
if flag:
    print(""YES"")
else:
    print(""NO"")",O(n)
"import sys

input = sys.stdin.readline

r, g, b = map(int, input().split())
sticks = [sorted([int(i) for i in input().split()], reverse = True) for j in range(3)]
dp, ans = [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)], 0
for i in range(r + 1):
    for j in range(g + 1):
        for k in range(b + 1):
            if i < r and j < g:
                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + sticks[0][i] * sticks[1][j])
            if i < r and k < b:
                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + sticks[0][i] * sticks[2][k])
            if j < g and k < b:
                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + sticks[1][j] * sticks[2][k])
            ans = max(ans, dp[i][j][k])
print(ans)
",O(n ^ 3)
"n,s=map(int,input().split())
r=10**18+1
l=0
def f(m):
  res=0
  while m>0:
    res+=m%10
    m//=10
  return res
while r-l>1:
  mid=(r+l)//2
  if mid-f(mid)>=s:
    r=mid
  else:
    l=mid
print(max(n-r+1,0))",O(logn)
"n, m, k = map(int, input().split())
a = sorted(map(int, input().split()))
r = [x for x in range(n + 1) if sum(a[n - x :]) + k >= m + x]
print(min(r) if r else -1)
",O(nlogn)
"class Solution(object):
    def sortEvenOdd(self, nums):
        def partition(index, nums):
            for i in range(len(nums)):
                j = i
                while nums[i] >= 0:
                    j = index(j)
                    nums[i], nums[j] = nums[j], ~nums[i] 
            for i in range(len(nums)):
                nums[i] = ~nums[i] 

        def inplace_counting_sort(nums, left, right, reverse=False): 
            if right-left+1 == 0:
                return
            count = [0]*(max(nums[i] for i in range(left, right+1))+1)
            for i in range(left, right+1):
                count[nums[i]] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(left, right+1)): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = left+count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(left, right+1):
                nums[i] = ~nums[i] 
            if reverse: 
                while left < right:
                    nums[left], nums[right] = nums[right], nums[left]
                    left += 1
                    right -= 1

        partition(lambda i: i//2 if i%2 == 0 else (len(nums)+1)//2+i//2, nums)
        inplace_counting_sort(nums, 0, (len(nums)+1)//2-1)
        inplace_counting_sort(nums, (len(nums)+1)//2, len(nums)-1, True)
        partition(lambda i: 2*i if i < (len(nums)+1)//2 else 1+2*(i-(len(nums)+1)//2), nums)
        return nums",O(n)
"class Solution_Recu(object):
    def copyRandomBinaryTree(self, root):
        def dfs(node, callback):
            if not node:
                return None
            left_node, copy = callback(node)
            dfs(left_node, callback)
            dfs(node.right, callback) 
            return copy
    
        def merge(node):
            copy = NodeCopy(node.val)
            node.left, copy.left = copy, node.left
            return copy.left, copy
        
        def clone(node):
            copy = node.left
            node.left.random = node.random.left if node.random else None
            node.left.right = node.right.left if node.right else None
            return copy.left, copy
        
        def split(node):
            copy = node.left
            node.left, copy.left = copy.left, copy.left.left if copy.left else None
            return node.left, copy
    
        dfs(root, merge)
        dfs(root, clone)
        return dfs(root, split)


",O(n)
"import sys
input=sys.stdin.readline
n=int(input())
ar=list(map(int,input().split()))
dic={}
li=[]
for i in range(n):
    xx=[]
    for j in range(n-i):
        xx.append(0)
    li.append(xx.copy())
for i in range(n):
    for j in range(n-i):
        if(i==0):
            li[i][j]=ar[j]
        else:
            li[i][j]=li[i-1][j]^li[i-1][j+1]
for i in range(1,n):
    for j in range(n-i):
        li[i][j]=max(li[i][j],li[i-1][j],li[i-1][j+1])
for _ in range(int(input())):
    l,r=map(int,input().split())
    print(li[r-l][l-1])",O(n ^ 2)
"import math
import random
import heapq, bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
import threading
from collections import defaultdict

mod = 10 ** 9 + 7
mod1 = 998244353

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class TreeNode:
    def __init__(self, k, v):
        self.key = k
        self.value = v
        self.left = None
        self.right = None
        self.parent = None
        self.height = 1
        self.num_left = 1
        self.num_total = 1

class AvlTree:

    def __init__(self):
        self._tree = None

    def add(self, k, v):
        if not self._tree:
            self._tree = TreeNode(k, v)
            return
        node = self._add(k, v)
        if node:
            self._rebalance(node)

    def _add(self, k, v):
        node = self._tree
        while node:
            if k < node.key:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(k, v)
                    node.left.parent = node
                    return node.left
            elif node.key < k:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(k, v)
                    node.right.parent = node
                    return node.right
            else:
                node.value = v
                return

    @staticmethod
    def get_height(x):
        return x.height if x else 0

    @staticmethod
    def get_num_total(x):
        return x.num_total if x else 0

    def _rebalance(self, node):

        n = node
        while n:
            lh = self.get_height(n.left)
            rh = self.get_height(n.right)
            n.height = max(lh, rh) + 1
            balance_factor = lh - rh
            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)
            n.num_left = 1 + self.get_num_total(n.left)

            if balance_factor > 1:
                if self.get_height(n.left.left) < self.get_height(n.left.right):
                    self._rotate_left(n.left)
                self._rotate_right(n)
            elif balance_factor < -1:
                if self.get_height(n.right.right) < self.get_height(n.right.left):
                    self._rotate_right(n.right)
                self._rotate_left(n)
            else:
                n = n.parent

    def _remove_one(self, node):

        replacement = node.left or node.right
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = replacement
            else:
                node.parent.right = replacement
            replacement.parent = node.parent
            node.parent = None
        else:
            self._tree = replacement
            replacement.parent = None
        node.left = None
        node.right = None
        node.parent = None
        self._rebalance(replacement)

    def _remove_leaf(self, node):
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = None
            else:
                node.parent.right = None
            self._rebalance(node.parent)
        else:
            self._tree = None
        node.parent = None
        node.left = None
        node.right = None

    def remove(self, k):
        node = self._get_node(k)
        if not node:
            return
        if AvlTree._is_leaf(node):
            self._remove_leaf(node)
            return
        if node.left and node.right:
            nxt = AvlTree._get_next(node)
            node.key = nxt.key
            node.value = nxt.value
            if self._is_leaf(nxt):
                self._remove_leaf(nxt)
            else:
                self._remove_one(nxt)
            self._rebalance(node)
        else:
            self._remove_one(node)

    def get(self, k):
        node = self._get_node(k)
        return node.value if node else -1

    def _get_node(self, k):
        if not self._tree:
            return None
        node = self._tree
        while node:
            if k < node.key:
                node = node.left
            elif node.key < k:
                node = node.right
            else:
                return node
        return None

    def get_at(self, pos):
        x = pos + 1
        node = self._tree
        while node:
            if x < node.num_left:
                node = node.left
            elif node.num_left < x:
                x -= node.num_left
                node = node.right
            else:
                return (node.key, node.value)
        raise IndexError(""Out of ranges"")

    @staticmethod
    def _is_left(node):
        return node.parent.left and node.parent.left == node

    @staticmethod
    def _is_leaf(node):
        return node.left is None and node.right is None

    def _rotate_right(self, node):
        if not node.parent:
            self._tree = node.left
            node.left.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.left
            node.left.parent = node.parent
        else:
            node.parent.right = node.left
            node.left.parent = node.parent
        bk = node.left.right
        node.left.right = node
        node.parent = node.left
        node.left = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    def _rotate_left(self, node):
        if not node.parent:
            self._tree = node.right
            node.right.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.right
            node.right.parent = node.parent
        else:
            node.parent.right = node.right
            node.right.parent = node.parent
        bk = node.right.left
        node.right.left = node
        node.parent = node.right
        node.right = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    @staticmethod
    def _get_next(node):
        if not node.right:
            return node.parent
        n = node.right
        while n.left:
            n = n.left
        return n

class SegmentTree1:
    def __init__(self, data, default=300006, func=lambda a, b: min(a , b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b:a + b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m

def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z

def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por

def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        if (arr[mid] <=key):
            count = mid + 1
            left = mid + 1

        else:
            right = mid - 1

    return count

def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    leftGreater = n

    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        else:
            l = m + 1

    return (n - leftGreater)

class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.isEndOfWord = False
class Trie:
    def __init__(self):
        self.root = self.getNode()
    def getNode(self):
        return TrieNode()
    def _charToIndex(self, ch):
        return ord(ch) - ord('a')
    def insert(self, key):
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
            if not pCrawl.children[index]:
                pCrawl.children[index] = self.getNode()
            pCrawl = pCrawl.children[index]
        pCrawl.isEndOfWord = True
    def search(self, key):
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
            if not pCrawl.children[index]:
                return False
            pCrawl = pCrawl.children[index]
        return pCrawl != None and pCrawl.isEndOfWord

class Node:
    def __init__(self, data):
        self.data = data
        self.count=0
        self.left = None
        self.right = None
class BinaryTrie:
    def __init__(self):
        self.root = Node(0)
    def insert(self, pre_xor):
        self.temp = self.root
        for i in range(31, -1, -1):
            val = pre_xor & (1 << i)
            if val:
                if not self.temp.right:
                    self.temp.right = Node(0)
                self.temp = self.temp.right
                self.temp.count+=1
            if not val:
                if not self.temp.left:
                    self.temp.left = Node(0)
                self.temp = self.temp.left
                self.temp.count += 1
        self.temp.data = pre_xor
    def query(self, xor):
        self.temp = self.root
        for i in range(31, -1, -1):
            val = xor & (1 << i)
            if not val:
                if self.temp.left and self.temp.left.count>0:
                    self.temp = self.temp.left
                elif self.temp.right:
                    self.temp = self.temp.right
            else:
                if self.temp.right and self.temp.right.count>0:
                    self.temp = self.temp.right
                elif self.temp.left:
                    self.temp = self.temp.left
            self.temp.count-=1
        return xor ^ self.temp.data

n=int(input())
l=list(map(int,input().split()))
fi=[""even"",""odd""]
q=defaultdict(int)
e=[0]*(n+1)
s=SegmentTree(e)
ans=0
for j in range(n):
    ans+=s.query(l[j]+1,n)
    s.__setitem__(l[j],1)
fi1=ans
for i in range(int(input())):
    a,b=map(int,input().split())
    a-=1
    b-=1
    fi1+=((b-a+1)*(b-a))//2
    print(fi[fi1%2])",O(n ^ 2)
"from itertools import combinations

n, l, r, x = map(int, input().split())
(*a,) = map(int, input().split())
sumu = 0
for i in range(2, n + 2):
    for j in combinations(a, i):
        if (r >= sum(j) >= l) and (max(j) - min(j) >= x):
            sumu += 1
print(sumu)
",np
"import math
def nCr(n,r):
	f = math.factorial
	return f(n) / f(r) / f(n-r)
dict1 = {'+':0,'-':0,'?':0}
for i in input():
	dict1[i]+=1
for i in input():
	if(i=='?'):
		dict1[i]+=1
	else:
		dict1[i]-=1
if dict1['+']<0 or dict1['-']<0:
	print(0.000000000000)
elif dict1['+']==0 and dict1['-']==0:
	print(1.000000000000)
elif dict1['+'] and dict1['-']:
	ans = (nCr(dict1['?'], dict1['+'])/(2**dict1['?']))
	print(""%.12f"" %ans)
else:
	ans = (1 / (2 ** dict1['?']))
	print(""%.12f"" % ans)",np
print(int(input()) // 2 + 1),O(1)
"import sys
input=sys.stdin.readline
from math import *

l,r=map(int,input().split())

l=list(bin(l)[2:])
r=list(bin(r)[2:])
l=['0' for i in range(len(r)-len(l))]+l

s=""""
for i in range(len(r)):
    if l[i]==r[i]:
        s+=""0""
    else:
        s+=""1""*(len(r)-i)
        break
print(int(s,2))",O(logn)
"x, k = map(int, input().split())
mo = 1000000007
if (not x):
    print(0)
elif (not k):
    print((x * 2) % mo)
else:
    ans = x * pow(2, k + 1, mo) + 1 - pow(2, k, mo)
    ans %= mo
    ans += mo
    ans %= mo
    print(ans)",O(logn)
"class Solution(object):
    def minSwaps(self, data):
        total_count = sum(data)
        result, count, left = 0, 0, 0
        for i in range(len(data)):
            count += data[i]
            if i-left+1 > total_count: 
                count -= data[left]
                left += 1
            result = max(result, count)
        return total_count-result",O(n)
"import os
import re
import sys
from bisect import bisect, bisect_left, insort, insort_left
from collections import Counter, defaultdict, deque
from copy import deepcopy
from decimal import Decimal
from fractions import gcd
from io import BytesIO, IOBase
from itertools import (
    accumulate, combinations, combinations_with_replacement, groupby,
    permutations, product)
from math import (
    acos, asin, atan, ceil, cos, degrees, factorial, hypot, log2, pi, radians,
    sin, sqrt, tan)
from operator import itemgetter, mul
from string import ascii_lowercase, ascii_uppercase, digits

def inp():
    return(int(input()))

def inlist():
    return(list(map(int, input().split())))

def instr():
    s = input()
    return(list(s[:len(s)]))

def invr():
    return(map(int, input().split()))

def getReamin(action, n):
    n -= action
    ans = (n*(n+1) // 2) - action
    return ans

def main():

    n, k = invr()
    l = 1
    r = n
    res = 0
    while l <= r:
        mid = l + (r-l)//2
        remain = getReamin(mid, n)
        if remain == k:
            res = mid
            break
        if remain > k:
            l = mid + 1
        else:
            r = mid - 1
    print(res)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(logn)
"class Solution2(object):
    def countHousePlacements(self, n):
        MOD = 10**9+7
        prev, curr = 1, 2
        for _ in range(n-1):
            prev, curr = curr, (prev+curr)%MOD
        return pow(curr, 2, MOD)",O(logn)
"def nine(p) :

    s=''
    for i in range(p) :
        s+='9'
    return int(s)
def prosh(p) :
    ans=0
    for i in range(1,p+1) :
        ans+=nine(i)*9
    return ans

n,k=map(int,input().split())
l=[0]*29
for i in range(19) :

    e=nine(19-i)

    l[i]=k//e

    k-=l[i]*e

    if k==0 :

        break
    if i==18  or k%e>prosh(19-i-1) :

        l[i]+=1
        break
otv=0
for i in range(19) :

    otv+=10**(19-i)*l[i]

print(max(n-otv+1,0))
",O(logn)
"class Solution(object):
    def diagonalSum(self, mat):
        return sum(mat[i][i]+mat[~i][i] for i in range(len(mat))) - (mat[len(mat)//2][len(mat)//2] if len(mat)%2 == 1 else 0)",O(n)
"import collections

        
class Solution(object):
    def minSetSize(self, arr):
        counting_sort = [0]*len(arr)
        count = collections.Counter(arr)
        for c in count.values():
            counting_sort[c-1] += 1
        result, total = 0, 0
        for c in reversed(range(len(arr))):
            if not counting_sort[c]:
                continue
            count = min(counting_sort[c],
                        ((len(arr)+1)//2 - total - 1)//(c+1) + 1)
            result += count
            total += count*(c+1)
            if total >= (len(arr)+1)//2:
                break
        return result",O(n)
"import sys
from collections import deque
n=int(input())
visited=[False for i in range(n+1)]
dp=[0 for i in range(n+1)]
l=[[] for i in range(n+1)]
for i in range(n-1):
    a,b=map(int,input().split())
    l[a].append(b)
    l[b].append(a)
b=list(map(int,input().split()))
s=[1]
visited[1]=True
c=1
c1=0
while len(s)!=n :
    aux=0
    for i in l[s[c1]]:
        if not visited[i]:
            visited[i]=True
            dp[i]=1
            aux+=1
    for i in range(c,c+aux):
        if dp[b[i]]==1:
            s.append(b[i])
            dp[b[i]]=0
        else:
            print(""No"")
            sys.exit()
    c+=aux
    c1+=1
print(""Yes"")
",O(nlogn)
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque

n, k = map(int,input().split())
s = input()

def judge(needed):

    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0

    effect = [[inf]*(n+1) for j in range(k)]

    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
            effect[j][i] = min(effect[j][i],inf)

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index])

        minstate[state] = minimum

    if minstate[-1]<=n:  return True
    return False

front = 0
rear = n//k+1

while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)

    if flag:
        front = mid + 1
    else:
        rear = mid

print(front-1)
",np
"from collections import deque, defaultdict, Counter
from itertools import product, groupby, permutations, combinations
from math import gcd, floor, inf, log2, sqrt, log10
from bisect import bisect_right, bisect_left
from statistics import mode
from string import ascii_uppercase

cases = int(input())
matrix1 = []
for _ in range(cases):
    matrix1.append(list(input()))

matrix2 = []
for _ in range(cases):
    matrix2.append(list(input()))

def transpose(matrix):
    return [list(x) for x in zip(*matrix)]

def reverse_row(matrix):
    return matrix[::-1]

def reverse_column(matrix):
    return [x[::-1] for x in matrix]
def rotate_90(matrix):

    return reverse_row(transpose(matrix))

def rotate_180(matrix):

    return reverse_row(reverse_column(matrix))
def rotate_270(matrix):

    return reverse_column(transpose(matrix))

if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \
    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):
    print(""Yes"")

    exit()

matrix2 = reverse_row(matrix2)
if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \
    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):
    print(""Yes"")
    exit()

matrix2 = reverse_column(matrix2)
if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \
    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):
    print(""Yes"")
    exit()
matrix2 = transpose(matrix2)
if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \
    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):
    print(""Yes"")
    exit()
else:
    print(""No"")
",O(n ^ 2)
"class Solution2(object):
    def killProcess(self, pid, ppid, kill):
        def killAll(pid, children, killed):
            killed.append(pid)
            for child in children[pid]:
                killAll(child, children, killed)

        result = []
        children = collections.defaultdict(set)
        for i in range(len(pid)):
            children[ppid[i]].add(pid[i])
        q = collections.deque()
        q.append(kill)
        while q:
            p = q.popleft()
            result.append(p)
            for child in children[p]:
                q.append(child)
        return result",O(n)
"MAXN = 200001

def less_sum(s, m):
    n = len(s)
    a = 0
    b = 0
    res = 0
    last = 0

    count = [0 for i in range(-MAXN, MAXN+1)]

    count[0] = 1
    x = 0
    last = 1

    for i in range(n):
        if s[i] > m:
            b += 1
        else:
            a += 1
        x = a-b

        if s[i] > m:
            last -= count[x+1]
        else:
            last += count[x]

        res += last
        count[x] += 1
        last += 1

    return res

n, m = map(int, input().split(' '))
s = list(map(int, input().split(' ')))[0:n]

print(less_sum(s, m) - less_sum(s, m-1))",O(nlogn)
"import sys
from functools import reduce
input = sys.stdin.readline

def readPair():
  return tuple(map(int, input().split()))

def readEntry():
  e = readPair()
  return (e[0], e[1], e[0] - e[1])

(n, m) = readPair()
entries = [readEntry() for _ in range(0, n)]

entries.sort(key=lambda x: x[2], reverse=True)

size = reduce(lambda s, e: s + e[0], entries, 0)
count = 0

while (size > m and count < n):
  size -= entries[count][2]
  count += 1

print(-1 if size > m else count)",O(nlogn)
"n,k = map(int,input().split())
print((2*n + k - 1) // k + (5*n+k-1) // k + (8*n+k-1)//k)
",O(1)
"def reach_max(n, k):
    return n * k + 1 - n * (n + 1) // 2

n, k = map(int, input().split())

if n == 1:
    print(0)
    exit()

lo, hi = 1, k - 1

if n > reach_max(hi, k):
    print(-1)
    exit()

while lo < hi:
    mid = (lo + hi) // 2
    if reach_max(mid, k) < n:
        lo = mid + 1
    else:
        hi = mid

print(lo)",O(logn)
"import collections
import itertools



class Solution(object):
    def timeTaken(self, arrival, state):
        def go_until(t):
            while curr[0] <= t and any(q):
                if not q[direction[0]]:
                    direction[0] ^= 1
                result[q[direction[0]].popleft()] = curr[0]
                curr[0] += 1
    
        UNKNOWN, ENTERING, EXITING = list(range(-1, 1+1))
        result = [0]*len(arrival)
        curr, direction = [float(""-inf"")], [UNKNOWN]
        q = [collections.deque(), collections.deque()]
        for i, (a, s) in enumerate(zip(arrival, state)):
            go_until(a-1)
            q[s].append(i)
            if not (a <= curr[0]):
                curr, direction = [a], [EXITING]
        go_until(float(""inf""))
        return result",O(n)
"n=int(input())
l1=[]
l2=[]
for _ in range(n):
    l1.append(input())
for _ in range(n):
    l2.append(input())
c=0
for i in range(n):
    if(l1[i]  in l2):
        l2.remove(l1[i])
    else:
        c+=1

print(c)
",O(n)
"n , k = map(int, input().split())
l = list(map(int,input().split()))
l.sort()
a = 0
i = 0
while i<(n-1):
    j = i+1
    while j<n and l[j]==l[i]:
        j+=1
    if j==n:
        break
    else:
        if l[j]<=l[i]+k:
            a+=(j-i)
    i = j
print(n-a)",O(nlogn)
"
import bisect


class Solution(object):
    def increasingTriplet(self, nums):
        min_num, a, b = float(""inf""), float(""inf""), float(""inf"")
        for c in nums:
            if min_num >= c:
                min_num = c
            elif b >= c:
                a, b = min_num, c
            else: 
                return True
        return False

",O(n)
"import sys
input=sys.stdin.readline
al=list(""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"")
n=int(input())
s=[input().rstrip() for i in range(3)]
l=len(s[0])
ans=[0]*3
for c in al:
    for i in range(3):
        cnt_c=s[i].count(c)
        if cnt_c+n<=l:
            ans[i]=max(ans[i],cnt_c+n)
        else:
            if n==1 and l==cnt_c:
                ans[i]=max(ans[i],l-1)
            else:
                ans[i]=l
if (ans[0]==ans[1] and max(ans)==ans[0]) or (ans[1]==ans[2] and max(ans)==ans[1]) or (ans[0]==ans[2] and max(ans)==ans[2]):
    print(""Draw"")
elif max(ans)==ans[0]:
    print(""Kuro"")
elif max(ans)==ans[1]:
    print(""Shiro"")
else:
    print(""Katie"")",O(n)
"from os import path
import sys
from heapq import heappush,heappop,heapify
from functools import cmp_to_key as ctk
from collections import deque,defaultdict as dd
from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right
from itertools import permutations
from datetime import datetime
from math import ceil,sqrt,log,gcd
def ii():return int(input())
def si():return input().rstrip()
def mi():return map(int,input().split())
def li():return list(mi())
abc='abcdefghijklmnopqrstuvwxyz'
mod=1000000007

inf = float(""inf"")
vow=['a','e','i','o','u']
dx,dy=[-1,1,0,0],[0,0,1,-1]

def bo(i):
    return ord(i)-ord('a')

file=1

def solve():

    n,q=mi()

    x=int(log(n+1,2))
    root=1<<(x-1)
    for i in range(q):
        u=ii()
        s=si()
        pos='U'
        if(u<root):
            pos='L'
        if(u>root):
            pos='R'

        s1=bin(u)[2:]
        s1='0'*(x-len(s1))+s1
        s1=list(s1)
        for j in s:
            for k in range(x-1,-1,-1):
                if s1[k]=='1':
                    f=k
                    break
            if j=='L':
                if(f==x-1):
                    continue
                s1[f]='0'
                s1[f+1]='1'
            elif(j=='R'):
                if(f==x-1):
                    continue
                s1[f+1]='1'
            else:
                if f==0:
                    continue
                if s1[f-1]=='1':
                    s1[f]='0'
                else:
                    s1[f-1]='1'
                    s1[f]='0'

        s1="""".join(s1)
        print(int(s1,2))

if __name__ ==""__main__"":

    if(file):

        if path.exists('input.txt'):
            sys.stdin=open('input.txt', 'r')
            sys.stdout=open('output.txt','w')
        else:
            input=sys.stdin.readline
    solve()",np
"class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        res = []

        q = collections.deque()
        q.append(root)

        while q:
            qLen = len(q)
            level = []
            for i in range(qLen):
                node = q.popleft()
                if node:
                    level.append(node.val)
                    q.append(node.left)
                    q.append(node.right)
            if level:
                res.append(level)

        return res
",O(n)
"class Solution(object):
    def flowerGame(self, n, m):
        return (n*m)//2",O(1)
"class Solution2(object):
    def minimumSteps(self, s):
        result = 0
        left, right = 0, len(s)-1
        while left < right:
            if left < len(s) and s[left] != '1':
                left += 1
                continue
            if right >= 0 and s[right] != '0':
                right -= 1
                continue
            result += right-left
            left += 1
            right -= 1
        return result",O(n)
"import itertools



class Solution(object):
    def minNumberOfHours(self, initialEnergy, initialExperience, energy, experience):
        result = 0
        for hp, ex in zip(energy, experience):
            inc1 = max((hp+1)-initialEnergy, 0)
            inc2 = max((ex+1)-initialExperience, 0)
            result += inc1+inc2
            initialEnergy += inc1-hp
            initialExperience += inc2+ex
        return result",O(n)
"n,m = map(int, input().strip().split(' '))
lst = list(map(int, input().strip().split(' ')))
res = list(dict.fromkeys(lst))
c=[]
for i in range(len(res)):
    c.append(lst.count(res[i]))

if m<n:
    print(0)
elif m==n:
    print(1)
else:
    m1=1
    c1=0
    j=2
    f=0
    while(True):
        c1=0
        for i in range(len(c)):
            c1+=c[i]//j
        if c1>=n:
            m1=j
            j+=1
        else:
            f=1
        if f==1:
            print(m1)
            break
",O(nlogn)
"class Solution(object):
    def advantageCount(self, A, B):
        sortedA = sorted(A)
        sortedB = sorted(B)

        candidates = {b: [] for b in B}
        others = []
        j = 0
        for a in sortedA:
            if a > sortedB[j]:
                candidates[sortedB[j]].append(a)
                j += 1
            else:
                others.append(a)
        return [candidates[b].pop() if candidates[b] else others.pop()
                for b in B]",O(nlogn)
"from sys import stdin, stdout, maxsize
from math import inf

R = lambda : stdin.readline().strip()
RL = lambda f=None: list(map(f, R().split(' '))) if f else list(R().split(' '))

output = lambda x: stdout.write(str(x) + '\n')
output_list = lambda x: output(' '.join(map(str, x)))

n, m, K = RL(int)

if K%2:
    for i in range(n):
        print( *(m*[-1]) )
    exit()

hor = [ RL(int) +[inf] for i in range(n) ]
vert = [ RL(int) for i in range(n-1) ] + [ m*[inf] ]

K = K//2
dp = [ [m*[inf] for i in range(n)] for j in range(0, K+1)]

dp[0] = [m*[0] for i in range(n)]

def valid(i, j):
    if -1 < i < n and  -1 < j < m:
        return True
    return False

for k in range(1, K+1):
    for i in range(n):
        for j in range(m):
            if valid(i, j+1):
                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i][j+1] + 2*hor[i][j])
            if valid(i+1, j):
                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i+1][j] + 2*vert[i][j])
            if valid(i-1, j):
                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i-1][j] + 2*vert[i-1][j])
            if valid(i, j-1):
                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i][j-1] + 2*hor[i][j-1])

for i in dp[-1]:
    print(*i)
",O(n ^ 3)
"from copy import *
n,T=map(int,raw_input().split())
cl=set(())
di={(0,0,0,T):1}
for k in range(n):
    t,g=map(int,raw_input().split())
    an=deepcopy(di)
    for k in an:
        nc=list(k)
        nc[3]-=t
        nc[g-1]+=1
        if nc[3]>=0:
            nc=tuple(nc)
            if nc in di:
                di[nc] += an[k]
            else:
                di[nc] = an[k]
nd={(1,0,0,0):1,(0,1,0,1):1,(0,0,1,2):1}
mo=10**9+7
def nb(tu):

    if not(tu in nd):
        if tu[tu[3]]==0:
            nd[tu] =0
        else:
            nt=list(tu)
            nt[tu[3]]-=1
            nt[3]=(nt[3]+1)%3
            nt2=nt[:]
            nt2[3]=(nt2[3]+1)%3
            nd[tu]=(tu[tu[3]]*(nb(tuple(nt))+nb(tuple(nt2))))%mo
    return nd[tu]

print(sum(di[k]*(nb(k[:3]+(1,))+nb(k[:3]+(0,))+nb(k[:3]+(2,))) for k in di if k[3]==0)%mo)
",np
"import sys
input = sys.stdin.readline
maxn = int(1e5 + 10)
ST = [0] * (4 * maxn)
def update(id, l, r, val):
    if l == r == val:
        ST[id] = 1
        return
    if l > val or r < val:
        return
    mid = int((l + r) / 2)
    update(id * 2, l, mid, val)
    update(id * 2 + 1, mid + 1, r, val)
    ST[id] = ST[id * 2] + ST[id * 2 + 1]
    return
def get(id, l, r, x, y):
    if l > y or r < x:
        return 0
    if x <= l and r <= y:
        return ST[id]
    mid = int((l + r) / 2)
    return get(id * 2, l, mid, x, y) + get(id * 2 + 1, mid + 1, r, x, y)
n, res = int(input()), 0
for x in list(map(int, input().split())):
    res ^= get(1, 1, n, x + 1, n) % 2
    update(1, 1, n, x)
for i in range (int(input())):
    x, y = list(map(int, input().split()))
    if int((y - x) * (y - x + 1) / 2) & 1:
        res ^= 1
    if res:
        print(""odd"")
    else:
        print(""even"")",O(n ^ 2)
"N = int(input())
L = [int(s) for s in input().split("" "")]
R = [int(s) for s in input().split("" "")]

C = [N - L[i] - R[i] for i in range(0, N)]

for i, x in enumerate(C):
    if C[i] <= 0:
        print(""NO"")
        exit()

    l = 0
    r = 0

    j = i-1
    while j >= 0:
        if C[j] > C[i]:
            l = l + 1

        j = j - 1

    j = i+1
    while j < N:
        if C[j] > C[i]:
            r = r + 1

        j = j + 1

    if L[i] != l or R[i] != r:
        print(""NO"")
        exit()

print(""YES"")
for i in range(0, N-1):
    print(C[i], end="" "")

print(C[N-1])
",O(n ^ 2)
"
import heapq


class Solution(object):
    def smallestChair(self, times, targetFriend):
        events = []
        for i, (s, e) in enumerate(times): 
            events.append((s, True, i))
            events.append((e, False, i))
        events.sort()

        lookup = {}
        min_heap = []
        for _, arrival, i in events: 
            if not arrival: 
                heapq.heappush(min_heap, lookup.pop(i))
                continue
            lookup[i] = heapq.heappop(min_heap) if min_heap else len(lookup)
            if i == targetFriend:
                break
        return lookup[targetFriend]
",O(nlogn)
"class Solution2(object):
    def getHint(self, secret, guess):
        A = sum(map(operator.eq, secret, guess))
        B = sum((Counter(secret) & Counter(guess)).values()) - A
        return ""%dA%dB"" % (A, B)",O(n)
"class ArrayReader(object):
   def compareSub(self, l, r, x, y):
       pass

   def length(self):
       pass

class Solution(object):
    def getIndex(self, reader):
        left, right = 0, reader.length()-1
        while left < right:
            mid = left + (right-left)//2
            if reader.compareSub(left, mid, mid if (right-left+1)%2 else mid+1, right) >= 0:
                right = mid
            else:
                left = mid+1
        return left",O(logn)
"import collections


class Solution2(object):
    def copyRandomBinaryTree(self, root):
        lookup = collections.defaultdict(lambda: NodeCopy())
        lookup[None] = None
        stk = [root]
        while stk:
            node = stk.pop()
            if not node:
                continue
            lookup[node].val = node.val
            lookup[node].left = lookup[node.left]
            lookup[node].right = lookup[node.right]
            lookup[node].random = lookup[node.random]
            stk.append(node.right)
            stk.append(node.left)
        return lookup[root]",O(n)
"import math

t = int(input())
res = []
while t:
	t -= 1
	n, k = map(int, input().split())
	limit = -1
	if n <= 60:
		limit = 0
		pow4 = 1
		for _ in range(n):
			limit += pow4
			pow4 *= 4
	if limit < k and limit != -1 or n == 2 and k == 3:
		res.append('NO')
	else:
		div = 1
		k -= 1
		size = 1
		while div < n and k >= 4 * size - 1:
			k -= 4 * size - 1
			size *= 2
			div += 1
		res.append('YES ' + str(n - div))

print('\n'.join(res))",O(logn)
"n,k = map(int,input().split())
print(-(-k//n))
",O(1)
"n = int(input())

arr = list(map(int, input().split()))

memo = [-1 for i in range(n+1)]
def can_win(idx):
	if memo[idx] != -1: return memo[idx]
	res = False

	delta = arr[idx]

	nidx = idx + delta
	while nidx < n:
		if arr[nidx] > arr[idx] and not can_win(nidx):
			res = True
			break
		nidx += delta

	nidx = idx - delta
	while not res and nidx >= 0:
		if arr[nidx] > arr[idx] and not can_win(nidx):
			res = True
			break
		nidx -= delta

	memo[idx] = res
	return res

ans = ['A' if can_win(i) else 'B' for i in range(n)]
print(''.join(ans))
",O(n ^ 2)
"import sys
import heapq

n, k = list(map(int,sys.stdin.readline().strip().split(' ')))
p = list(map(int,sys.stdin.readline().strip().split(' ')))
c = list(map(int,sys.stdin.readline().strip().split(' ')))

sortedp = sorted([(pi,i) for (i,pi) in enumerate(p)])

ans = [0 for i in range(n)]
acc_coins = 0
acc = []

if k == 0:
	print(' '.join(map(str,c)))
else:
	for i in range(n):
		coins = c[sortedp[i][1]]
		ans[sortedp[i][1]] += acc_coins + coins
		if len(acc) < k:
			acc_coins += coins
			heapq.heappush(acc,coins)
		else:
			smallest_coin = heapq.nsmallest(1,acc)[0]
			if smallest_coin < coins:
				acc_coins -= smallest_coin
				heapq.heappop(acc)
				heapq.heappush(acc,coins)
				acc_coins += coins
	print(' '.join(map(str,ans)))
",O(nlogn)
"import collections



class Solution(object):
    def minimumPushes(self, word):
        return sum(x*(i//(9-2+1)+1) for i, x in enumerate(sorted(iter(collections.Counter(word).values()), reverse=True)))",O(n)
"from sys import stdout

n = int(input())

if n % 4 == 2:

    print(""! -1"")

    exit(0)

print(""?"", 1)

stdout.flush()

a = int(input())

print(""?"", 1 + n // 2)

stdout.flush()

b = int(input())

if a == b:

    print(""!"", 1)

    exit(0)

l = 1

r = 1 + n // 2

while(l != r):

    mid = ( l + r ) // 2

    print(""?"", mid)

    stdout.flush()

    c = int(input())

    print(""?"", mid + n // 2)

    stdout.flush()

    d = int(input())

    if c == d:

        print(""!"", mid)

        exit(0)

    if a < b:

        if c < d:

            l = mid + 1

        else:

            r = mid

    else:

        if c > d:

            l = mid + 1

        else:

            r = mid

print(""!"", l)
",O(logn)
"s = input()
k = []
for i in range(len(s)):
    for j in range(i+1,len(s)+2):
        x = s[i:j]
        for t in range(i+1,len(s)):
            if x == s[t:t+j-i]:
                k += [j-i]
print(max(k) if k != [] else 0)",O(n ^ 3)
"import sys

def query(c, d):
    print('? %d %d' % (c, d))
    sys.stdout.flush()
    res = int(input())
    return res

a = 0
b = 0
big = query(0, 0)

for i in range(29, -1, -1):
    p = query(a ^ (1 << i), b)
    q = query(a, b ^ (1 << i))
    if p == q:
        if big == 1:
            a ^= 1 << i
        else:
            b ^= 1 << i
        big = p
    elif p == -1:
        a ^= 1 << i
        b ^= 1 << i

print('! %d %d' % (a, b))
sys.stdout.flush()
",O(1)
"n, m = map(int, input().split())
A = list(map(int, input().split()))
L = [0]*n
for i in range(m):
    L[A[i]-1] += 1
print(min(L))",O(n ^ 2)
"class Solution:
    def countSubstrings(self, s: str) -> int:
        res = 0

        for i in range(len(s)):
            for j in range(i, len(s)):
                l, r = i, j
                while l < r and s[l] == s[r]:
                    l += 1
                    r -= 1
                res += (l >= r)

        return res
",O(n ^ 3)
"
class Solution(object):
    def findMaxAverage(self, nums, k):
        result = total = sum(nums[:k])
        for i in range(k, len(nums)):
            total += nums[i] - nums[i-k]
            result = max(result, total)
        return float(result) / k

",O(n)
"import itertools



class Solution2(object):
    def getWordsInLongestSubsequence(self, n, words, groups):
        def check(s1, s2):
            return len(s1) == len(s2) and sum(a != b for a, b in zip(s1, s2)) == 1

        dp = [[1, -1] for _ in range(n)]
        for i in range(n):
            for j in range(i):
                if groups[i] != groups[j] and check(words[j], words[i]):
                    dp[i] = max(dp[i], [dp[j][0]+1, j])
        result = []
        i = max(range(n), key=lambda x: dp[x])
        while i != -1:
            result.append(words[i])
            i = dp[i][1]
        result.reverse()
        return result",O(n ^ 2)
"def detect_cycle(n,edges):
        visited = [False]*n
        stack = []
        color = [0]*n
        for v in range(n):
            if not visited[v]:
                if dfs_visit(v,edges,visited,stack,color):
                    return stack
        return None

def dfs_visit(v,edges,visited,stack,color):
        visited[v] = True
        stack.append(v)
        color[v] = 1
        for u in edges[v]:
            if not visited[u]:
               if dfs_visit(u,edges,visited,stack,color):
                   return True

            elif color[u] == 1:
                stack.append(u)
                return True

        color[v] = 2
        stack.pop(stack.index(v))
        return False

if __name__ == '__main__':
        n,m = map(int,input().split())
        edges = [[] for i in range(n)]
        for _ in range(m):
            u,v  = map(int,input().split())
            edges[u - 1].append(v - 1)

        inCycle = detect_cycle(n,edges)
        if inCycle:
            possible = False
            index = inCycle.index(inCycle[-1])
            inCycle = inCycle[index:]
            for v in range(len(inCycle) - 1):
                edges[inCycle[v]].remove(inCycle[v + 1])
                if detect_cycle(n,edges) is None:
                    possible = True
                    break
                else:
                    edges[inCycle[v]].append(inCycle[v + 1])
        else: possible = True
print('YES' if possible else 'NO')
",O(n ^ 2)
"class Solution(object):
    def longestSubarray(self, nums):
        mx = max(nums)
        result, l = 1, 0
        for x in nums:
            if x == mx:
                l += 1
                result = max(result, l)
            else:
                l = 0
        return result",O(n)
"class Solution(object):
    def numTeams(self, rating):
        result = 0
        for i in range(1, len(rating)-1):
            less, greater = [0]*2, [0]*2
            for j in range(len(rating)):
                if rating[i] > rating[j]:
                    less[i < j] += 1
                if rating[i] < rating[j]:
                    greater[i < j] += 1
            result += less[0]*greater[1] + greater[0]*less[1]
        return result",O(n ^ 2)
"class Solution(object):
    def getNoZeroIntegers(self, n):
        a, curr, base = 0, n, 1
        while curr: 
            if curr % 10 == 0 or (curr % 10 == 1 and curr != 1):
                a += base
                curr -= 10 
            a += base
            base *= 10
            curr //= 10
        return [a, n-a]",O(logn)
"class Solution(object):
    def boxDelivering(self, boxes, portsCount, maxBoxes, maxWeight):
        dp = [0]*(len(boxes)+1)
        left, cost, curr = 0, 1, 0
        for right in range(len(boxes)):
            if right == 0 or boxes[right][0] != boxes[right-1][0]:
                cost += 1
            curr += boxes[right][1]
            while right-left+1 > maxBoxes or \
                  curr > maxWeight or \
                  (left+1 < right+1 and dp[left+1] == dp[left]): 
                curr -= boxes[left][1]
                if boxes[left+1][0] != boxes[left][0]:
                    cost -= 1
                left += 1
            dp[right+1] = dp[(left-1)+1] + cost
        return dp[len(boxes)]",O(n)
"import collections

class Solution2(object):
    def canConstruct(self, ransomNote, magazine):
        return not collections.Counter(ransomNote) - collections.Counter(magazine)",O(n)
"import sys

def main():

    n,k=map(int,sys.stdin.readline().strip().split())
    arr=list(map(int,sys.stdin.readline().strip().split()))
    arr.sort()
    dic={}
    for a in arr:
        if a/k not in dic:
            dic[a]=1

    print(len(dic))

main()",O(nlogn)
"class Solution:
    def __init__(self):
        self.map = {}

    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        if head is None:
            return None
        if head in self.map:
            return self.map[head]

        copy = Node(head.val)
        self.map[head] = copy
        copy.next = self.copyRandomList(head.next)
        copy.random = self.map.get(head.random)
        return copy
",O(n)
"import random

n = int(input())
v = []
for i in range(0, n):
    x, y = map(int, input().split())
    v.append([x, y, i])

while 1>0:
    random.shuffle(v)
    x = y = 0
    ans = [0]*n
    for i in range(n):

        if (x+v[i][0])**2+(y+v[i][1])**2 < (x-v[i][0])**2+(y-v[i][1])**2:
            x += v[i][0]
            y += v[i][1]
            ans[v[i][2]] = 1
        else:
            x -= v[i][0]
            y -= v[i][1]
            ans[v[i][2]] = -1
    if x*x+y*y <= 1500000**2:
        print(*ans)
        break
2",O(nlogn)
"import sys
input = sys.stdin.buffer.readline

def process(A):
    d = {}
    final = set([])
    for x in A:
        if x not in d:
            d[x] = 0
        d[x]+=1
        if d[x] >= 4:
            return [x, x, x, x]
        if d[x] >= 2:
            final.add(x)
    L = sorted(final)
    answer = [float('inf'), None, None]
    for i in range(len(L)-1):
        a = L[i]
        b = L[i+1]
        a1 = a/b+b/a
        answer = min(answer, [a1, a, b])
    a1, a, b = answer
    return [a, a, b, b]

t = int(input())
for i in range(t):
    n = int(input())
    A = [int(x) for x in input().split()]
    a, b, c, d = process(A)
    print(f'{a} {b} {c} {d}')",O(nlogn)
"def get_kth_digit(i):
    if i < 10:
        return i

    batch = 9
    count = 9
    width = 1

    while i >  10 * batch * (width + 1) + count:
        batch *= 10
        width += 1
        count += batch * width

    k = i - count - 1
    num = 10 ** width + k// (width + 1)
    return str(num)[k % (width + 1)]

def main():
    i = int(input())

    print(get_kth_digit(i))

if __name__ == '__main__':
    main()",O(logn)
"n,m,k = map(int,input().split())
P = [int(x) for x in input().split()]
P.reverse()

ops = 0
i = 1
while P:

    nxt = P[-1]
    togo = nxt - i
    skip = togo//k*k
    i += skip

    space = k
    while space:
        special = 0
        while P and P[-1] < i + space:
            special += 1
            P.pop()
        i += space
        if not special:
            break
        ops += 1
        space = special

print(ops)
",O(n)
"n, m = map(int, input().split())
dist = [int(x) for x in input().split()]
taxi = [int(x) for x in input().split()]
dists = {}
d = []
for person in range(len(taxi)):
    if taxi[person]:
        dists[dist[person]] = 0
        d.append(dist[person])
start = 0
d.append(10**11)
for person in range(len(taxi)):
    if taxi[person] == 0:
        while dist[person] > d[start + 1]:
            start += 1
        if abs(dist[person] - d[start]) <= abs(dist[person] - d[start + 1]):
            dists[d[start]] += 1
        else:
            dists[d[start + 1]] += 1
for d in dists:
    print(dists[d] if d!=10**11 else '', end=' ')
",O(n)
"a = [ord(e) - ord('0') for e in list(input().strip())]
b = [ord(e) - ord('0') for e in list(input().strip())]

a.sort(reverse=True)
h = [0 for i in range(10)]
for x in a:
    h[x] += 1

if len(a) < len(b):
    print(''.join(map(str, a)))
    exit(0)

def gmax(hx):
    s = list(hx)
    res = list()
    for i in range(9, -1, -1):
        while s[i] > 0:
            res.append(i)
            s[i] -= 1
    return res

def gmin(hx):
    s = list(hx)
    res = list()
    for i in range(10):
        while s[i] > 0:
            res.append(i)
            s[i] -= 1
    return res

res = list()

def finalize(x):
    for y in range(x-1, -1, -1):
        if h[y] > 0:
            res.append(y)
            h[y] -= 1
            for i in range(9, -1, -1):
                while h[i] > 0:
                    res.append(i)
                    h[i] -= 1
            return

p = 0
while p < len(a):
    x = b[p]
    if h[x] > 0:
        hh = list(h)
        hh[x] -= 1
        if b[p+1:] >= gmin(hh):
            res.append(x)
            h[x] -= 1
        else:
            finalize(x)
            break
    else:
        finalize(x)
        break
    p += 1
print(''.join(map(str, res)))",O(n ^ 3)
"class Solution(object):
    def canReachCorner(self, X, Y, circles):
        def check(x1, y1, r1, x2, y2, r2):
            return (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2

        def iter_dfs():
            lookup = [False]*len(circles)
            stk = []
            dst = [False]*len(circles)
            for u in range(len(circles)):
                x, y, r = circles[u]
                if x-r <= 0 or y+r >= Y:
                    lookup[u] = True
                    stk.append(u)
                if x+r >= X or y-r <= 0:
                    dst[u] = True
            while stk:
                u = stk.pop()
                if dst[u]:
                    return True
                x1, y1, r1 = circles[u]
                for v in range(len(circles)):
                    x2, y2, r2 = circles[v]
                    if lookup[v] or not check(x1, y1, r1, x2, y2, r2):
                        continue
                    lookup[v] = True
                    stk.append(v)
            return False

        return not iter_dfs()",O(n ^ 2)
"t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int,input().split()))
    a.sort()
    if a[-2]>n-2:
        print(n-2)
    else:
        print(a[-2]-1)",O(nlogn)
"n=int(input())
if n%4==2:
    print('!', '-1')
    exit()
def qry(i):
    print('?', i+1, flush=True)
    a=int(input())
    return a
def qry2(i):
    a=qry(i+n//2)-qry(i)
    if a==0:
        print('!', i+1)
        exit()
    return a
a=qry2(0)
lb,rb=1,n//2-1
while lb<=rb:
    mb=(lb+rb)//2
    b=qry2(mb)
    if (a>0)==(b>0):
        lb=mb+1
    else:
        rb=mb-1",O(logn)
"from collections import deque
from copy import deepcopy

m,n,k  = map(int,input().split())

horizon = []
for i in range(m):
    horizon.append( list(map(int,input().split()))  )

vertical = []
for i in range(m-1):
    vertical.append( list(map(int,input().split()))  )

if k%2==1:
    ans = [-1]*n
    for i in range(m):
        print("" "".join(map(str,ans)))
    exit()

direc = [[0,-1],[0,1],[1,0],[-1,0]]

ans = [[0 for j in range(n)] for i in range(m)]

for t in range(k//2):
    tempans = deepcopy(ans)

    for i in range(m):
        for j in range(n):
            ans[i][j] = 2147483647
            for d in range(4):
                neighi = i + direc[d][0]
                neighj = j + direc[d][1]
                if neighi<0 or neighi>=m or neighj<0 or neighj>=n: continue
                base = tempans[neighi][neighj]
                if d==0: base += 2 * horizon[neighi][neighj]
                if d==1: base += 2 * horizon[neighi][neighj-1]
                if d==2: base += 2 * vertical[neighi-1][neighj]
                if d==3: base += 2 * vertical[neighi][neighj]
                ans[i][j] = min(ans[i][j],base)

for ele in ans:
    print("" "".join(map(str,ele)))
",O(n ^ 3)
"class Solution(object):
    def sortArray(self, nums):
        def min_moves(d):
            def index(x):
                return d*(len(nums)-1) if x == 0 else x-d

            lookup = [False]*len(nums)
            result = len(nums)
            for i in range(len(nums)):
                if lookup[nums[i]]:
                    continue
                l = 0
                while not lookup[nums[i]]:
                    lookup[nums[i]] = True
                    l += 1
                    i = index(nums[i])
                result -= 1
                if l >= 2:
                    result += 2
            return result-2*int(nums[d*(len(nums)-1)] != 0)

        return min(min_moves(0), min_moves(1))",O(n)
"n, k = map(int, input().split())
s = input()

for i in range(1, n):
    if s[:n - i] == s[i:]:
        print(s + s[n - i:] * (k - 1))
        exit()
print(s * k)
",O(n ^ 2)
"n = int(input())
if n % 2 == 1:
    print((n + 2) // 2)
elif n > 0:
    print(n + 1)
else:
    print(0)
",O(1)
"import os, sys
from io import BytesIO, IOBase

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class dict(dict):
    def __missing__(self, key):
        return 0.0

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [tuple([i] + inp(dtype)) for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
get_bit = lambda x, i: (x >> i) & 1

n = int(input())
a, masks, big = inp_2ds(float, n), dict(), 2 ** n - 1

if n == 1:
    exit(print(1))

for i in range(n):
    for j in range(i + 1, n):
        masks[big ^ (1 << j)] += a[i][j]
        masks[big ^ (1 << i)] += a[j][i]

for _ in range(2, n):
    tem = dict()
    for msk in masks:
        for bit in range(18):
            if get_bit(msk, bit):
                tem[msk ^ (1 << bit)] += sum([a[i][bit] for i in range(n) if get_bit(msk, i)]) * masks[msk]
    masks = tem

su = sum(masks.values())
print(*[masks[1 << i] / su for i in range(n)])
",np
"n=int(input())
p=[0,0]+list(map(int,input().split()))
d=[0]*(n+1)
for i in range(n,1,-1):
    if d[i]==0:
        d[i]=1
    d[p[i]]+=d[i]
if n==1:
    d[1]=1
d=d[1:]
d.sort()
print(*d)",O(n)
"import os
import heapq
import sys, threading
import math
import bisect
import operator
from collections import defaultdict

sys.setrecursionlimit(10 ** 5)
from io import BytesIO, IOBase

def gcd(a, b):
    if b == 0:

        return a
    else:
        return gcd(b, a % b)

def power(x, p, m):
    res = 1
    while p:
        if p & 1:
            res = (res * x) % m
        x = (x * x) % m
        p >>= 1
    return res

def inar():
    return [int(k) for k in input().split()]

def lcm(num1, num2):
    return (num1 * num2) // gcd(num1, num2)
rr=0
gg=0
bb=0
dp=[]
def func(x,y,z,red,green,blue):
    if (x>=rr and y>=gg) or (y>=gg and z>=bb) or (x>=rr and z>=bb):
        return 0
    if dp[x][y][z]!=-1:
        return dp[x][y][z]
    take=0
    if x<rr and y<gg:
        take=max(take,red[x]*green[y]+func(x+1,y+1,z,red,green,blue))
    if y<gg and z<bb:
        take=max(take,green[y]*blue[z]+func(x,y+1,z+1,red,green,blue))
    if x<rr and z<bb:
        take=max(take,red[x]*blue[z]+func(x+1,y,z+1,red,green,blue))
    dp[x][y][z]=take
    return take

def main():
    global rr,gg,bb,dp

    for i in range(202):
        temp=[]
        for j in range(202):
            lis=[]
            for k in range(202):
                lis.append(-1)
            temp.append(lis)
        dp.append(temp)
    rr, gg, bb = map(int, input().split())
    red = inar()
    green = inar()
    blue = inar()
    red.sort(reverse=True)
    green.sort(reverse=True)
    blue.sort(reverse=True)
    print(func(0,0,0,red,green,blue))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"class Solution(object):
    def sortByBits(self, arr):
        def popcount(n): 
            result = 0
            while n:
                n &= n - 1
                result += 1
            return result
        
        arr.sort(key=lambda x: (popcount(x), x))
        return arr",O(nlogn)
"n=input()
n1=int(n)
c=[]
for i in range(0,n1):
    z4=0
    p,q=input().split()
    a=int(p)
    b=int(q)
    while a!=0 and b!=0:
        z1=z3=0
        if a<=b:
          z=(b/a)
          z1=int(z)
          b=b-(z1*a)
        if b<=a and b!=0:
          z2=a/b
          z3=int(z2)
          a=a-(z3*b)
        z4=z4+z1+z3
    c.append(z4)
l=len(c)
for j in range(0,l):
    print(c[j])
",O(1)
"import math

n=int(input())

s2=input()
s2=list(s2)
s=[]
for i in range(n):
    if s2[i]=='0':
        continue
    else:
        s.append(int(s2[i]))
s1=sum(s)
n=len(s)
l=[]
for i in range(2,n+1):
    if s1%i==0:
        l.append(s1//i)
f=0
if len(s)==0:
    f=1
for i in range(len(l)):
    c=0
    if f==1:
        break
    for j in range(n):
        c+=s[j]
        if c==l[i]:
            c=0
            if j==n-1:
                f=1
        elif c<l[i]:
            c=c
        else:
            break
if f==0:
    print('NO')
else:
    print('YES')",O(n ^ 2)
"class Solution:
    def isPalindrome(self, s: str) -> bool:
        newStr = ''
        for c in s:
            if c.isalnum():
                newStr += c.lower()
        return newStr == newStr[::-1]
",O(n)
"from heapq import heappop, heappush

n, m, k = [int(i) for i in input().split()]
if k % 2 == 1:
    for _ in range(n):
        print("" "".join([""-1""] * m))
    exit()

E_right = []
for i in range(n):
    E_right.append([int(j) for j in input().split()])

E_down = []
for i in range(n - 1):
    E_down.append([int(j) for j in input().split()])

P = [[0 for _ in range(m)] for _ in range(n)]
new_P = [[0 for _ in range(m)] for _ in range(n)]

for k in range(k // 2 + 1):
    for i in range(n):
        for j in range(m):
            possible = []
            if i - 1 >= 0:
                e = E_down[i - 1][j]
                possible.append(P[i - 1][j] + e)

            if i + 1 < n:
                e = E_down[i][j]
                possible.append(P[i + 1][j] + e)

            if j - 1 >= 0:
                e = E_right[i][j - 1]
                possible.append(P[i][j - 1] + e)

            if j + 1 < m:
                e = E_right[i][j]
                possible.append(P[i][j + 1] + e)

            new_P[i][j] = min(possible)

    tmp = P
    P = new_P
    new_P = tmp

for i in range(n):
    print("" "".join(str(s * 2) for s in new_P[i]))
",O(n ^ 3)
"input()
print(25)",O(1)
"class Solution(object):
    def canPlaceFlowers(self, flowerbed, n):
        for i in range(len(flowerbed)):
            if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and \
                (i == len(flowerbed)-1 or flowerbed[i+1] == 0):
                flowerbed[i] = 1
                n -= 1
            if n <= 0:
                return True
        return False",O(n)
"parent = [i for i in range(int(1e5 + 10))]
def findSet(u):
    if parent[u] != u:
        parent[u] = findSet(parent[u])
    return parent[u]

def unionSet(u, v):
    up = findSet(u)
    vp = findSet(v)
    parent[up] = vp

if __name__ == '__main__':
    n, a, b = map(int, input().split())
    lst = list(map(int, input().split()))
    temp = {lst[i]: i for i in range(n)}
    for i in range(n):
        if a - lst[i] in temp:
            unionSet(i, temp[a - lst[i]])
        else:
            unionSet(i, n)
        if b - lst[i] in temp:
            unionSet(i, temp[b - lst[i]])
        else:
            unionSet(i, n + 1)

    if findSet(n) == findSet(n + 1):
        print('NO')
    else:
        print('YES')
        tmp = findSet(n + 1)
        lst = [0 if findSet(i) == tmp else 1 for i in range(n)]
        print(*lst)",O(n)
"from sys import stdin,stdout,setrecursionlimit
stdin.readline
def mp(): return list(map(int, stdin.readline().strip().split()))
def it():return int(stdin.readline().strip())
from collections import defaultdict as dd,Counter as C,deque
from math import ceil,gcd,sqrt,factorial,log2,floor
from bisect import bisect_right as br,bisect_left as bl
import heapq

def solve(a,b):
	if a == 0:
		return 0
	return b//a + solve(b%a,a)
print(solve(*mp()))
",O(1)
"import collections


class Solution(object):
    def makeEqual(self, words):
        cnt = collections.defaultdict(int)
        for w in words:
            for c in w:
                cnt[c] += 1
        return all(v%len(words) == 0 for v in cnt.values())",O(n)
"def main():
    n = int(input())
    ans = n * n + (n - 1) * (n - 1)
    print(ans)

if __name__ == ""__main__"":
    main()
",O(1)
"from random import randint, seed



class SkipNode(object):
    def __init__(self, level=0, val=None):
        self.val = val
        self.nexts = [None]*level
        self.prevs = [None]*level

class SkipList(object):
    P_NUMERATOR, P_DENOMINATOR = 1, 2 
    MAX_LEVEL = 32 

    def __init__(self, end=[float(""inf""), float(""inf""), float(""inf"")], can_duplicated=True):
        seed(0)
        self.__head = SkipNode()
        self.__len = 0
        self.__can_duplicated = can_duplicated
        self.add(end)
        self.__end = self.find(end)

    def begin(self):
        return self.__head.nexts[0]
    
    def end(self):
        return self.__end

    def lower_bound(self, target, cmp=lambda x, y: x < y):
        return self.__lower_bound(target, self.__find_prev_nodes(target, cmp))

    def find(self, target):
        return self.__find(target, self.__find_prev_nodes(target))
        
    def add(self, val):
        if not self.__can_duplicated and self.find(val):
            return self.find(val), False
        node = SkipNode(self.__random_level(), val)
        if len(self.__head.nexts) < len(node.nexts): 
            self.__head.nexts.extend([None]*(len(node.nexts)-len(self.__head.nexts)))
        prevs = self.__find_prev_nodes(val)
        for i in range(len(node.nexts)):
            node.nexts[i] = prevs[i].nexts[i]
            if prevs[i].nexts[i]:
                prevs[i].nexts[i].prevs[i] = node
            prevs[i].nexts[i] = node
            node.prevs[i] = prevs[i]
        self.__len += 1
        return node if self.__can_duplicated else (node, True)

    def remove(self, it):
        prevs = it.prevs
        curr = self.__find(it.val, prevs)
        if not curr:
            return self.__end
        self.__len -= 1   
        for i in reversed(range(len(curr.nexts))):
            prevs[i].nexts[i] = curr.nexts[i]
            if curr.nexts[i]:
                curr.nexts[i].prevs[i] = prevs[i]
            if not self.__head.nexts[i]:
                self.__head.nexts.pop()
        return curr.nexts[0]
    
    def __lower_bound(self, val, prevs):
        if prevs:
            candidate = prevs[0].nexts[0]
            if candidate:
                return candidate
        return None

    def __find(self, val, prevs):
        candidate = self.__lower_bound(val, prevs)
        if candidate and candidate.val == val:
            return candidate
        return None

    def __find_prev_nodes(self, val, cmp=lambda x, y: x < y):
        prevs = [None]*len(self.__head.nexts)
        curr = self.__head
        for i in reversed(range(len(self.__head.nexts))):
            while curr.nexts[i] and cmp(curr.nexts[i].val, val):
                curr = curr.nexts[i]
            prevs[i] = curr
        return prevs

    def __random_level(self):
        level = 1
        while randint(1, SkipList.P_DENOMINATOR) <= SkipList.P_NUMERATOR and \
              level < SkipList.MAX_LEVEL:
            level += 1
        return level
    
    def __iter__(self):
        it = self.begin()
        while it != self.end():
            yield it.val
            it = it.nexts[0]

    def __len__(self):
        return self.__len-1 

    def __str__(self):
        result = []
        for i in reversed(range(len(self.__head.nexts))):
            result.append([])
            curr = self.__head.nexts[i]
            while curr:
                result[-1].append(str(curr.val))
                curr = curr.nexts[i]
        return ""\n"".join([""->"".join(x) for x in result])



class LineContainer(object):
    def __init__(self):
        self.__skiplist = SkipList()

    def add(self, k, m):
        self.__skiplist.add([k, m, 0])
        z = self.__skiplist.find([k, m, 0])
        x = y = z
        z = z.nexts[0]
        while self.__intersect(y, z):
            z = self.__skiplist.remove(z)
        if x != self.__skiplist.begin():
            x = x.prevs[0]
            if self.__intersect(x, y):
                y = self.__skiplist.remove(y)
                self.__intersect(x, y)
        y = x
        while y != self.__skiplist.begin():
            x = x.prevs[0]
            if x.val[2] < y.val[2]:
                break
            y = self.__skiplist.remove(y)
            self.__intersect(x, y)
            y = x
    
    def query(self, x):
        it = self.__skiplist.lower_bound(x, cmp=lambda x, y: x[2] < y)
        return it.val[0]*x + it.val[1]

    def __intersect(self, x, y):
        if y == self.__skiplist.end():
            x.val[2] = float(""inf"")
            return False
        if x.val[0] == y.val[0]:
            x.val[2] = float(""inf"") if x.val[1] > y.val[1] else float(""-inf"")
        else:
            x.val[2] = (y.val[1]-x.val[1])//(x.val[0]-y.val[0])
        return x.val[2] >= y.val[2]

    def __iter__(self):
        return iter(self.__skiplist)

    def __len__(self):
        return len(self.__skiplist)

    def __str__(self):
        return str(self.__skiplist)



class Solution(object):
    def minimumCost(self, nums, cost, k):
        prefix1 = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix1[i+1] = prefix1[i]+nums[i]
        prefix2 = [0]*(len(cost)+1)
        for i in range(len(nums)):
            prefix2[i+1] = prefix2[i]+cost[i]
        dp = 0
        lc = LineContainer()
        for i in reversed(range(len(nums))):
            lc.add(prefix1[i+1], -(dp+prefix1[i+1]*prefix2[i+1]))
            dp = (-lc.query(prefix2[i]))+(k*(prefix2[-1]-prefix2[i]))
        return dp",O(nlogn)
"import collections



class Solution(object):
    def countSubarrays(self, nums, k):
        idx = nums.index(k)
        lookup = collections.Counter()
        curr = 0
        for i in reversed(range(idx+1)):
            curr += 0 if nums[i] == k else -1 if nums[i] < k else +1
            lookup[curr] += 1
        result = curr = 0
        for i in range(idx, len(nums)):
            curr += 0 if nums[i] == k else -1 if nums[i] < k else +1
            result += lookup[-curr]+lookup[-(curr-1)]
        return result",O(n)
"class Solution(object):
    def threeConsecutiveOdds(self, arr):
        count = 0
        for x in arr:
            count = count+1 if x%2 else 0
            if count == 3:
                return True
        return False",O(n)
"n = int(input())
if n==1:
    print(5)
else:
    print(25)
",O(1)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def sumNumbers(self, root):
        return self.sumNumbersRecu(root, 0)

    def sumNumbersRecu(self, root, num):
        if root is None:
            return 0

        if root.left is None and root.right is None:
            return num * 10 + root.val

        return self.sumNumbersRecu(root.left, num * 10 + root.val) + self.sumNumbersRecu(root.right, num * 10 + root.val)",O(n)
"import collections



class Solution(object):
    def divideArray(self, nums):
        return all(cnt%2 == 0 for cnt in collections.Counter(nums).values())",O(n)
"class Solution(object):
    def integerReplacement(self, n):
        result = 0
        while n != 1:
            b = n & 3
            if n == 3:
                n -= 1
            elif b == 3:
                n += 1
            elif b == 1:
                n -= 1
            else:
                n /= 2
            result += 1

        return result",O(logn)
"import collections



class Solution3(object):
    def divisibleTripletCount(self, nums, d):
        result = 0
        for i in range(len(nums)):
            cnt = collections.Counter()
            for j in range(i+1, len(nums)):
                result += cnt[nums[j]%d]
                cnt[-(nums[i]+nums[j])%d] += 1
        return result",O(n ^ 2)
"from collections import defaultdict
n, s= int(input()), []
for i in range(n):
  a = [int(x) for x in input().split()]
  s += [(a[0], 0), (a[1], 1)]
s.sort()
now, rev = 0, defaultdict(int)
for a, b in zip(s, s[1:]):
  now += 1 if a[1] == 0 else -1
  if(a[1] == 0):
    rev[now] += b[0] - a[0] + (1 if b[1] == 1 else 0)
  elif b[0] != a[0]:
    rev[now] += b[0] - a[0] - (1 if b[1] == 0 else 0)
[print(rev[i], end="" "") for i in range(1, n+1)]
",O(nlogn)
"class Solution4(object):
    def singleNumber(self, nums):
        return (sum(set(nums)) * 3 - sum(nums)) / 2",O(n)
"n, M = map(int,input().split())

combdic = {}

def fastfrac(a,b,M):
    numb = pow(b,M-2,M)
    return ((a%M)*(numb%M))%M

def comb(p,q):
    if p==1: return q
    if (p,q) in combdic: return combdic[(p,q)]
    output = (comb(p-1,q-1)*q)%M
    output = fastfrac(output,p,M)
    combdic[(p,q)] = output
    return output

def getnext(i,j,dic):
    if 2*j+1>i: return 0
    if (i,j) in dic: return dic[(i,j)]

    if j==0:
        dic[(i,j)] = (1<<(i-1))%M
        return dic[(i,j)]

    output = 0
    for k in range(2,i):
        if 2*j-1>i-k: break

        output += (getnext(i-k,j-1,dic)*getnext(k-1,0,dic))%M*comb(k-1,i-j)
        output = output%M

    dic[(i,j)] = output

    return output

dic = {}
ans = 0

dp = [[0 for j in range(n//2+3)] for i in range(n+1)]

for i in range(1,n+1):
    dp[i][0] = (1<<(i-1))%M
    for j in range(1,n+1):
        if 2*j+1>i: break

        for k in range(2,i):
            if 2*j-1>i-k: break
            dp[i][j] +=  ((dp[i-k][j-1] * dp[k-1][0])%M * comb(k-1,i-j))%M
            dp[i][j] = dp[i][j]%M

ans = 0
for j in range(n):
    if 2*j+1>i: break

    ans += dp[n][j]
    ans = ans%M

print(ans)
",O(n ^ 3)
"import sys
m,n=map(int,sys.stdin.readline().split())
res=m^n
s=bin(res)
s=s[2:]
s=int(s)
if(s==0):
    print(0)
else:
    s=str(s)
    res=(2**len(s))-1
    print(res)",O(logn)
"n=int(input())
ans=0
for i in range(2,n+1):
	for j in range(2*i,n+1,i):
		ans+=(4*(j//i))
print(ans)",O(nlogn)
"class Solution(object):
    def shortestWordDistance(self, words, word1, word2):
        dist = float(""inf"")
        is_same = (word1 == word2)
        i, index1, index2 = 0, None, None
        while i < len(words):
            if words[i] == word1:
                if is_same and index1 is not None:
                    dist = min(dist, abs(index1 - i))
                index1 = i
            elif words[i] == word2:
                index2 = i

            if index1 is not None and index2 is not None:
                dist = min(dist, abs(index1 - index2))
            i += 1

        return dist",O(n)
"mass = list(input())
b = int(input())
mass.sort()
mass = mass[::-1]
p = ''
while(len(mass)>0):
	for i in range(len(mass)):
		n = p + mass[i] + ''.join(sorted(mass[:i] + mass[i + 1:]))
		if int(n) <= b:
			p += mass[i]
			mass = mass[:i] + mass[i + 1:]
			break
print(p)",O(n ^ 3)
"from sys import stdin

memo = {}
def max_splits(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    if n in memo:
        return memo[n]
    result = 4 * max_splits(n - 1) + 1
    memo[n] = result
    return result

t = int(stdin.readline())
for i in range(t):
    n, k = [int(s) for s in stdin.readline().strip().split()]

    min_splits = 1
    path_count = 3

    if n > 75:
        print(""YES"", n - 1)
        continue

    square_size = n - 1
    max_buffer = max_splits(square_size)

    while min_splits + path_count <= k and square_size > 0:
        min_splits += path_count
        max_buffer += (4 * path_count - (2 * path_count + 1)) * max_splits(square_size - 1)
        path_count = 2 * path_count + 1
        square_size -= 1

    if min_splits <= k <= min_splits + max_buffer:
        print(""YES"", square_size)
    else:
        print(""NO"")
",O(n ^ 2)
"def nr(): return nrs()[0]
def nrs(): return [int(i) for i in input().split()]

n = 10**7
squares = [i * i for i in range(1, 3162)]

p = [i for i in range(n + 1)]
for i in range(1, n + 1):
	if p[i] == i:
		for sq in squares:
			if i * sq > n: break
			p[i * sq] = i

for _ in range(nr()):
	N, K = nrs()
	A = [p[a] for a in nrs()]
	dp = [N] * (K + 1)
	dp[0] = 1
	used = [set()] * (K + 1)
	for a in A:
		for j in range(K, -1, -1):
			if dp[j] == N: continue
			if a in used[j]:
				if j < K and dp[j + 1] > dp[j]:
					dp[j + 1] = dp[j]
					used[j + 1] = used[j]
				dp[j] += 1
				used[j] = set([a])
			else:
				used[j].add(a)
	print(min(dp))
",O(n ^ 3)
"class Solution(object):
    def maximumEnergy(self, energy, k):
        result = float(""-inf"")
        for i in range(k):
            curr = 0
            for j in reversed(range(((len(energy)-i)-1)%k, len(energy)-i, k)): 
                curr += energy[j]
                result = max(result, curr)
        return result",O(n)
"from sys import stdin, stdout

n,m = [int(x) for x in stdin.readline().split()]

if n == 2:
    c = 1
    way = []
    mult = 1
    for x in range(m-1,-1,-1):
        way.append(c)
        c += x*mult
        mult *= -1
    for x in way:
        print(1, x)
    for x in way[::-1]:
        print(2,x)

elif n == 1:
    c = 1
    way = []
    mult = 1
    for x in range(m-1,-1,-1):
        way.append(c)
        c += x*mult
        mult *= -1
    for x in way:
        print(1, x)

elif m == 2:
    c = 1
    way = []
    mult = 1
    for x in range(n-1,-1,-1):
        way.append(c)
        c += x*mult
        mult *= -1
    for x in way:
        print(x,1)
    for x in way[:-1:-1]:
        print(x,2)

elif m == 1:
    c = 1
    way = []
    mult = 1
    for x in range(n-1,-1,-1):
        way.append(c)
        c += x*mult
        mult *= -1
    for x in way:
        print(x,1)
else:
    outStr = ''
    for x in range(n//2):
        for y in range(1,m+1):
            stdout.write(str(x+1) + ' ' + str(y)+'\n')
            stdout.write(str(n-x) + ' ' + str(m+1-y)+'\n')
    if n%2 == 1:
        c = 1
        way = []
        mult = 1
        for x in range(m-1,-1,-1):
            way.append(c)
            c += x*mult
            mult *= -1
        for x in way:
            stdout.write(str(n//2+1)+' ' + str(x)+'\n')
",O(n ^ 2)
"n = int(input())
a = [int(i) for i in input().split()]

d = {}
power = [2**i for i in range(31)]
ans = []
for i in a:
    d[i] = 0

for num in d.keys():
    for p in power:
        if num+p in d:
            ans = [num, num+p]
            if num+p+p in d:
                print(3)
                ans.append(num+p+p)
                print(*ans)
                exit()
if ans:
    print(2)
    print(*ans)
else:
    print(1)
    print(a[0])
",O(nlogn)
"class Solution(object):
    def longestCommonPrefix(self, s, t):
        result = i = j = 0
        removed = False
        while i < len(s) and j < len(t):
            if s[i] == t[j]:
                result += 1
                i += 1
                j += 1
            elif not removed:
                removed = True
                i += 1
            else:
                break
        return result",O(n)
"def is_square(x):
    sq = int(x**0.5)
    return sq * sq == x

for _ in range(int(input())):
    n = int(input())

    if ((n % 2 == 0 and is_square(n//2))
            or (n % 4 == 0 and is_square(n//4))):
        print(""YES"")
    else:
        print(""NO"")
",O(1)
"n = int(input())
wyn = 1
x = 4
for i in range(n - 1):
	wyn += x
	x += 4
print(wyn)",O(n)
"x,k=map(int,input().split())
if x==0:
  print(0)
else:
    u=(pow(2,k,1000000007)*(2*x-1)+1)%1000000007
    print(int(u))
",O(logn)
"n,m,k = map(int,input().split())
a = list(map(int,input().split()))
a.sort()
a = a[::-1]
if m<=k:
    print(0)
else:
    c=0
    while(c<n):
        k = k+a[c]-1
        c+=1
        if k>=m:
            print(c)
            exit()
    else:
        print(-1)
",O(nlogn)
"class Solution:
    def myPow(self, x: float, n: int) -> float:
        def helper(x, n):
            if x == 0:
                return 0
            if n == 0:
                return 1

            res = helper(x * x, n // 2)
            return x * res if n % 2 else res

        res = helper(x, abs(n))
        return res if n >= 0 else 1 / res
",O(logn)
"n, a, b = [int(i) for i in input().split()]
lst = sorted([int(i) for i in input().split()])
print(lst[b]-lst[b-1])
",O(nlogn)
"n=int(input())
li=[]
for i in range(1,n+1):
    if n%i==0:
        li.append(i)
p=0
for t in li:
    l=[m for m in str(t)]
    if set(l)=={'4'} or set(l)=={'7'} or set(l)=={'4','7'}:
        p+=1
if p>0:
    print('YES')
else:
    print('NO')",O(1)
"from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__

class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):

    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):

    self.out.append(str(text))

  def writeLine(self, text):

    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

def bootstrap(f, stack=[]):

  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc

class MDArray(object):

  def __init__(self, dimensions, initial_value=0):

    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):

    return self.arr[self._index(indexes)]

  def set(self, indexes, value):

    self.arr[self._index(indexes)] = value
    return value

def encode(row, col, n, m):
  return row * m + col

def main(inp, out):

  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = [-1] * (n*m*(k/2+1))

  @bootstrap
  def solve(node, remain):
    if remain == 0:
      yield 0

    key = (node + remain * n * m)
    mem = dp[key]
    if mem != -1:
      yield mem

    result = []
    for x in adj[node]:
      result.append((yield solve(x[0], remain-1)) + x[1])
    ans = min(result)
    dp[key] = ans
    yield ans

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(solve(node, k/2) * 2)
    out.writeLine(' '.join(map(str, ans)))

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",O(n ^ 3)
"a , b = input(), input()
ans = 0

ones = [0 for i in range(len(b)+1)]
zeros = [0 for i in range(len(b)+1)]

for i in range(len(b)):
    ones[i] = ones[i-1] + int(b[i])
    zeros[i] = i + 1 - ones[i]

for i in range(len(a)):
    if a[i] == '1':
        ans += zeros[len(b)-len(a)+i] - zeros[i-1]

    else:
        ans += ones[len(b)-len(a)+i] - ones[i-1]

print(ans)
",O(n)
"class Solution2(object):
    def maxPotholes(self, road, budget):
        ls = []
        l = 0
        for i in range(len(road)):
            l += 1
            if i+1 == len(road) or road[i+1] != road[i]:
                if road[i] == 'x':
                    ls.append(l)
                l = 0
        ls.sort()
        result = 0
        for l in reversed(ls):
            c = min(l+1, budget)
            if c-1 <= 0:
                break
            result += c-1
            budget -= c
        return result",O(nlogn)
"class Solution:
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        pair = [(p, s) for p, s in zip(position, speed)]
        pair.sort(reverse=True)
        stack = []
        for p, s in pair:
            stack.append((target - p) / s)
            if len(stack) >= 2 and stack[-1] <= stack[-2]:
                stack.pop()
        return len(stack)
",O(nlogn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def maxProduct(self, root):
        MOD = 10**9 + 7
        def dfs(root, total, result):
            if not root:
                return 0
            subtotal = dfs(root.left, total, result)+dfs(root.right, total, result)+root.val
            result[0] = max(result[0], subtotal*(total-subtotal) )
            return subtotal

        result = [0]
        dfs(root, dfs(root, 0, result), result)
        return result[0] % MOD",O(n)
"class Solution2(object):

    def __init__(self):
        self._cache = {}
        self.url = 'http://tinyurl.com/'

    def encode(self, long_url):
        key = sha256(long_url.encode()).hexdigest()[:6]
        self._cache[key] = long_url
        return self.url + key

    def decode(self, short_url):
        key = short_url.replace(self.url, '')
        return self._cache[key]",O(1)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n,m=map(int,input().split())
s=0
e=n-1
for i in range(n//2):
    for j in range(m):
        print(s+1,j+1)
        print(e+1,m-j)
    s+=1
    e-=1
if n%2==1:
    s=n//2
    for j in range(m//2):
            print(s+1,j+1)
            print(s+1,m-j)
    if m%2==1:
            print(s+1,m//2+1)",O(n ^ 2)
"chores = [int(x) for x in input().split()]
complexity = [int(x) for x in input().split()]
complexity.sort()
print(complexity[chores[2]]-complexity[chores[2]-1])
",O(nlogn)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def amountOfTime(self, root, start):
        def iter_dfs(root, start):
            result = -1
            stk = [(1, (root, [-1]*2))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    curr, ret = args
                    if curr is None:
                        continue
                    left, right = [-1]*2, [-1]*2
                    stk.append((2, (curr, left, right, ret)))
                    stk.append((1, (curr.right, right)))
                    stk.append((1, (curr.left, left)))
                elif step == 2:
                    curr, left, right, ret = args
                    d = -1
                    if curr.val == start:
                        d = 0
                        result = max(left[0], right[0])+1
                    elif left[1] >= 0:
                        d = left[1]+1
                        result = max(result, right[0]+1+d)
                    elif right[1] >= 0:
                        d = right[1]+1
                        result = max(result, left[0]+1+d)
                    ret[:] = [max(left[0], right[0])+1, d] 
            return result

        return iter_dfs(root, start)",O(n)
"from math import factorial

def calc_arrangement(n, m):
    return(factorial(n) / factorial(n - m))

def calc_combination(n, m):
    return(calc_arrangement(n, m) / factorial(m))

str1 = list(input())
str2 = list(input())

n = 0
diff = 0

for i in range(len(str1)):
	if str1[i] == '+':
		diff += 1
	else:
		diff -= 1
	if str2[i] == '+':
		diff -= 1
	elif str2[i] == '-':
		diff += 1
	else:
		n += 1

if n == 0:
	if diff == 0:
		print(1.0)
	else:
		print(0.0)
elif n < abs(diff):
	print(0.0)
else:
	res = calc_combination(n, (n - diff) / 2) * (0.5 ** n)
	print(res)
",np
"def MI():
    return map(int,input().split())
def I():
    return int(input())
def LI():
    return [int(i) for i in input().split()]

n,k=MI()

b=-(2*n+3)
c=n*n+n-2*k
x=(-b-((b*b-4*c)**0.5))//2
y=(-b+((b*b-4*c)**0.5))//2
x,y=int(x),int(y)
for i in [x-1,x,x+1,y-1,y,y+1]:
    if i**2+b*i+c==0 and 0<=i<=n-1:
        print(i)
        break",O(1)
"T = input().split(' ')
n = int(T[0])
m = int(T[1])
S = input().split(' ')
for i in range(n):
    S[i] = int(S[i])
ind = 0
for k in range(n):
    if S[k] == m:
        ind = k
k = ind
P = [0]*(n+1)
N = [0]*(n+1)
R = [0]*(n-k)
L = [0]*(k+1)
for i in range(k):
    if S[k-1-i] < m:
        L[k-1-i] = L[k-i] - 1
    else:
        L[k-1-i] = L[k-i] + 1
for i in range(n-k-1):
    if S[k+1+i] > m:
        R[1+i] = R[i] + 1
    else:
        R[1+i] = R[i] - 1
c = 0
for el in R:
    if el >= 0:
        P[el]+=1
        if el == 0:
            N[el]+=1
    else:
        N[-el]+=1
for el in L:
    if el >= 1:
        c = c + N[el] + N[el-1]
    else:
        c = c + P[-el] + P[-el+1]
print(c)
",O(nlogn)
"for t in range(int(input())):
	n, k = map(int, input().split())
	lev = 1
	b = False
	if n >= 60:
		all_moves = 0
		b = True
	else:
		all_moves = (4 ** n - 1) // 3

	cnt = 1
	step = 0
	prev_need = 0
	while True:
		need = 2 * cnt - 1

		if k >= need and step < n:
			k -= need
			all_moves -= need
			cnt *= 2
			step += 1
			prev_need = need
		else:
			if b:
				print('YES', n - step)
				break
			if all_moves < k:
				print('NO')
				break

			all_moves -= (4 ** (n - step)) // 3 * need
			if all_moves >= k or b:
				print('YES', n - step)
				break
			else:
				print('NO')
				break",O(logn)
"class Solution:
    def minMeetingRooms(self, intervals: List[Interval]) -> int:
        time = []
        for i in intervals:
            time.append((i.start, 1))
            time.append((i.end, -1))

        time.sort(key=lambda x: (x[0], x[1]))

        res = count = 0
        for t in time:
            count += t[1]
            res = max(res, count)
        return res
",O(nlogn)
"import sys
from collections import deque
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))

n = inp()
edges = [[] for _ in range(n)]
for _ in range(n-1):
    a,b = inpl()
    a,b = a-1,b-1
    edges[a].append(b)
    edges[b].append(a)
dist = [-1] * n
dist[0] = 0
pa = [-1] * n
se = set()
pq = []
q = deque()
q.append(0)
while q:
    now = q.popleft()
    for nx in edges[now]:
        if dist[nx] != -1:
            continue
        pa[nx] = now
        dist[nx] = dist[now] + 1
        if dist[nx] > 2:
            se.add(nx)
            pq.append((dist[nx], nx))
        q.append(nx)
pq = pq[::-1]
res = 0
ind = 0
while se:
    d,v = pq[ind]
    ind += 1
    if not v in se:
        continue
    res += 1
    pv = pa[v]
    se.discard(pv)
    for nv in edges[pv]:
        se.discard(nv)
print(res)",O(n)
"from collections import deque
n=int(input())
visited=[False for i in range(n+2)]
dp=[-1 for i in range(n+2)]
l=[[] for i in range(n+2)]
for i in range(n-1):
    a,b=map(int,input().split())
    l[a].append(b)
    l[b].append(a)
b=deque(map(int,input().split()))
b.popleft()
s=deque([1])
ans=""Yes""
visited[1]=True
while len(b)>0 and len(s)>0:
    aux=0
    for i in l[s[0]]:
        if not visited[i]:
            visited[i]=True
            dp[i]=1
            aux+=1
    for i in range(aux):
        x=b.popleft()
        if dp[x]==1:
            s.append(x)
            dp[x]=-1
        else:
            ans=""No""
            b=[]
            break
    s.popleft()
print(ans)
",O(nlogn)
"n,l,r,x = map(int,input().split())
diff = list(map(int,input().split()))

ans = 0
currSum = 0
maxim = 0
minim = 0

for i in range(2**n):

    currSum = 0
    maxim = 0
    minim = 1000001
    ptr = n-1

    while i > 0:

        if i & 1:

            currSum += diff[ptr]
            maxim = max(maxim,diff[ptr])
            minim = min(minim,diff[ptr])

        ptr -= 1
        i = i >> 1

    if currSum <= r and currSum >= l:

        if maxim - minim >= x:

            ans += 1

print(ans)
",np
"def Sort(x):
	if len(x) == 1:
		return x

	a = Sort(x[:len(x) // 2])
	b = Sort(x[len(x) // 2:])

	c = []
	i = 0
	j = 0
	while (i < len(a))and(j < len(b)):
		if a[i] < b[j]:
			c.append(a[i])
			i += 1
		else:
			c.append(b[j])
			j += 1

	c = c + b[j:]
	c = c + a[i:]

	return c

input()
m = [int(i) for i in input().split(' ')]

newm = Sort(m)
count = 0
for i in range(len(m)):
 if newm[i] != m[i]:
  count += 1

if count / 2 <= 1:
 print('YES')
else:
 print('NO')
",O(nlogn)
"n = int(input())

a = sorted(map(int, input().split()))

if not any(a):
    print('cslnb')
elif n > 2 and a[0] == a[1] == 0:
    print('cslnb')
else:
    seq_cnt = 0
    seq_sz = 1
    max_seq_sz = 1
    for i in range(n-1):
        if a[i] == a[i+1]:
            seq_sz += 1
        elif a[i] + 1 == a[i+1] and i + 2 < n and a[i+1] == a[i+2]:
            max_seq_sz = 3
            break
        else:
            max_seq_sz = max(seq_sz, max_seq_sz)
            seq_cnt += seq_sz > 1
            seq_sz = 1

    max_seq_sz = max(seq_sz, max_seq_sz)
    seq_cnt += seq_sz > 1

    if max_seq_sz > 2 or seq_cnt > 1:
        print('cslnb')
    else:
        last = to_play = 0
        for i in range(n):
            to_play += a[i] - last
            last += 1

        if to_play % 2 == 0:
            print('cslnb')
        else:
            print('sjfnb')
",O(nlogn)
"def Solve(n):
    if n <=2:
        return n
    elif n % 6== 0:
        return (n -1)*(n -2)*(n - 3)
    elif n % 2 == 0:
        return n * (n - 1) * (n - 3)
    else:
        return n * (n - 1) * (n - 2)

n = int(input())
print(Solve(n))",O(1)
"n,m=map(int,input().split())
listi=[]
for i in range(0,n):
    string=input()
    listi.append(string)
rownum=0
flag=False
for row in listi:

    for letter in row:
            if(""B"" in row):
                p=row.index(""B"")

                s=row[::-1]
                q=abs(m-s.index(""B"")-1)

                if(p==q):
                    print(rownum+1,row.index(row[p])+1)
                    flag=True
                    break
                mr=(q+p)/2

                length=abs(q-p+1)

                rn= rownum + length//2

                print(rn+1,int(mr+1))
                flag=True
                break

    if(flag==True):
        break

    rownum+=1",O(n ^ 2)
"n,k=map(int,input().split())
b=(9+8*(n+k))**0.5
a=int(b)
print(n-(a-3)//2)",O(1)
"class Solution(object):
    def minCostToMoveChips(self, chips):
        count = [0]*2
        for p in chips:
            count[p%2] += 1
        return min(count)",O(n)
"class Solution2(object):
    def longestSubarray(self, nums):
        result, count, left = 0, 0, 0
        for right in range(len(nums)):
            count += (nums[right] == 0)
            while count >= 2:
                count -= (nums[left] == 0)
                left += 1
            result = max(result, right-left+1)
        return result-1",O(n)
"n,s = input().split()

i = int(s)
d_sum = sum(list(map(int,str(i))))
while i - d_sum < int(s):
    i += 1
    d_sum = sum(list(map(int,str(i))))

print((max(0,int(n)-i+1)))
",O(logn)
"n,m,k = map(int,input().split())
right = [[9999999 for i in range(m-1)] for j in range(n)]
down =  [[9999999 for i in range(m)] for j in range(n-1)]
for i in range(n):
    right[i] = list(map(int,input().split()))
for i in range(n-1):
    down[i] = list(map(int,input().split()))

if(k%2==1):
    for i in range(n):
        for j in range(m):
            print(""-1"",end="" "")
        print()
else:
    k = k//2
    row = n
    col = m
    dp  = [[[9999999 for i in range(m)] for j in range(n)] for ii in range(k+1)]
    for steps in range(k+1):
        for i in range(row):
            for j in range(col):
                if(steps==0):
                    dp[steps][i][j] = 0
                    continue
                ans = 99999999999
                if(i>0):
                    ans = min(ans,dp[steps-1][i-1][j]+down[i-1][j])
                if(i<n-1):
                    ans = min(ans,dp[steps-1][i+1][j]+down[i][j])
                if(j<m-1):
                    ans = min(ans,dp[steps-1][i][j+1]+right[i][j])
                if(j>0):
                    ans = min(ans,dp[steps-1][i][j-1]+right[i][j-1])
                dp[steps][i][j] = ans

    for i in range(n):
        for j in range(m):
            print(2*dp[k][i][j],end="" "")
        print()
",O(n ^ 3)
"class Solution2(object):
    def cloneTree(self, root):
        def dfs(node):
            if not node:
                return None
            copy = Node(node.val)
            for child in node.children:
                copy.children.append(dfs(child))
            return copy
        
        return dfs(root)",O(n)
"n = int(input())
mod = 10**9+7
dp = [0]*(n+1)
dp[0] = 1
for i in range(n):
    nx = [0]*(n+1)
    s = str(input())
    if s == 'f':
        nx[0] = 0
        for j in range(1, n+1):
            nx[j] = dp[j-1]
            nx[j] %= mod
    else:
        nx[n] = dp[n]
        for j in reversed(range(n)):
            nx[j] = nx[j+1]
            nx[j] += dp[j]
            nx[j] %= mod
    if i != n-1:
        dp = nx
print(sum(dp)%mod)
",O(n ^ 2)
"n,k = list(map(int,input().split()))

limit = 998244353

if k > 2*n:
    print(0)
elif k == 1 or k == 2*n:
    print(2)
else:
    same = [0] * (k+1)
    same[1] = 2

    diff = [0] * (k+1)
    diff[2] = 2

    for i in range(2, n+1):
        for j in range(min(k, 2*i), 1, -1):

            same[j] = same[j] + 2*diff[j] + same[j-1]
            same[j] %= limit

            diff[j] = diff[j] + 2*same[j-1] + diff[j-2]
            diff[j] %= limit

    print((same[k] + diff[k]) % limit)",np
"import math

n, d = [int(x) for x in input().split(' ')]
pos = [int(x) for x in input().split(' ')]

count = 2

for i in range(1,n):
	if math.fabs(pos[i] - pos[i-1]) > 2*d:
		count += 2
	elif math.fabs(pos[i] - pos[i-1]) == 2*d:
		count += 1
	else:
		continue;

print(count)
",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def btreeGameWinningMove(self, root, n, x):
        def count(node, x, left_right):
            if not node:
                return 0
            left, right = count(node.left, x, left_right), count(node.right, x, left_right)
            if node.val == x:
                left_right[0], left_right[1] = left, right
            return left + right + 1

        left_right = [0, 0]
        count(root, x, left_right)
        blue = max(max(left_right), n-(sum(left_right)+1))
        return blue > n-blue",O(n)
"n = int(input())
for i in range(n):
    p = int(input())
    a = list(map(int,input().split()))
    a = sorted(a)
    if p == 2:
        print(0)
        continue
    k = a[-2] - 1
    print(min(k, p - 2))",O(nlogn)
"S = input()
best = 0
for i in range(len(S)):
    for j in range(i+1, len(S)+1):
        s = S[i:j]
        c = 0
        for k in range(len(S)):
            if S[k:].startswith(s): c += 1

        if c >= 2:
            best = max(best, len(s))
print(best)",O(n ^ 3)
"x,y,z,t1,t2,t3 = map(int, input().split())
time1 = abs(x-y)*t1
time2 = (abs(x-y)+abs(z-x))*t2+3*t3
if time2 <= time1:
    print(""YES"")
else: print(""NO"")",O(1)
"def solve(moves,candies_end):
    total_candies = 1
    low = 0
    high = moves
    while low <= high:
        mid = (low+high)//2
        if (((moves-mid)*(moves-mid+1))//2)-mid == candies_end:
            return mid
        elif (((moves-mid)*(moves-mid+1))//2)-mid < candies_end:
            high = mid-1
        else:
            low = mid+1

n,k = map(int,input().split())
print(solve(n,k))",O(logn)
"class Solution(object):
    def largestTriangleArea(self, points):
        result = 0
        for i in range(len(points)-2):
            for j in range(i+1, len(points)-1):
                for k in range(j+1, len(points)):
                    result = max(result,
                                 0.5 * abs(points[i][0] * points[j][1] +
                                           points[j][0] * points[k][1] +
                                           points[k][0] * points[i][1] -
                                           points[j][0] * points[i][1] -
                                           points[k][0] * points[j][1] -
                                           points[i][0] * points[k][1]))
        return result",O(n ^ 3)
"a = input()
b = input()
list_a = list(a)
list_a.sort()
max_a = int(''.join(list_a))
for i in range(len(a)):
    for j in range(i+1, len(a)):
        list_a[i], list_a[j] = list_a[j], list_a[i]
        temp_a = int(''.join(list_a))
        if int(b) < temp_a or temp_a <= max_a:
            list_a[i], list_a[j] = list_a[j], list_a[i]
        else:
            max_a = temp_a
print(max_a)",O(n ^ 3)
"Q = int(input())
src = [tuple(map(int,input().split())) for i in range(Q)]
ans = []
for x,y,k in src:
    d = max(x,y)
    if (x+y)%2:
        ans.append(-1 if d > k else k-1)
    else:
        if d > k:
            ans.append(-1)
        else:
            ans.append(k-2 if (d+k)%2 else k)

print(*ans,sep='\n')
",O(1)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import factorial
from collections import Counter, defaultdict
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')

def main():
    n, k = RLL()
    dp = [[0]*4 for _ in range(k+2)]
    dp[1][0] = 1
    dp[1][3] = 1
    dp[2][1] = 1
    dp[2][2] = 1
    tag = 0
    for i in range(2, n+1):
        new = [[0]*4 for _ in range(k+2)]
        for j in range(1, k+2):
            for l in range(4):
                tag+=1
                new[j][l] = ((dp[j][l])%mod + (new[j][l])%mod)%mod
                if l==0 or l==3:
                    new[j][l] = ((dp[j-1][l^3])%mod + (new[j][l])%mod)%mod
                    new[j][l] = (((dp[j][1])%mod+(dp[j][2])%mod) + (new[j][l])%mod)%mod
                elif l==1 or l==2:
                    new[j][l] = (((dp[j-1][0])%mod+(dp[j-1][3])%mod) + (new[j][l])%mod)%mod
                    if j-2>=0: new[j][l] = ((dp[j-2][l^3])%mod + (new[j][l])%mod)%mod
        dp = new
    print(sum(dp[k])%mod)

if __name__ == ""__main__"":
    main()
",np
"import sys
input = sys.stdin.readline
n = int(input().strip())
a = [int(x) for x in input().strip().split()]
dp = [[0]*n for i in range(n)]
for i in range(n):
    dp[i][i] = [a[i], 1]
for i in range(1, n):
    for j in range(n-i):
        v, c = -1, i+1
        for k in range(i):
            if dp[j][j+k][0]!=-1 and dp[j][j+k][0] == dp[j+k+1][j+i][0]:
                v,c = dp[j][j+k][0]+1, 1
                break
            else:
                v, c = -1, min(c, dp[j][j+k][1] + dp[j+k+1][j+i][1])
        dp[j][j+i] = [v, c]
print(dp[0][-1][1])
",O(n ^ 3)
"import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

n, m, k = map(int, input().split())

filters = list(map(int, input().split()))
filters.sort()

supply_filters_needed = 0
if k < m:
    spots = k
    end = n - 1
    while spots < m and end >= 0:
        spots += filters[end] - 1
        supply_filters_needed += 1
        end -= 1

    if spots < m:
        print(-1)
    else:
        print(supply_filters_needed)
else:
    print(0)",O(nlogn)
"class Solution(object):
    def averageHeightOfBuildings(self, buildings):
        points = []
        for x, y, h in buildings:
            points.append((x, 1, h))
            points.append((y, -1, h))
        points.sort()
        result = []
        total = cnt = 0
        prev = -1
        for curr, c, h in points:
            if cnt and curr != prev:
                if result and result[-1][1] == prev and result[-1][2] == total//cnt:
                    result[-1][1] = curr
                else:
                    result.append([prev, curr, total//cnt])
            total += h*c
            cnt += c
            prev = curr
        return result",O(nlogn)
"class Solution(object):
    def findMissingAndRepeatedValues(self, grid):
        n = len(grid)
        a_xor_b = 0
        for i in range(n**2):
            r, c = divmod(i, n)
            a_xor_b ^= grid[r][c]^(i+1)
        base = a_xor_b&-a_xor_b
        result = [0]*2
        for i in range(n**2):
            r, c = divmod(i, len(grid[0]))
            result[1 if (i+1)&base != 0 else 0] ^= i+1
            result[1 if grid[r][c]&base != 0 else 0] ^= grid[r][c]
        if any(x == result[1] for row in grid for x in row):
            result[0], result[1] = result[1], result[0]
        return result",O(n ^ 2)
"import sys

n, q = list(map(int,sys.stdin.readline().strip().split()))
a = list(map(int,sys.stdin.readline().strip().split()))
m = [0] * q

M = max(a)
i = 0
x = a[0]
L = []
L1 = []
L2 = []
while x != M:
    L1.append(x)
    L2.append(a[i+1])
    i = i + 1
    if x < a[i]:
        L.append(x)
        x = a[i]
    else:
        L.append(a[i])

b = a[i+1:] + L

for j in range (0, q):
    m = int(sys.stdin.readline().strip())
    if m <= i:
        print(str(L1[m-1]) + "" "" + str(L2[m-1]))
    else:
        print(str(x) + "" "" + str(b[(m - i - 1) % (n-1)]))
",O(n)
"class node:
    def __init__(self,l,r,u,d):
        self.u = u
        self.d = d
        self.l = l
        self.r = r
        if l == 20000001 and r ==20000001 and u == 20000001 and d == 20000001:
            self.marr = [20000001 for i in range(11)]
        else:
            self.marr = [0 for i in range(11)]
            self.marr[1] = min(l,r,u,d)
    def mo(self,st):
        return self.marr[st-1]

n,m,s = (int(i) for i in input().split())
hor = [[20000001 for i in range(m+3)] for j in range(n+2)]
ver = [[20000001 for i in range(m+2)] for j in range(n+3)]
for i in range(1,n+1):
    hor[i][2:1+m] = [int(i) for i in input().split()]
for i in range(2,1+n):
    ver[i][1:m+1] = [int(i) for i in input().split()]
if s%2 == 0 :
    nds = [[node(hor[i][j],hor[i][j+1],ver[i][j],ver[i+1][j]) for j in range(m+2)] for i in range(n+2)]
    for st in range(2,s//2+1):
        for i in range(1,n+1):
            for j in range(1,m+1):
                x = nds[i][j].marr[1]
                l = nds[i][j].l
                r = nds[i][j].r
                u = nds[i][j].u
                d = nds[i][j].d
                nds[i][j].marr[st] = min(x*st,r+nds[i][j+1].mo(st),l+nds[i][j-1].mo(st),u+nds[i-1][j].mo(st),d+nds[i+1][j].mo(st))
    ans = [[nds[i][j].marr[s//2]*2 for j in range(1,m+1)] for i in range(1,n+1)]
    for i in range(n):
        print(*tuple(ans[i]))
else :
    a = [[-1 for i in range(m)] for j in range(n)]
    for i in range(n):
        print(*tuple(a[i]))
",O(n ^ 3)
"N, K = map(int, input().split())
A = [int(a) for a in input().split()]
D = sorted([A[i+1]-A[i] for i in range(N-1)])
print(A[-1]-A[0]-(sum(D[-K+1:]) if K-1 else 0))
",O(nlogn)
"import sys
input = sys.stdin.readline

n = int(input())
x = list(map(int, input().split()))
x.sort()
s = set(x)
m, ans = 1, [x[0]]
pow2 = [1]
for _ in range(35):
    pow2.append(2 * pow2[-1])
for i in x:
    for j in pow2:
        if (i - j) in s and (i + j) in s:
            m = 3
            ans = [i - j, i, i + j]
            break
        elif (i - j) in s and m < 2:
            m = 2
            ans = [i, i - j]
        elif (i + j) in s and m < 2:
            m = 2
            ans = [i, i + j]
    if m == 3:
        break
print(m)
print(*ans)",O(nlogn)
"class Solution(object):
    def pivotIndex(self, nums):
        total = sum(nums)
        left_sum = 0
        for i, num in enumerate(nums):
            if left_sum == (total-left_sum-num):
                return i
            left_sum += num
        return -1",O(n)
"class Solution(object):
    def parseTernary(self, expression):
        if not expression:
            return """"

        stack = []
        for c in expression[::-1]:
            if stack and stack[-1] == '?':
                stack.pop() 
                first = stack.pop()
                stack.pop() 
                second = stack.pop()

                if c == 'T':
                    stack.append(first)
                else:
                    stack.append(second)
            else:
                stack.append(c)


        return str(stack[-1])",O(n)
"
class Solution(object):
    def targetIndices(self, nums, target):
        less = sum(x < target for x in nums)
        return list(range(less, less+sum(x == target for x in nums)))
",O(n)
"n=int(input())
a=[*map(int,input().split())]
s=[0]*n
m=n
while m:
 for i,x in enumerate(a):
  if s[i]==0:
   r=range(i%x,n,x)
   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1
   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1
print(''.join(s))",O(n ^ 2)
"class Solution(object):
    def minOperations(self, nums):
        def unique(nums):
            left = 0
            for right in range(1, len(nums)):
                if nums[left] != nums[right]:
                    left += 1
                    nums[left] = nums[right]
            return left

        def erase(nums, i):
            while len(nums) > i+1:
                nums.pop()

        n = len(nums)
        nums.sort()
        erase(nums, unique(nums))
        result = l = 0
        for i in range(len(nums)):
            if nums[i] <= nums[i-l]+n-1:
                l += 1
        return n-l",O(nlogn)
"class Solution2(object):
    def shortestPalindrome(self, s):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        if not s:
            return s

        A = s + s[::-1]
        prefix = getPrefix(A)
        i = prefix[-1]
        while i >= len(s):
            i = prefix[i]
        return s[i+1:][::-1] + s",O(n)
"n,l,r,x=map(int,input().split())
import math
z=list(map(int,input().split()))
count=0
for i in range(pow(2,len(z))):

    mini=math.inf
    maxa=0
    j=i
    inde=0
    sume=0
    while(j>0):

        if(j&1):
            sume+=z[inde]
            maxa=max(maxa,z[inde])
            mini=min(mini,z[inde])
        j=j>>1
        inde+=1

    if(maxa-mini>=x and l<=sume<=r):
        count+=1

print(count)
",np
"n=int(input())
l1=list(map(int,input().split()))
ans=0
l1.sort()
visited=[0]*n
for i in range(n):
    if visited[i]==1:
        continue
    visited[i]=1
    ans+=1
    for j in range(i+1,n):
        if visited[j]==0 and l1[j]%l1[i]==0:
            visited[j]=1
print(ans)",O(n ^ 2)
"M=10**9+7
n=int(input())
a=[]
for i in range(n):
    a.append(input())
dp=[[0]*(n+5) for i in range(n+2)]
dp[0][0]=1
for i in range(1,n):
    count=0
    if a[i-1]=='f':
        for j in range(n-2,-1,-1):
            if dp[i-1][j]>0:
                dp[i][j+1]=(dp[i][j+1]+dp[i-1][j])%M
    else:
        for j in range(n-2,-1,-1):
            if dp[i-1][j]>0:
                count=(count+dp[i-1][j])%M
            dp[i][j]=(dp[i][j]+count)%M
print(sum(dp[n-1])%M)",O(n ^ 2)
"k=int(input())
a=[]
for i in range(0,12):
    s=9*pow(10,i)*(i+1)
    if k<=s:
        break
    else:
        k-=s
pos=i+1
num=(pow(10,pos-1)+(k//pos)-1)
if k%pos==0:
    print(str(num)[-1])
else:
    print(str(num+(0 if pos==1 else 1))[(k%pos)-1])
",O(logn)
"class Solution2(object):
    def rotate(self, matrix):
        return [list(reversed(x)) for x in zip(*matrix)]",O(n ^ 2)
"import collections



class Solution(object):
    def maxSubarraySum(self, nums):
        result = float(""-inf"")
        curr = mn = mn0 = 0
        mn1 = collections.defaultdict(int)
        for x in nums:
            curr += x
            result = max(result, curr-mn)
            mn1[x] = min(mn1[x], mn0)+x
            mn0 = min(mn0, curr)
            mn = min(mn, mn1[x], mn0)
        return result",O(n)
"n,k=list(map(int,input().split()))

if k%2==0:
    s="".""
    s=s+""
    s=s+"".""*(n-len(s))
    print(""YES"")
    print("".""*n)
    print(s)
    print(s)
    print("".""*n)

else:
    if k<=n-2:
        a=""
        s="".""*((n-k)//2)+a+"".""*((n-k)//2)
        print(""YES"")
        print("".""*n)
        print(s)
        print("".""*n)
        print("".""*n)
    else:
        k=k-n+3
        a=""
        s="".""*((n-k)//2)+a+"".""*((n-k)//2)
        print(""YES"")
        print("".""*n)
        print("".""+""
        s=list(s)
        s[n//2]="".""
        s="""".join(s)
        print(s)
        print("".""*n)",O(n)
"from math import *
from cmath import *
from itertools import *
from decimal import *
from fractions import *
from sys import *

n, a, b = map(int, input().split())
s = [int(x) for x in input().split()]
s.sort()
if s[b-1] == s[b]:
    print(0)
else:
    print(s[b] - s[b-1])",O(nlogn)
"class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        seen = set()
        for num in nums:
            if num in seen:
                return num
            seen.add(num)
        return -1
",O(n)
"n,v = map(int,input().split())

if n <= v + 1:
    print( n - 1 )
else:
    b = n - v
    print( v - 1 + ((b*(b+1))//2))
",O(1)
"class Solution(object):
    def maxSizeSlices(self, slices):
        def maxSizeSlicesLinear(slices, start, end):
            dp = [[0]*(len(slices)//3+1) for _ in range(2)]
            for i in range(start, end):
                for j in reversed(range(1, min(((i-start+1)-1)//2+1, len(slices)//3)+1)):
                    dp[i%2][j] = max(dp[(i-1)%2][j], dp[(i-2)%2][j-1] + slices[i])
            return dp[(end-1)%2][len(slices)//3]
        
        return max(maxSizeSlicesLinear(slices, 0, len(slices)-1),
                   maxSizeSlicesLinear(slices, 1, len(slices)))",O(n ^ 2)
"n=int(input())
l=list(map(int,input().split()))
l.sort()
v=[False for i in range(n)]
ans=0
i=0
while i<n:
	if v[i]==False:
		ans+=1
		for j in range(i+1,n):
			if l[j]%l[i]==0:
				v[j]=True
	i+=1
print(ans)",O(n ^ 2)
"n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]

def get_ans(x):

    lim = 1<<m
    match = lim-1
    track = [-1 for i in range(lim)]

    for i in range(n):
        mask = 0
        for j in range(m):
            if(a[i][j] >= x):
                mask |= 1 << j
        track[mask] = i

    for i in range(lim):
        for j in range(lim):
            if(i|j == match and track[i] != -1 and track[j] != -1):
                return track[i], track[j]

    return -1, -1

lo = 0
hi = 1000000000
while(lo < hi-1):
    mid = (lo+hi)/2
    i, j = get_ans(mid)
    if(i == -1):
        hi = mid-1
    else:
        lo = mid

i,j = get_ans(hi)
if(i != -1):
    print(""{} {}"".format(i+1,j+1))
else:
    i,j = get_ans(lo)
    print(""{} {}"".format(i+1,j+1))
",np
"class Solution(object):
    def minimumRefill(self, plants, capacityA, capacityB):
        result = 0 
        left, right = 0, len(plants)-1
        canA, canB = capacityA, capacityB
        while left < right: 
            if canA < plants[left]:
                result += 1
                canA = capacityA
            canA -= plants[left]
            if canB < plants[right]:
                result += 1
                canB = capacityB
            canB -= plants[right]
            left, right = left+1, right-1
        if left == right:
            if max(canA, canB) < plants[left]:
                result += 1
        return result",O(n)
"class Solution(object):
    def minimumCardPickup(self, cards):
        lookup = {}
        result = float(""inf"")
        for i, x in enumerate(cards):
            if x in lookup:
                result = min(result, i-lookup[x]+1)
            lookup[x] = i
        return result if result != float(""inf"") else -1",O(n)
"from collections import defaultdict
_input = [int(num) for num in input().split("" "")]
l = _input[0]
r = _input[1]

if l != r:
    binary_r = bin(r)[2:]
    binary_l = bin(l)[2:].zfill(len(binary_r))

    max_idx_prefix = 0
    for idx, l_digit in enumerate(binary_l):
        if l_digit != binary_r[idx]:
            max_idx_prefix = idx
            break

    a_binary = [0 for num in range(len(binary_r))]
    a_binary[max_idx_prefix] = 0
    for idx in range(max_idx_prefix + 1, len(a_binary)):
        a_binary[idx] = 1

    b_binary = [0 for num in range(len(binary_r))]
    b_binary[max_idx_prefix] = 1

    a_binary = ''.join(str(digit) for digit in a_binary)
    b_binary = ''.join(str(digit) for digit in b_binary)

    a_binary = int(a_binary, 2)
    b_binary = int(b_binary, 2)

    max_xor = a_binary ^ b_binary

    print(max_xor)
else:
    print(l ^ r)
",O(logn)
"import math
k, n, s, p = map(int, input().split())
sheets = math.ceil(n/s) * k
print(math.ceil(sheets/p))
",O(1)
"class Solution(object):
    def stableMountains(self, height, threshold):
        return [i for i in range(1, len(height)) if height[i-1] > threshold]",O(n)
"import sys
input=sys.stdin.buffer.readline
n,m=map(int,input().split())
for i in range(n//2+n%2):
    x1=i+1
    x2=n-i
    if(x1==x2):
        for j in range(m//2+m%2):
            if(j+1==m-j):
                sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n""))
            else:
                sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n""))
                sys.stdout.write((str(x2)+"" ""+str(m-j)+""\n""))
    else:
        if(i%2==0):
            for j in range(m):
                sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n""))
                sys.stdout.write((str(x2)+"" ""+str(m-j)+""\n""))
        else:
            for j in range(m):
                sys.stdout.write((str(x1)+"" ""+str(m-j)+""\n""))
                sys.stdout.write((str(x2)+"" ""+str(j+1)+""\n""))",O(n ^ 2)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def sortedArrayToBST(self, nums):
        return self.sortedArrayToBSTRecu(nums, 0, len(nums))

    def sortedArrayToBSTRecu(self, nums, start, end):
        if start == end:
            return None
        mid = start + self.perfect_tree_pivot(end - start)
        node = TreeNode(nums[mid])
        node.left = self.sortedArrayToBSTRecu(nums, start, mid)
        node.right = self.sortedArrayToBSTRecu(nums, mid + 1, end)
        return node

    def perfect_tree_pivot(self, n):
        x = 1
        x = 1 << (n.bit_length() - 1) 

        if x // 2 - 1 <= (n - x):
            return x - 1 
        else:
            return n - x // 2",O(n)
"import math
def maxor(bawah, atas):
	if bawah == atas:
		return 0
	xor = bawah^atas
	pangkat2 = math.log(xor, 2)
	return 2**int(math.floor(pangkat2)+1) - 1
a=input().split()
print(maxor(int(a[0]),int(a[1])))",O(logn)
"x = list(map(int, input().split()))

start = 0
end = x[0] -1

target = x[1]

ans = 0

while start<= end:

    mid = (start+end)//2
    sum = mid*(mid+1) //2

    ans1 = x[0] - mid

    if sum - ans1 == target:
        ans = ans1
        break
    elif sum - ans1 > target:
        end = mid - 1
    else:
        start = mid+1

print(ans)
",O(logn)
"n, k = [int(e) for e in input().split()]
a = sorted([int(e) for e in input().split()])
s = set()
for i in range(n):
    if a[i] % k != 0:
        s.add(a[i])
    elif a[i] / k not in s:
        s.add(a[i])
print(len(s))",O(nlogn)
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

n,d=map(int,input().split())
x=list(map(int,input().split()))
ans=0
for i in range(1,n):
    diff=x[i]-x[i-1]

    if diff >= 2*d:
        ans+=min(2,(x[i]-d)-(x[i-1]+d)+1)

ans+=2
print(ans)",O(n)
"n,l,r,x = map(int,input().split())
a = list(map(int,input().split()))
count=0
for i in range(2**n):
    maxc=-1
    minc=-1
    c=0
    for j in range(n):
        if i>>j&1==1:
            c+=a[j]
            maxc=max(maxc,a[j])
            if minc==-1:
                minc=a[j]
            else:
                minc=min(a[j],minc)
    if c>=l and c<=r and maxc - minc >=x:
        count+=1
print(count)
",np
"from math import factorial as fact

s=input()
t=input()

pos=s.count('+')-t.count('+')
neg=s.count('-')-t.count('-')
que=t.count('?')
if pos<0 or neg<0:
    print(0)
else:
    print((fact(que)/(fact(pos)*fact(neg)))/(2**que))
",np
"import sys

input = lambda: sys.stdin.readline().rstrip()

N, M, K = map(int, input().split())
if K % 2:
    for _ in range(N):
        print(*[-1] * M)
    exit()
A = [[int(a) for a in input().split()] for _ in range(N)]
B = [[int(a) for a in input().split()] for _ in range(N - 1)]
X = [[0] * M for _ in range(N)]
inf = 1 << 30
for k in range(1, K // 2 + 1):
    nX = [[inf] * M for _ in range(N)]
    for i in range(N):
        for j in range(M):
            if i: nX[i][j] = min(nX[i][j], X[i - 1][j] + B[i - 1][j])
            if i < N - 1: nX[i][j] = min(nX[i][j], X[i + 1][j] + B[i][j])
            if j: nX[i][j] = min(nX[i][j], X[i][j - 1] + A[i][j - 1])
            if j < M - 1: nX[i][j] = min(nX[i][j], X[i][j + 1] + A[i][j])
    X = nX
for x in X:
    print(*[a * 2 for a in x])",O(n ^ 3)
"n=int(input())
w = [(int(x), c+1) for c, x in enumerate(input().split())]
b=sorted(w,reverse=True)
f=[]
p=[]
k=input()
for i in k:
    if i==""0"":
        x=b.pop()
        f.append(x)
        p.append(x[1])
    else:
        y=f.pop()
        p.append(y[1])
print(*p)
",O(nlogn)
"def main():
    n = int(input())

    arr = list(map(int, input().split()))
    numb = [0 for i in range(n + 1)]
    for i in range(len(arr)):
        numb[arr[i]] = i + 1

    brr = list(map(int, input().split()))
    ind = 0
    for c in brr:
        total = 0
        num = numb[c]
        if num > ind:
            total = num - ind
            ind = num
        print(total, end=' ')

main()",O(n)
"import collections



class Solution(object):
    def minimumOperations(self, nums):
        even_top = collections.Counter(nums[i] for i in range(0, len(nums), 2)).most_common(2) 
        odd_top = collections.Counter(nums[i] for i in range(1, len(nums), 2)).most_common(2) 
        if not odd_top or even_top[0][0] != odd_top[0][0]:
            return len(nums)-even_top[0][1]-(odd_top[0][1] if odd_top else 0)
        return min(len(nums)-even_top[0][1]-(odd_top[1][1] if len(odd_top) == 2 else 0),
                   len(nums)-odd_top[0][1]-(even_top[1][1] if len(even_top) == 2 else 0))",O(n)
"class Solution(object):
    def findPermutation(self, s):
        result = []
        for i in range(len(s)+1):
            if i == len(s) or s[i] == 'I':
                result += list(range(i+1, len(result), -1))
        return result",O(n)
"import math
from decimal import Decimal

def sum2(s, e):
    return sum1(e) - sum1(s - 1) - (e - s)

def sum1(i):
    return i * (i + 1) / 2

line = input().split()
n = Decimal(line[0])
k = Decimal(line[1])
if(n == 1):
    print(0)
elif(k > n):
    print(1)
elif(sum2(Decimal(2),k) < n):
    print(-1)
else:
    c = 2 * n + k - k * k
    discriminant = (9 - 4 * c).sqrt()
    res1 = math.floor((3 + discriminant) / 2)
    res2 = math.floor((3 - discriminant) / 2)
    res1 = max(res1, res2)
    print(int(k - res1 + 1));",O(logn)
"import decimal

n, k = input().split(' ')
n = int(n)
k = int(k)
coef1 = (k*k-k-2*n)*100+225
if coef1 < 0:
    print('-1')
else:
    D = decimal.Decimal
    coef11 = D(coef1)
    coef1 = coef11.sqrt()
    coef2 = k*10-5
    coef = (coef2-coef1)/10
    if coef % 1 == 0:
        print(int(coef))
    else:
        print(int(coef)+1)
",O(logn)
"print(""? 0 0"")
ans00 = input()
xr = 0
a = 0
b = 0
cb = 2 ** 29
while cb:
	print(""?"", xr + cb, cb)
	ans11 = input()
	print(""?"", xr, cb)
	if ans11 == ans00:
		ans01 = input()
		if ans01 == '1':
			a += cb
			b += cb
	else:
		ans00 = input()
		if ans11 == '1':
			b += cb
		else:
			a += cb
		xr += cb
	cb //= 2
print(""!"", a, b)
",O(logn)
"import sys
input = sys.stdin.readline
sys.setrecursionlimit(100000)

def getN():
    return int(input())
def getList():
    return list(map(int, input().split()))
import math

def validation(n, k, x):
    if (x*(x+1)) // 2 - (n-x) == k:
        return 0
    if (x * (x + 1)) // 2 - (n - x) > k:
        return 1
    return 2

n, k = getList()

l = 0
r = 1000000001
while(True):
    mid = (l+r)//2
    flag = validation(n, k, mid)
    if flag == 0:
        ans = mid
        break
    elif flag == 1:
        r = mid
    else:
        l = mid

print(n - ans)
",O(logn)
"input()
c = list(map(int, input().split()))
a = list(map(int, input().split()))

u = [0] * len(a)

ans = 0

for i in range(len(a)):
    if u[i] != 0:
        continue
    idx = i
    while u[idx] == 0:
        u[idx] = 1
        idx = a[idx] - 1

    if (u[idx] == 2):
        idx = i
        while u[idx] == 1:
            u[idx] = 2
            idx = a[idx] - 1
        continue

    start = idx
    mn = c[idx]
    u[idx] = 2
    while a[idx] - 1 != start:
        idx = a[idx] - 1
        mn = min(mn, c[idx])
        u[idx] = 2

    idx = i
    while u[idx] == 1:
        u[idx] = 2
        idx = a[idx] - 1
    ans += mn
print(ans)
",O(n)
"import pprint
nr, ng, nb = map(int, input().split())
*r, = map(int, input().split())
*g, = map(int, input().split())
*b, = map(int, input().split())
dp = []
for _ in range(nr + 1):
    dp.append([[0] * (nb + 1) for _ in range(ng + 1)])

r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

mx = 0
for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            if i and j:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])
            if i and k:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1])
            if j and k:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1])

mx_i = mx_j = mx_k = -1

for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            if dp[i][j][k] > mx:
                mx_i = i
                mx_j = j
                mx_k = k
                mx = dp[i][j][k]

print(mx)
",O(n ^ 3)
"n = int(input())

one_seat = []

two_seats = []

j = 1

for item in input().split():
    two_seats.append((int(item), j))
    j += 1

two_seats.sort(key=lambda x: -x[0])

for person in input():
    if person == '0':
        q = two_seats.pop()
        print(q[1], end=' ')
        one_seat.append(q)
    else:
        print(one_seat.pop()[1], end=' ')
",O(nlogn)
"x, k = map(int, input().split())

if x == 0:
    print(0)
    exit()

mod = 10 ** 9 + 7

a = ((x % mod) * pow(2, k + 1, mod)) % mod

print((a - (pow(2, k, mod) - 1)) % mod)
",O(logn)
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key=lambda x: x[1])
        n = len(intervals)
        dp = [0] * n

        for i in range(n):
            dp[i] = 1
            for j in range(i):
                if intervals[j][1] <= intervals[i][0]:
                    dp[i] = max(dp[i], 1 + dp[j])

        max_non_overlapping = max(dp)
        return n - max_non_overlapping
",O(n ^ 2)
"n,m=map(int, input().split())
out=[n]
i=n-1
m-=1
for _ in range(n-1):
    if m%2:
        out.append(i)
    else:
        out=[i]+out

    m//=2
    i-=1

for i in out:
    print(i, end="" "")
print()
",np
"class Solution5(object):
    def divisorGame(self, n):
        def factors(n):
            for i in range(1, n+1):
                if n%i:
                    continue
                yield i
    
        def memoization(n):
            if lookup[n] is None:
                lookup[n] = any(not memoization(n-i) for i in factors(n) if i != n)
            return lookup[n]

        lookup = [None]*(n+1)
        return memoization(n)",O(n ^ 2)
"class Solution(object):
    def search(self, reader, target):
        left, right = 0, 19999
        while left <= right:
            mid = left + (right-left)//2
            response = reader.get(mid)
            if response > target:
                right = mid-1
            elif response < target:
                left = mid+1
            else:
                return mid
        return -1",O(logn)
"n=int(input())
a=[*map(int,input().split())]
b=[0]*n
s=[0]*n
m=n
while m:
 for i,x in enumerate(a):
  if s[i]==0:
   r=range(i%x,n,x)
   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1
   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1
print(''.join(s))
",O(n)
"n,k=[int(i) for i in raw_input().split()]

M=10**9+7
def power(x,y):
    if y==0:
      return 1
    z=(power(x,y/2)**2)%M
    z=(z*x)%M if y%2 else z
    return z%M

z=(((2*n-1+M)%M)*power(2,k)+1)%M if n!=0 else 0
print(z)
",O(logn)
"import sys

readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
ns = lambda: readline().rstrip()
ni = lambda: int(readline().rstrip())
nm = lambda: map(int, readline().split())
nl = lambda: list(map(int, readline().split()))
prn = lambda x: print(*x, sep='\n')

def solve():
    s = list(map(lambda x: x-97, ns()))
    t = list(map(lambda x: x-97, ns()))
    n, m = len(s), len(t)
    nxt = [[n+1]*26 for _ in range(n+2)]
    for i in range(n-1, -1, -1):
        nxt[i] = nxt[i+1][:]
        nxt[i][s[i]] = i
    for b in range(m):
        t1 = t[:b]
        t2 = t[b:]
        dp = [[n+1]*(m-b+1) for _ in range(b+1)]
        dp[0][0] = 0
        for j in range(b+1):
            for k in range(m-b+1):
                if j:
                    dp[j][k] = min(dp[j][k], nxt[dp[j-1][k]][t1[j-1]] + 1)
                if k:
                    dp[j][k] = min(dp[j][k], nxt[dp[j][k-1]][t2[k-1]] + 1)

        if dp[b][m-b] <= n:
            print('YES')
            return
    print('NO')
    return

T = ni()
for _ in range(T):
    solve()
",O(n ^ 3)
"n=int(input())
L=list(map(int,input().split()))
ans=['']*n
revL=[0]*n
ans[-1]='B'
for i in range(n):
    revL[L[i]-1]=i+1
for i in range(n-2,-1,-1):
    t=revL[i]-1
    counter='B'
    for j in range(t,-1,-i-1):
        if j==t:continue
        if ans[L[j]-1]=='B':
            counter='A'
            break
    if counter!='A':
        for k in range(t,n,i+1):
            if k==t:continue
            if ans[L[k]-1]=='B':
                counter='A'
                break
    ans[i]=counter
for i in range(n):
    print(ans[L[i]-1],sep='',end='')",O(n ^ 2)
"def c(a, b, l, ans, pro):
    if l != 0:
        n = a[:]
        mx = None
        pro1 = pro
        prosh = set()
        for i in range(l):
            pro = pro1
            if a[i] == prosh:
                continue
            elif (a[i] <= b[0] and pro):
                n.pop(i)
                prosh = a[i]
                if pro == True:
                    if a[i] < b[0]:
                        pro = False
                m = c(n, b[1:], l-1, ans+str(a[i]), pro)
                n = a[:]
                if m != None:
                    if mx == None:
                        mx = int(m)
                    elif mx < int(m):
                        mx = int(m)
            elif not(pro):
                a.sort(reverse = True)
                a = list(map(str, a))
                return ans +''.join(a)
            else:
                break
        return mx
    else:
        return ans
a = input()
b = input()
l = len(a)
if len(a) != len(b):
    a = list(a)
    a.sort()
    print(''.join(a[::-1]))
else:
    a = list(map(int, a))
    b = list(map(int, b))
    a.sort()
    n = a[:]
    mx = 0
    prosh = -1
    for i in range(l):
        if a[i] == prosh:
            continue
        elif a[i] != 0 and a[i] <= b[0]:
            n.pop(i)
            prosh = a[i]
            pro = False
            if a[i] == b[0]:
                pro = True
            m = c(n, b[1:], l-1, str(a[i]), pro)
            n = a[:]
            if m != None:
                if mx < int(m):
                    mx = int(m)
        elif a[i] > b[0]:
            break
    print(mx)
",O(n ^ 3)
"import operator
from functools import reduce


class Solution(object):
    def getXORSum(self, arr1, arr2):
        return reduce(operator.xor, arr1) & reduce(operator.xor, arr2)",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict

def toposort(graph):
    res = []
    found = [0] * len(graph)
    stack = list(range(len(graph)))
    while stack:
        node = stack.pop()
        if node < 0:
            res.append(1+(~node))
        elif not found[node]:
            found[node] = 1
            stack.append(~node)
            stack.extend(graph[node])

    for node in res:
        node-=1
        if any(found[nei] for nei in graph[node]):
            print(""NO"")
            return
        found[node] = 0

    print(""YES"")
    print(*res[::-1])

n,m,k=map(int,input().split())
patterns=set()
pos=dict()

for i in range(n):
    p=input().rstrip()
    patterns.add(p)
    pos[p]=i

matches=[[] for _ in range(n)]

chk=True
for i in range(m):
    s,mt=input().rstrip().split()
    mt=int(mt)-1
    if(chk):
        chk=False
        for i in range(1<<k):
            tmp=[]
            for j in range(k):
                if(i&(1<<j)):
                    tmp.append('_')
                else:
                    tmp.append(s[j])
            tmp=''.join(tmp)
            if(tmp in patterns):
                if(mt==pos[tmp]):
                    chk=True
                else:
                    matches[mt].append(pos[tmp])

if(not chk):
    print(""NO"")
else:
    toposort(matches)
",np
"n, v = map(int, input().split())
b = 0
ans = 0
sss = 0
for i in range(1, n + 1):
    while b < v:
        if sss == n - 1:
            break
        sss += 1
        ans += i
        b += 1
    b -= 1
print(ans)",O(n ^ 2)
"import sys

def find_pair(candidate,data,m):
    ans = (-1,-1)
    binary_bit = [False for i in range(1 << m)]
    for i in data:
        bit_tmp = 0
        for j in range(len(i)):
            if i[j] >= candidate: bit_tmp |= 1 << j
        binary_bit[bit_tmp] = True

    for i in range(1 << m):
        for j in range(1 << m):
            if i | j == (( 1 << m ) - 1) and binary_bit[i] and binary_bit[j]:
                ans = i , j
                break
    return ans

def backtracking(candidate,ans,data):
    idx_i = -1 ; idx_j = -1
    for i in range(len(data)):
        bit_tmp = 0
        for j in range(len(data[i])):
            if data[i][j] >= candidate: bit_tmp |= 1 << j
        if bit_tmp == ans[0]: idx_i = i
        if bit_tmp == ans[1]: idx_j = i

    print(str(idx_i + 1) + "" "" + str(idx_j + 1))

def main():
    n , m = [int(i) for i in input().split()]
    data = [[int(i) for i in input().split()] for i in range(n)]
    a = 0 ; b = 10**9 + 7
    ans = (-1,-1)
    candidate = -1
    while a <= b:
        mid = (a + b)//2
        bin_ans = find_pair(mid,data,m)
        if bin_ans[0] != -1 and bin_ans[1] != -1:
            ans = bin_ans
            candidate = mid
            a = mid + 1
        else:
            b = mid - 1
    backtracking(candidate,ans,data)

main()",np
"class Solution(object):
    def maximumElementAfterDecrementingAndRearranging(self, arr):
        arr.sort()
        result = 1
        for i in range(1, len(arr)):
            result = min(result+1, arr[i])
        return result",O(nlogn)
"class Solution(object):
    def buildArray(self, target, n):
        result, curr = [], 1
        for t in target:
            result.extend([""Push"", ""Pop""]*(t-curr))
            result.append(""Push"")
            curr = t+1
        return result",O(n)
"class Solution(object):
    def minimalKSum(self, nums, k):
        result = k*(k+1)//2
        curr = k+1
        for x in sorted(set(nums)):
            if x < curr:
                result += curr-x
                curr += 1
        return result",O(nlogn)
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        maxP = 0
        minBuy = prices[0]

        for sell in prices:
            maxP = max(maxP, sell - minBuy)
            minBuy = min(minBuy, sell)
        return maxP
",O(n)
"from math import ceil

n=int(input())
d={1:[1],2:[1,2],3:[1,1,3]}
if n in d:
    for i in d[n]:
        print(i,end=' ')
    exit()
def f(n):
    if n in d:
        return d[n]
    odds=ceil(n/2)
    lis=[1]*odds
    even=n//2
    lis1=f(even)
    for i in range(len(lis1)):
        lis1[i]*=2
    return lis+lis1
ans=f(n)
for i in ans:
    print(i,end=' ')",O(nlogn)
"class Solution3(object):
    def numberOfPairs(self, nums1, nums2, diff):
        def merge_sort(nums, left, right, result):
            if left == right:
                return
            mid = left+(right-left)//2
            merge_sort(nums, left, mid, result)
            merge_sort(nums, mid+1, right, result)
            r = mid+1
            for l in range(left, mid+1):
                while r < right+1 and nums[l]-nums[r] > diff:
                    r += 1
                result[0] += right-r+1
            tmp = []
            l, r = left, mid+1
            while l < mid+1 or r < right+1:
                if r >= right+1 or (l < mid+1 and nums[l] <= nums[r]):
                    tmp.append(nums[l])
                    l += 1
                else:
                    tmp.append(nums[r])
                    r += 1
            nums[left:right+1] = tmp

        nums = [x-y for x, y in zip(nums1, nums2)]
        result = [0]
        merge_sort(nums, 0, len(nums)-1, result)
        return result[0]",O(nlogn)
"def pow2(n):
    j=0
    while(n%2==0):
        n//=2
        j+=1
    return j
n,q=map(int,input().split())
for j in range(q):
    u=int(input())
    s=input()
    for k in range(len(s)):
        num=pow2(u)
        if(s[k]==""R"" and num!=0):
            u=u+2**(num-1)
        elif(s[k]==""L"" and num!=0):
            u=u-2**(num-1)
        elif(s[k]==""U"" and u!=(n+1)//2):
            m1=u+2**(num)
            m2=u-2**(num)
            if(pow2(m1)==(num+1)):
                u=m1
            else:
                u=m2
    print(u)",np
"class Solution(object):
    def minimizeXor(self, num1, num2):
        def popcount(x):
            return bin(x)[2:].count('1')
        
        cnt1, cnt2 = popcount(num1), popcount(num2)
        result = num1
        cnt = abs(cnt1-cnt2)
        expect = 1 if cnt1 >= cnt2 else 0
        i = 0
        while cnt:
            if ((num1>>i)&1) == expect:
                cnt -= 1
                result ^= 1<<i
            i += 1
        return result",O(logn)
"from sys import stdin, stdout
from collections import defaultdict, Counter, deque
for _ in range(1):
    n,k=map(int, stdin.readline().split())
    li = list(map(int, stdin.readline().split()))
    dic=Counter(li)
    li=list(set(li))
    li.sort()
    n=len(li)
    for i in range(1,n):
        for j in range(i-1,-1,-1):
            if li[j]+k>=li[i] and dic[li[j]]!=0:
                dic[li[j]]=0
            else:
                break
    stdout.write(str(sum(dic.values()))+""\n"")",O(nlogn)
"n,m = map(int, input().split())

class Knight:
	def __init__(self, andis, p, c):
		self.p = int(p)
		self.c = int(c)
		self.andis = int(andis)
		self.ans = self.c

p = list(map(int, input().split()))
c = list(map(int, input().split()))
x = []
for i in range(n):
	x.append(Knight(i, p[i], c[i]))

x.sort(key=lambda x: x.p)
coins = []
for i in range(n-1):
	if len(coins) < m:
		coins.append(x[i].c)
		coins.sort()
	elif len(coins) > 0:
		if coins[0] < x[i].c:
			coins[0] = x[i].c
			coins.sort()
	x[i+1].ans += sum(coins)

x.sort(key=lambda x:x.andis)
for k in x:
	print(k.ans, end=' ')
",O(nlogn)
"class Solution3(object):
    def numberOfSubstrings(self, s):
        result, right, count = 0, 0, [0]*3
        for left, c in enumerate(s):
            while right < len(s) and not all(count):
                count[ord(s[right])-ord('a')] += 1
                right += 1
            if all(count):
                result += (len(s)-1) - (right-1) + 1
            count[ord(c)-ord('a')] -= 1
        return result",O(n)
"class Solution(object):
    def maxHeight(self, cuboids):
        for cuboid in cuboids:
            cuboid.sort()
        cuboids.append([0, 0, 0])
        cuboids.sort()
        dp = [0]*len(cuboids)
        for i in range(1, len(cuboids)):
            for j in range(i):
                if all(cuboids[j][k] <= cuboids[i][k] for k in range(3)):
                    dp[i] = max(dp[i], dp[j]+cuboids[i][2])
        return max(dp)",O(n ^ 2)
"class Solution2(object):
    def minimumTimeToInitialState(self, word, k):
        def ceil_divide(a, b):
            return (a+b-1)//b

        for i in range(k, len(word), k):
            if all(word[i+j] == word[j] for j in range(len(word)-i)):
                return i//k
        return ceil_divide(len(word), k)",O(n ^ 2)
"import math,sys,bisect,heapq,os
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate
from functools import lru_cache

pr = lambda x:    x
def input(): return sys.stdin.readline().rstrip('\r\n')

aj = lambda: list(map(int, input().split()))
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]

def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])

def solve():
    n, = aj()
    A = aj()
    if A.count(0) >= 2:
        print('cslnb')
    elif n == 1:
        if A[0]%2:
            print('sjfnb')
        else:
            print('cslnb')
    else:
        g2 = 0;flag = 1
        C = Counter(A)
        for i in C.keys():
            if C[i] >= 3:
                flag = 0
            if C[i] == 2 and C[i-1] >= 1:
                flag = 0
            if C[i] == 2:
                g2 += 1
        if g2 >= 2:
            flag = 0
        if not flag:
            print('cslnb')
        else:
            movescount = 0
            A.sort()
            for ii,i in enumerate(A):
                movescount += i - ii
            if movescount % 2 == 0:
                print('cslnb')
            else:
                print('sjfnb')

try:

    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
    from aj import *
except:
    pass

solve()",O(nlogn)
"q = int(input())
for i in range(q):
    l, r = map(int, input().split())
    if l % 2 == 0:
        count = -((r - l + 1) // 2)
    else:
        count = ((r - l + 1) // 2)
    if (r - l + 1) % 2 == 0:
        print(count)
    else:
        if r % 2 == 0:
            print(count + r)
        else:
            print(count - r)",O(1)
"import itertools
from sortedcontainers import SortedList



class Solution(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")
        def query(sl, k):
            j = sl.bisect_left((k,))
            return sl[j-1][1] if j-1 >= 0 else NEG_INF
    
        def update(sl, k, v):
            j = sl.bisect_left((k,))
            if j < len(sl) and sl[j][0] == k:
                if not (sl[j][1] < v):
                    return
                del sl[j]
            elif not (j-1 < 0 or sl[j-1][1] < v):
                return
            sl.add((k, v))
            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:
                del sl[j+1]

        result = NEG_INF
        sl1, sl2 = SortedList(), SortedList()
        for price, profit in zip(prices, profits):
            result = max(result, query(sl2, price)+profit)
            update(sl1, price, profit)
            update(sl2, price, query(sl1, price)+profit)
        return result if result != NEG_INF else -1",O(nlogn)
"n = int(input())
ans = 1
if n == 1:
    ans = 1
elif n == 2:
    ans = 2
elif n == 3:
    ans = 6
elif n%2 == 0:
    if n%3 == 0:
        ans = (n-1)*(n-2)*(n-3)
    else:
        ans = n*(n-1)*(n-3)
else:
    ans = n*(n-1)*(n-2)

print(ans)",O(1)
"n,s=map(int,input().split())
count=0
for i in range(n):
    count+=(s//(n-i))
    s-=(s//(n-i))*(n-i)
print(count)
",O(1)
"import re
import sys
exit=sys.exit
from bisect import bisect_left as bsl,bisect_right as bsr
from collections import Counter,defaultdict as ddict,deque
from functools import lru_cache
cache=lru_cache(None)
from heapq import *
from itertools import *
from math import inf
from pprint import pprint as pp
enum=enumerate
ri=lambda:int(rln())
ris=lambda:list(map(int,rfs()))
rln=sys.stdin.readline
rl=lambda:rln().rstrip('\n')
rfs=lambda:rln().split()
mod=1000000007
d4=[(0,-1),(1,0),(0,1),(-1,0)]
d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]

m,n=ris()
m,n=m+2,n+2
grid =['.'*n]
grid+=['.'+rl()+'.' for _ in range(m-2)]
grid+=['.'*n]

up=[[0]*n for _ in range(m)]
dw=[[0]*n for _ in range(m)]
lf=[[0]*n for _ in range(m)]
rg=[[0]*n for _ in range(m)]
rs=[[0]*n for _ in range(m)]
cs=[[0]*n for _ in range(m)]

for i in range(1,m-1):
  for j in range(1,n-1):
    if grid[i][j]=='*':
      up[i][j]=1+up[i-1][j]
      lf[i][j]=1+lf[i][j-1]
for i in range(m-1,0,-1):
  for j in range(n-1,0,-1):
    if grid[i][j]=='*':
      dw[i][j]=1+dw[i+1][j]
      rg[i][j]=1+rg[i][j+1]

ans=[]
for i in range(1,m-1):
  for j in range(1,n-1):
    if grid[i][j]=='.':
      continue
    s=min(up[i-1][j],dw[i+1][j],lf[i][j-1],rg[i][j+1])
    if s==0:
      continue
    ans.append((i,j,s))
    rs[i-s][j]+=1
    rs[i+s+1][j]-=1
    cs[i][j-s]+=1
    cs[i][j+s+1]-=1

for i in range(1,m-1):
  for j in range(1,n-1):
    rs[i][j]+=rs[i-1][j]
    cs[i][j]+=cs[i][j-1]

for i in range(1,m-1):
  for j in range(1,n-1):
    if grid[i][j]=='.':
      continue
    if rs[i][j]==0 and cs[i][j]==0:
      print(-1)
      exit()

print(len(ans))
for i,j,s in ans:
  print(i,j,s)
",O(n ^ 2)
"from collections import defaultdict
n=int(input())
a=list(map(int, input().split()))

d=defaultdict(int)
cnt=0

for i in range(n):
    d[a[i]]+=1

for i in range(n):
    f=0
    for j in range(1,31):
        p=2**j-a[i]
        if p<=0:
            continue
        if p!=a[i]:
            if d[p]>=1:
                f=1
        else:
            if d[p]>=2:
                f=1
    if not f:
        cnt+=1
print(cnt)
",O(nlogn)
"class Solution(object):
    def minInsertions(self, s):
        add, bal = 0, 0
        for c in s:
            if c == '(':
                if bal > 0 and bal%2:
                    add += 1
                    bal -= 1
                bal += 2
            else:
                bal -= 1
                if bal < 0:
                    add += 1
                    bal += 2
        return add + bal",O(n)
"class Solution(object):
    def computeArea(self, A, B, C, D, E, F, G, H):
        return (D - B) * (C - A) + \
               (G - E) * (H - F) - \
               max(0, (min(C, G) - max(A, E))) * \
               max(0, (min(D, H) - max(B, F)))",O(1)
"n = int(input())

nums = list(map(int, input().split()))
costs = list(map(int, input().split()))

k = -1

for i in range(n):

    kc = -1
    for c in range(i + 1, n):
        if nums[i] < nums[c] and (kc == -1 or kc > costs[c]):
            if kc == -1:
                kc = costs[c]
            kc = costs[c]

    if kc > -1:
        nat = kc
        kc = -1
        for c in range(i):
            if nums[i] > nums[c] and (kc == -1 or kc > costs[c]):
                if kc == -1:
                    kc = costs[c]

                kc = costs[c]

        if kc > -1:
            if k == -1:
                k = nat + kc + costs[i]
            k = min(nat + kc + costs[i], k)

print(k)
",O(n ^ 2)
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        res = 0
        prevEnd = intervals[0][1]

        for start, end in intervals[1:]:
            if start >= prevEnd:
                prevEnd = end
            else:
                res += 1
                prevEnd = min(end, prevEnd)
        return res
",O(nlogn)
"import sys;
def transform(c):
	if c == '.': return 0;
	if c == '
	return 2;

def take_care(board,n,m):
	if n + 2 >= N:
		return;
	if m + 2 >= M:
		return;
	if board[n][m+1] == 0 or board[n][m+2] == 0 or board[n+1][m] == 0 or board[n+1][m+2] == 0 or board[n+2][m] == 0 or board[n+2][m+1] == 0 or board[n+2][m+2] == 0:
		return;
	board[n][m] = 2
	board[n][m+1] = 2
	board[n][m+2] = 2
	board[n+1][m] = 2
	board[n+1][m+2] = 2
	board[n+2][m] = 2
	board[n+2][m+1] = 2
	board[n+2][m+2] = 2
	return False,board;

N,M = [int(i) for i in input().strip().split()];
board = [];
for n in range(N):
	row = input().strip();
	row = [ transform(c) for c in row];
	board.append(row);

for n in range(N):
	for m in range(M):
		take_care(board,n,m);
for row in board:
	if 1 in row:
		print('NO');
		sys.exit();
print('YES');
",O(n ^ 2)
"import itertools




class SegmentTree2(object):
    def __init__(self, N,
                 build_fn=lambda _: float(""inf""),
                 query_fn=lambda x, y: y if x is None else x if y is None else min(x, y),
                 update_fn=lambda x: x):
        self.tree = [None]*(2*2**((N-1).bit_length()))
        self.base = len(self.tree)//2
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in range(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(range(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

    def update(self, i, h):
        x = self.base+i
        self.tree[x] = self.update_fn(h)
        while x > 1:
            x //= 2
            self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

    def query(self, L, R):
        if L > R:
            return None
        L += self.base
        R += self.base
        left = right = None
        while L <= R:
            if L & 1:
                left = self.query_fn(left, self.tree[L])
                L += 1
            if R & 1 == 0:
                right = self.query_fn(self.tree[R], right)
                R -= 1
            L //= 2
            R //= 2
        return self.query_fn(left, right)



class Solution2(object):
    def longestRepeating(self, s, queryCharacters, queryIndices):
        LEFT, RIGHT, LEFT_LEN, RIGHT_LEN, LEN, MAX_LEN, SIZE = range(7)
        def build(i):
            return update(s[i])

        def update(y):
            result = [0]*SIZE
            result[LEN] = result[LEFT_LEN] = result[RIGHT_LEN] = result[MAX_LEN] = 1
            result[LEFT] = result[RIGHT] = y
            return result

        def query(x, y):
            return y if x is None else x if y is None else \
                   [x[LEFT],
                    y[RIGHT],
                    x[LEFT_LEN]+(y[LEFT_LEN] if x[LEFT_LEN] == x[LEN] and x[RIGHT] == y[LEFT] else 0),
                    y[RIGHT_LEN]+(x[RIGHT_LEN] if y[RIGHT_LEN] == y[LEN] and y[LEFT] == x[RIGHT] else 0),
                    x[LEN]+y[LEN],
                    max(x[MAX_LEN], y[MAX_LEN], x[RIGHT_LEN]+y[LEFT_LEN] if x[RIGHT] == y[LEFT] else 0)]
        
        result = []
        st = SegmentTree2(len(s), build_fn=build, query_fn=query, update_fn=update)
        for c, i in zip(queryCharacters, queryIndices):
            st.update(i, c)
            result.append(st.query(0, len(s)-1)[MAX_LEN])
        return result",O(nlogn)
"n = int(input())
l = list( map( int, input().split() ) )
ans = max(l)
for i in range(n):
    ans = min( ans, l[ i ] // max( i, n - i - 1 ))
print( ans )",O(n)
"class Solution(object):
    def maximumANDSum(self, nums, numSlots):
        def hungarian(a): 
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in range(1, n):
                p[0] = i
                j0 = 0 
                dist, pre = [float(""inf"")]*m, [-1]*m
                done = [False]*(m+1)
                while True: 
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float(""inf"")
                    for j in range(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur < dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] < delta:
                            delta, j1 = dist[j], j
                    for j in range(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0: 
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in range(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans 
    
        return -hungarian([[-((nums[i] if i < len(nums) else 0) & (1+x//2)) for x in range(2*numSlots)] for i in range(2*numSlots)])[0]",O(n ^ 3)
"n,s=map(int,input().split())
lo,hi=s,n
ans=n+1
while lo<=hi:
    mid=(lo+hi)//2
    z=sum(map(int,str(mid)))
    if mid>=s+z:
        ans=mid
        hi=mid-1
    else:
        lo=mid+1
print(n-ans+1)",O(logn)
"class Solution(object):
    def minimumRightShifts(self, nums):
        i = next((i for i in range(len(nums)) if not nums[i] < nums[(i+1)%len(nums)]), len(nums))
        j = next((j for j in range(i+1, len(nums)) if not nums[j%len(nums)] < nums[(j+1)%len(nums)]), len(nums))
        return len(nums)-(i+1) if j == len(nums) else -1",O(n)
"def good(max_branch, s, n):
    nodes = 0
    can = 1
    lowest_s = 0
    depth = 1
    while(nodes < n):
        added = min(n - nodes, can)
        lowest_s += added * depth
        nodes += added
        can *= max_branch
        depth += 1
    return lowest_s <= s

n, s = map(int, input().split())

if s < 2 * n - 1 or s * 2 > n * (n + 1):
    print('No')
else:
    lo, hi = 1, n
    while lo < hi:
        mid = (lo + hi) >> 1
        if good(mid, s, n) == False:
            lo = mid + 1
        else:
            hi = mid

    max_branch = lo

    level_size = [1] * (n + 1)
    node_level = [i for i in range(n + 1)]
    cur_node = n
    cur_level = 1
    cur_sum = n * (n + 1) // 2
    can = 1
    while cur_sum > s:
        if level_size[cur_level] == can:
            cur_level += 1
            can *= max_branch

        if cur_sum - (cur_node - cur_level) < s:
            cur_level = cur_node - (cur_sum - s)

        node_level[cur_node] = cur_level
        level_size[cur_level] += 1
        cur_sum -= cur_node - cur_level
        cur_node -= 1

    node_list = [[] for _ in range(n + 1)]
    for i in range(1, n + 1):
        node_list[node_level[i]].append(i)

    pre = 0
    children = [0] * (n + 1)
    parent = [-1] * (n + 1)
    seen_nodes = 1
    for level in range(2, n + 1):
        idx = 0
        if not node_list[level - 1]:
            assert seen_nodes == n
            break
        cur_father = node_list[level - 1][0]
        for node in node_list[level]:
            if children[cur_father] == max_branch:
                idx += 1
                cur_father = node_list[level - 1][idx]
            children[cur_father] += 1
            parent[node] = cur_father
            seen_nodes += 1

    print('Yes')
    print(*parent[2:])
",O(n)
"from sys import stdin,stdout
n,q=map(int,input().split())
mod=1000000007
o=[]
s=[]
r=m=0
a=input()
for i in a:
    if i=='0':
        r+=1
    else:
        m+=1
    o.append(r)
    s.append(m)
z=[1]

for i in range(100000):
    z.append((z[-1]*2)%mod)
for j in range(q):
    l,r=(int(j) for j in stdin.readline().split())
    m=r-l+1
    zs=o[r-1]-o[l-1]+(a[l-1]=='0')
    os=m-zs

    if zs!=0:
        print((((z[os]-1)%mod)*((z[zs])%mod))%mod)
    else:
        print(((z[os]-1)%mod))
",O(n)
"n=int(input())
if(n==0):
    print(0)
elif(n%2!=0):
    print((n+1)//2)
else:
    print(n+1)
",O(1)
"from sys import stdin, stdout
import math
N = int(input())

arr = [int(x) for x in stdin.readline().split()]

if sum(arr)==0:
    print('cslnb')
    quit()

arr.sort()
zeros = 0
freq = {}
dup = 0
res = 0

for i in range(N):
    num = arr[i]
    if num==0:
        zeros += 1
        if zeros==2:
            print('cslnb')
            quit()

    if num not in freq:
        freq[num] = 1
    else:
        dup += 1
        freq[num] += 1

    if dup==2:
        print('cslnb')
        quit()

for i in range(N):
    num = arr[i]
    if freq[num]==2:
        if (num-1) not in freq:
            freq[num-1] = 1
            freq[num] = 1
            arr[i] = arr[i] - 1
            res += 1
            break
        else:
            print('cslnb')
            quit()

minus = [0]*N

level = 0
for i in range(N):
    minus[i] = min(arr[i],level)
    if arr[i]>=level:
        level += 1

for i in range(N):
    res += arr[i] - minus[i]

if res%2==0:
    print('cslnb')
else:
    print('sjfnb')
",O(nlogn)
"a,b= map(int, input().split())

c=2*(a-1)-b*(b-1)
if c > 0:
    print(-1)
else:
    d = int((1 + (1 - 4 * c) ** 0.5) / 2)
    if d * (d - 1) + c > 0:
        d -= 1

    print(b -d)",O(logn)
"import collections



class Solution2(object):
    def minimumAddedInteger(self, nums1, nums2):
        def check(cnt2, cnt1):
            return all(cnt1.get(k, 0)-v >= 0 for k, v in cnt2.items()) 
        
        def topk(a, k): 
            result = [float(""-inf"")]*k
            for x in a:
                for i in range(len(result)):
                    if x > result[i]:
                        result[i], x = x, result[i]
            return result
    
        mx = max(nums2)
        cnt2 = collections.Counter(nums2)
        return next(d for d in [mx-x for x in topk(nums1, 3)] if check(cnt2, collections.Counter(x+d for x in nums1)))",O(n)
"import os, sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
from math import ceil
mod = 10 ** 9 + 7

def get_original_pieces(x):
    common = (pow(x, 2) - 1) // 2
    first_piece = ""10""*common + '1'
    second_piece = '0' + ""10""*common
    return [first_piece, second_piece]

for _ in range(1):
    n = int(input())
    pieces = ["""" for _ in range(4)]
    original_pieces = get_original_pieces(n)
    i = 0
    for _ in range(3 + (n*4)):
        s = input()
        if s:
            pieces[i] += s
        else:
            i += 1

    till = pow(n, 2)
    fp = [[0,i] for i in range(4)]
    sp = [[0,i] for i in range(4)]
    for i in range(4):
        fpc, spc = 0, 0
        for j in range(till):
            if pieces[i][j] != original_pieces[0][j]:
                fpc += 1
            if pieces[i][j] != original_pieces[1][j]:
                spc += 1
        fp[i][0] = fpc
        sp[i][0] = spc
    fp.sort()
    sp.sort()
    ans1 = fp[0][0] + fp[1][0]
    ans2 = sp[0][0] + sp[1][0]
    for i in range(4):
        if sp[i][1] not in [fp[0][1], fp[1][1]]: ans1 += sp[i][0]
        if fp[i][1] not in [sp[0][1], sp[1][1]]: ans2 += fp[i][0]
    ans = min(ans1, ans2)
    print(ans)",O(n ^ 2)
"class Solution(object):
    def validMountainArray(self, A):
        i = 0
        while i+1 < len(A) and A[i] < A[i+1]:
            i += 1
        j = len(A)-1
        while j-1 >= 0 and A[j-1] > A[j]:
            j -= 1
        return 0 < i == j < len(A)-1",O(n)
"import bisect



class Solution2(object):
    def maximumBeauty(self, flowers, newFlowers, target, full, partial):
        flowers.sort()
        n = bisect.bisect_left(flowers, target)
        prefix = [0]*(n+1)
        for i in range(n):
            prefix[i+1] = prefix[i]+flowers[i]
        result = suffix = 0
        left = n
        for right in reversed(range(n+1)):
            if right != n:
                suffix += flowers[right]
            total = newFlowers-((n-right)*target-suffix)
            if total < 0:
                continue
            left = min(left, right)
            while not (left == 0 or (prefix[left]-prefix[left-1])*left-prefix[left] <= total):
                left -= 1
            mn = min((total+prefix[left])//left if left else 0, target-1)
            result = max(result, mn*partial+(len(flowers)-right)*full)
        return result",O(nlogn)
"from os import path;import sys,time
mod = int(1e9 + 7)
from math import ceil, floor,gcd,log,log2 ,factorial,sqrt
from collections import defaultdict ,Counter , OrderedDict , deque;from itertools import combinations,permutations
from string import ascii_lowercase ,ascii_uppercase
from bisect import *;from functools import reduce;from operator import mul;maxx = float('inf')
I = lambda :int(sys.stdin.buffer.readline())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().strip('\n')
grid = lambda  r :[lint() for i in range(r)]
localsys = 0
start_time = time.time()

nCr = lambda n, r: reduce(mul, range(n - r + 1, n + 1), 1) // factorial(r)
def ceill(n,x):
    return (n+x -1 )//x
T =0

def solve():
	arr = list(map(int , S()))
	s , cnt , ans = 0 , 0 ,0
	for i in arr:
		s , cnt = s + i , cnt + 1
		if i % 3 ==0 or cnt % 3 ==0 or s % 3 ==0:
			s , cnt,ans  =0 , 0 , ans + 1
	print(ans)

def run():
    if (path.exists('input.txt')):
        sys.stdin=open('input.txt','r')
        sys.stdout=open('output.txt','w')

run()
T = I() if T else 1
for _ in range(T):
    solve()

if localsys:
    print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")
",O(n)
"class Solution(object):
    def orArray(self, nums):
        return [nums[i]|nums[i+1] for i in range(len(nums)-1)]",O(n)
"import sys
from collections import deque
import bisect
def chk(l,r,total):
    b = len(l)
    prev = 0
    i = 0
    f = 1
    cnt = 0
    while i < b:
        prev = prev+l[i]
        if cnt == total and prev == r:
            i = i+1
            continue

        if prev == r:
            cnt += 1
            if cnt != total:
                prev = 0

        i = i+1

    if cnt < total or i != b:
        f = 0

    return f

for _ in range(1):
    n = int(input())
    s = input()
    l = []
    som = 0
    for i in s:
        l.append(int(i))
        som += int(i)

    flag = 0
    for i in range(2,n+1):
        if som%i == 0:
            r = som//i
            if chk(l,r,i):
                flag = 1
                break

        if flag:
            break

    if flag:
        print(""YES"")

    else:
        print(""NO"")
",O(n ^ 2)
"from collections import deque
from collections import OrderedDict
import math

import sys
import os
import threading
import bisect

import operator

import heapq

from atexit import register
from io import BytesIO

import io

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

r,g,b = map(int, input().split())
a = []
for i in range(3):
    a.append([int(x) for x in input().split()])
    a[i].sort(reverse=True)

dp = [[[0 for i in range(205)] for j in range(205)] for k in range(205)]
answer = 0

for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i<r and j<g:
                dp[i+1][j+1][k]=max(dp[i+1][j+1][k], dp[i][j][k]+a[0][i]*a[1][j])
            if i<r and k<b:
                dp[i+1][j][k+1]=max(dp[i+1][j][k+1], dp[i][j][k]+a[0][i]*a[2][k])
            if j<g and k<b:
                dp[i][j+1][k+1]=max(dp[i][j+1][k+1], dp[i][j][k]+a[1][j]*a[2][k])
            answer=max(answer, dp[i][j][k])
print(answer)

sys.exit(0)

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

p1 = Person(""heelo"", 27)

print(help(Person))

age = 26
name = 'Swaroop'
print(' {} -- {} '.format(name, age))
print(help(object))
",O(n ^ 3)
"l,r=map(int,input().split())
for i in range(61)[::-1]:
  if (l>>i)&1!=(r>>i)&1:
    print((1<<(i+1))-1)
    exit()
print(0)",O(logn)
"ii=lambda:int(input())
kk=lambda:map(int, input().split())
ll=lambda:list(kk())

from math import log
l,r=kk()
i=msb = int(max(log(l,2),log(r,2)))
while ((2**i)&l) == ((2**i)&r):
	i-=1
	if i == -1:
		break
i+=1
print(2**i-1)",O(logn)
"

class Solution(object):
    def maximumBags(self, capacity, rocks, additionalRocks):
        for i in range(len(capacity)):
            capacity[i] -= rocks[i]
        capacity.sort()
        for i, c in enumerate(capacity):
            if c > additionalRocks:
                return i
            additionalRocks -= c
        return len(capacity)
",O(nlogn)
"n = int(input())

parts = []
for i in range(4):
    part = []
    for _i in range(n):
        part.append([int(x) for x in input()])
    parts.append(part)

    if i < 3:input()

processed_parts = []
for part in parts:
    dt1 = 0
    exp = 1

    for h in range(n):
        for w in range(n):
            if part[h][w] != exp:
                dt1 += 1
            exp = (exp+1) % 2

    dt2 = 0
    for h in range(n):
        for w in range(n):
            if part[h][w] != exp:
                dt2 += 1
            exp = (exp+1) % 2

    processed_parts.append([dt1, dt2])

ans = n*n*4

for i in range(3):
    for j in range(i+1, 4):
        a = 0
        for k, part in enumerate(processed_parts):
            if k == i or k == j:
                a += part[0]
            else:
                a += part[1]
        ans = min(ans, a)

print(ans)",O(n ^ 2)
"import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return map(int, minp().split())

n,m = mints()
a = list(mints())
b = list(mints())
l = [None]*(n+m)
r = [None]*(n+m)
c = [0]*(n+m)
x = None
for i in range(len(a)):
	l[i] = x
	if b[i] == 1:
		x = i
x = None
for i in range(len(a)-1,-1,-1):
	r[i] = x
	if b[i] == 1:
		x = i
for i in range(len(a)):
	if b[i] == 0:
		aa = a[i]
		ll = l[i]
		rr = r[i]
		if ll == None:
			if rr != None:
				c[rr] += 1
		elif rr == None:
			c[ll] += 1
		else:
			if aa-a[ll] <= a[rr]-aa:
				c[ll] += 1
			else:
				c[rr] += 1

for i in range(len(a)):
	if b[i] == 1:
		print(c[i], end=' ')
",O(n)
"s = input()
if int(s) < 0:
    k = int(s)/10
    m = s[:len(s)-2]+s[-1]
    print(max(int(k),int(m)))

else:
    print(s)",O(1)
"class Solution(object):
    def longestPath(self, parent, s):
        def topological_sort(s, adj, in_degree):
            result = 1
            top2 = collections.defaultdict(lambda:[0]*2)
            q =  [(i, 1) for i, d in enumerate(in_degree) if not d]
            while q:
                new_q = []
                for (u, l) in q:
                    for v in adj[u]:
                        if s[v] != s[u]:
                            if l > top2[v][0]:
                                top2[v][0], top2[v][1] = l, top2[v][0]
                            elif l > top2[v][1]:
                                top2[v][1] = l
                        in_degree[v] -= 1
                        if in_degree[v]:
                            continue
                        new_q.append((v, top2[v][0]+1))
                        result = max(result, top2[v][0]+top2[v][1]+1)
                        del top2[v]
                q = new_q
            return result

        adj = [[] for _ in range(len(s))]
        in_degree = [0]*len(s)
        for i in range(1, len(parent)):
            adj[i].append(parent[i])
            in_degree[parent[i]] += 1
        return topological_sort(s, adj, in_degree)",O(n)
"m=1000000007
def power(x, y, p=1000000007):
    res = 1
    x = x % p
    while (y > 0) :
        if ((y & 1) == 1) :
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res
x,k=list(map(int,input().split()))
if(x==0):
    print(0)
elif(k==0):
    print((x*2)%m)
else:
    temp=power(2,k)
    maxi=(((x*temp)%m)*2)%m
    mini=(m+maxi-(2*(temp-1))%m)%m
    print((((maxi+mini)%m)*500000004)%m)",O(logn)
"x, k = map(int, input().split())
ans = 0
md = 1000000007

def bpow(base, exp, md):
    if (exp == 0):
        return 1
    if (exp % 2 == 1):
        return (base * bpow(base, exp-1, md)) % md
    else:
        k = bpow(base, exp//2, md)
        return (k*k) % md

pw = bpow(2, k, md)
ans = (2 * pw * x) % md
if (x != 0):
    ans -= pw-1
ans = (ans + md) % md
print(ans)",O(logn)
"[l,r]=list(map(int,input().split()))

if l==r:
    print(0)
else:
    a=bin(l)
    b=bin(r)
    a=list(a[2:])
    b=list(b[2:])
    d=0
    if len(a)!=len(b):
        d=len(b)-len(a)
        acta=['0']*d
        for j in a:
            acta.append(j)
        a=acta
    flag=0
    sol=len(b)
    pos=-1
    for i in range(len(b)-1,-1,-1):
        if a[i]!=b[i]:
            pos=sol-i
    if pos!=-1:
        sol=pos

    print((2**sol)-1)",O(logn)
"def totaller(i):
    if i==0:
        return 0
    else:
        total1=totaller(i-1)+ 9*(10**(i-1))*i
        return total1

no_of_digits=int(input())
j=0
for i in range(1,13):
    if no_of_digits>=totaller(i):
        j=i
kth_digit=(no_of_digits-totaller(j))//(j+1)
if(((no_of_digits-totaller(j))%(j+1))!=0):
    answer=str(kth_digit+10**j)

    print(answer[((no_of_digits-totaller(j))%(j+1))-1])
else:
    answer=str(kth_digit+10**j-1)
    print(answer[((no_of_digits-totaller(j))%(j+1))-1])
",O(logn)
"import sys
import math
import collections
import heapq
input=sys.stdin.readline
k1,k2,k3=(int(i) for i in input().split())
l=[k1,k2,k3]
if(1 in l):
    print(""YES"")
elif(l.count(2)>=2):
    print(""YES"")
elif(l.count(3)==3):
    print(""YES"")
elif(sorted(l)==[2,4,4]):
    print(""YES"")
else:
    print(""NO"")",O(1)
"n, k = map(int, input().split())
l = list(map(int, input().split()))
cost = l[n - 1] - l[0]
if k == 1:
	print(cost)
else:
	diff = [0 for _ in range(n - 1)]
	for i in range(n - 1):
		diff[i] = l[i + 1] - l[i]

	diff = sorted(diff)
	diff.reverse()
	print(cost - sum(diff[:k - 1]))",O(nlogn)
"def popcount(i):
    assert 0 <= i < 0x100000000
    i = i - ((i >> 1) & 0x55555555)
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333)
    return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24

N, T = map(int, input().split())
TG = [list(map(int, input().split())) for _ in range(N)]
mod = 10**9+7

dp = [[0]*(2**N) for _ in range(4)]
for i in range(1, 4):
    dp[i][0] = 1

for S in range(2**N):
    if popcount(S) == 1:
        dp[TG[(S&(-S)).bit_length() - 1][1]][S] = 1
    for i in range(1, 4):
        for j in range(N):
            if S & (2**j) or i == TG[j][1]:
                continue
            dp[TG[j][1]][S|(2**j)] = (dp[TG[j][1]][S|(2**j)] + dp[i][S]) % mod

table = [0]*(2**N)
for S in range(2**N):
    table[S] = sum(TG[j][0] for j in range(N) if 2**j & S)

ans = 0
for S in range(2**N):
    if table[S] == T:
        for i in range(1, 4):
            ans = (ans + dp[i][S]) % mod

print(ans)",np
"n=int(input())-1
print(2*n*(n+1)+1)
",O(1)
"n, m = list(map(int, input().split()))
cl = []
for i in range(n):
  cl.append(input())

def is_squad(x, y):
  if cl[x][y]=='
    return True
  else:
    return False

def cv(x, y):
  counter = 0
  if x-2>=0 and y+2<=m-1 and is_squad(x-2, y):
    return True

  elif x-1>=0 and x+1<=n-1 and y+2<=m-1 and is_squad(x-1, y):
    return True

  elif x+2<=n-1 and y+2<=m-1 and is_squad(x, y):
    return True

  elif x+2<=n-1 and y+1<=m-1 and y-1>=0 and is_squad(x, y-1):
    return True

  elif x+2<=n-1 and y-2>=0 and is_squad(x, y-2):
    return True

  elif x+1<=n-1 and x-1>=0 and y-2>=0 and is_squad(x-1, y-2):
    return True

  elif x-2>=0 and y-2>=0 and is_squad(x-2, y-2):
    return True

  elif x-2>=0 and y-1>=0 and y+1<=m-1 and is_squad(x-2, y-1):
    return True
  else:
    return False

for i in range(n):
  for j in range(m):
    if cl[i][j]=='
      if not cv(i, j):
        print('NO')
        exit()

print('YES')",O(n ^ 2)
"def problem(s, p):
    n = len(s)
    F = [[n] * 26 for _ in range(n + 2)]
    for i in range(n - 1, -1, -1):
        F[i][:] = F[i + 1]
        F[i][ord(s[i]) - 97] = i

    def interleaving(l, r):
        dp = [-1] + [n] * len(r)

        for j in range(1, len(r) + 1):
            dp[j] = F[dp[j - 1] + 1][ord(r[j - 1]) - 97]

        for i in range(1, len(l) + 1):
            dp[0] = F[dp[0] + 1][ord(l[i - 1]) - 97]

            for j in range(1, len(r) + 1):
                a = F[dp[j] + 1][ord(l[i - 1]) - 97]
                b = F[dp[j - 1] + 1][ord(r[j - 1]) - 97]
                dp[j] = min(a, b)

        return dp[-1] < n

    for i in range(len(p)):
        if interleaving(p[:i], p[i:]):
            return 'YES'
    return 'NO'

for _ in range(int(input())):
    print(problem(input(), input()))
",O(n ^ 3)
"import sys
import string
from math import gcd
import getpass
import math
from decimal import Decimal
import pprint

def ria():
    return [int(i) for i in input().split()]

if getpass.getuser() != 'frohenk':
    filename = 'half'

else:
    sys.stdin = open('input.txt')

n = ria()[0]
x, y = ria()
d1 = abs(1 - x) + abs(1 - y)
d2 = abs(n - x) + abs(n - y)
if d1<=d2:
    print('White')
else:
    print('Black')",O(1)
"from math import ceil
def paper(a,b,c,d):
    return ceil((a*(ceil(b/c)))/d)

a,b,c,d=map(int,input().strip().split())
print(paper(a,b,c,d))",O(1)
"n,m=[int(x) for x in input().split()]
s=[]
for i in range(n):
    s.append(input())
mapp=[[False]*m for i in range(n)]

rnd=((-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1))

def gene(x,y,p):
    cx=x-rnd[p][0]
    cy=y-rnd[p][1]
    ans=[]
    for i in range(8):
        ans.append((cx+rnd[i][0],cy+rnd[i][1]))
    return ans
def judge(ps):
    for x,y in ps:
        if x>=0 and x<n and y>=0 and y<m and s[x][y]=='
            continue
        else:
            return False
    return True
def dye(ps):
    global mapp
    for x,y in ps:
        mapp[x][y]=True
def check(x,y):
    for i in range(8):
        r=gene(x,y,i)
        if judge(r):
            dye(r)
            return True
    return False
for i in range(n):
    for j in range(m):
        if s[i][j]=='
            if check(i,j):
                continue
            else:
                print('NO')
                quit()
print('YES')",O(n ^ 2)
"line = input().split()
l = int(line[0])
r = int(line[1])

diff = (r ^ l)
print(pow(2, diff.bit_length()) - 1)
",O(logn)
"from random import randint
for _ in range(int(input())):
    n, m = map(int, input().split())
    A = [list(map(int, input().split())) for _ in range(n)]
    ans = 0
    for _ in range(100):
        for j in range(m):
            x = randint(0, n - 1)
            if x:
                B = []
                for i in range(n):
                    B.append(A[i][j])
                B = B[x:] + B[:x]
                for i in range(n):
                    A[i][j] = B[i]
        c = 0
        for i in range(n):
            c += max(A[i])
        ans = max(ans, c)
    print(ans)",np
"class Solution(object):
    def minimumFuelCost(self, roads, seats):
        def ceil_divide(a, b):
            return (a+b-1)//b
    
        def dfs(u, p, d):
            cnt = 1+sum(dfs(v, u, d+1) for v in adj[u] if v != p)
            if d:
                result[0] += ceil_divide(cnt, seats)
            return cnt
    
        adj = [[] for _ in range(len(roads)+1)]
        for u, v in roads:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]
        dfs(0, -1, 0)
        return result[0]",O(n)
"import heapq

n, k = list(map(int, input().strip().split()))

p = list(map(int, input().strip().split()))
c = list(map(int, input().strip().split()))

p = sorted([(x, i) for i, x in enumerate(p)], key=lambda x: x[0])

ans = []
top_k = []

cur_gold = 0
for i, t in enumerate(p):
    if k == 0:
        ans.append((c[t[1]], t[1]))
    else:
        if i < k:
            cur_gold += c[t[1]]
            ans.append((cur_gold, t[1]))
            heapq.heappush(top_k, c[t[1]])
        else:
            smallest = heapq.nsmallest(1, top_k)[0]
            if smallest < c[t[1]]:
                cur_gold += c[t[1]]
                ans.append((cur_gold, t[1]))
                heapq.heappop(top_k)
                heapq.heappush(top_k, c[t[1]])
                cur_gold -= smallest
            else:
                ans.append((cur_gold + c[t[1]], t[1]))

ans = sorted(ans, key=lambda x: x[1])
print("" "".join(map(lambda x: str(x[0]), ans)))",O(nlogn)
"def bin(n):
    if n == 0:
        return 1
    else:
        if n % 2 == 1:
            return bin(n - 1) * 2
        else:
            b = (bin(n // 2)) % 1000000007
            return b * b;
x, k = map(int,input().split())
if x == 0:
    print(0)
else:
    z = bin(k + 1) % 1000000007
    z = z * (x - 1)
    z = z % 1000000007
    z += bin(k)
    z += 1
    while(z < 0):
        z += 1000000007
    print(z % 1000000007)",O(logn)
"class Solution(object):
    def validTicTacToe(self, board):
        def win(board, player):
            for i in range(3):
                if all(board[i][j] == player for j in range(3)):
                    return True
                if all(board[j][i] == player for j in range(3)):
                    return True

            return (player == board[1][1] == board[0][0] == board[2][2] or \
                    player == board[1][1] == board[0][2] == board[2][0])

        FIRST, SECOND = ('X', 'O')
        x_count = sum(row.count(FIRST) for row in board)
        o_count = sum(row.count(SECOND) for row in board)
        if o_count not in {x_count-1, x_count}: return False
        if win(board, FIRST) and x_count-1 != o_count: return False
        if win(board, SECOND) and x_count != o_count: return False

        return True",O(1)
"class ListNode(object):
    def __init__(self, key, val):
        self.val = val
        self.key = key
        self.next = None
        self.prev = None

class LinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, node):
        node.next, node.prev = None, None 
        if self.head is None:
            self.head = node
        else:
            self.tail.next = node
            node.prev = self.tail
        self.tail = node

    def delete(self, node):
        if node.prev:
            node.prev.next = node.__next__
        else:
            self.head = node.__next__
        if node.__next__:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        node.next, node.prev = None, None 

class Solution2(object):

    def __init__(self, capacity):
        self.list = LinkedList()
        self.dict = {}
        self.capacity = capacity

    def get(self, key):
        if key not in self.dict:
            return -1
        val = self.dict[key].val
        self.__update(key, val)
        return val

    def put(self, key, val):
        if key not in self.dict and len(self.dict) == self.capacity:
            del self.dict[self.list.head.key]
            self.list.delete(self.list.head)
        self.__update(key, val)

    def __update(self, key, val):
        if key in self.dict:
            self.list.delete(self.dict[key])
        node = ListNode(key, val)
        self.list.insert(node)
        self.dict[key] = node",O(1)
"class Solution(object):
    def numberOfSpecialSubstrings(self, s):
        result = left = 0
        lookup = [-1]*26
        for right in range(len(s)):
            if lookup[ord(s[right])-ord('a')] >= left:
                left = lookup[ord(s[right])-ord('a')]+1
            lookup[ord(s[right])-ord('a')] = right
            result += (right-left+1)
        return result",O(n)
"class Solution(object):
    def findLatestStep(self, arr, m):
        if m == len(arr):
            return m
        length = [0]*(len(arr)+2)
        result = -1
        for i, x in enumerate(arr):
            left, right = length[x-1], length[x+1]
            if left == m or right == m:
                result = i
            length[x-left] = length[x+right] = left+right+1
        return result",O(n)
"class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        prevMap = {}

        for i, n in enumerate(nums):
            diff = target - n
            if diff in prevMap:
                return [prevMap[diff], i]
            prevMap[n] = i
",O(n)
"def main():
    l,r = map(int,input().split())

    if l == r:
        print(0)
        return

    l = bin(l)[2:]
    r = bin(r)[2:]

    if len(l) == len(r):
        i = 1
        while l[i] == r[i]:
            i += 1
        tam = len(l)-i
    else:
        tam = len(r)

    num = """"
    for i in range(tam):
        num += '1'

    print(int(num,2))

main()",O(logn)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")

def check(mid: int) -> bool:
    global ans
    dic = {}
    for i in range(n):
        bit = 0
        for j in range(m):
            if a[i][j] >= mid:
                bit += 1
            bit <<= 1
        dic[bit >> 1] = i
    for x, idx in dic.items():
        for y, idy in dic.items():
            if x | y == 2**m-1:
                ans = idx + 1, idy + 1
                return True
    return False

n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]
ans = []
le = 0
ri = int(1e9)
while le <= ri:
    mid = (le + ri) >> 1
    if check(mid):
        le = mid + 1
    else:
        ri = mid - 1
print(ans[0], ans[1])",np
"t=int(input())
l=list(map(int,input().split()))
b_sum=0
l.sort()
for i in l:
  b_sum += i

m_sum=0
c=0
for i in l[::-1]:
  m_sum += i
  c += 1
  if m_sum > (b_sum/2):
    break
print(c)",O(nlogn)
"class Solution(object):
    def findBuildings(self, heights):
        result = []
        for i, h in enumerate(heights):
            while result and heights[result[-1]] <= h:
                result.pop()
            result.append(i)
        return result",O(n)
"from sys import stdout
a, b = 0, 0

mp = 29

c, d = 0,0

powers = [1]
for i in range(32):
    powers.append(powers[-1]*2)

qqq = 0

def get_ans(c, d):
    global qqq
    qqq += 1
    a, b = 1073741823, 1073741821
    a, b = 3, 1

    print(c, d)

    if (a^c) > (b^d):
        print(1)
        return -1
    elif (a^c) < (b^d):
        print(-1)
        return 1
    print(0)
    return 0

def get_ans(c, d):
    print('? {} {}'.format(c, d))
    stdout.flush()
    return -int(input())

q = get_ans(0, 0)

for i in range(mp+1):
    cp = mp - i
    c += powers[cp]
    d += powers[cp]

    if q == 0:
        continue
    t = get_ans(c, d)

    if t != q:

        if t == 1:
            a += powers[cp]
            c -= powers[cp]
        elif t == -1:
            b += powers[cp]
            d -= powers[cp]
        q = get_ans(c, d)

for i in range(mp+1):
    cp = mp - i

    if c & powers[cp] > 0 and d & powers[cp] > 0:
        c -= powers[cp]
        t = get_ans(c, d)

        if t < 0:
            a += powers[cp]
            b += powers[cp]

        c += powers[cp]

print('!', a, b)
",O(logn)
"import os,sys
from io import BytesIO, IOBase

def check(mid,arr,m,n):
    ls = [[] for _ in range(1<<m)]
    for i in range(n):
        ans = 0
        for j in range(m):
            if arr[i][j] >= mid:
                ans += 1<<j
        ls[ans].append(i+1)
    for i in range(len(ls)):
        for j in range(len(ls)):
            if len(ls[i]) and len(ls[j]) and i|j == (1<<m)-1:
                return ls[i][0],ls[j][0]
    return 0

def main():
    n,m = map(int,input().split())
    arr = [list(map(int,input().split())) for _ in range(n)]
    hi,lo,ind1 = 10**9,0,(1,1)
    while hi >= lo:
        mid = (hi+lo)//2
        ind = check(mid,arr,m,n)
        if ind:
            ind1 = ind
            lo = mid+1
        else:
            hi = mid-1
    print(*ind1)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",np
"n, m, k = list(map(int, input().split()))
a = list(map(int, input().split()))
ret = 0
for i in range(m):
	cur = 0
	for j in range(i, n):
		if j % m == i:
			cur = max(0, cur)
			cur -= k
		cur += a[j]
		ret = max(ret, cur)
print(ret)",O(n ^ 2)
"n=int(input())
a=list(map(int,input().split()))
s=sum(a)
new=0
i=0
while 2*(new+a[i])<s:
    new+=a[i]
    i+=1
print(i+1)
",O(n)
"n = int(input())
a = list(map(int, input().split()))

a.sort()
ans = 0
while a:
	m = a[0]
	b = []
	for x in a[1:]:
		if x % m != 0:
			b.append(x)
	a = b
	ans += 1
print(ans)",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')

def main():
    for _ in range(N()):
        n, m = RL()
        arr = []
        for _ in range(n): arr.append(RLL())

        larr = [list(i) for i in zip(*arr)]
        larr.sort(key = lambda a: max(a), reverse=1)
        larr = larr[:n]

        res = 0

        def dfs(lst, pos=0):
            nonlocal res
            if pos==min(n, len(larr)):
                res = max(res, sum(lst))
                return

            for i in range(n):
                nex = lst.copy()
                for j in range(n):
                    nex[(i+j)%n] = max(nex[(i+j)%n], larr[pos][j])
                dfs(nex, pos+1)

        dfs([0]*n)
        print(res)

if __name__ == ""__main__"":
    main()
",np
"x, y, z, t1, t2, t3 = map( int, input().split() )
elevator = t2 * ( abs( x - y ) + abs( z - x ) ) + 3 * t3
stairs = t1 * abs( x - y )
if elevator > stairs:
    print( 'NO' )
else:
    print( 'YES' )
",O(1)
"n = int(input())
a = sorted(list(map(int, input().split())))
s = []
for q in a:
    for q1 in s:
        if q % q1 == 0:
            break
    else:
        s.append(q)
print(len(s))
",O(n ^ 2)
"import sys

def query(c, d):
    print('? %d %d' % (c, d))
    sys.stdout.flush()
    res = int(input())
    return res

a = 0
b = 0
big = query(0, 0)

for i in range(29, -1, -1):
    p = query(a ^ (1 << i), b)
    q = query(a, b ^ (1 << i))
    if p == q:
        if big == 1:
            a ^= 1 << i
        else:
            b ^= 1 << i
        big = p
    elif p == -1:
        a ^= 1 << i
        b ^= 1 << i

print('! %d %d' % (a, b))
sys.stdout.flush()
",O(logn)
"import collections



class Solution2(object):
    def maxSelectedElements(self, nums):
        nums.sort()
        dp = collections.defaultdict(int)
        dp[nums[0]] = dp[nums[0]+1] = 1
        for i in range(1, len(nums)):
            if nums[i] == nums[i-1]:
                dp[nums[i]+1] = dp[nums[i]]+1
            elif nums[i] == nums[i-1]+1:
                dp[nums[i]+1] = dp[nums[i]]+1
                dp[nums[i]] = dp[nums[i]-1]+1
            elif nums[i] == nums[i-1]+2:
                dp[nums[i]] = dp[nums[i]-1]+1
                dp[nums[i]+1] = 1
            else:
                dp[nums[i]] = dp[nums[i]+1] = 1
        return max(dp.values())",O(nlogn)
"a = (input().split())
a.sort()

if(a[0] == a[1] == a[2]):
    print(0)
    exit()
elif(a[0] == a[1] or a[1] == a[2]):
    print(1)
    exit()

a1 = []
for i in range(3):
    a1.append([int(a[i][0]), a[i][1]])
a1.sort()

if(a1[1][1] == a1[2][1] == a1[0][1]):
    if(a1[0][0] == a1[1][0] - 1 and a1[0][0] == a1[2][0] - 2):
        print(0)
        exit()
    found = False
    for i in range(3):
        for j in range(3):
            if(abs(a1[i][0] - a1[j][0]) == 1 or abs(a1[i][0] - a1[j][0]) == 2 ):
                print(1)
                exit()
    print(2)
    exit()
for i in range(3):
    for j in range(i + 1, 3):
        if(a1[i][1] == a1[j][1]):
            if(a1[i][0] == a1[j][0] - 1 or a1[i][0] == a1[j][0] - 2):
                print(1)
            else:
                print(2)
            exit()
print(2)
",O(nlogn)
"n,k=map(int,input().split())
l,c=[],0
for _ in range(n):
	l.append(list(map(int,input().split())))
l.sort(reverse=True)
a,x,y=l[k-1][0],k-1,k-1
for i in range(k-2,-1,-1):
	if l[i][0]==a:
		x=i
	else:
		break
for i in range(k,n):
	if l[i][0]==a:
		y=i
	else:
		break
d=k-1-x
d=y-d
for i in range(y,x-1,-1):
	if l[i]==l[d]:
		c+=1
print(c)",O(nlogn)
"n, q = map(int,input().split())
ai = list(map(int,input().split()))
ar  = []
ar3 = []
num = 1
nummm = max(ai)
if ai[0] != nummm:
    num2 = ai[0]
    for i in range(1,n):
        ar3 += [[num2,ai[i]]]
        if ai[i] == nummm:
            ar += [num2]
            num = i+1
            break
        if ai[i] > num2:
            ar += [num2]
            num2 = ai[i]
        else:
            ar += [ai[i]]
ar2 = []
for i in range(num,n):
    ar2 += [ai[i]]
for i in range(len(ar)):
    ar2 += [ar[i]]
num = len(ar3)
for i in range(q):
    m = int(input())
    if m <= num:
        print(ar3[m-1][0],ar3[m-1][1])
    else:
        m -= num
        m -= 1
        print(nummm,ar2[m % (n-1)])
",O(n)
"import math

SPACE = ' '

def get_data(file_name):
    result = list()
    state = 0
    data = list()

    try:
        for line in open(file_name, 'r').readlines():
            line = line.strip()
            if state == 0:
                if line == 'Input':
                    data = list()
                    state = 1
                elif line == 'Answer':
                    state = 2
            elif state == 1:
                data += list(map(int, line.split(SPACE)))
                state = 11
            elif state == 11:
                data += list(map(int, line.split(SPACE)))
                state = 0
            elif state == 2:
                data.append(float(line))
                result.append(data)
                state = 0
    except FileNotFoundError:
        print(f'File {file_name} not found.')
    return result

def time(d=None, v=None, v0=0, steady=False):
    if steady:
        return d / v

    if d is None:

        return (v - v0) / ACCEL

    if v is None:
        v = vel(d=d, v0=v0)
    return (2 * d) / (v + v0)

def dist(t=None, v=None, v0=0, steady=False):
    if steady:
        return v * t

    if t is None:

        return (pow(v, 2) - pow(v0, 2)) / (2 * ACCEL)

    return (1 / 2) * (v + v0) * t

def vel(d=None, t=None, v0=0, steady=False):
    if steady:
        return d / t

    if d is None:

        return t * ACCEL - v0

    return pow(2 * d * ACCEL + v0 ** 2, 1 / 2)

def can_ignore_sign(v, w, d):
    return v <= w or d <= dist(v=w)

def ignore_sign(v, w, l):
    dmax = dist(v=v)
    if l <= dmax:
        return time(d=l)
    return time(v=v) + time(d=l - dmax, v=v, steady=True)

def get_time(a, v, l, d, w):
    global ACCEL
    ACCEL = a

    if can_ignore_sign(v, w, d):
        return ignore_sign(v, w, l)

    tmax, dmax = time(v=v), dist(v=v)
    tlim_max, dlim_max = time(v=v, v0=w), dist(v=v, v0=w)
    if dmax + dlim_max <= d:

        res = tmax + time(d=d - dmax - dlim_max, v=v, steady=True) + tlim_max
    else:

        res = time(v=w) + time(v=vel(d=(d - dist(v=w)) / 2, v0=w), v0=w) * 2

    x = d + dist(v=v) - dist(v=w)
    if x >= l:

        res += time(d=l - d, v0=w)
        return res
    return res + time(v=v, v0=w) + time(d=l - x, v=v, steady=True)

if __name__ == '__main__':
    a, v = map(int, input().split())
    l, d, w = map(int, input().split())
    print(get_time(a, v, l, d, w))
",O(1)
"import collections
from functools import reduce


class Solution(object):
    def longestDupSubstring(self, S):
        M = 10**9+7
        D = 26

        def check(S, L):
            p = pow(D, L, M)
            curr = reduce(lambda x, y: (D*x+ord(y)-ord('a')) % M, S[:L], 0)
            lookup = collections.defaultdict(list)
            lookup[curr].append(L-1)
            for i in range(L, len(S)):
                curr = ((D*curr) % M + ord(S[i])-ord('a') -
                        ((ord(S[i-L])-ord('a'))*p) % M) % M
                if curr in lookup:
                    for j in lookup[curr]: 
                        if S[j-L+1:j+1] == S[i-L+1:i+1]:
                            return i-L+1
                lookup[curr].append(i)
            return 0

        left, right = 1, len(S)-1
        while left <= right:
            mid = left + (right-left)//2
            if not check(S, mid):
                right = mid-1
            else:
                left = mid+1
        result = check(S, right)
        return S[result:result + right]",O(nlogn)
"t=int(input())
for _ in range(t):
	n,k=list(map(int,input().split()))
	if n>=32:
		print(""YES ""+str(n-1))
	else:
		ans=-1
		for i in range(1,n+1):
			p=(4**i)-(2**(i+1))+1
			p*=(((4**(n-i))-1)//3)
			g=(((4**i)-1)//3)
			p+=(((4**i)-1)//3)
			g=(((4**i)-1)//3)-(((4**(i-1))-1)//3)
			if g<=k and p>=k:
				ans=n-i
				break
		if ans!=-1:
			print(""YES ""+str(ans))
		else:
			print(""NO"")",O(logn)
"n=int(input())
l=list(map(int,input().split()))
s=set(l)
x=0
if x in s:
    print(len(s)-1)
else:
    print(len(s))",O(n)
"n = int(input())
rng = []
for _ in range(n):
    x, w = map(int, input().split())
    rng.append((x-w, x+w))
rng.sort(key=lambda x: (x[1], x[0]))

ans = 0
tmp = - 10 ** 10
for l, r in rng:
    if tmp <= l:
        ans += 1
        tmp = r

print(ans)",O(nlogn)
"for _ in range(int(input())):
    i, j = map(int, input().split())
    i -= 1
    print((j//2 * (j//2 + 1) - i//2 * (i//2 + 1)) -
          (((j - j//2) * (j - j//2)) - ((i - i//2) * (i - i//2))))",O(1)
"class Solution2(object):
    def maximumGap(self, nums):
        if len(nums) < 2:
            return 0

        nums.sort()
        pre = nums[0]
        max_gap = float(""-inf"")

        for i in nums:
            max_gap = max(max_gap, i - pre)
            pre = i
        return max_gap",O(nlogn)
"import math
import sys
from bisect import bisect_right, bisect_left, insort_right
from collections import Counter, defaultdict
from heapq import heappop, heappush
from itertools import accumulate
from sys import stdout

R = lambda: map(int, input().split())
t = input()
s = input()
k = t.count('+') - s.count('+')
n = s.count('?')
if k > n or k < 0:
    print('0.0')
else:
    print(math.factorial(n) / (math.factorial(k) * math.factorial(n - k)) / 2**n)",np
"from math import sqrt
for _ in ' '*int(input()):
    n = int(input())
    if int(sqrt(n/2)) == sqrt(n/2) or int(sqrt(n/4)) == sqrt(n/4):
        print(""YES"")
    else: print(""NO"")",O(1)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def recoverFromPreorder(self, S):
        i = 0
        stack = []
        while i < len(S):
            level = 0
            while i < len(S) and S[i] == '-':
                level += 1
                i += 1
            while len(stack) > level:
                stack.pop()
            val = []
            while i < len(S) and S[i] != '-':
                val.append(S[i])
                i += 1
            node = TreeNode(int("""".join(val)))
            if stack:
                if stack[-1].left is None:
                    stack[-1].left = node
                else:
                    stack[-1].right = node
            stack.append(node)
        return stack[0]",O(n)
"n, l, r, x = list(map(int, input().split("" "")))
c = sorted(list(map(int, input().split("" ""))))
ways = 0

for i in range(0, 2 ** n):
    temp = 0
    m = 10 ** 9 + 1
    M = -1
    for j in range(0, n):
        if i & 1 << j:
            temp += c[j]
            m = min(m, c[j])
            M = max(M, c[j])
    if temp >= l and temp <= r and (M - m) >= x:
        ways += 1

print(ways)
",np
"import sys
input = sys.stdin.readline
import math
import copy
import collections
from collections import deque
import heapq
import itertools
from collections import defaultdict
from collections import Counter

n,k = map(int,input().split())
mod = 998244353
dp = [[[0 for z in range(2)] for j in range(k+1)] for i in range(n)]

dp[0][1][0] = 1
if k>=2:
    dp[0][2][1] = 1
for i in range(1,n):
    for j in range(1,k+1):
        dp[i][j][0] += dp[i-1][j-1][0]+dp[i-1][j][0]+2*dp[i-1][j][1]
        dp[i][j][0]%=mod
        if j-2>=0:
            dp[i][j][1] += 2*dp[i-1][j-1][0]+dp[i-1][j][1]+dp[i-1][j-2][1]
        else:
            dp[i][j][1] += dp[i-1][j-1][0]+dp[i-1][j][1]+dp[i][j-1][0]
        dp[i][j][1]%=mod
ans = 0
for z in range(2):
    ans+=dp[n-1][k][z]
ans*=2
print(ans%mod)
",np
"class Solution(object):
    def missingRolls(self, rolls, mean, n):
        MAX_V = 6
        MIN_V = 1
        total = sum(rolls)
        missing = mean*(n+len(rolls))-total
        if missing < MIN_V*n or missing > MAX_V*n:
            return []
        q, r = divmod(missing, n)
        return [q+int(i < r) for i in range(n)]",O(n)
"n,k = map(int,input().split())
s = input()
f = 0
for i in range(1,n):
    if s[:n-i]==s[i:]:
        f=1
        break
if f==0:
    print(s*k)
else:
    j = n-i
    final = s[j:]
    print(s+final*(k-1))",O(n ^ 2)
"
class Solution(object):
    def boundaryOfBinaryTree(self, root):
        def leftBoundary(root, nodes):
            if not root or (not root.left and not root.right):
                return
            nodes.append(root.val)
            if not root.left:
                leftBoundary(root.right, nodes)
            else:
                leftBoundary(root.left, nodes)

        def rightBoundary(root, nodes):
            if not root or (not root.left and not root.right):
                return
            if not root.right:
                rightBoundary(root.left, nodes)
            else:
                rightBoundary(root.right, nodes)
            nodes.append(root.val)

        def leaves(root, nodes):
            if not root:
                return
            if not root.left and not root.right:
                nodes.append(root.val)
                return
            leaves(root.left, nodes)
            leaves(root.right, nodes)

        if not root:
            return []

        nodes = [root.val]
        leftBoundary(root.left, nodes)
        leaves(root.left, nodes)
        leaves(root.right, nodes)
        rightBoundary(root.right, nodes)
        return nodes

",O(n)
"n = int(input())
s = input()
ans = 10000
for i in range(0, 105):
	f = True
	x = i
	for c in s:
		if c == '-':
			x -= 1
		else:
			x += 1
		if x < 0:
			f = False
	if f:
		ans = min(ans, x)
print(ans)
",O(n)
"import sys
import math
import bisect
from sys import stdin, stdout
from math import gcd, floor, sqrt, log
from collections import defaultdict as dd
from bisect import bisect_left as bl, bisect_right as br
from collections import Counter
from collections import defaultdict as dd
from collections import deque

flush = lambda: stdout.flush()
stdstr = lambda: stdin.readline()
stdint = lambda: int(stdin.readline())
stdpr = lambda x: stdout.write(str(x))
stdmap = lambda: map(int, stdstr().split())
stdarr = lambda: list(map(int, stdstr().split()))

mod = 1000000007

n,m = stdmap()
arr =  stdarr()

if(n > m):
    print(0)
else:
    c = Counter(arr)
    d1 = list(sorted(c.values()))

    days = 0
    for i in range(1, 101):
        br = False
        d = d1.copy()

        people = 0
        done = False

        while(1):
            if(people >= n):

                days = i
                done = True
                break
            else:
                if(len(d) == 0):
                    break
                curr = d[-1]//i

                d.pop()

                people += curr

        if(done):
            days = i

    print(days)",O(nlogn)
"def maxXORInRange(L, R):
	LXR = L ^ R
	msbPos = 0
	while(LXR):
		msbPos += 1
		LXR >>= 1

	maxXOR = (1<<msbPos)-1
	return maxXOR

l,r=map(int,input().split())
print(maxXORInRange(l, r))
",O(logn)
"k1,k2,k3=map(int,input().split())
a=[k1,k2,k3];a=sorted(a)
if a[0]==1 or a.count(2)>=2 or a.count(3)==3:print(""YES"")
elif a.count(4)==2 and a.count(2)==1:print(""YES"")
else:print(""NO"")
",O(1)
"class Solution(object):
    def beautifulIndices(self, s, a, b, k):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        def KMP(text, pattern):
            prefix = getPrefix(pattern)
            j = -1
            for i in range(len(text)):
                while j+1 > 0 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    yield i-j
                    j = prefix[j]

        result = []
        if not (len(a) <= len(s) and len(b) <= len(s)):
            return result
        lookup = list(KMP(s, b))
        j = 0
        for i in KMP(s, a):
            while j < len(lookup) and lookup[j] < i-k:
                j += 1
            if j < len(lookup) and lookup[j] <= i+k:
                result.append(i)
        return result",O(n)
"r, g, b = map(int, input().split())
R = list(map(int, input().split()))
G = list(map(int, input().split()))
B = list(map(int, input().split()))
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)

memo = [[[-1]*(b+1) for i in range(g+1)] for j in range(r+1)]

def calc(ir, ig, ib):
    if memo[ir][ig][ib] != -1:
        return memo[ir][ig][ib]
    ans = 0
    if ir < r and ig < g:
        ans = max(ans, calc(ir+1, ig+1, ib)+R[ir]*G[ig])
    if ir < r and ib < b:
        ans = max(ans, calc(ir+1, ig, ib+1)+R[ir]*B[ib])
    if ig < g and ib < b:
        ans = max(ans, calc(ir, ig+1, ib+1)+G[ig]*B[ib])
    memo[ir][ig][ib] = ans
    return ans

print(calc(0, 0, 0))
",O(n ^ 3)
"import sys;input=sys.stdin.readline

def solve():
    n, l, r, x = map(int,input().split())
    lis = list(map(int,input().split()))
    lis = sorted(lis)
    dp = [0]
    dp_low = [0]
    dp_high = [0]
    for i in range(len(lis)):
        for j in range(len(dp)):
            if dp_low[j]==0:
                dp_low.append(lis[i])
            else:
                dp_low.append(dp_low[j])
            dp_high.append(lis[i])
            dp = dp+[dp[j]+lis[i]]
    count = 0
    for i in range(len(dp)):
        if dp[i]>=l and dp[i]<=r and dp_high[i]-dp_low[i]>=x:
            count+=1
    print(count)

solve()
",np
"import pandas as pd



def Solution(employees: pd.DataFrame) -> pd.DataFrame:
    return employees.assign(bonus=2*employees[""salary""])",O(n)
"def binary(n,k,low,high):
    if low<=high:
        mid=(low+high)//2
        if (mid*(mid+1))//2-(n-mid)==k:
            return n-mid
        elif mid*(mid+1)//2-(n-mid)>k:
            return binary(n,k,low,mid-1)
        else:
            return binary(n,k,mid+1,high)

n,k=[int(x) for x in input().split()]
print(binary(n,k,1,n))",O(logn)
"class Solution(object):
    def addSpaces(self, s, spaces):
        prev = len(s)
        s = list(s)
        s.extend([None]*len(spaces))
        for i in reversed(range(len(spaces))):
            for j in reversed(range(spaces[i], prev)):
                s[j+1+i] = s[j]
            s[spaces[i]+i] = ' '
            prev = spaces[i]
        return """".join(s)",O(n)
"import sys

n,m=map(int,sys.stdin.readline().split())
X=[int(sys.stdin.readline()) for i in range(n)]
Y=[list(map(int,sys.stdin.readline().split())) for i in range(m)]
Z=[]

ANS=0
for y in Y:
    if y[0]==1 and y[1]==10**9:
        ANS+=1
    elif y[0]==1:
        Z.append(y[1])
X.sort(reverse=True)
Z.sort(reverse=True)

XCOUNT=[0]*n

i=0
j=0
l=len(Z)
X.append(0)
Z.append(0)
while i<l+1 and j<n:
    if Z[i]>=X[j]:
        i+=1
    else:
        XCOUNT[j]=i
        j+=1

count=n
XCOUNT.reverse()
for i in range(n):
    if count>i+XCOUNT[i]:
        count=i+XCOUNT[i]

print(count+ANS)
",O(nlogn)
"n = int(input())
ans = [1, 3, 5, 7, 9, 11, 13, 15]
dct = \
{
    1 : 1,
    3 : 18,
    5 : 1800,
    7 : 670320,
    9 : 734832000,
    11 : 890786230,
    13 : 695720788,
    15 : 150347555
}
if n in ans:
    print(dct[n])
else:
    print(0)",np
"import math
import random
import heapq, bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
import threading
from collections import defaultdict

mod = 10 ** 9 + 7
mod1 = 998244353

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class TreeNode:
    def __init__(self, k, v):
        self.key = k
        self.value = v
        self.left = None
        self.right = None
        self.parent = None
        self.height = 1
        self.num_left = 1
        self.num_total = 1

class AvlTree:

    def __init__(self):
        self._tree = None

    def add(self, k, v):
        if not self._tree:
            self._tree = TreeNode(k, v)
            return
        node = self._add(k, v)
        if node:
            self._rebalance(node)

    def _add(self, k, v):
        node = self._tree
        while node:
            if k < node.key:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(k, v)
                    node.left.parent = node
                    return node.left
            elif node.key < k:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(k, v)
                    node.right.parent = node
                    return node.right
            else:
                node.value = v
                return

    @staticmethod
    def get_height(x):
        return x.height if x else 0

    @staticmethod
    def get_num_total(x):
        return x.num_total if x else 0

    def _rebalance(self, node):

        n = node
        while n:
            lh = self.get_height(n.left)
            rh = self.get_height(n.right)
            n.height = max(lh, rh) + 1
            balance_factor = lh - rh
            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)
            n.num_left = 1 + self.get_num_total(n.left)

            if balance_factor > 1:
                if self.get_height(n.left.left) < self.get_height(n.left.right):
                    self._rotate_left(n.left)
                self._rotate_right(n)
            elif balance_factor < -1:
                if self.get_height(n.right.right) < self.get_height(n.right.left):
                    self._rotate_right(n.right)
                self._rotate_left(n)
            else:
                n = n.parent

    def _remove_one(self, node):

        replacement = node.left or node.right
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = replacement
            else:
                node.parent.right = replacement
            replacement.parent = node.parent
            node.parent = None
        else:
            self._tree = replacement
            replacement.parent = None
        node.left = None
        node.right = None
        node.parent = None
        self._rebalance(replacement)

    def _remove_leaf(self, node):
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = None
            else:
                node.parent.right = None
            self._rebalance(node.parent)
        else:
            self._tree = None
        node.parent = None
        node.left = None
        node.right = None

    def remove(self, k):
        node = self._get_node(k)
        if not node:
            return
        if AvlTree._is_leaf(node):
            self._remove_leaf(node)
            return
        if node.left and node.right:
            nxt = AvlTree._get_next(node)
            node.key = nxt.key
            node.value = nxt.value
            if self._is_leaf(nxt):
                self._remove_leaf(nxt)
            else:
                self._remove_one(nxt)
            self._rebalance(node)
        else:
            self._remove_one(node)

    def get(self, k):
        node = self._get_node(k)
        return node.value if node else -1

    def _get_node(self, k):
        if not self._tree:
            return None
        node = self._tree
        while node:
            if k < node.key:
                node = node.left
            elif node.key < k:
                node = node.right
            else:
                return node
        return None

    def get_at(self, pos):
        x = pos + 1
        node = self._tree
        while node:
            if x < node.num_left:
                node = node.left
            elif node.num_left < x:
                x -= node.num_left
                node = node.right
            else:
                return (node.key, node.value)
        raise IndexError(""Out of ranges"")

    @staticmethod
    def _is_left(node):
        return node.parent.left and node.parent.left == node

    @staticmethod
    def _is_leaf(node):
        return node.left is None and node.right is None

    def _rotate_right(self, node):
        if not node.parent:
            self._tree = node.left
            node.left.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.left
            node.left.parent = node.parent
        else:
            node.parent.right = node.left
            node.left.parent = node.parent
        bk = node.left.right
        node.left.right = node
        node.parent = node.left
        node.left = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    def _rotate_left(self, node):
        if not node.parent:
            self._tree = node.right
            node.right.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.right
            node.right.parent = node.parent
        else:
            node.parent.right = node.right
            node.right.parent = node.parent
        bk = node.right.left
        node.right.left = node
        node.parent = node.right
        node.right = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    @staticmethod
    def _get_next(node):
        if not node.right:
            return node.parent
        n = node.right
        while n.left:
            n = n.left
        return n

class SegmentTree1:
    def __init__(self, data, default=2**30, func=lambda a, b: min(a , b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b:a + b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m

def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z

def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por

def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        if (arr[mid] < key):
            count = mid + 1
            left = mid + 1

        else:
            right = mid - 1

    return count

def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    leftGreater = n

    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] > k):
            leftGreater = m
            r = m - 1

        else:
            l = m + 1

    return (n - leftGreater)

class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.isEndOfWord = False
class Trie:
    def __init__(self):
        self.root = self.getNode()
    def getNode(self):
        return TrieNode()
    def _charToIndex(self, ch):
        return ord(ch) - ord('a')
    def insert(self, key):
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
            if not pCrawl.children[index]:
                pCrawl.children[index] = self.getNode()
            pCrawl = pCrawl.children[index]
        pCrawl.isEndOfWord = True
    def search(self, key):
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
            if not pCrawl.children[index]:
                return False
            pCrawl = pCrawl.children[index]
        return pCrawl != None and pCrawl.isEndOfWord

class Node:
    def __init__(self, data):
        self.data = data
        self.count=0
        self.left = None
        self.right = None
class BinaryTrie:
    def __init__(self):
        self.root = Node(0)
    def insert(self, pre_xor):
        self.temp = self.root
        for i in range(31, -1, -1):
            val = pre_xor & (1 << i)
            if val:
                if not self.temp.right:
                    self.temp.right = Node(0)
                self.temp = self.temp.right
                self.temp.count+=1
            if not val:
                if not self.temp.left:
                    self.temp.left = Node(0)
                self.temp = self.temp.left
                self.temp.count += 1
        self.temp.data = pre_xor
    def query(self, xor):
        self.temp = self.root
        for i in range(31, -1, -1):
            val = xor & (1 << i)
            if not val:
                if self.temp.left and self.temp.left.count>0:
                    self.temp = self.temp.left
                elif self.temp.right:
                    self.temp = self.temp.right
            else:
                if self.temp.right and self.temp.right.count>0:
                    self.temp = self.temp.right
                elif self.temp.left:
                    self.temp = self.temp.left
            self.temp.count-=1
        return xor ^ self.temp.data

n,m=map(int,input().split())
l=[]
pm=2**m-1
for i in range(n):
    l.append(list(map(int,input().split())))
def find (x):
    s=set()
    d=defaultdict(int)
    for i in range(n):
        a=""""
        for j in range(m):
            if l[i][j]>=x:
                a+='1'
            else:
                a+='0'
        d[int(a,2)]=i
        s.add(int(a,2))
    s=list(s)

    for i in range(len(s)):
        for j in range(i,len(s)):
            if s[i]|s[j]==pm:
                return [d[s[i]]+1,d[s[j]]+1]
    return [-1,-1]
st=0
end=10**9
ans=(0,0)
while(st<=end):
    mid=(st+end)//2
    s=find(mid)
    if s[0]!=-1:
        ans=s
        st=mid+1
    else:
        end=mid-1
print(*ans)",np
"n, m, k = map(int, input().split())
reb1 = [list(map(int, input().split())) for i in range(n)]
reb2 = [list(map(int, input().split())) for i in range(n - 1)]
if k % 2:
    for i in range(n):
        for j in range(m):
            print(-1, end="" "")
        print()
    exit(0)
minsum = [[0] * m for i in range(n)]
nminsum = [[0] * m for i in range(n)]
for it in range(k // 2):
    for i in range(n):
        for j in range(m):
            cmin = 1000000000010
            if i != 0:
                cmin = min(cmin, minsum[i - 1][j] + reb2[i - 1][j])
            if i != n - 1:
                cmin = min(cmin, minsum[i + 1][j] + reb2[i][j])
            if j != 0:
                cmin = min(cmin, minsum[i][j - 1] + reb1[i][j - 1])
            if j != m - 1:
                cmin = min(cmin, minsum[i][j + 1] + reb1[i][j])
            nminsum[i][j] = cmin
    for i in range(n):
        for j in range(m):
            minsum[i][j] = nminsum[i][j]
for i in minsum:
    for j in i:
        print(j * 2, end="" "")
    print()
",O(n ^ 3)
"class Solution2(object):
    def singleNumber(self, A):
        one, two, carry = 0, 0, 0
        for x in A:
            two |= one & x
            one ^= x
            carry = one & two
            one &= ~carry
            two &= ~carry
        return one",O(n)
"class Solution3(object):
    def countEven(self, num):
        return sum(sum(map(int, str(x)))%2 == 0 for x in range(1, num+1))",O(nlogn)
"base=998244353;
def power(x, y):
    if(y==0):
        return 1
    t=power(x, y//2)
    t=(t*t)%base
    if(y%2):
        t=(t*x)%base
    return t;
def inverse(x):
    return power(x, base-2)
ft=[0]
for i in range(0, 200000):
    ft.append(0)
def get(i):
    res=0
    while(i<=200000):
        res+=ft[i]
        i+=i&-i
    return res
def update(i, x):
    while(i):
        ft[i]+=x
        i-=i&-i
n=int(input())
a=[0]
a+=list(map(int, input().split()))
neg=[0]
non=[0]
for i in range(1, n+1):
    non.append(0)
for i in range(1, n+1):
    if(a[i]!=-1):
        non[a[i]]+=1
for i in range(1, n+1):
    non[i]+=non[i-1]
for i in range(1, n+1):
    if(a[i]==-1):
        neg.append(neg[i-1]+1)
    else:
        neg.append(neg[i-1])
m=neg[n]
ans=0
for i in range(1, n+1):
    if(a[i]!=-1):
        ans+=get(a[i])
        update(a[i], 1)
fm=1
fs=fm
for i in range(1, m+1):
    fs=fm
    fm=(fm*i)%base
fs=(fs*inverse(fm))%base
for i in range(1, n+1):
    if(a[i]!=-1):
        less=a[i]-non[a[i]]
        more=m-less
        ans=(ans+neg[i]*more*fs)%base
        ans=(ans+(m-neg[i])*less*fs)%base
ans=(ans+m*(m-1)*inverse(4))%base
print(ans)",O(nlogn)
"class Solution(object):
    def wordPattern(self, pattern, str):
        if len(pattern) != self.wordCount(str):
            return False

        w2p, p2w = {}, {}
        for p, w in zip(pattern, self.wordGenerator(str)):
            if w not in w2p and p not in p2w:
                w2p[w] = p
                p2w[p] = w
            elif w not in w2p or w2p[w] != p:
                return False
        return True

    def wordCount(self, str):
        cnt = 1 if str else 0
        for c in str:
            if c == ' ':
                cnt += 1
        return cnt

    def wordGenerator(self, str):
        w = """"
        for c in str:
            if c == ' ':
                yield w
                w = """"
            else:
                w += c
        yield w",O(n)
"def f_pow(a, n):
    if n < 0:
        return 0
    if n == 0:
        return 1
    if n % 2 == 0:
        return f_pow(a * a, n // 2)
    else:
        return a * f_pow(a, n - 1)

def get_c(n):
    if(n > 68):
        return int(1e40)
    return (f_pow(4, n) - 4) // 12

def get_cc(n):
    if(n > 51):
        return int(1e30)
    return (f_pow(4, n) - 4) // 12

def ans(n, k):
    side = n - 1
    way = 4
    cnt_all = get_c(n + 1)
    c = 2
    op = 1
    while (True):
        if k < op or side < 0:
            break
        way_blocks = way - 1
        if(get_cc(side - 1) > k):
            return side
        per_block = get_cc(side + 1)
        kk = k - op
        if cnt_all - way_blocks * per_block - op >= kk:
            return side

        side -= 1
        op += (1 << c) - 1
        c += 1
        way *= 2
    return -1

def read():
    return [int(i) for i in input().split()]

t = int(input())

for i in range(t):
    n, k = read()
    a = ans(n, k)
    if(a == -1):
        print(""NO"")
    else:
        print(""YES {}"".format(a))",O(logn)
"class Solution2(object):
    def treeQueries(self, n, edges, queries):
        def dfs(u, p, d):
            L[u] = cnt[0]
            cnt[0] += 1
            dist[u] = d
            for v, w in adj[u]:
                if v == p:
                    continue
                lookup[v] = w
                dfs(v, u, d+w)
            R[u] = cnt[0]

        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            u -= 1
            v -= 1
            adj[u].append((v, w))
            adj[v].append((u, w))
        L, R, dist, lookup = [0]*n, [0]*n, [0]*n, [0]*n
        cnt = [0]
        dfs(0, -1, 0)
        bit = BIT(n)
        result = []
        for q in queries:
            if q[0] == 1:
                _, u, v, w = q
                u -= 1
                v -= 1
                if L[u] > L[v]:
                    u, v = v, u 
                diff = w-lookup[v]
                bit.add(L[v], diff)
                bit.add(R[v], -diff)
                lookup[v] = w
            else:
                _, x = q
                x -= 1
                result.append(dist[x]+bit.query(L[x]))
        return result",O(nlogn)
"class Solution(object):
    def sortVowels(self, s):
        def inplace_counting_sort(nums, reverse=False): 
            if not nums:
                return
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()
    
        VOWELS = ""AEIOUaeiou""
        LOOKUP = {x:i for i, x in enumerate(VOWELS)}
        vowels = [LOOKUP[x] for x in s if x in LOOKUP]
        inplace_counting_sort(vowels, reverse=True)
        return """".join(VOWELS[vowels.pop()] if x in LOOKUP else x for x in s)",O(n)
"class Solution2(object):
    def minimalKSum(self, nums, k):
        result = prev = 0
        nums.append(float(""inf""))
        for x in sorted(set(nums)):
            if not k:
                break
            cnt = min((x-1)-prev, k)
            k -= cnt
            result += ((prev+1)+(prev+cnt))*cnt//2
            prev = x
        return result",O(nlogn)
"import os, sys
from io import BytesIO, IOBase
from math import log2, ceil, sqrt, gcd
from _collections import deque
import heapq as hp
from bisect import bisect_left, bisect_right
from math import cos, sin

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

mod = 10 ** 9 + 7

def ask(x, y):
    print('?', x, y, flush=True)
    return int(input())

a = b = 0
cond = ask(a, b)
for i in range(29, -1, -1):
    if cond:
        x = a + (1 << i)
        y = b + (1 << i)
        n_cond = ask(x, y)
        if cond == n_cond:
            if cond == 1:
                n_cond1 = ask(x, b)
            else:
                n_cond1 = ask(a, y)

            if cond != n_cond1:
                a = x
                b = y

        else:
            if cond == 1:
                a = x
            else:
                b = y
            cond = ask(a, b)
    else:
        x = a + (1 << i)
        y = b + (1 << i)
        n_cond = ask(x, b)
        if n_cond == -1:
            a = x
            b = y
print('!', a, b, flush=True)
",O(1)
"def func():
    count = 0
    for i in range(1 << n):
        temp = []
        for j in range(n):
            if 1 << j & i:
                temp.append(c[j])

        if l <= sum(temp) <= r and temp[-1] - temp[0] >= x:
            count += 1
    print(count)

n, l, r, x = map(int, input().split())
c = list(map(int, input().split()))
c.sort()
func()
",np
"n = int(input())
l = list(map(int, input().split("" "")))
l2 = list(map(int, input().split("" "")))
dp_1 = l2.copy()
dp_2 = [9999999999]*n
dp_3 = [9999999999]*n
for i in range(1, n):
    for j in range(i):
        if l[i] > l[j]:
            dp_2[i] = min(dp_2[i], dp_1[j]+l2[i])

    for j in range(i):
        if l[i] > l[j]:
            dp_3[i] = min(dp_3[i], dp_2[j]+l2[i])

x = min(dp_3)
if x == 9999999999:
    print(-1)
else:
    print(x)",O(n ^ 2)
"n, k = map(int, input().split())

strr = """"
while len(strr) < n:
    strr += ""0"" * ((n-k) // 2) + ""1""
strr = strr[:n]
print(strr)",O(n)
"class Solution(object):
    def numMovesStonesII(self, stones):
        stones.sort()
        left, min_moves = 0, float(""inf"")
        max_moves = max(stones[-1]-stones[1], stones[-2]-stones[0]) - (len(stones)-2)
        for right in range(len(stones)):
            while stones[right]-stones[left]+1 > len(stones):
                left += 1
            if len(stones)-(right-left+1) == 1 and stones[right]-stones[left]+1 == len(stones)-1:
                min_moves = min(min_moves, 2) 
            else:
                min_moves = min(min_moves, len(stones)-(right-left+1)) 
        return [min_moves, max_moves]",O(nlogn)
"import math
a = str(input())
b = str(input())
posa = a.count('+') - a.count('-')
posb = b.count('+') - b.count('-')
q = b.count('?')
dist = (posa - posb)
ones = (abs(dist) + q) / 2
if q < abs(dist) or ((dist+q) % 2):
    ans = 0
else:
    ans = float(math.factorial(q)/(math.factorial(ones)*math.factorial(q-ones)))
    ans /= pow(2, q)
print(f'{ans:.9f}')
",np
"a, b = map(int, input().split())
print(""1""*a)
print(int(""1"" + (""0"" * a)) - int(""1"" * a))",O(1)
"s = input()
while s!="""":
	if s==s[::-1]:
		s=s[:(len(s)-1)]
	else:
		break
print(len(s))",O(n)
"n, k = map(int, input().split())
count = [0] * k
for c in input():
    count[ord(c) - ord(""A"")] += 1
print(k * min(count))
",O(n)
"import decimal
decimal.getcontext().prec = 100

a, v = map(decimal.Decimal, input().split())
l, d, w = map(decimal.Decimal, input().split())

def DecimalPow(a, b):
    return decimal.Decimal(a) ** decimal.Decimal(b)

def getLastT(v1, dist):
    t1 = (v - v1) / a
    d1 = v1 * t1 + decimal.Decimal(0.5) * a * DecimalPow(t1, 2)
    if d1 >= dist:
        return (-v1 + (v1 ** decimal.Decimal(2) + 2 * a * dist) ** decimal.Decimal(0.5)) / a
    t2 = (dist - d1) / v
    return t1 + t2

if w >= v:
    t = getLastT(0, l)
    print('{t:.5f}'.format(t = t))

elif (w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d:
    t = getLastT(0, l)
    print('{t:.5f}'.format(t = t))

elif (v ** decimal.Decimal(2) - 0) / (2 * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d:
    t2 = -w / a + ((w ** decimal.Decimal(2)) / (2 * (a ** decimal.Decimal(2))) + d / a) ** decimal.Decimal(0.5)
    t1 = w / a + t2
    t3 = getLastT(w, l - d)
    t = t1 + t2 + t3
    print('{t:.5f}'.format(t = t))

else:
    t1 = v / a
    t3 = (v - w) / a
    t2 = (d - ((v ** decimal.Decimal(2) - 0) / (decimal.Decimal(2) * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a))) / v
    t4 = getLastT(w, l - d)
    t = t1 + t2 + t3 + t4
    print('{t:.5f}'.format(t = t))",O(1)
"class Solution(object):
    def minimumOperationsToWriteY(self, grid):
        cnt = [[0]*3 for _ in range(2)]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                cnt[(i <= (len(grid[0])-1)//2 and (i-j == 0 or i+j == len(grid[0])-1)) or (i > (len(grid[0])-1)//2 == j)][grid[i][j]] += 1
        return len(grid)*len(grid[0])-max(cnt[0][i]+cnt[1][j] for i in range(3) for j in range(3) if i != j)",O(n ^ 2)
"class Solution(object):
    def numberOfGoodPartitions(self, nums):
        MOD = 10**9+7
        lookup = {x:i for i, x in enumerate(nums)}
        result = 1
        right = cnt = 0
        for left, x in enumerate(nums):
            if left == right+1:
                cnt += 1
            right = max(right, lookup[x])
        return pow(2, cnt, MOD)",O(n)
"import collections


class Solution2(object):
    def lastSubstring(self, s):
        count = collections.defaultdict(list)
        for i in range(len(s)):
            count[s[i]].append(i)

        max_c = max(count.keys())
        starts = {}
        for i in count[max_c]:
            starts[i] = i+1
        while len(starts)-1 > 0:
            lookup = set()
            next_count = collections.defaultdict(list)
            for start, end in starts.items():
                if end == len(s): 
                    lookup.add(start)
                    continue
                next_count[s[end]].append(start)				
                if end in starts: 
                    lookup.add(end)			
            next_starts = {}
            max_c = max(next_count.keys())
            for start in next_count[max_c]:
                if start not in lookup:
                    next_starts[start] = starts[start]+1
            starts = next_starts
        return s[next(iter(starts.keys())):]",O(n)
"class Solution(object):
    def maxPrice(self, items, capacity):
        result = 0
        items.sort(key=lambda x: float(x[0])/x[1], reverse=True)
        for p, c in items:
            cnt = min(c, capacity)
            capacity -= cnt
            result += (float(p)/c)*cnt
        return result if capacity == 0 else -1",O(nlogn)
"D = False

def hash(r,c):
    return str(r) + ""-"" + str(c)

def sol():
    R, C = [int(x) for x in input().split("" "")]
    m = []
    count = 0
    for _ in range(R):
        line = input()
        m.append(line)
        count += line.count(""

    if D: print(""Count:"", count)

    lookup = {}
    for r in range(1, R-1):
        for c in range(1, C-1):

            if D: print(""  row,col:"", r, c)

            offset = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]
            lst = []
            fail = False

            for o in offset:

                cell = (r + o[0], c + o[1])
                if D: print(""  cell:"", cell, m[cell[0]][cell[1]])
                h = hash(cell[0], cell[1])

                if m[cell[0]][cell[1]] == ""
                    if (not h in lookup):
                        lst.append(h)

                else:
                    fail = True
                    break

            if not fail:
                for item in lst:
                    lookup[item] = True
                count -= len(lst)

    return ""YES"" if count == 0 else ""NO""

ans = sol()
print(ans)
",O(n ^ 2)
"import sys,math
from collections import deque,defaultdict
import operator as op
from functools import reduce
from itertools import permutations

I=sys.stdin.readline

def ii():
	return int(I().strip())
def li():
	return list(map(int,I().strip().split()))
def mi():
	return map(int,I().strip().split())

def ncr(n, r, p):

    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
            p - 2, p)) % p

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def valid(row,col,rows,cols,rcross,lcross):
 	return rows[row]==0 and cols[col]==0 and rcross[col+row]==0 and lcross[col-row]==0

def div(n):
	if n==1:
		return 1
	cnt=2
	for i in range(2,int(n**.5)+1):
		if n%i==0:
			if i!=n//i:
				cnt+=2
			else:
				cnt+=1
	return cnt

def isPrime(n):
	if n<=1:
		return False
	elif n<=2:
		return True
	else:
		flag=True
		for i in range(2,int(n**.5)+1):
			if n%i==0:
				flag=False
				break
		return flag

def s(b):
	ans=[]
	while b>0:
		tmp=b%10
		ans.append(tmp)
		b=b//10
	return ans

def main():
	n,k=mi()
	arr=[]
	for _ in range(n):
		x,y=mi()
		arr.append((-x,y))

	arr.sort()

	cnt=arr.count(arr[k-1])
	print(cnt)

if __name__ == '__main__':
	main()",O(nlogn)
"import itertools


class Solution(object):
    def fib(self, N):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) \
                     for col in ZB] for row in A]

        T = [[1, 1],
             [1, 0]]
        return matrix_mult([[1, 0]], matrix_expo(T, N))[0][1]",O(logn)
"class Solution(object):
    def lastNonEmptyString(self, s):
        cnt = [0]*26
        for x in s:
            cnt[ord(x)-ord('a')] += 1
        mx = max(cnt)
        result = []
        for x in reversed(s):
            if cnt[ord(x)-ord('a')] != mx:
                continue
            cnt[ord(x)-ord('a')] -= 1
            result.append(x)
        return """".join(reversed(result))",O(n)
"n = int(input())
t = [0 for i in range(2000)]
c = [0 for i in range(2000)]
for i in range(n) :
    x = int(input())
    r = 0
    ok = False
    for j in range(2000) :
        if x >> j & 1 :
            if t[j] != 0 :
                x ^= t[j]
                r ^= c[j]
            else :
                t[j] = x
                c[j] = r ^ (1 << i)
                ok = True
                break
    if ok :
        print(0)
        continue
    a = []
    for j in range(2000) :
        if r >> j & 1 :
            a.append(j)
    print(len(a))
    for y in a :
        print(y)
",np
"n,m = map(int,input().split())
arr1 = list(map(int,input().split()))
arr2 = list(map(int,input().split()))

j = 0
for i in range(n):
    if j<m and arr2[j]>=arr1[i]:
        j+=1
print(j)
",O(n)
"import sys
input = sys.stdin.readline
sys.setrecursionlimit(100000)

def getN():
    return int(input())
def getList():
    return list(map(int, input().split()))
import math

def main():

    n = getN()
    nums = getList()
    nums.sort()
    margins = [num - i for i, num in enumerate(nums)]
    for m in margins:
        if m < 0:
            print(""cslnb"")
            return
    flag = False
    if len(nums) > 1:
        if nums[0] == nums[1]:
                flag = True
    for a, b, c in zip(nums, nums[1:], nums[2:]):
        if b == c:
            if a == b or b - a == 1:
                print(""cslnb"")
                return
            if flag:
                print(""cslnb"")
                return
            flag = True

    margin = sum(margins)

    if margin % 2 == 1:
        print(""sjfnb"")
    else:
        print(""cslnb"")

if __name__ == ""__main__"":
    main()
",O(nlogn)
"n = int(input())
a = list(map(int, input().split()))
dp = [ [False,False,False,False,False] for _ in range(n) ]
dp[0] = [True, True, True, True, True]
for i in range(1, n):
	for j in range(5):
		if a[i] == a[i - 1]:
			for k in range(5):
				if k != j:
					dp[i][j] = dp[i][j] or dp[i - 1][k]
		elif a[i] > a[i - 1]:
			for k in range(j):
				dp[i][j] = dp[i][j] or dp[i - 1][k]
		else:
			for k in range(j + 1, 5):
				dp[i][j] = dp[i][j] or dp[i - 1][k]
if dp[-1].count(True) == 0:
	print(-1)
	exit(0)
j = 0
for k in range(5):
	if dp[-1][k]:
		j = k
ans = []
for i in range(n - 1, -1, -1):
	ans.append(j + 1)
	if i == 0:
		break
	if a[i] == a[i - 1]:
		for k in range(5):
			if k != j and dp[i - 1][k]:
				j = k
				break
	elif a[i] > a[i - 1]:
		for k in range(j):
			if dp[i - 1][k]:
				j = k
				break
	else:
		for k in range(j + 1, 5):
			if dp[i - 1][k]:
				j = k
				break
print(*ans[::-1])",O(n ^ 2)
"a = input()
b = input()
o = []
z = []
c0 = 0
c1 = 0
for i in b:
    if i == ""0"":
        c0 += 1

    else:
        c1 += 1

    o.append(c1)
    z.append(c0)

n = len(b)-1
m = len(a)-1
ans = 0
for i in range(len(a)):
    x = a[i]
    if x == ""1"":
        ans += z[(n-(m-i))]-z[i]
        if b[i] == ""0"":
            ans += 1

    else:
        ans += o[(n - (m - i))] - o[i]
        if b[i] == ""1"":
            ans += 1

print(ans)",O(n)
"n=int(input())
print(int(n**2+(n-1)**2))",O(1)
"n = int(input())
d1 = {}
for _ in range(n):
  a, x = map(int, input().split())
  d1[a] = x
d2 = {}
m = int(input())
for _ in range(m):
  b, y = map(int, input().split())
  d2[b] = y
ans = 0
for key in set(d1.keys()) | set(d2.keys()):
  ans += max(d1.get(key, 0), d2.get(key, 0))
print(ans)",O(nlogn)
"from os import path
import sys,time

from math import ceil, floor,gcd,log,log2 ,factorial
from collections import *

maxx = float('inf')

I = lambda :int(sys.stdin.buffer.readline())
tup= lambda : map(int , sys.stdin.buffer.readline().split())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().replace('\n', '').strip()
def grid(r, c): return [lint() for i in range(r)]
stpr = lambda x : sys.stdout.write(f'{x}' + '\n')
star = lambda x: print(' '.join(map(str, x)))
localsys = 0
start_time = time.time()
if (path.exists('input.txt')):
	sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');

n = I()
ls = [int(i) for i in S()]
pre , s =[] , 0
for i in ls:
	s+=i
	pre.append(s)
for i in range(n-1):
	cnt =0
	su =0
	for j in range(i+1 , n):
		su+=ls[j]
		if su == pre[i]:
			cnt+=1
			su =0
	if cnt and su ==0:
		print('YES')
		exit()
print('NO')

if localsys:
	print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")
",O(n ^ 2)
"point = {}

n = int(input())

for i in range(n):
    l, r = map(int, input().split())
    r += 1
    if l not in point:
        point[l] = 0
    if r not in point:
        point[r] = 0
    point[l] += 1
    point[r] -= 1

line = []
for key in point:
    line.append((key,point[key]))
line.sort()
ans = [0] * (n+1)

last_index = 0
last_value = 0

for index, value in line:
    ans[last_value] += index - last_index
    last_index = index
    last_value += value

for cnt in ans[1:]:
    print(cnt,end=' ')",O(nlogn)
"class Solution(object):
    def numOfSubarrays(self, arr, k, threshold):
        result, curr = 0, sum(itertools.islice(arr, 0, k-1))
        for i in range(k-1, len(arr)):
            curr += arr[i]-(arr[i-k] if i-k >= 0 else 0)
            result += int(curr >= threshold*k)
        return result",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def sumRootToLeaf(self, root):
        M = 10**9 + 7
        def sumRootToLeafHelper(root, val):
            if not root:
                return 0
            val = (val*2 + root.val) % M
            if not root.left and not root.right:
                return val
            return (sumRootToLeafHelper(root.left, val) +
                    sumRootToLeafHelper(root.right, val)) % M
        
        return sumRootToLeafHelper(root, 0)",O(n)
"import itertools

n, l, r, x = map(int, input().split())
C = list(map(int, input().split()))

ans = 0
for i in range(2, n+1):
  for c in itertools.combinations(C, i):
    d = sum(c)
    if d < l or d > r:
      continue
    if max(c) - min(c) < x:
      continue
    ans += 1

print(ans)",np
"class Solution(object):
    def minimumFlips(self, root, result):
        INF = float(""inf"")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y,
            4: lambda x, y: x^y ,
            5: lambda x, y: not x if x is not None else not y
        }
        
        def iter_dfs(root, result):
            ret = collections.defaultdict(lambda: INF)
            stk = [(1, (root, ret))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if not node:
                        ret[None] = 0
                        continue
                    if node.left == node.right:
                        ret[True] = node.val^1
                        ret[False] = node.val^0
                        continue
                    ret1 = collections.defaultdict(lambda: INF)
                    ret2 = collections.defaultdict(lambda: INF)
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    for k1, v1 in ret1.items():
                        for k2, v2 in ret2.items():
                            ret[OP[node.val](k1, k2)] = min(ret[OP[node.val](k1, k2)], v1+v2)
            return ret[result]

        return iter_dfs(root, result)


import collections",O(n)
"import os
import io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

from math import sqrt,ceil

max_n=10**7+1
spf = [i for i in range(max_n)]

for i in range(4,max_n,2):
    spf[i]=2

for i in range(3,ceil(sqrt(max_n))):
    if (spf[i]==i):
        for j in range(i*i,max_n,i):
            if(spf[j]==j):
                spf[j]=i

from collections import Counter,defaultdict
from bisect import insort

def f(x):
    c=Counter()
    ans=1
    while(x!=1):
        c[spf[x]]+=1
        x//=spf[x]
    for i in c:
        if(c[i]%2==1):
            ans*=i
    return(ans)

t=int(input())
for _ in range(t):
    n,k=map(int,input().split())
    a=list(map(int,input().split()))
    for i in range(n):
        a[i]=f(a[i])
    dp_depth=[[n for j in range(k+1)] for i in range(n)]
    recent=[n for i in range(k+1)]
    closest=defaultdict(lambda: -1)
    for i in range(n-1,-1,-1):
        if(closest[a[i]]>=0):
            insort(recent,closest[a[i]])
            recent.pop()
        dp_depth[i]=recent.copy()
        closest[a[i]]=i
    dp=[[i for j in range(k+1)] for i in range(n+1)]

    dp[0]=[0 for j in range(k+1)]
    for i in range(n):
        for x in range(k+1):
            end=dp_depth[i][x]

            for y in range(k-x+1):
                dp[end][x+y]=min(dp[end][x+y],dp[i][y]+1)
    print(dp[n][k])
",O(n ^ 3)
"n, m, k = map(int, input().split())

a = list(map(int, input().split()))

best = 0
dp = [0] * (n + 1)
for i in range(n):
    b2 = 0
    for j in range(max(-1, i - m), i + 1):
        b2 = max(b2, dp[j] - k + sum(a[j + 1:i + 1]))
    dp[i] = max(b2, a[i] - k)
    best = max(best, dp[i])

print(best)
",O(n ^ 2)
"import math as m

nDiscs, r = [int(x) for x in input().split()]

x = [int(x) for x in input().split()]
y = []

for i in range(len(x)):
    tempY = [r]
    for j in range(i):
        diffX = abs(x[i] - x[j])
        if diffX <= (2 * r):
            addY = m.sqrt((4 * r * r) - (diffX * diffX))
            tempY.append(y[j] + addY)
    y.append(max(tempY))

for i in range(len(y)):
    print(y[i], end=' ')
print()
",O(n ^ 2)
"details=[4,7,44,77,444,777,47,74,447,774,474,747,477]
n=int(input())
f=0
for i in details:
    if n%i==0:
        f=1
        break
if f:
    print(""YES"")
else:
    print(""NO"")",O(1)
"from itertools import combinations_with_replacement
import sys
from sys import stdin
import math
import bisect

def BinarySearch(a, x):
    i = bisect.bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i
    else:
        return -1
def iinput():
    return int(input())
def minput():
    return map(int,input().split())
def linput():
    return list(map(int,input().split()))

def fiinput():
    return int(stdin.readline())
def fminput():
    return map(int,stdin.readline().strip().split())
def flinput():
    return list(map(int,stdin.readline().strip().split()))

x,k=minput()

if(x==0):
    print(0)
else:
    mod=(10**9)+7
    a=pow(2,k,mod)
    b=((2*x)%mod-1)%mod
    ans=((a*b)%mod+1)%mod
    print(ans)",O(logn)
"s = input()
n = len(s)
Ans = 0
for i in range(n):
    for j in range(i + 1, n):
        L = i
        R = j
        while L < R and s[L] == s[R]:
            L += 1
            R -= 1
        if L < R and Ans < j - i + 1:
            Ans = j - i + 1
print(Ans)
",O(n)
"n, k = map(int, input().split())

if n == 1:
    print(0)
elif k + (k - 1) * (k - 2) // 2 < n:
    print(-1)
else:
    l = 0
    r = k - 1
    while r - l > 1:
        m = (l + r) // 2
        if  (2*k - m + 1) * m // 2 - (m - 1) >= n:
            r = m
        else:
            l = m
    print(r)
",O(logn)
"class Solution(object):
    def divisibilityArray(self, word, m):
        result = []
        curr = 0
        for c in word:
            curr = (curr*10+(ord(c)-ord('0')))%m
            result.append(int(curr == 0))
        return result",O(n)
"class Solution(object):
    def maxRepeating(self, sequence, word):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j + 1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        if len(sequence) < len(word):
            return 0

        prefix = getPrefix(word)
        result, count, j, prev = 0, 0, -1, -1
        for i in range(len(sequence)):
            while j > -1 and word[j+1] != sequence[i]:
                j = prefix[j]
            if word[j+1] == sequence[i]:
                j += 1
            if j+1 == len(word):     
                count = count+1 if i-prev == len(word) else 1
                result = max(result, count)
                j, prev = -1, i
        return result",O(n)
"from math import ceil, sqrt

t = 1
for test in range(1,t+1):
    n,m = (map(int, input().split()))
    arr = [[""."" for i in range(m)] for i in range(n)]
    arr2 = []
    for i in range(n):
        arr2.append(list(input()))
    for i in range(1,n-1):
        for j in range(1,m-1):
            if arr2[i+1][j] == arr2[i][j+1]==arr2[i+1][j+1]==arr2[i-1][j]==arr2[i][j-1]==arr2[i-1][j-1]==arr2[i+1][j-1]==arr2[i-1][j+1]==""
                arr[i+1][j] = arr[i][j+1]=arr[i+1][j+1]=arr[i-1][j]=arr[i][j-1]=arr[i-1][j-1]=arr[i+1][j-1]=arr[i-1][j+1]=""

    if arr == arr2:
        print(""YES"")
    else:
        print(""NO"")
",O(n ^ 2)
"def naiveSolve():

    return

def main():

    t=int(input())
    allans=[]
    for _ in range(t):
        n,m=readIntArr()
        grid=[]
        for __ in range(n):
            grid.append(readIntArr())
        columns=[]
        for col in range(m):
            temp=[grid[i][col] for i in range(n)]
            columns.append(temp)

        valCol=[]
        for i in range(n):
            for j in range(m):
                valCol.append((grid[i][j],j))
        valCol.sort(reverse=True)

        topCols=set()
        for val,col in valCol:
            topCols.add(col)
            if len(topCols)==n:
                break

        m2=len(topCols)
        grid2=[[-1 for __ in range(m2)] for ___ in range(n)]
        topColsList=list(topCols)
        for j in range(m2):
            col=topColsList[j]
            for i in range(n):
                grid2[i][j]=grid[i][col]
        ans=-inf
        for mask in range(n**m2):
            grid3=[[-1 for __ in range(m2)] for ___ in range(n)]
            for col in range(m2):
                shift=mask%n
                for row in range(n):
                    grid3[row][col]=grid2[(shift+row)%n][col]
                mask//=n
            tempAns=0
            for row in range(n):
                maxx=-inf
                for col in range(m2):
                    maxx=max(maxx,grid3[row][col])
                tempAns+=maxx
            ans=max(ans,tempAns)
        allans.append(ans)

    multiLineArrayPrint(allans)

    return

import sys
input=sys.stdin.buffer.readline

def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))

def readIntArr():
    return [int(x) for x in input().split()]

def makeArr(defaultValFactory,dimensionArr):
    dv=defaultValFactory;da=dimensionArr
    if len(da)==1:return [dv() for _ in range(da[0])]
    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]

def queryInteractive(r):
    print('? {}'.format(r))
    sys.stdout.flush()
    return readIntArr()

def answerInteractive(adj,n):
    print('!')
    for u in range(1,n+1):
        for v in adj[u]:
            if v>u:
                print('{} {}'.format(u,v))
    sys.stdout.flush()

inf=float('inf')
MOD=10**9+7

from math import gcd,floor,ceil

for _abc in range(1):
    main()",np
"class Solution:
    def isNStraightHand(self, hand, groupSize):
        if len(hand) % groupSize:
            return False
        count = Counter(hand)
        hand.sort()
        for num in hand:
            if count[num]:
                for i in range(num, num + groupSize):
                    if not count[i]:
                        return False
                    count[i] -= 1
        return True
",O(nlogn)
"import collections


class Solution2(object):
    def twoOutOfThree(self, nums1, nums2, nums3):
        K = 2
        cnt = collections.Counter()
        result = []
        for nums in nums1, nums2, nums3:
            for x in set(nums):
                cnt[x] += 1
                if cnt[x] == K:
                    result.append(x)
        return result",O(n)
"import sys
from array import array
import typing as Tp

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

def output(*args):
    sys.stdout.buffer.write(
        ('\n'.join(map(str, args)) + '\n').encode('utf-8')
    )

def main():
    n, m, k = map(int, input().split())
    a = list(map(float, input().split()))
    add = [[0] * n for _ in range(n + 1)]
    for xi, yi, ci in (map(int, input().split()) for _ in range(k)):
        add[xi - 1][yi - 1] = float(ci)

    minf = float('-inf')
    dp = [[minf] * (2**n) for _ in range(n + 1)]
    dp[n][0] = 0.0

    for bitset in range(2**n):
        if bin(bitset).count('1') >= m:
            continue

        for i in range(n + 1):
            if dp[i][bitset] == minf:
                continue
            for j in range(n):
                if (1 << j) & bitset:
                    continue
                dp[j][bitset | (1 << j)] = max(
                    dp[j][bitset | (1 << j)],
                    dp[i][bitset] + a[j] + add[i][j]
                )

    print(int(max(max(_dp) for _dp in dp) + 1e-7))

if __name__ == '__main__':
    main()
",np
"n = int(input())

print('0','0',n)
",O(1)
"class Solution(object):
    def canBeIncreasing(self, nums):
        deleted = False
        for i in range(1, len(nums)):
            if nums[i] > nums[i-1]:
                continue
            if deleted:
                return False
            deleted = True
            if i >= 2 and nums[i-2] > nums[i]: 
                nums[i] = nums[i-1]
        return True",O(n)
"class Solution(object):
    def colorRed(self, n):
        result = [[1, 1]]
        for i in range(2, n+1):
            if i%2 == n%2:
                result.extend([i, j] for j in range((1 if i%4 == n%4 else 3), 2*i, 2))
            else:
                result.append([i, (2 if i%4 == (n-1)%4 else 1)])
        return result",O(n ^ 2)
"x, y, z, t1, t2, t3 = map(int, input().split())
d1 = abs(x - y) * t1
d2 = abs(x - z) * t2 + abs(x - y) * t2 + 3 * t3
if d2 <= d1:
    print('YES')
else:
    print('NO')
",O(1)
"n = int(input())
d = {'red':'Reality', 'purple': 'Power', 'yellow':'Mind', 'orange':'Soul','blue':'Space','green':'Time'}
stones = ['Reality', 'Power', 'Mind', 'Soul', 'Space', 'Time']
st=[]
for _ in range(n):
    st.append(d[input()])
b=[]
for a in stones:
    if a not in st:
        b.append(a)
print(len(b))
for k in b:
    print(k)",O(1)
"class Solution(object):
    def longestDecomposition(self, text):
        def compare(text, l, s1, s2):
            for i in range(l):
                if text[s1+i] != text[s2+i]:
                    return False
            return True

        MOD = 10**9+7
        D = 26
        result = 0
        left, right, l, pow_D = 0, 0, 0, 1
        for i in range(len(text)):
            left = (D*left + (ord(text[i])-ord('a'))) % MOD
            right = (pow_D*(ord(text[-1-i])-ord('a')) + right) % MOD
            l += 1
            pow_D = (pow_D*D) % MOD 
            if left == right and compare(text, l, i-l+1, len(text)-1-i):
                result += 1
                left, right, l, pow_D = 0, 0, 0, 1
        return result",O(n)
"MOD = int(1e9)+7

def fast_power(x, y):
    res = 1
    x %= MOD
    while y > 0:
        if y % 2 == 1:
            res = (res * x) % MOD
        x = (x * x) % MOD
        y = y >> 1
    return res

x, k = map(int, input().split())
if(x == 0):
    print(0)
else:
    a = fast_power(2, k)
    b = (2 * x - 1) % MOD
    c = (a * b) % MOD + 1
    print(c % MOD)
",O(logn)
"class Solution2(object):
    def maxNumOfSubstrings(self, s):
        def find_right_from_left(s, first, last, left):
            right, i = last[ord(s[left])-ord('a')], left
            while i <= right:
                if first[ord(s[i])-ord('a')] < left:
                    return -1
                right = max(right, last[ord(s[i])-ord('a')])
                i += 1
            return right

        first, last = [float(""inf"")]*26, [float(""-inf"")]*26
        for i, c in enumerate(s):
            first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i)
            last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i)
        intervals = []
        for c in range(len(first)):
            if first[c] == float(""inf""):
                continue
            left, right = first[c], find_right_from_left(s, first, last, first[c])
            if right != -1:
                intervals.append((right, left))
        intervals.sort() 
        result, prev = [], -1
        for right, left in intervals:
            if left <= prev:
                continue
            result.append(s[left:right+1])
            prev = right
        return result",O(n)
"import collections



class Solution(object):
    def countGood(self, nums, k):
        result = curr = left = 0
        cnt = collections.Counter()
        for right in range(len(nums)):
            curr += cnt[nums[right]]
            cnt[nums[right]] += 1
            while curr >= k:
                cnt[nums[left]] -= 1
                curr -= cnt[nums[left]]
                left += 1
            result += left
        return result",O(n)
"class Solution3(object):
    def minimizeResult(self, expression):
        best = None
        min_val = float(""inf"")
        pos = expression.index('+')
        for i in range(pos):
            for j in range(pos+1, len(expression)):
                val = (int(expression[:i] or ""1"")*
                       (int(expression[i:pos])+int(expression[pos+1:j+1]))*
                       int(expression[j+1:] or ""1"")) 
                if val < min_val:
                    min_val = val
                    best = (i, j)
        return """".join([expression[:best[0]], '(', expression[best[0]:best[1]+1], ')', expression[best[1]+1:]])",O(n ^ 2)
"from math import *
a,r = map(int,input().split())
x = list(map(int,input().split()))
y = [0]*a
for i in range(a):
    h = r
    for j in range(i):
        if abs(x[i]-x[j])<=2*r:
            h = max(h,sqrt((2*r)**2 - (x[i]-x[j])**2)+y[j])
    y[i] = h
    print(h, end = "" "")
",O(n ^ 2)
"from sys import stdout
def main():
    n = int(raw_input())
    k = 2
    a = []
    m = n
    while 1:
        t = n / k
        if t <= 1:
            k /= 2
            a.extend([k] * m)
            a[-1] = n / k * k
            break
        a.extend([k / 2] * (m - t))
        m = t
        k *= 2
    stdout.write(' '.join(map(str, a)))
main()
",O(n)
"class BIT(object): 
    def __init__(self, n):
        self.__bit = [0]*(n+1)

    def add(self, i, val):
        i += 1
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def query(self, i):
        i += 1
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret



class Solution(object):
    def minMovesToMakePalindrome(self, s):
        idxs = [[] for _ in range(26)]
        for i, c in enumerate(s):
            idxs[ord(c)-ord('a')].append(i)
        targets, pairs = [0]*len(s), []
        for c, idx in enumerate(idxs):
            for i in range(len(idx)//2):
                pairs.append((idx[i], idx[~i]))
            if len(idx)%2:
                targets[idx[len(idx)//2]] = len(s)//2
        pairs.sort()
        for i, (l, r) in enumerate(pairs):
            targets[l], targets[r] = i, (len(s)-1)-i
        bit = BIT(len(s))
        result = 0
        for i in targets:
            result += i-bit.query(i-1) 
            bit.add(i, 1)
        return result",O(nlogn)
"k = int(input())
x = [0,9]
i = 2
y = 90
while x[-1] < 10**12:
    x.append(x[-1]+y*i)
    y *= 10
    i += 1
if k in x:
    print(9)
else:
    for t in range(len(x)):
        if k < x[t]:
            break
    e = k-x[t-1]
    if t == 1:q=str(e)
    else:q =str(10**(t-1)+e//t-1)
    if e%t == 0:
        print(q[-1])
    else:
        q = str(int(q)+1)
        print(q[e%t-1])
",O(logn)
"import sys
n=int(input())
ind=0
dig=0
for i in range(1,12):
    dig+=i*10**(i-1)*9

    if dig>n:
        ind=i-1
        rt=dig-i*10**(i-1)*9
        break
n-=rt
no=10**ind

if n==0:
    print(9)
    sys.exit()
u=n
n-=(n//(ind+1))*(ind+1)
no+=max(0,(u//(ind+1))-1)

if n==0:
    print(str(no)[-1])
else:
    no+=1
while(n>0):
    if n<=ind+1:
        e=str(no)
        print(e[n-1])
    n-=ind+1
    no+=1
",O(logn)
"class Solution(object):
    def accountBalanceAfterPurchase(self, purchaseAmount):
        return 100-(purchaseAmount+5)//10*10",O(1)
"class Solution(object):
    def maximizeWin(self, prizePositions, k):
        dp = [0]*(len(prizePositions)+1)
        result = left = 0
        for right in range(len(prizePositions)):
            while prizePositions[right]-prizePositions[left] > k:
                left += 1
            dp[right+1] = max(dp[right], right-left+1)
            result = max(result, dp[left]+(right-left+1))
        return result",O(n)
"class Solution(object):
    def countWays(self, nums):
        cnt = [0]*(len(nums)+1)
        for x in nums:
            cnt[x] += 1
        result = prefix = 0
        for i in range(len(nums)+1):
            if prefix == i and cnt[i] == 0:
                result += 1
            prefix += cnt[i]
        return result",O(n)
"class Solution2(object):
    def minChanges(self, n, k):
        def popcount(x):
            return bin(x).count('1')

        return popcount(n^k) if n|(n^k) == n else -1",O(logn)
"import io, sys
input = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip()

ii = lambda: int(input())
mi = lambda: map(int, input().split())
li = lambda: list(mi())

n = ii()
a = li()
p = a.index(max(a))
b = sorted(a)
b.pop()
ok = 1
i, j = p - 1, p + 1
while i >= 0 or j < n:
    if i >= 0 and a[i] == b[-1]:
        b.pop()
        i -= 1
    elif j < n and a[j] == b[-1]:
        b.pop()
        j += 1
    else:
        ok = 0
        break
print('YES' if ok else 'NO')",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def main():
    pass

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def lts(l):
    s = ''.join(map(str, l))
    return s

def stl(s):

    l = list(s)

    return l

def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans

def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1

    return (cnt)

def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)

mod = int(1e9) + 7
import math

n=int(input())
d={}
for i in range(n-1):
    u,v=map(int,input().split())
    d.setdefault(u,[]).append(v)
    d.setdefault(v,[]).append(u)
node=1
for key in d:
    if(len(d[key])>len(d[node])):
        node=key
ans=[]
visited=[0]*n
visited[node-1]=1
for c in d[node]:
    while(True):
        visited[c-1]=1
        if(len(d[c])==1):
            ans.append([node,c])
            break
        for child in d[c]:
            if(visited[child-1]!=1):
                c=child
                break
if(sum(visited)==n):
    print(""Yes"")
    print(len(ans))
    for c in ans:
        print(*c)
else:
    print(""No"")",O(n)
"n=int(input())
print(int(n/2+1))",O(1)
"class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        cnt = k
        res = root.val

        def dfs(node):
            nonlocal cnt, res
            if not node:
                return

            dfs(node.left)
            cnt -= 1
            if cnt == 0:
                res = node.val
                return
            dfs(node.right)

        dfs(root)
        return res
",O(n)
"
import pandas as pd



def Solution(students: pd.DataFrame) -> pd.DataFrame:
    return students.rename(columns={
        ""id"" : ""student_id"",
        ""first"" : ""first_name"",
        ""last"" : ""last_name"",
        ""age"" : ""age_in_years"",
    })
",O(n)
"a = input()
b = input()
digits = {}
def greedy(digits,s):
    for i in range(9,-1,-1):
        d = str(i)
        if d in digits:
            while digits[d] > 0:
                s += d
                digits[d] -= 1
    return s
for d in a:
    if d in digits:
        digits[d] += 1
    else:
        digits[d] = 1
if len(a) < len(b):
    print(greedy(digits,""""))
else:
    ind = 0
    cur = """"
    back = False
    done = False
    while 1:
        if ind == len(a) or done == True:
            break
        found = False
        for i in range(9,-1,-1):
            x = str(i)
            if i == int(b[ind]) and x in digits and digits[x] > 0:
                found = True
                digits[x] -= 1
                cur += x
                break
            elif i < int(b[ind]) and x in digits and digits[x] > 0:
                found = True
                done = True
                digits[x] -= 1
                cur += x
                print(greedy(digits,cur))
                break
        if found == False:
            back = True
            break
        ind += 1

    if back == False and done == False:
        print(cur)
    elif done == False:
        for i in range(ind-1,-1,-1):
            digits[cur[i]] += 1
            for j in range(9,-1,-1):
                d = str(j)
                if j < int(b[i]) and d in digits and digits[d] > 0:
                    done = True
                    s = cur[:i]
                    s += d
                    digits[d] -= 1
                    print(greedy(digits,s))
                    break
            if done:
                break",O(n ^ 3)
"import sys

n,m=map(int,input().split())
A=list(map(int,input().split()))

if n==1:
    print(0)
    sys.exit()

A.sort(reverse=True)

NOW=A[0]
ANS=1
i=1
while i<n:
    if A[i]==A[i-1]:
        NOW=max(1,NOW-1)
        ANS+=1
    else:
        if A[i]>=NOW-1:
            ANS+=1
            NOW=max(NOW-1,1)
        else:
            ANS+=max(1,NOW-A[i])
            NOW=A[i]
    i+=1

ANS+=(NOW-1)
print(sum(A)-ANS)
",O(nlogn)
"class Solution(object):
    def haveConflict(self, event1, event2):
        return max(event1[0], event2[0]) <= min(event1[1], event2[1])",O(1)
"class Solution(object):
    def findRoot(self, tree):
        root = 0
        for node in tree:
            root ^= id(node)
            for child in node.children:
                root ^= id(child)
        for node in tree:
            if id(node) == root:
                return node
        return None",O(n)
"def find(n,k):
    x=9+8*(n+k)
    a=(-3+int(x**0.5))//2
    b=n-a
    return b
n,k=list(map(int,input().strip().split(' ')))
print(find(n,k))",O(1)
"n, k = map(int, input().split())

def prod(n):
	if n%2:
		return n*((n+1)//2)
	else:
		return (n//2)*(n+1)

def total_count(n, k):
	if k >= n:
		return (0, 0, 1)
	else:
		count = 0
		l = 1; r = k
		s = prod(k)
		while l <= r:
			mid = (l+r)//2
			if n > s - prod(mid) + mid:
				r = mid-1
			else:
				l = mid+1

		n = n - (s - prod(l) + l)
		count += (k-l+1)
		k = l-1
		return (n, k, count)

if prod(k) - (k-1) < n:
	print(-1)
elif n == 1:
	print(0)
elif k >= n:
	print(1)
else:
	n = n-k
	k = k-2
	count = 1
	while n > 0:
		(n, k, temp) = total_count(n, k)
		count += temp
	print(count)",O(logn)
"import collections
import itertools


class Solution(object):
    def threeSumMulti(self, A, target):
        count = collections.Counter(A)
        result = 0
        for i, j in itertools.combinations_with_replacement(count, 2):
            k = target - i - j
            if i == j == k:
                result += count[i] * (count[i]-1) * (count[i]-2) // 6
            elif i == j != k:
                result += count[i] * (count[i]-1) // 2 * count[k]
            elif max(i, j) < k:
                result += count[i] * count[j] * count[k]
        return result % (10**9 + 7)",O(n ^ 2)
"class Solution(object):
    def findLeaves(self, root):
        def findLeavesHelper(node, result):
            if not node:
                return -1
            level = 1 + max(findLeavesHelper(node.left, result), \
                            findLeavesHelper(node.right, result))
            if len(result) < level + 1:
                result.append([])
            result[level].append(node.val)
            return level

        result = []
        findLeavesHelper(root, result)
        return result",O(n)
"import collections


class Solution(object):
    def numTilePossibilities(self, tiles):
        fact = [0.0]*(len(tiles)+1)
        fact[0] = 1.0
        for i in range(1, len(tiles)+1):
            fact[i] = fact[i-1]*i
        count = collections.Counter(tiles)

        
        coeff = [0.0]*(len(tiles)+1)
        coeff[0] = 1.0
        for i in count.values():
            new_coeff = [0.0]*(len(tiles)+1)
            for j in range(len(coeff)):
                for k in range(i+1):
                    if k+j >= len(new_coeff):
                        break
                    new_coeff[j+k] += coeff[j]*1.0/fact[k]
            coeff = new_coeff

        result = 0
        for i in range(1, len(coeff)):
            result += int(round(coeff[i]*fact[i]))
        return result",O(n ^ 2)
"import collections



class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def deleteDuplicatesUnsorted(self, head):
        count = collections.defaultdict(int)
        curr = head
        while curr:
            count[curr.val] += 1
            curr = curr.__next__
        curr = dummy = ListNode(0, head)
        while curr.__next__:
            if count[curr.next.val] == 1:
                curr = curr.__next__
            else:
                curr.next = curr.next.__next__
        return dummy.__next__",O(n)
"n,m=map(int,input().split())
count=[0]*n
a=list(map(int,input().split()))
for i in range(m):
    count[a[i]-1]+=1
print(min(count))",O(n ^ 2)
"s=input()
m=0
n=len(s)
for i in range(n-1):
    for j in range(i,n+1) :
        if s[i:j] in s[i+1:n] and len(s[i:j])>m:
            m=len(s[i:j])
print(m)",O(n ^ 3)
"a,b=map(int,input().split(' '))
print((b+a-1)//a)",O(1)
"T = (0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889)
k = int(input())
a = 0
for i in T:
    if i - k > 0:
        a = T.index(i)
        break
temp = T[a] - k
x = temp % a
res = (10 ** a) - 1 - int(temp / a)
ans = int((res % (10 ** (x+1))) / (10 ** x))
print(ans)
",O(logn)
"x, k = list(map(int,input().split()))
m = 1000000000 +7
if x!=0:
    p1 = x*2 - 1
    p2 = x*2
    p = (p1 + p2)//2
    print((p*pow(2,k,m) + 1)%m)
else:
    print(x*2)
",O(logn)
"n = int(input())
l = [int(x) - 1 for x in input().split()]
parity = 0
explore = set(l)
while len(explore) > 0:
    x = explore.pop()
    tmp = x
    found = [x]
    while l[tmp] != x:
        tmp = l[tmp]
        found.append(tmp)
    for i in found[1:]:
        explore.remove(i)
    parity ^= (len(found) - 1) % 2

if parity == n % 2:
    print(""Petr"")
else:
    print(""Um_nik"")",O(nlogn)
"n = int(input())
A = map(int, input().split())
a = []
for x in A:
	a.append(x)
tot = 0
for i in range(n):
	l = i
	r = n - i - 1
	tot += a[i] * l + -a[i] * r

from collections import defaultdict

for_cnt = defaultdict(int)

for i in range(n):
	fault = for_cnt[a[i] - 1] + for_cnt[a[i] + 1] + for_cnt[a[i]]
	tot -= a[i] * fault
	for_cnt[a[i]] += 1

back_cnt = defaultdict(int)

i = n - 1
while i >= 0:
	fault = back_cnt[a[i] - 1] + back_cnt[a[i] + 1] + back_cnt[a[i]]
	tot -= -a[i] * fault
	back_cnt[a[i]] += 1
	i -= 1

print(tot)
",O(nlogn)
"import bisect


class Solution(object):
    def sampleStats(self, count):
        n = sum(count)
        mi = next(i for i in range(len(count)) if count[i]) * 1.0
        ma = next(i for i in reversed(range(len(count))) if count[i]) * 1.0
        mean = sum(i * v for i, v in enumerate(count)) * 1.0 / n
        mode = count.index(max(count)) * 1.0
        for i in range(1, len(count)):
            count[i] += count[i-1]
        median1 = bisect.bisect_left(count, (n+1) // 2)
        median2 = bisect.bisect_left(count, (n+2) // 2)
        median = (median1+median2) / 2.0
        return [mi, ma, mean, median, mode]",O(n)
"class Solution3(object):
    def sumCounts(self, nums):
        MOD = 10**9+7
        result = 0
        for i in range(len(nums)):
            lookup = set()
            for j in reversed(range(i+1)):
                lookup.add(nums[j])
                result = (result+len(lookup)**2) % MOD
        return result",O(n ^ 2)
"n=int(input())
l=list(map(int,input().split()))
r=list(map(int,input().split()))
c=[n]*n
for i in range(n):
    c[i]-=(r[i]+l[i])
for i in range(n):
    m=0
    for j in range(0,i):
        if c[j]>c[i]:
            m+=1
    if m!=l[i]:
        exit(print('NO'))
for i in range(n):
    m=0
    for j in range(i+1,n):
        if c[j]>c[i]:
            m+=1
    if m!=r[i]:
        exit(print('NO'))
print('YES')
print(*(c))
",O(n ^ 2)
"from sys import stdin
MOD = 1000000007
s = stdin.readline().strip()
n = len(s)
buc = [0] * 101
fac = [0] * (n + 1)
inv = [0] * (n + 1)
dp = [0] * (n + 1)

ans = [[0] * 55 for _ in range(55)]

def find(c: 'str') -> 'int':
    if 'A' <= c <= 'Z':
        return ord(c) - ord('A') + 26
    else:
        return ord(c) - ord('a')

def add(a: 'int', b: 'int') -> 'int':
    a += b
    if a >= MOD:
        a -= MOD
    return a

def sub(a: 'int', b: 'int') -> 'int':
    a -= b
    if a < 0:
        a += MOD
    return a

for i in s:
    buc[find(i)] += 1

fac[0] = 1
for i in range(1, n + 1):
    fac[i] = (fac[i - 1] * i) % MOD
inv[n] = pow(fac[n], MOD - 2, MOD)
for i in range(n - 1, -1, -1):
    inv[i] = (inv[i + 1] * (i + 1)) % MOD

num = pow(fac[n // 2], 2, MOD)
for i in range(0, 52):
    num = (num * inv[buc[i]]) % MOD

dp[0] = 1

for i in range(0, 52):
    if not buc[i]:
        continue
    for j in range(n, buc[i] - 1, -1):
        dp[j] = add(dp[j], dp[j - buc[i]])

for i in range(52):
    ans[i][i] = dp[n // 2]

for i in range(52):
    if not buc[i]:
        continue
    temp_dp = dp.copy()
    for k in range(buc[i], n + 1):
        temp_dp[k] = sub(temp_dp[k], temp_dp[k - buc[i]])

    for j in range(i + 1, 52):
        if not buc[j]:
            continue
        for k in range(buc[j], n + 1):
            temp_dp[k] = sub(temp_dp[k], temp_dp[k - buc[j]])

        ans[i][j] = (2 * temp_dp[n // 2]) % MOD

        for k in range(n, buc[j] - 1, -1):
            temp_dp[k] = add(temp_dp[k], temp_dp[k - buc[j]])

q = int(input())
l = stdin.read().splitlines()
for i in l:
    x, y = map(int, i.split())
    l, r = find(s[x - 1]), find(s[y - 1])
    if l > r:
        l, r = r, l
    print(num * ans[l][r] % MOD)
",O(n ^ 3)
"n = int(input())

m = input()

s = list(m)

if n==1:
    ans = s[0]
else:
    count = 0
    for i in range(0,n):
        if s[i]=='0':
            count = count + 1
    ans = '1'
    for i in range(0,count):
        ans = ans + '0'

print(ans)",O(n)
"from heapq import heappush, heappop
class MinCostFlow:
    INF = 10**18

    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap, cost):
        forward = [to, cap, cost, None]
        backward = forward[3] = [fr, 0, -cost, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def flow(self, s, t, f):
        N = self.N; G = self.G
        INF = MinCostFlow.INF

        res = 0
        H = [0]*N
        prv_v = [0]*N
        prv_e = [None]*N

        d0 = [INF]*N
        dist = [INF]*N

        while f:
            dist[:] = d0
            dist[s] = 0
            que = [(0, s)]

            while que:
                c, v = heappop(que)
                if dist[v] < c:
                    continue
                r0 = dist[v] + H[v]
                for e in G[v]:
                    w, cap, cost, _ = e
                    if cap > 0 and r0 + cost - H[w] < dist[w]:
                        dist[w] = r = r0 + cost - H[w]
                        prv_v[w] = v; prv_e[w] = e
                        heappush(que, (r, w))
            if dist[t] == INF:
                return None

            for i in range(N):
                H[i] += dist[i]

            d = f; v = t
            while v != s:
                d = min(d, prv_e[v][1])
                v = prv_v[v]
            f -= d
            res += d * H[t]
            v = t
            while v != s:
                e = prv_e[v]
                e[1] -= d
                e[3][1] += d
                v = prv_v[v]
        return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

n,m = map(int,input().split())

G = MinCostFlow(n+2)
coef = [0 for i in range(n)]
edge = []
for _ in range(m):
    x,y,b = map(int,input().split())
    G.add_edge(y,x,10**18,-1)
    coef[x-1] += b
    coef[y-1] -= b
    edge.append((x,y))

s = 0
for i in range(n):
    if coef[i]<0:
        G.add_edge(0,i+1,-coef[i],0)
        s -= coef[i]
    elif coef[i]>0:
        G.add_edge(i+1,n+1,coef[i],0)

f = G.flow(0,n+1,s)

Edge = [[] for i in range(n)]
use = [False]*m
uf = UnionFindVerSize(n)
for i in range(m):
    u,v = edge[i]
    for e in G.G[u]:
        to = e[0]
        if to==v and e[1]:
            Edge[v-1].append((u-1,1))
            Edge[u-1].append((v-1,-1))
            use[i] = True
            uf.unite(u-1,v-1)

edge = [(edge[i][0],edge[i][1]) for i in range(m) if not use[i]]
for u,v in edge:
    if not uf.is_same_group(u-1,v-1):
        Edge[v-1].append((u-1,1))
        Edge[u-1].append((v-1,-1))
        uf.unite(u-1,v-1)

used_1 = [False]*n
used_2 = [False]*n
lazy = [0 for i in range(n)]
a = [0 for i in range(n)]
def dfs(v,pv):
    lazy[v] = min(lazy[v],a[v])
    for nv,c in Edge[v]:
        if not used_1[nv]:
            used_1[nv] = True
            a[nv] = a[v] + c
            dfs(nv,v)
            lazy[v] = min(lazy[v],lazy[nv])

def add(v,pv,ff):
    a[v] += ff
    for nv,c in Edge[v]:
        if not used_2[nv]:
            used_2[nv] = True
            add(nv,v,ff)

for i in range(n):
    if not used_1[i]:
        used_1[i] = True
        dfs(i,-1)
        used_2[i] = True
        add(i,-1,-lazy[i]+1)

print(*a)
",np
"class Solution(object):
    def maxPower(self, s):
        result, count = 1, 1
        for i in range(1, len(s)):
            if s[i] == s[i-1]:
                count += 1
            else:
                count = 1
            result = max(result, count)
        return result",O(n)
"class Solution:
    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:
        if len(hand) % groupSize != 0:
            return False
        count = Counter(hand)
        for num in hand:
            start = num
            while count[start - 1]:
                start -= 1
            while start <= num:
                while count[start]:
                    for i in range(start, start + groupSize):
                        if not count[i]:
                            return False
                        count[i] -= 1
                start += 1
        return True
",O(n)
"import math

n=int(input())
k=1
while(n > 9*k*(10**(k-1))):
    n = n - 9*k*(10**(k-1))
    k = k + 1
remainder = n%k
if remainder == 0:
    remainder = k
if k==1:
    quoteint = math.ceil(n/k)
else:
    adder = ""9""*(k-1)
    adder = int(adder)
    quoteint = math.ceil(n/k) + adder
print(str(quoteint)[remainder-1])
",O(logn)
"class Solution(object):
    def numFactoredBinaryTrees(self, A):
        M = 10**9 + 7
        A.sort()
        dp = {}
        for i in range(len(A)):
            dp[A[i]] = 1
            for j in range(i):
                if A[i] % A[j] == 0 and A[i] // A[j] in dp:
                    dp[A[i]] += dp[A[j]] * dp[A[i] // A[j]]
                    dp[A[i]] %= M
        return sum(dp.values()) % M",O(n ^ 2)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

prime = [True for i in range(200001)]
pp=[0]*200001
def SieveOfEratosthenes(n=200000):

    p = 2
    while (p * p <= n):

        if (prime[p] == True):

            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1

n,k = map(int,input().split())
arr = list(map(int,input().split()))
xors = defaultdict(int)
xors[0]=1
comp = (1<<k)-1
ans = n*(n+1)//2
xor = 0
for a in arr:
	xor^=a
	if xors[xor]>xors[comp^xor]:
		xor^=comp
	ans-=xors[xor]
	xors[xor]+=1
print(ans)",O(n)
"from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__

class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):

    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):

    self.out.append(str(text))

  def writeLine(self, text):

    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

def bootstrap(f, stack=[]):

  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc

class MDArray(object):

  def __init__(self, dimensions, initial_value=0):

    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):

    return self.arr[self._index(indexes)]

  def set(self, indexes, value):

    self.arr[self._index(indexes)] = value
    return value

def encode(row, col, n, m):
  return row * m + col

def solve(node, remain, adj, dp, n, m):
  if remain == 0:
    return 0

  key = (node + remain * n * m)
  mem = dp[key]
  if mem != -1:
    return mem

  ans = min(map(lambda x: solve(x[0], remain-1,
            adj, dp, n, m) + x[1], adj[node]))
  dp[key] = ans
  return ans

def main(inp, out):

  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = [-1] * (n*m*(k/2+1))

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(solve(node, k/2, adj, dp, n, m) * 2)
    out.writeLine(' '.join(map(str, ans)))

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",O(n ^ 3)
"class Solution2(object):
    def numberOfWays(self, n):
        MOD = 10**9+7
        def count_1_2_6(n):
            return (n//2+1)*((n//6)-0+1)-3*((n//6)+0)*((n//6)-0+1)//2

        return reduce(lambda x, y: (x+count_1_2_6(n-4*y))%MOD, (i for i in range(min(n//4, 2)+1)), 0)",O(1)
"def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]

n = INT()
arr = LIST()
k = []
i = 0
while 2 ** i <= 10**18 :
    k.append(2 ** i)
    i+=1

d = {}
s1 = set()
for i in arr:
    s1.add(i)
    if i not in d :
        d[i] = 1
    else:
        d[i]+=1

s2 = set()
for i in s1 :
    flag = False
    for j in k :
        x = j - i
        y = -1
        try:
            y = d[x]
        except:
            y = -1
        if y != -1:
            if x == i and d[i] == 1:
                continue
            flag = True
            break
    if flag==False:
        s2.add(i)

res = 0
for i in s2 :
    res+=d[i]
print(res)
",O(nlogn)
"class Solution(object):
    def minimumEffort(self, tasks):
        tasks.sort(key=lambda x: x[1]-x[0]) 
        result = 0
        for a, m in tasks: 
            result = max(result+a, m)
        return result",O(nlogn)
"def getArray():
    return list(map(int, input().split()))
def createDP(R, G, B):
    dp = []
    for i in range(R):
        temp1 = []
        for j in range(G):
            temp2 = []
            for k in range(B):
                temp2.append(-1)
            temp1.append(temp2)
        dp.append(temp1)
    return dp
def go(r, g, b, R, G, B, ri, gi, bi, state):
    if state[ri][gi][bi] != -1 :
        return state[ri][gi][bi]
    best = 0
    if ri < R and gi < G:
        best = max(best, r[ri]*g[gi] + go(r, g, b, R, G, B, ri+1, gi+1, bi, state))
    if ri < R and bi < B:
        best = max(best, r[ri]*b[bi] + go(r, g, b, R, G, B, ri+1, gi, bi+1, state))
    if gi < G and bi < B:
        best = max(best, g[gi]*b[bi] + go(r, g, b, R, G, B, ri, gi+1, bi+1, state))

    state[ri][gi][bi] = best
    return best

R,G,B = map(int, input().split())
r = getArray()
g = getArray()
b = getArray()
r.sort(reverse = True)
g.sort(reverse = True)
b.sort(reverse = True)
dp = createDP(201,201,201)
print(go(r, g, b, R, G, B, 0, 0, 0, dp))",O(n ^ 3)
"class Solution(object):

    def __init__(self, k):
        self.__start = 0
        self.__size = 0
        self.__buffer = [0] * k

    def insertFront(self, value):
        if self.isFull():
            return False
        self.__start = (self.__start-1) % len(self.__buffer)
        self.__buffer[self.__start] = value
        self.__size += 1
        return True

    def insertLast(self, value):
        if self.isFull():
            return False
        self.__buffer[(self.__start+self.__size) % len(self.__buffer)] = value
        self.__size += 1
        return True

    def deleteFront(self):
        if self.isEmpty():
            return False
        self.__start = (self.__start+1) % len(self.__buffer)
        self.__size -= 1
        return True

    def deleteLast(self):
        if self.isEmpty():
            return False
        self.__size -= 1
        return True

    def getFront(self):
        return -1 if self.isEmpty() else self.__buffer[self.__start]

    def getRear(self):
        return -1 if self.isEmpty() else self.__buffer[(self.__start+self.__size-1) % len(self.__buffer)]

    def isEmpty(self):
        return self.__size == 0

    def isFull(self):
        return self.__size == len(self.__buffer)",O(1)
"class Solution(object):
    def pivotInteger(self, n):
        x = int(((n+1)*n//2)**0.5+0.5)
        return x if x**2 == (n+1)*n//2 else -1",O(1)
"class Solution3(object):
    def triangularSum(self, nums):
        for i in reversed(range(len(nums))):
            for j in range(i):
                nums[j] = (nums[j]+nums[j+1])%10
        return nums[0]",O(n ^ 2)
"class Solution(object):
    def gameResult(self, head):
        cnt = 0
        while head:
            cnt += cmp(head.val, head.next.val)
            head = head.next.__next__
        return ""Tie"" if cnt == 0 else ""Odd"" if cnt < 0 else ""Even""",O(n)
"mod = 998244353
eps = 10**-9

def main():
    import sys
    input = sys.stdin.readline

    N = int(input())
    A = list(map(int, input().split())) + [0]
    A.sort()

    dp = [[0] * (i+1) for i in range(N+1)]
    dp[0][0] = 1
    l = 0
    for i in range(1, N+1):
        for ll in range(l+1, i):
            if A[ll] * 2 <= A[i]:
                l = ll
            else:
                break
        for j in range(1, l+2):
            dp[i][j] = (dp[l][j-1] + (dp[i][j-1] * (l-j+2))%mod)%mod
        for j in range(i):
            dp[i][j] = (dp[i-1][j] + dp[i][j])%mod
    print(dp[-1][-1])

if __name__ == '__main__':
    main()
",O(n ^ 3)
"import sys
input = sys.stdin.readline

n, m = map(int, input().split())
mask = (1 << m) - 1

l = []
for i in range(n):
    l.append(list(map(int,input().split())))

lo = -1
hi = 10 ** 9 + 1
while hi - lo > 1:
    test = (hi + lo) // 2

    things = dict()
    for i in range(n):
        curr = 0
        for v in l[i]:
            curr *= 2
            if v >= test:
                curr += 1
        things[curr] = i

    works = False
    for v1 in things:
        for v2 in things:
            if v1 | v2 == mask:
                outi = things[v1]
                outj = things[v2]
                works = True
                break
        if works:
            break

    if works:
        lo = test
    else:
        hi = test

print(outi + 1, outj + 1)
",np
"import random
for _ in range(int(input())):
    N, M = map(int, input().split())
    X = [[int(a) for a in input().split()] for _ in range(N)]
    Y = [[X[i][j] for i in range(N)] for j in range(M)]
    ma = 0
    for t in range(99):
        for i in range(M):
            a = random.randrange(N)
            Y[i] = [Y[i][j-a] for j in range(N)]
        ma = max(ma, sum([max([Y[i][j] for i in range(M)]) for j in range(N)]))
    print(ma)
",np
"from sys import stdin,stdout
from collections import Counter
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
def pos(n):
    t=0
    for k,v in d.items():
        if v>=n:t+=v//n
    return t>=p
for _ in range(1):
    p,n=lst()
    d=Counter(lst())
    ans=0
    for sel in range(1,n+1):
         if pos(sel):ans=max(ans,sel)
    print(ans)",O(nlogn)
"class Solution(object):
    def thousandSeparator(self, n):
        result = []
        s = str(n)
        for i, c in enumerate(str(n)):
            if i and (len(s)-i)%3 == 0:
                result.append(""."")
            result.append(c)
        return """".join(result)",O(n)
"class Solution2(object):
    def numberOfRounds(self, startTime, finishTime):
        h1, m1 = list(map(int, startTime.split("":"")))
        h2, m2 = list(map(int, finishTime.split("":"")))
        if m1 > m2:
            h2 -= 1
            m2 += 60
        return max((h2-h1)%24*4 + m2//15 - (m1+15-1)//15, 0)",O(1)
"class Solution2(object):
    def decodeCiphertext(self, encodedText, rows):
        cols = len(encodedText)//rows
        result = []
        for i in range(cols):
            for j in range(i, len(encodedText), cols+1):
                result.append(encodedText[j])
        while result and result[-1] == ' ':
            result.pop()
        return """".join(result)",O(n)
"import sys,io,os,math
try:yash=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
except:yash=lambda:sys.stdin.readline().encode()
I=lambda:[*map(int,yash().split())]
import __pypy__;an=__pypy__.builders.StringBuilder()
n,=I();lis=I();N=22;dp=[-1]*(1<<22)
for i in range(n):
    dp[lis[i]]=lis[i]
    for j in range(22):
        lis[i]^=(1<<j)
for mask in range(1<<22):
    for i in range(22):
        if (mask&(1<<i)) and dp[mask^(1<<i)]!=-1:dp[mask]=dp[mask^(1<<i)]
for num in lis:
    an.append(""%s ""%(dp[num]))
an.append(""\n"")
os.write(1, an.build().encode())",np
"class Solution(object):
    def maximumValueSum(self, nums, k, edges):
        result = parity = 0
        diff = float(""inf"")
        for x in nums:
            y = x^k
            result += max(x, y)
            parity ^= int(x < y)
            diff = min(diff, abs(x-y))
        return result-parity*diff",O(n)
"from sys import stdin,stdout
stdout.flush()
def qu(a,b):
    print(""?"",a,b)
    return int(input())
a=0
b=0
big=qu(a,b)
for i in range(29,-1,-1):
    x=2**i
    f=qu(a+x,b)
    l=qu(a,b+x)
    if l==f:
        if big==1:
            a+=x
        else:
            b+=x
        big=f
    elif f==-1:
        a+=x
        b+=x
print(""!"",a,b)
",O(logn)
"l1,r=map(int,input().split())
if(l1==r):
    print(0)
else:
    if(r&(r-1)==0):
        print(r^(r-1))
    else:
        x=l1^r
        p1=1
        while(p1<=x):
            p1*=2
        print(p1-1)
",O(logn)
"n, v = map(int, raw_input().split())

res=0
fuel=0
for i in range(1,n):
    miss = min(v-fuel, n-i-fuel)
    res+=i*miss
    fuel+=miss-1
    if v-fuel==0:
        print(res)
        exit(0)
print(res)",O(n)
"def good(x1, y1, x2, y2):
    if (x1 > x2):
        x1, x2 = x2, x1
        y1, y2 = y2, y1
    return (x2 >= y1)

def check(cent):
    for i in range(n):
        if (not good(cent - t, cent + t, x[i] - a[i], x[i] + a[i])):
            return 0
    return 1

n, t = map(int, input().split())
x = [0] * n
a = [0] * n
for i in range(n):
    x[i], a[i] = map(int, input().split())
    x[i] *= 2

ans = set()

for i in range(n):
    val1 = x[i] - a[i] - t
    val2 = x[i] + a[i] + t
    if (check(val1)):
        ans.add(val1)
    if (check(val2)):
        ans.add(val2)
print(len(ans))
",O(nlogn)
"class Solution(object):
    def doubleIt(self, head):
        if head.val >= 5:
            head = ListNode(0, head)
        curr = head
        while curr:
            curr.val = (curr.val*2)%10
            if curr.__next__ and curr.next.val >= 5:
                curr.val += 1
            curr = curr.__next__
        return head",O(n)
"class Solution(object):
    def mergeArrays(self, nums1, nums2):
        result = []
        i = j = 0
        while i < len(nums1) or j < len(nums2):
            if j == len(nums2) or (i < len(nums1) and nums1[i][0] < nums2[j][0]):
                if result and result[-1][0] == nums1[i][0]:
                    result[-1][1] += nums1[i][1]
                else:
                    result.append(nums1[i])
                i += 1
            else:
                if result and result[-1][0] == nums2[j][0]:
                    result[-1][1] += nums2[j][1]
                else:
                    result.append(nums2[j])
                j += 1
        return result",O(n)
"class Solution(object):
    def countKConstraintSubstrings(self, s, k, queries):
        def count(l):
            return (l+1)*l//2

        result = cnt = left = 0
        prefix = [0]*(len(s)+1)
        lookup = [-1]*len(s)
        for right in range(len(s)):
            cnt += int(s[right] == '1')
            while not (cnt <= k or (right-left+1)-cnt <= k):
                cnt -= int(s[left] == '1')
                left += 1
            result += right-left+1
            prefix[right+1] = prefix[right]+(right-left+1)
            lookup[left] = right
        assert(lookup[0] != -1)
        for i in range(len(s)-1):
            if lookup[i+1] == -1:
                lookup[i+1] = lookup[i]
        return [count(min(lookup[left], right)-left+1)+(prefix[right+1]-prefix[min(lookup[left], right)+1]) for left, right in queries]",O(n)
"k1,k2,k3=map(int,input().split())
fl=0
for i1 in range(5):
    for i2 in range(5):
        for i3 in range(5):
            flak=1
            for i in range(8):
                if (i-i1)%k1==0 or (i-i2)%k2==0 or (i-i3)%k3==0:
                    continue
                else:
                    flak=0
            if flak==1:
                fl=1
if fl==1:
    print(""YES"")
else:
    print(""NO"")",O(1)
"import sys

input = sys.stdin.readline

n = int(input())
a = list(map(int, input().split()))
a.sort()
if a[-1] == 1: ans = a[:-1] + [2]
else: ans = [1] + a[:-1]
print(*ans)
",O(nlogn)
"class Solution2(object):
    def maxLevelSum(self, root):
        result, level, max_total = 0, 1, float(""-inf"")
        q = collections.deque([root])
        while q:
            total = 0
            for _ in range(len(q)):
                node = q.popleft()
                total += node.val
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            if total > max_total:
                result, max_total = level, total
            level += 1
        return result",O(n)
"import collections


class Solution(object):
    def numberOfSubstrings(self, s):
        return sum(v*(v+1)//2 for v in collections.Counter(s).values())",O(n)
"from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

def mapin():
    return map(int, input().split())

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
x, k = mapin()
p = 1000000007
if(x == 0):
    print(0)
else:
    a = power(2, k, p)

    b = x+x-1
    b %= p
    a = (a*b) % p
    a += 1
    a %= p
    print(a)",O(logn)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

for t in range(ii()):
    n, k = mi()
    if n == 1:
        ans = 'YES 0' if k == 1 else 'NO'
    elif n == 2:
        if k <= 2:
            ans = 'YES 1'
        elif k == 3 or k > 5:
            ans = 'NO'
        else:
            ans = 'YES 0'
    elif n <= 32 and k > (4 ** n - 1) // 3:
        ans = 'NO'
    else:
        c, x = 0, n
        p2 = 2
        while x > 0:
            if c + p2 - 1 > k:
                break
            c += p2 - 1
            x -= 1
            p2 *= 2
        ans = 'YES %d' % (x,)
    print(ans)
",O(logn)
"class Solution2(object):
    def differenceOfSums(self, n, m):
        return (n+1)*n//2 - 2*(((n//m+1)*(n//m)//2)*m)",O(1)
"n = int(input())

p = []
for i in range(n):
    la = list(map(float,input().split()))
    p.append(la)

full_bit =  (1<<n) - 1
dp = [0]*(full_bit) + [1]

for i in range(full_bit,0,-1):

    cunt = bin(i)[2:].count('1')

    if cunt == 1 or dp[i] == 0:
        continue

    mul = 1/((cunt*(cunt-1))>>1)

    for x in range(n):
        if (i & (1<<x)) == 0:
            continue
        for y in range(x+1,n):
            if (i & (1<<y)) == 0:
                continue

            dp[i-(1<<y)]+=dp[i]*p[x][y]*mul
            dp[i-(1<<x)]+=dp[i]*p[y][x]*mul

ans = []
for i in range(n):
    ans.append(dp[1<<i])

print(*ans)
",np
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def averageOfSubtree(self, root):
        def iter_dfs(root):
            result = 0
            stk = [(1, (root, [0]*2))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if not node:
                        continue
                    ret1, ret2 = [0]*2, [0]*2
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    ret[0] = ret1[0]+ret2[0]+node.val
                    ret[1] = ret1[1]+ret2[1]+1
                    result += int(ret[0]//ret[1] == node.val)
            return result
        
        return iter_dfs(root)",O(n)
"class Solution(object):
    def numOfMinutes(self, n, headID, manager, informTime):
        children = collections.defaultdict(list)
        for child, parent in enumerate(manager):
            if parent != -1:
                children[parent].append(child)

        result = 0
        stk = [(headID, 0)]
        while stk:
            node, curr = stk.pop()
            curr += informTime[node]
            result = max(result, curr)
            if node not in children:
                continue
            for c in children[node]:
                stk.append((c, curr))
        return result",O(n)
"def wzor(n):
    return (n*(n+1))/2

def mafia():
    pom = [int(x) for x in input().split()]
    n = pom[0]
    c = pom[1]

    po = 1
    ko = n
    sr = (po + ko)//2
    while po != ko:
        if wzor(sr)-(n-sr) >= c:
            ko = sr
        else:
            po = sr+1
        sr = (po+ko)//2

    print(int(wzor(po)-c))

mafia()
",O(logn)
"n, k = map(int, input().split())
arr = [int(x) for x in input().split()]
diff = [0] * (n - 1)
p = arr[-1] - arr[0]
for i in range(n - 1):
    diff[i] = arr[i + 1] - arr[i]
diff.sort(reverse=True)
print(p - sum(diff[:k - 1]))
",O(nlogn)
"class Solution(object):
    def numSpecial(self, mat):
        rows, cols = [0]*len(mat), [0]*len(mat[0])
        for i in range(len(rows)):
            for j in range(len(cols)):
                if mat[i][j]:
                    rows[i] += 1
                    cols[j] += 1
        result = 0
        for i in range(len(rows)):
            for j in range(len(cols)):
                if mat[i][j] == rows[i] == cols[j] == 1:
                    result += 1
        return result",O(n ^ 2)
"import math
import heapq,bisect
import sys
from collections import deque,defaultdict
from fractions import Fraction
mod=10**9+7
mod1=998244353

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree1:
    def __init__(self, data, default=9999999, func=lambda a, b: min(a , b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a + b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m

def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z

def product(l):
    por=1
    for i in range(len(l)):
        por*=l[i]
    return por

def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        if (arr[mid] <= key):

            count = mid + 1
            left = mid + 1

        else:
            right = mid - 1

    return count

def countdig(n):
    c=0
    while(n>0):
        n//=10
        c+=1
    return c
def countGreater(arr, n, k):
    l = 0
    r = n - 1

    leftGreater = n

    while (l <= r):
        m = int(l + (r - l) / 2)

        if (arr[m] > k):
            leftGreater = m
            r = m - 1

        else:
            l = m + 1

    return (n - leftGreater)

def findmin(h,n):
    n.sort()
    h=int(h)
    ans='-1'

    for i in n:
        if int(i)>h:
            break
        ans=i

    return ans
n=list(input())
n1=list(input())
if len(n)<len(n1):
    n.sort(reverse=True)
    print(*n,sep='')
    sys.exit()
n.sort()
ans=""""
f=0
for i in range(len(n)):
    t=i-1
    c=0
    r = findmin(n1[i], n)
    if r=='-1':
        while(r=='-1'):
            n.append(ans[-c-1])
            r=findmin(int(n1[t])-1,n)
            t-=1
            c+=1
        ans=ans[:len(ans)-c]
        ans+=r
        n.remove(r)
        f=1
        break
    n.remove(r)
    if r==n1[i]:
        ans+=r
        continue
    else:
        ans+=r
        f=1
        break
if f==1:
    n.sort(reverse=True)
    for i in n:
        ans+=i
print(ans)",O(n ^ 3)
"class Solution(object):
    def findThePrefixCommonArray(self, A, B):
        result = [0]*len(A)
        cnt = collections.Counter()
        curr = 0
        for i, (a, b) in enumerate(zip(A, B)):
            cnt[a] += 1
            if cnt[a] == 2:
                curr += 1
            cnt[b] += 1
            if cnt[b] == 2:
                curr += 1
            result[i] = curr
        return result",O(n)
"line = input().split()
line.sort()
a,b,c = line
if a == b and a == c:
    print(0)
elif a == b:
    print(1)
elif b == c:
    print(1)
else:
    if a[1] == b[1] and b[1] == c[1] \
        and int(b[0])-int(a[0]) == 1 and int(c[0])-int(b[0]) == 1:
        print(0)
    elif a[1] == b[1] and int(b[0])-int(a[0]) in [1,2]:
        print(1)
    elif b[1] == c[1] and int(c[0])-int(b[0]) in [1,2]:
        print(1)
    elif a[1] == c[1] and int(c[0])-int(a[0]) in [1,2]:
        print(1)
    else:
        print(2)
",O(nlogn)
"class Solution(object):
    def isUnivalTree(self, root):
        s = [root]
        while s:
            node = s.pop()
            if not node:
                continue
            if node.val != root.val:
                return False
            s.append(node.left)
            s.append(node.right)
        return True
    ",O(n)
"def solution():
    k = int(input())
    k -= 1
    n, m = 1, 9
    while k > n*m:
        k, n, m = k - n*m, n+1, m*10

    x = str(10**(n-1) + k//n)[k % n]

    print(x)

if __name__ == ""__main__"":
    solution()
",O(logn)
"import sys

n = int(sys.stdin.buffer.readline().decode('utf-8'))
cost = [0] + \
    list(map(int, sys.stdin.buffer.readline().decode('utf-8').split()))
a = [line.decode('utf-8').rstrip() for line in sys.stdin.buffer]

mask = [0, 1, 51, 1911]
inf, bs_size, full_bit = 10**9, 1 << 12, (1 << 12) - 1
dp = [[inf]*bs_size for _ in range(4*n+1)]
dp[0][0] = 0

for i in range(4*n):
    y, x = i & 3, i >> 2
    is_dot = 1 if a[y][x] == '.' else 0

    for bitset in range(bs_size):
        if y == 0:

            if dp[i+4][full_bit] > dp[i][bitset] + cost[4]:
                dp[i+4][full_bit] = dp[i][bitset] + cost[4]

        if (is_dot | bitset & 1) and\
                dp[i+1][bitset >> 1] > dp[i][bitset]:
            dp[i+1][bitset >> 1] = dp[i][bitset]

        for k in range(1, min(4-y, 3)+1):
            if dp[i][bitset | mask[k]] > dp[i][bitset] + cost[k]:
                dp[i][bitset | mask[k]] = dp[i][bitset] + cost[k]

print(min(dp[4*n]))
",O(n)
"class Solution2(object):
    def minSideJumps(self, obstacles):
        dp = [1, 0, 1]        
        for i in obstacles:
            if i:
                dp[i-1] = float(""inf"")
            for j in range(3):
                if j+1 != i:
                    dp[j] = min(dp[0]+(j != 0), dp[1]+(j != 1), dp[2]+(j != 2))
        return min(dp)",O(n)
"class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        self.count -= 1
        return True


class Solution(object):
    def minCostToSupplyWater(self, n, wells, pipes):
        w = [[c, 0, i] for i, c in enumerate(wells, 1)]
        p = [[c, i, j] for i, j, c in pipes]
        result = 0
        union_find = UnionFind(n+1)
        for c, x, y in sorted(w+p):
            if not union_find.union_set(x, y):
                continue
            result += c
            if union_find.count == 1:
                break
        return result",O(nlogn)
"import collections


class Solution(object):
    def canReach(self, arr, start):
        q, lookup = collections.deque([start]), set([start])
        while q:
            i = q.popleft()
            if not arr[i]:
                return True
            for j in [i-arr[i], i+arr[i]]:
                if 0 <= j < len(arr) and j not in lookup:
                    lookup.add(j)
                    q.append(j) 
        return False",O(n)
"class Solution3(object):
    def findRoot(self, tree):
        root = 0
        for node in tree:
            root += node.val-sum(child.val for child in node.children)
        for node in tree:
            if node.val == root:
                return node
        return None",O(n)
"class Solution(object):

    def __init__(self):
        self.__s = []

    def next(self, price):
        result = 1
        while self.__s and self.__s[-1][0] <= price:
            result += self.__s.pop()[1]
        self.__s.append([price, result])
        return result",O(1)
"class Solution:
    def reverse(self, x: int) -> int:
        MIN = -2147483648
        MAX = 2147483647

        res = 0
        while x:
            digit = int(math.fmod(x, 10))
            x = int(x / 10)

            if res > MAX // 10 or (res == MAX // 10 and digit > MAX % 10):
                return 0
            if res < MIN // 10 or (res == MIN // 10 and digit < MIN % 10):
                return 0
            res = (res * 10) + digit

        return res
",O(1)
"n=int(input())
print((n+n%2)*((n+2)//2)//2)",O(n)
"a=sorted(input())

b=int(input())

a=a[::-1]

p=""""

while a:

	for i, z in enumerate(a):

		n=p+a[i]+"""".join(sorted(a[:i]+a[i+1:]))

		if int(n)<=b:

			p+=z

			a.pop(i)

			break

print(p)
",O(n ^ 3)
"from collections import defaultdict
n = int(input())
a = list(map(int, input().split()))

rec = defaultdict(list)
for j in range(n):
    for k in range(j, n):
        rec[sum(a[j:k + 1])].append((j, k))

ans = []
for k in rec.keys():
    tmp = []
    rec[k] = sorted(rec[k], key=lambda x: x[1])
    pre = -1
    for a, b in rec[k]:
        if pre >= a:
            continue
        else:
            tmp.append((a + 1, b + 1))
            pre = b
    if len(tmp) > len(ans):
        ans = tmp

print(len(ans))
for a, b in ans:
    print(a, b)",O(n ^ 3)
"fast=lambda:stdin.readline().strip()
zzz=lambda:[int(i) for i in fast().split()]
z,zz=input,lambda:list(map(int,z().split()))
szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())
from re import *
from sys import *
from math import *
from heapq import *
from queue import *
from bisect import *
from string import *
from itertools import *
from collections import *
from math import factorial as f
from bisect import bisect as bs
from bisect import bisect_left as bsl
from collections import Counter as cc
from itertools import accumulate as ac
def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))
def output(answer):stdout.write(str(answer))

s=fast()
ans=s.replace('1','')+'2'
t=ans.find('2')
print(ans[:t]+'1'*s.count('1')+ans[t:-1])
",O(n)
"from collections import *
n = int(input())
a = list(map(int,input().split()))
d = Counter(a)
ans = 0
for i in range(n):
    for j in range(31):
        s = 1<<j
        s = s-a[i]
        if d.get(s)!=None and ((d[s]==1 and s!=a[i]) or d[s]>=2):
            break
    else:
        ans+=1
print(ans)",O(nlogn)
"import sys, math
import io, os

from bisect import bisect_left as bl, bisect_right as br, insort

from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n')
def out(var): sys.stdout.write(str(var) + '\n')
from decimal import Decimal

INF = 10001
mod = int(1e9) + 7

n=int(data())
a=mdata()
ans=[n]
dp1=[[0]*n for i in range(n)]
dp2=[[n]*n for i in range(n)]
for i in range(n-1,-1,-1):
    dp1[i][i]=a[i]
    dp2[i][i]=1
    for j in range(i+1,n):
        for k in range(i,j):
            if dp1[i][k] == dp1[k+1][j] != 0:
                dp1[i][j] = dp1[i][k] + 1
                dp2[i][j] = 1
            dp2[i][j] = min(dp2[i][j], dp2[i][k] + dp2[k + 1][j])
out(dp2[0][n-1])",O(n ^ 3)
"def bin(a):
    if a <= 1:
        return a
    else:
        return 10*bin(a//2)+a%2

def convBin(a):
    k,i = 0,0
    while a!=0:
        k += (a%10)*int((2**i))
        a //= 10
        i += 1
    return k

def maxi(a,b):
    if a == b:
        return 0
    elif a+1 == b:
        return a^b
    elif a+2 == b:
        x = a^(a+1)
        y = a^(a+2)
        z = (a+1)^(a+2)
        return max(max(x,y),z)
    else:
        x = str(bin(a^b))
        y = '1'*len(x)
        return convBin(int(y))
a = list(map(int,input().split()))
print(maxi(a[0],a[1]))
",O(logn)
"import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return map(int, minp().split())

n = mint()
a = [0]*n
dp = [0]*n
for i in range(n):
	a[i] = tuple(mints())
a.sort()
for i in range(n):
	x, p = a[i]
	l = -1
	r = n
	v = x-p
	while r-l > 1:
		c = (l + r)//2
		if a[c][0] >= v:
			r = c
		else:
			l = c
		if l == -1:
			dp[i] = i-l-1
		else:
			dp[i] = i-l-1+dp[l]

z = 1e9
for i in range(n):
	z = min(z,dp[i]+n-i-1)
print(z)",O(n)
"import collections

def main():

    n = int(input())
    left = list(map(int, input().split()))
    right = list(map(int, input().split()))
    res = [0] * n
    val = n

    if all(not left[i] and not right[i] for i in range(n)):
        print(""YES"")
        print(' '.join(['1'] * n))
        return

    while not all(not left[i] and not right[i] for i in range(n)):
        zeroSet = set()
        for i in range(n):
            if not left[i] and not right[i] and res[i] == 0:
                zeroSet.add(i)
                res[i] = val
        for v in zeroSet:
            for i in range(v + 1, n):
                if i not in zeroSet and res[i] == 0:
                    left[i] -= 1
            for i in range(v):
                if i not in zeroSet and res[i] == 0:
                    right[i] -= 1
        val -= 1

        if not zeroSet:
            print(""NO"")
            return

    for i in range(n):
        if not res[i]:
            res[i] = str(val)
        else:
            res[i] = str(res[i])
    if any(i == '0' for i in res):
        print(""NO"")
        return
    print(""YES"")
    print(' '.join(res))

main()
",O(n ^ 2)
"class Solution3(object):
    def specialArray(self, nums):
        MAX_NUM = 1000
        def counting_sort(nums, reverse=False): 
            count = [0]*(MAX_NUM+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            result = [0]*len(nums)
            if not reverse:
                for num in reversed(nums): 
                    count[num] -= 1
                    result[count[num]] = num
            else:
                for num in nums: 
                    count[num] -= 1
                    result[count[num]] = num
                result.reverse()
            return result
    
        nums = counting_sort(nums, reverse=True) 
        left, right = 0, len(nums)-1
        while left <= right: 
            mid = left + (right-left)//2
            if nums[mid] <= mid:
                right = mid-1
            else:
                left = mid+1
        return -1 if left < len(nums) and nums[left] == left else left",O(n)
"ser = [0, 1]
def fib(n):
    i = 1
    while i < n:
        ser.append(i)
        i = ser[-1] + ser[-2]
    if i != n:
        return -1
    else:
        return len(ser)

n = int(input())
a, b, c = 0, 0, 0
ans = 1
if n == 0:
    ans = 1
elif n == 1:
    a = 1
elif n == 2:
    a = 1
    b = 1
elif n == 3:
    a = 1
    b = 1
    c = 1
else:
    ans = fib(n)
    if ans != -1:
        a = ser[ans-2]
        b = ser[ans-2]
        c = ser[ans-3]
if ans != -1:
    print(a, b, c)
else:
    print(""I'm too stupid to solve this problem"")
",O(1)
"import random
astr=input()
N=int(astr)
s=input()
sk=s.split(' ')
ml=[int(i) for i in sk]
kl=[0 for i in ml]

k=0
for i in range(0,N):
    if kl[i]==0:
        kl[i]=1
        j=ml[i]
        k=k+1
        while(kl[j-1]==0):
            kl[j-1]=1
            j=ml[j-1]

if k%2==0: print(""Petr"")
else: print(""Um_nik"")
",O(nlogn)
"class Solution(object):
    def distinctAverages(self, nums):
        lookup = set()
        nums.sort()
        left, right = 0, len(nums)-1
        while left < right:
            lookup.add(nums[left]+nums[right])
            left, right = left+1, right-1
        return len(lookup)",O(nlogn)
"def solve():
    n, k = [int(x) for x in input().split(' ')]
    t = input()
    j = 0
    for i in range(1, n):
        if t[:i] == t[-i:]:
            j = i
    s = t + (k - 1) * t[-(n - j):]
    return s

print(solve())
",O(n ^ 2)
"n=int(input())
arr=list(map(int,input().split()))
maxval=max(arr)
maxindex=-1
for i in range(n):
	if(arr[i]==maxval):
		maxindex=i
		break

flag=0
temp=maxval
for i in range(maxindex-1,-1,-1):
	if(temp<=arr[i]):
		flag=1
		break
	else:
		temp=arr[i]

temp=maxval
for i in range(maxindex+1,n):
	if(arr[i]>=temp):
		flag=1
		break
	else:
		temp=arr[i]

if(flag==0):
	print(""YES"")
else:
	print(""NO"")
",O(n)
"import math as ma
import sys
from sys import exit
from decimal import Decimal as dec
from itertools import permutations

def li():
	return list(map(int , input().split()))

def num():
	return map(int , input().split())

def nu():
	return int(input())

def find_gcd(x , y):
	while (y):
		x , y = y , x % y
	return x

n=nu()
a=li()
b=li()
z=[]
for i in range(n):
	z.append((a[i]+b[i],i))
z.sort()
fl=True
x=[]
cc=0
xp=0
mp={}
np=[]
for i in range(n):
	if(a[i]>i):
		fl=False
	if(b[i]>(n-i-1)):
		fl=False
	if((n-a[i]-b[i])<=0):
		fl=False

if(fl==False):
	print(""NO"")
else:
	zz=[0]*n
	for i in range(n):
		zz[i]=(n-a[i]-b[i])
	for i in range(n):
		xl = 0
		xr = 0
		for j in range(i + 1 , n):
			if (zz[j] > zz[i]):
				xr += 1
		for j in range(i - 1 , -1 , -1):
			if (zz[j] > zz[i]):
				xl += 1
		if (xl != a[i] or xr != b[i]):
			fl = False
			break
	if (fl == True):
		print(""YES"")
		print(*zz)
	else:
		print(""NO"")
",O(n ^ 2)
"class Solution(object):
    def fractionToDecimal(self, numerator, denominator):
        result = """"
        if (numerator > 0 and denominator < 0) or (numerator < 0 and denominator > 0):
            result = ""-""

        dvd, dvs = abs(numerator), abs(denominator)
        result += str(dvd / dvs)
        dvd %= dvs

        if dvd > 0:
            result += "".""

        lookup = {}
        while dvd and dvd not in lookup:
            lookup[dvd] = len(result)
            dvd *= 10
            result += str(dvd / dvs)
            dvd %= dvs

        if dvd in lookup:
            result = result[:lookup[dvd]] + ""("" + result[lookup[dvd]:] + "")""

        return result",O(n)
"Q = int(input())

def getsum(N):
    A = (N+1)//2
    r1 = -A + A*(A+1)
    B = N // 2
    r2 = B*(B+1)
    return -r1 + r2

while Q != 0:
    L, R = map(int, input().split())
    print(getsum(R) - getsum(L-1))
    Q -= 1
",O(1)
"from math import ceil
n, k = map(int, input().split())
cou = 0
cou += ceil(n*2/k)
cou += ceil(n*5/k)
cou += ceil(n*8/k)
print(cou)",O(1)
"import math

def main():
    n,m,k,l = map(int, input().strip().split())

    t = int(k + l + m - 1) // m

    if k + l > n:
        print(-1)
        return

    if m * t > n:
        print(-1)
        return

    print(t)

if __name__ == '__main__':
    main()",O(1)
"MOD = 10**9 + 7
I = lambda:list(map(int,input().split()))
from collections import defaultdict as dd
n , = I()
d = dd(list)
for i in range(n-1):
	t = I()
	d[t[0]].append(t[1])
	d[t[1]].append(t[0])
l = I()
v = [0]*(n+1)
s = 1
what = 0
v[1] = 1
while what < s:
        a = set()
        i = l[what]
        for j in d[i]:
                if not v[j]:
                        a.add(j)
        b = set()
        for j in range(s,s + len(a)):
                b.add(l[j])
        if a!=b:
                print('No')
                exit()
        kkk = 0
        for k in a:
            kkk += 1
            v[k] = 1
        s += kkk
        what += 1
if s != n:
    print('No')
    exit()
print('Yes')
",O(nlogn)
"import collections


class Solution(object):
    def characterReplacement(self, s, k):
        result, max_count = 0, 0
        count = collections.Counter()
        for i in range(len(s)):
            count[s[i]] += 1
            max_count = max(max_count, count[s[i]])
            if result - max_count >= k:
                count[s[i-result]] -= 1
            else:
                result += 1
        return result",O(n)
"n = int(input())
m = int(input())
r = 1
for power in range(n):
    r *= 2
    if r > m:
        print(m)
        break
else:
    if r == m:
        print(0)
    else:
        print(m % r)
",O(1)
"import math

t = int(input())

def eval_(n, k):
    level = 0.5*math.log2(3*k+1)
    if n > 30:
        cond = (level - n) > 0
    else:
        cond = (3*k+1) > 4**n
    if cond:
        return ""NO""
    elif n == 2 and k == 3:
        return ""NO""
    else:
        level = math.floor(level)

        if n > 5:

            temp = 1 + 0.5*math.log2(3*(k-1) + 1)
            if n > temp:
                return ""YES "" + str(n - 1)
            else:
                return ""YES  0""
        else:
            delta = 2**(n-level)*(2**level-1)*(4**(n-level)-1)//3
            start = (4**(level)-1)//3
            if k <=(start+delta):
                return ""YES "" + str(n - level)
            else:
                return ""YES "" + str(n - level-1)

for i in range(t):
    (n, k) = [int(i) for i in input().split()]
    print(eval_(n, k))",O(1)
"from collections import deque as de
import math
from collections import Counter as cnt
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()

def isPrime(n) :

	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):

    prime_factors = []

    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2

    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic

n=int(input())
pp=n
nn=n

pl=[]
nl=[]
while pp:
    pp-=1
    pl.append(input())
while nn:
    nn-=1
    nl.append(input())
ans=0
pmc=pl.count(""M"")
mc=nl.count(""M"")
if pmc < mc:
    ans+=mc -pmc
psc=pl.count(""S"")
sc=nl.count(""S"")
if psc < sc:
    ans+=sc -psc

plc=pl.count(""L"")
lc=nl.count(""L"")
if plc < lc:
    ans+=lc -plc

pxlc=pl.count(""XL"")
xlc=nl.count(""XL"")
if pxlc < xlc:
    ans+=xlc -pxlc

pxxlc=pl.count(""XXL"")
xxlc=nl.count(""XXL"")
if pxxlc < xxlc:
    ans+=xxlc -pxxlc

pxxxlc=pl.count(""XXXL"")
xxxlc=nl.count(""XXXL"")
if pxxxlc < xxxlc:
    ans+=xxxlc -pxxxlc

pxsc=pl.count(""XS"")
xsc=nl.count(""XS"")
if pxsc < xsc:
    ans+=xsc -pxsc

pxxsc=pl.count(""XXS"")
xxsc=nl.count(""XXS"")
if pxxsc < xxsc:
    ans+=xxsc -pxxsc

pxxxsc=pl.count(""XXXS"")
xxxsc=nl.count(""XXXS"")
if pxxxsc < xxxsc:
    ans+=xxxsc -pxxxsc
print(ans)
",O(n)
"n, pos, l, r=map(int, input().split())
if l==1 and r==n:
	print(0)
elif l==1 and r!=n:
	print(abs(pos-r)+1)
elif l!=1 and r==n:
	print(abs(pos-l)+1)
else:
	print(r-l+2+min(abs(pos-l), abs(pos-r)))",O(1)
"def factorial(n):
    result = 1
    for i in range(2, n+1):
        result *= i
    return result

commands = input().strip()
received = input().strip()
n = len(commands)
positive = 0
negative = 0
count = 0
for i in range(n):
    if commands[i] == ""+"":
        positive += 1
    else:
        negative += 1
    if received[i] == ""+"":
        positive -= 1
    elif received[i] == ""-"":
        negative -= 1
    else:
        count += 1
cases = 2**count
probability = 0.0
if positive >= 0 and negative >= 0:
    probability = (factorial(count)/(factorial(positive)*factorial(negative)))/cases

print(""{0:.9f}"".format(probability))",np
"class Solution(object):
    def findKthNumber(self, n, k):
        result = 0

        cnts = [0] * 10
        for i in range(1, 10):
            cnts[i] = cnts[i - 1] * 10 + 1

        nums = []
        i = n
        while i:
            nums.append(i % 10)
            i /= 10

        total, target = n, 0
        i = len(nums) - 1
        while i >= 0 and k > 0:
            target = target*10 + nums[i]
            start = int(i == len(nums)-1)
            for j in range(start, 10):
                candidate = result*10 + j
                if candidate < target:
                    num = cnts[i+1]
                elif candidate > target:
                    num = cnts[i]
                else:
                    num = total - cnts[i + 1]*(j-start) - cnts[i]*(9-j)
                if k > num:
                    k -= num
                else:
                    result = candidate
                    k -= 1
                    total = num-1
                    break
            i -= 1

        return result",O(logn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def maximumAverageSubtree(self, root):
        def maximumAverageSubtreeHelper(root, result):
            if not root:
                return [0.0, 0]
            s1, n1 = maximumAverageSubtreeHelper(root.left, result)
            s2, n2 = maximumAverageSubtreeHelper(root.right, result)
            s = s1+s2+root.val
            n = n1+n2+1
            result[0] = max(result[0], s / n)
            return [s, n]

        result = [0]
        maximumAverageSubtreeHelper(root, result)
        return result[0]",O(n)
"class Solution(object):
    def wiggleSort(self, nums):
        nums.sort()
        mid = (len(nums) - 1) / 2
        nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1]",O(nlogn)
"n = int(input())
*a, = map(int, input().split())
dp = [[0 for i in range(n + 1)] for j in range(n + 1)]
for i in range(n):
    dp[0][i] = a[i]
for i in range(1, n):
    for j in range(n - i + 1):
        dp[i][j] = dp[i - 1][j] ^ dp[i - 1][j + 1]
for i in range(1, n):
    for j in range(n - i):
        dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i - 1][j + 1])
for i in range(int(input())):
    l, r = map(int, input().split())
    print(dp[r - l][l - 1])",O(n ^ 2)
"from collections import deque
n, q = map(int, input().split())
a = deque(map(int, input().split()))
b = []
m = a.index(max(a))
for i in range(m):
    a0, a1 = a.popleft(), a.popleft()
    b.append([a0, a1])
    if a0 < a1:
        a0, a1 = a1, a0
    a.appendleft(a0)
    a.append(a1)
for i in range(q):
    c = int(input())
    if c <= m:
        print('{} {}'.format(b[c-1][0], b[c-1][1]))
    else:
        c -= m+1
        c %= n-1
        print('{} {}'.format(a[0], a[c+1]))
",O(n)
"n, k = map(int, input().split())
print((k + n - 1) // n)",O(1)
"class Solution(object):
    def bestClosingTime(self, customers):
        result = mx = curr = 0
        for i, x in enumerate(customers):
            curr += 1 if x == 'Y' else -1
            if curr > mx:
                mx = curr
                result = i+1
        return result",O(n)
"from __future__ import division
from sys import stdin, stdout

def write(x):
    stdout.write(str(x) + ""\n"")

n = int(stdin.readline())
out = 0
for i in range(2, n + 1):
    out += 4 * (n // i - 1) * i

write(out)
",O(n)
"import collections


class Solution(object):
    def shortestSubarray(self, A, K):
        accumulated_sum = [0]*(len(A)+1)
        for i in range(len(A)):
            accumulated_sum[i+1] = accumulated_sum[i]+A[i]

        result = float(""inf"")
        mono_increasing_q = collections.deque()
        for i, curr in enumerate(accumulated_sum):
            while mono_increasing_q and curr <= \
                    accumulated_sum[mono_increasing_q[-1]]:
                mono_increasing_q.pop()
            while mono_increasing_q and \
                    curr-accumulated_sum[mono_increasing_q[0]] >= K:
                result = min(result, i-mono_increasing_q.popleft())
            mono_increasing_q.append(i)
        return result if result != float(""inf"") else -1",O(n)
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n+1) for _ in range(2024)]

d = [[] for _ in range(n)]
for j, v in enumerate(b):
	e[v][j] = j
	d[j].append(j)

for v in range(1, 2024):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)

a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])
",O(n ^ 3)
"n = int(input())
board = list(map(int,input().split("" "")))
index = list(range(0,n))
ascending = [x for _,x in sorted(zip(board,index))]

winners = n * [""""]

for c in reversed(ascending):
	if board[c] == n:
		winners[c] = ""B""

	toCheck = c - board[c]
	while(toCheck >= 0):
		if winners[toCheck] == ""B"":
			winners[c] = ""A""
		toCheck = toCheck - board[c]
	if winners[c] == """":
		toCheck = c + board[c]
		while(toCheck < n):
			if winners[toCheck] == ""B"":
				winners[c] = ""A""
			toCheck = toCheck + board[c]
	if winners[c] == """":
		winners[c] = ""B""

for i in range(n):
	print(winners[i],end="""")
print()
",O(nlogn)
"import sys

input = sys.stdin.readline

def intersection(segs):
    end = float('inf')
    start = - float('inf')
    for l, r in segs:
        end = min(end, r)
        start = max(start, l)
    return start, end

def solve():
    n = int(input())
    segs = [tuple([int(x) for x in input().split(' ')]) for s in range(n)]
    starts = {}
    ends = {}
    x = intersection(segs)
    for l, r in segs:
        if r in starts:
            starts[r] = max(starts[r], l)
        else:
            starts[r] = l
        if l in ends:
            ends[l] = min(ends[l], r)
        else:
            ends[l] = r

    b = segs.copy()
    b.remove((x[0], ends[x[0]]))
    y = intersection(b)

    c = segs.copy()
    c.remove((starts[x[1]], x[1]))
    z = intersection(c)

    return max(x[1] - x[0], y[1] - y[0], z[1] - z[0], 0)

print(solve())
",O(n)
"class Solution(object):
    def reversePairs(self, nums):
        def merge(nums, start, mid, end):
            r = mid + 1
            tmp = []
            for i in range(start, mid + 1):
                while r <= end and nums[i] > nums[r]:
                    tmp.append(nums[r])
                    r += 1
                tmp.append(nums[i])
            nums[start:start+len(tmp)] = tmp

        def countAndMergeSort(nums, start, end):
            if end - start <= 0:
                return 0

            mid = start + (end - start) / 2
            count = countAndMergeSort(nums, start, mid) + countAndMergeSort(nums, mid + 1, end)
            r = mid + 1
            for i in range(start, mid + 1):
                while r <= end and nums[i] > nums[r] * 2:
                    r += 1
                count += r - (mid + 1)
            merge(nums, start, mid, end)
            return count

        return countAndMergeSort(nums, 0, len(nums) - 1)",O(nlogn)
"from sys import stdin,stdout
from math import ceil
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int, stdin.readline().split()))
for _ in range(1):
    n=nmbr()
    a=lst()
    p=0
    ans=float('inf')
    for i in range(n):
        turns=ceil((a[i]-i)/n)
        if turns<ans:
            ans=turns
            p=i
    print(p+1)",O(n)
"import collections
import time
import os
import sys
import bisect
import heapq
from typing import List

def check(val, A, M):
    s = set()
    for row in A:
        v = 0
        for u in row:
            v <<= 1
            if u >= val:
                v |= 1
        s.add(v)

    x = 1 << M
    for u in s:
        for v in range(x):
            if v in s and u | v == x - 1:
                return True

    return False

def getAnswer(val, A, M):
    vi = {}
    for i, row in enumerate(A):
        v = 0
        for u in row:
            v <<= 1
            if u >= val:
                v |= 1
        vi[v] = i

    x = 1 << M
    for u in vi:
        for v in range(x):
            if v in vi and u | v == x - 1:
                return vi[u], vi[v]

    return 0, 0

def solve(N, M, A):
    lo, hi = 0, max([max(row) for row in A])

    while lo <= hi:
        m = (lo + hi) // 2
        if check(m, A, M):
            lo = m + 1
        else:
            hi = m - 1

    a, b = getAnswer(hi, A, M)
    print('{} {}'.format(a + 1, b + 1))

N, M = map(int, input().split())
A = []
for i in range(N):
    row = [int(x) for x in input().split()]
    A.append(row)

solve(N, M, A)
",np
"n,p,v = input().split()
x= list(map(int,input().split()))

x.sort()
print(x[int(v)]-x[int(v)-1])",O(nlogn)
"n, m = map(int, input().split())
sun, su, ans = 0, 0, 0
dif = []
for i in range(n):
    a, b = map(int, input().split())
    sun += a; su += b
    dif.append(a - b)
if(su > m):print(-1)
elif(sun == m):print(0)
else:
    dif.sort()
    j = n - 1
    while(sun > m):
        sun -= dif[j]
        ans += 1
        j -= 1
    print(ans)",O(nlogn)
"n, k = map(int, input().split())
a = list(map(int, input().split()))
b = []
for i in range(n - 1):
    b.append(a[i + 1] - a[i])
b.sort()
print(sum(b[:len(b) - k + 1]))",O(nlogn)
"def sum(l):
    s=0
    for i in range(len(l)):
        s+=l[i]
    return s

n=int(input())
cns=list(map(int,input().split()))
xs,nm,c=0,0,0
cns.append(0)
while(xs<=nm):
    m=max(cns)
    cns.remove(m)
    xs+=m
    nm=sum(cns)
    c+=1
print(c)
",O(nlogn)
"import io
import os

from collections import Counter, defaultdict, deque

DEBUG = False

def bisect_f(f, lo, hi):
    if DEBUG:
        assert f(lo) and not f(hi)
    while hi - lo > 1:
        mid = (lo + hi) // 2
        if f(mid):
            lo = mid
        else:
            hi = mid
        if DEBUG:
            assert f(lo) and not f(hi)
    if DEBUG:
        assert hi - lo == 1
        assert f(lo) and not f(hi)
    return lo

def solve(N, M, arrs):
    def isPossible(target):
        possible = set()
        for arr in arrs:
            mask = 0
            for pos, x in enumerate(arr):
                if x >= target:
                    mask += 1 << pos
            possible.add(mask)
        allMask = (1 << M) - 1
        for mask1 in possible:
            for mask2 in possible:
                if mask1 | mask2 == allMask:
                    return (mask1 << 8) + mask2
        return 0

    lo = min(arrs[0])
    hi = 10 ** 9 + 1
    index = bisect_f(isPossible, lo, hi)

    mask1, mask2 = divmod(isPossible(index), 1 << 8)
    ans = [-1, -1]
    for i, arr in enumerate(arrs):
        mask = 0
        for pos, x in enumerate(arr):
            if x >= index:
                mask += 1 << pos
        if mask == mask1:
            ans[0] = str(i + 1)
        if mask == mask2:
            ans[1] = str(i + 1)
    return "" "".join(ans)

if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    N, M = [int(x) for x in input().split()]
    arrs = [[int(x) for x in input().split()] for i in range(N)]
    ans = solve(N, M, arrs)
    print(ans)
",np
"class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        queue = deque([root])
        while queue:
            node = queue.popleft()
            node.left, node.right = node.right, node.left
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        return root
",O(n)
"n, s = map(int,input().split())

def digs(k):
	r = k
	while k:
		r -= k % 10
		k //= 10
	return r
x = s + 19*9
while digs(x-1) >= s:
	x -= 1
print(max(n - x + 1, 0))",O(logn)
"class Solution(object):
    def largestInteger(self, num):
        def count(num):
            cnt = [0]*10
            while num:
                num, d = divmod(num, 10)
                cnt[d] += 1
            return cnt

        cnt = count(num)
        result = 0
        digit = [0, 1]
        base = 1
        while num:
            num, d = divmod(num, 10)
            while not cnt[digit[d%2]]:
                digit[d%2] += 2
            cnt[digit[d%2]] -= 1
            result += digit[d%2]*base
            base *= 10
        return result",O(logn)
"from collections import namedtuple
n = int(input())
vertex = namedtuple('vertex', ['degree', 'id'])
a, b, c = [], [], 0

rr = list(map(int, input().split()))

for i in range(n):
    tmp = rr[i]
    v = vertex(tmp, i + 1)
    if tmp > 1:
        a.append(v)
    else:
        b.append(v)
    c += tmp

if c < (n - 1)*2:
    print('NO')
else:
    if len(a) == 0:
        print('YES 1')
        print('1 2')
    else:
        print('YES', len(a) - 1 + min(2, len(b)))
        print(n - 1)
        for i in range(len(a)):
            if i == 0:
                continue
            print(a[i - 1].id, a[i].id)
        if len(b) > 0:
            print(b[0].id, a[0].id)
        if len(b) > 1:
            print(b[1].id, a[-1].id)
        j = 2
        for i in range(len(a)):
            if j >= len(b):
                yes = 1
                break
            k = a[i].degree - 2
            yes = 0
            for t in range(k):
                print(a[i].id, b[j].id)
                j += 1
                if j >= len(b):
                    yes = 1
                    break
            if yes == 1:
                break",O(n)
"import sys
input = sys.stdin.readline
n = int(input())
s = list(map(int,input().split()))
c = list(map(int,input().split()))
d = {}
for i in range(n-1):
    ans = 10**12
    for j in range(i+1,n):
        if s[i] < s[j]:
            ans = min(ans,c[i]+c[j])

    d[i] = ans

ans = 10**12
for i in range(n-2):
    for j in range(i+1,n-1):
        if s[i] < s[j]:
            ans = min(ans,c[i]+d[j])

if ans == 10**12:
    print(-1)

else:
    print(ans)",O(n ^ 2)
"class Solution(object):
    def longestPrefix(self, s):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j != -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix
        
        return s[:getPrefix(s)[-1]+1]",O(n)
"k = input()
k = int(k)

n = 1
while (k - n*9*(10**(n-1)) > 0):
    k = k - n*9*(10**(n-1))
    n = n + 1

n = n - 1

if n == 0:
    print(k)
else:
    nth_num = (k-1) // (n+1) + 1
    num = 10**n + nth_num - 1
    pos = (k-1) % (n+1)
    print(int(str(num)[pos]))
",O(logn)
"import sys

f = sys.stdin

def line():
    return f.readline().strip().split()

def powers(limit):
    size = limit+1
    p = [1]*size
    for n in range(1,size):
        p[n] = 2*p[n-1] % M

    return p

def binomials(limit):
    size = limit+1
    bc = [[0 for k in range(size)] for n in range(size)]
    for n in range(size):
        bc[n][0]=1

    for n in range(1,size):
        for k in range(1,n+1):
            bc[n][k] = bc[n-1][k-1] + bc[n-1][k]
            bc[n][k] %= M

    return bc

def solve():

    dp = [[0 for _ in range(N)] for _ in range(N)]
    dp[0][0]=1

    for i in range(1,N):
        for k in range(1,i):
            for j in range(1,i):
                dp[i][j] += BC[j+1][i-k] * dp[k-1][j-1-(i-k-1)] * POW[i-k-1]
                dp[i][j] %= M
        dp[i][i] = POW[i]

    res=0
    for j in range(0,N):
        res = (res + dp[N-1][j]) % M

    return str(res)

T = 1
for test in range(1,T+1):
    N,M = map(int,line())

    BC = binomials(N)
    POW = powers(N)

    print(solve())

f.close()",O(n ^ 3)
"tam,q = [int(i) for i in input().split()]
t = input()
s = t

posi = -1

for j in range(tam-1):
    if(t[:j+1] == t[tam - j -1:]):
        posi = j

add = t[posi+1:]

for j in range(q-1):
    s += add

print(s)",O(n ^ 2)
"n=int(input())
print(2*(n*(n-1))+1)
",O(1)
"n = int(input())
a = list(map(int, input().split()))
res = []
if n == 1:
    print(1)
    exit(0)

i = 0
if a[0] < a[1]:

    if i >= n - 2:
        res = [1]
        cur = 2
    else:
        if a[i + 1] < a[i + 2]:
            res = [1]
            cur = 2
        elif a[i + 1] > a[i + 2]:
            res = [1]
            cur = 5
        else:
            res = [1]
            cur = 2

elif a[0] > a[1]:

    if i >= n - 2:
        res = [5]
        cur = 4
    else:
        if a[i + 1] < a[i + 2]:
            res = [5]
            cur = 1
        elif a[i + 1] > a[i + 2]:
            res = [5]
            cur = 4
        else:
            res = [5]
            cur = 4

else:
    if i >= n - 2:
        res.append(1)
        cur = 2
    else:
        if a[i + 1] < a[i + 2]:
            res.append(2)
            cur = 1
        elif a[i + 1] > a[i + 2]:
            res.append(4)
            cur = 5
        else:
            res.append(2)
            cur = 3

for i in range(1, n - 1):
    if not (1 <= cur <= 5):

        print(-1)
        exit(0)
    res.append(cur)
    if a[i] > a[i + 1]:

        if i >= n - 2:
            cur -= 1
        else:
            if a[i + 1] < a[i + 2]:
                cur = min(cur - 1, 1)
            elif a[i + 1] > a[i + 2]:
                cur -= 1
            else:
                cur -= 1

    elif a[i] < a[i + 1]:

        if i >= n - 2:
            cur += 1
        else:
            if a[i + 1] < a[i + 2]:
                cur += 1
            elif a[i + 1] > a[i + 2]:
                cur = max(cur + 1, 5)
            else:
                cur += 1

    else:
        if i >= n - 2:
            if cur != 3:
                cur = 3
            else:
                cur = 2
        else:
            if a[i + 1] < a[i + 2]:
                if cur == 1:
                    cur = 2
                else:
                    cur = 1
            elif a[i + 1] > a[i + 2]:
                if cur == 5:
                    cur = 4
                else:
                    cur = 5
            else:
                if cur != 3:
                    cur = 3
                else:
                    cur = 2
if not (1 <= cur <= 5):

    print(-1)
    exit(0)
res.append(cur)
print(*res)
",O(n)
"class Solution(object):
    def waysToBuildRooms(self, prevRoom):
        MOD = 10**9+7
        fact = [1, 1]
        inv = [0, 1]
        inv_fact = [1, 1]
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def dfs(adj, curr):
            total_ways, total_cnt = 1, 0
            for child in adj[curr]:
                ways, cnt = dfs(adj, child)
                total_cnt += cnt
                total_ways = (((total_ways*ways) % MOD)*nCr(total_cnt, cnt)) % MOD
            return total_ways, total_cnt+1

        adj = [[] for _ in range(len(prevRoom))]
        for i in range(1, len(prevRoom)):
            adj[prevRoom[i]].append(i)
        return dfs(adj, 0)[0]",O(n)
"def main():
    n, m = list(map(int, input().split()))
    b = list(map(int, input().split()))
    g = list(map(int, input().split()))
    b.sort()
    g.sort()
    if b[-1] > g[0]:
        print(-1)
        return
    if b[-1] == g[0]:
        print(sum(g) + m * (sum(b) - b[-1]))
        return
    if n == 1:
        print(-1)
        return
    print(sum(g) + b[-1] + b[-2] * (m - 1) + m * (sum(b) - b[-1] - b[-2]))
main()",O(nlogn)
"n,m=map(int,input().split())
vert=[]
for i in range(n):
    vert.append(int(input()))
horiz=[]
for i in range(m):
    a,b,c=map(int,input().split())
    if a==1:
        horiz.append(b)
vert.sort()
vert.append(1000000000)
vert.append(2000000000)
horiz.sort()
oof=[0]*(n+2)
b=0
for i in range(len(horiz)):
    while True:
        if horiz[i]<vert[b]:
            oof[b]+=1
            break
        else:
            b+=1
mini=1000000
bad=len(horiz)
for i in range(n+1):
    bad-=oof[i]
    if bad+i<mini:
        mini=bad+i
print(mini)",O(nlogn)
"import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return map(int, minp().split())

def add(a,b):
	return (a+b)%1000000007

def mul(a,b):
	return (a*b)%1000000007

def sub(a,b):
	return (a-b+1000000007)%1000000007

def qpow(a, b):
	r = 1
	k = a
	for i in range(17):
		if b & (1<<i):
			r = mul(r, k)
		k = mul(k, k)
	return r

n, q = mints()
a = list(minp())
c = [0]*(n+1)
for i in range(n):
	c[i+1] = c[i] + int(a[i])
for i in range(q):
	l, r = mints()
	k = (r-l+1)
	o = c[r]-c[l-1]
	z = sub(qpow(2,o),1)
	print(mul(z,qpow(2,k-o)))",O(n)
"class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        if len(nums) == 1:
            return nums[0]

        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])

        for i in range(2, len(nums)):
            dp[i] = max(dp[i - 1], nums[i] + dp[i - 2])

        return dp[-1]
",O(n)
"import math
s1=input()
s2=input()
s1p=s1.count(""+"")
s1m=s1.count(""-"")
s2p=s2.count(""+"")
s2m=s2.count(""-"")
s2q=0
if '?' in s2:
    s2q=s2.count(""?"")
if s2q==0:
    if s1p==s2p and s1m==s2m:
        print(""%.12f""%1)
    else:
        print(""%.12f""%0)
else:
    if s1p>=s2p and s1m>=s2m:
        s2q=math.factorial(s2q)/(math.factorial(s1p-s2p)*math.factorial(s1m-s2m))
        print(""%.12f""%(s2q/(2**s2.count(""?""))))
    else:
        print(""%.12f""%0)
",np
"class Solution(object):
    def stringSequence(self, target):
        return [target[:i]+chr(x) for i in range(len(target)) for x in range(ord('a'), ord(target[i])+1)]",O(n ^ 2)
"import itertools



class Solution(object):
    def getWordsInLongestSubsequence(self, n, words, groups):
        def check(s1, s2):
            return len(s1) == len(s2) and sum(a != b for a, b in zip(s1, s2)) == 1

        dp = [[1, -1] for _ in range(n)]
        for i in reversed(range(n)):
            for j in range(i+1, n):
                if groups[i] != groups[j] and check(words[j], words[i]):
                    dp[i] = max(dp[i], [dp[j][0]+1, j])
        result = []
        i = max(range(n), key=lambda x: dp[x])
        while i != -1:
            result.append(words[i])
            i = dp[i][1]
        return result",O(n ^ 2)
"class Solution2(object):
    def evenProduct(self, nums):
        result = cnt = 0
        for i, x in enumerate(nums):
            if x%2 == 0:
                cnt = i+1
            result += cnt
        return result",O(n)
"class Solution(object):
    def addedInteger(self, nums1, nums2):
        return max(nums2)-max(nums1)",O(n)
"class Solution(object):
    def widthOfBinaryTree(self, root):
        def dfs(node, i, depth, leftmosts):
            if not node:
                return 0
            if depth >= len(leftmosts):
                leftmosts.append(i)
            return max(i-leftmosts[depth]+1, \
                       dfs(node.left, i*2, depth+1, leftmosts), \
                       dfs(node.right, i*2+1, depth+1, leftmosts))

        leftmosts = []
        return dfs(root, 1, 0, leftmosts)",O(n)
"N = int(input())
terms = 1
n = 9
total = 0

while N > terms*n:
	N = N - terms*n
	total = total + n
	terms=terms+1
	n = n*10
print(str(total+(N+terms-1)//terms)[(N-1)%terms])
",O(logn)
"class Solution(object):
    def lengthLongestPath(self, input):
        def split_iter(s, tok):
            start = 0
            for i in range(len(s)):
                if s[i] == tok:
                    yield s[start:i]
                    start = i + 1
            yield s[start:]


        max_len = 0
        path_len = {0: 0}
        for line in split_iter(input, '\n'):
            name = line.lstrip('\t')
            depth = len(line) - len(name)
            if '.' in name:
                max_len = max(max_len, path_len[depth] + len(name))
            else:
                path_len[depth + 1] = path_len[depth] + len(name) + 1
        return max_len",O(n)
"from bisect import insort,bisect_right,bisect_left
from sys import stdout, stdin, setrecursionlimit
from heapq import heappush, heappop, heapify
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from string import *
from queue import *
from math import *
from re import *
from os import *

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
graph, mod, szzz =  {}, 10**9 + 7, lambda: sorted(zzz())
def getStr(): return input()
def getInt(): return int(input())
def listStr(): return list(input())
def getStrs(): return input().split()
def isInt(s): return '0' <= s[0] <= '9'
def input(): return stdin.readline().strip()
def zzz(): return [int(i) for i in input().split()]
def output(answer, end='\n'): stdout.write(str(answer) + end)
def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))

def getPrimes(N = 10**5):
    SN = int(sqrt(N))
    sieve = [i for i in range(N+1)]
    sieve[1] = 0
    for i in sieve:
        if i > SN:
            break
        if i == 0:
            continue
        for j in range(2*i, N+1, i):
            sieve[j] = 0
    prime = [i for i in range(N+1) if sieve[i] != 0]
    return prime
def primeFactor(n,prime=getPrimes()):
    lst = []
    mx=int(sqrt(n))+1
    for i in prime:
        if i>mx:break
        while n%i==0:
            lst.append(i)
            n//=i
    if n>1:
        lst.append(n)
    return lst

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]
daysInMounth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

a = int(stdin.readline())
b = getInt()

ans = ''

c = sorted(list(str(a)))

while c:
    for i in range(len(c) - 1, -1, -1):
        if int(''.join(list(ans) + [c[i]] + c[:i] + c[i + 1:])) <= b:
            ans += c[i]
            c.pop(i)
            break

stdout.write(ans)
",O(n ^ 3)
"class Solution(object):
    def minimumBuckets(self, street):
        result = 0
        street = list(street)
        for i, c in enumerate(street):
            if c != 'H' or (i and street[i-1] == 'B'):
                continue
            if i+1 < len(street) and street[i+1] == '.':
                street[i+1] = 'B'
                result += 1
            elif i and street[i-1] == '.':
                street[i-1] = 'B'
                result += 1
            else:
                return -1
        return result",O(n)
"import collections


class Solution(object):
    def subarraySum(self, nums, k):
        result = 0
        accumulated_sum = 0
        lookup = collections.defaultdict(int)
        lookup[0] += 1
        for num in nums:
            accumulated_sum += num
            result += lookup[accumulated_sum - k]
            lookup[accumulated_sum] += 1
        return result",O(n)
"n = int(input()) + 1

if n == 1:
    print(0)
else:
    if n % 2:
        print(n)
    else:
        print(n // 2)",O(1)
"n, m = map(int, input().split())
daf1 = list(map(int, input().split()))
daf2 = dict()

for i in range(n):
    daf2[i+1] = 0

for i in daf1:
    if i in daf2.keys():
        daf2[i] += 1

print(min(daf2.values()))
",O(n ^ 2)
"class Solution(object):
    def maxScore(self, cardPoints, k):
        result, total, curr, left = float(""inf""), 0, 0, 0
        for right, point in enumerate(cardPoints):
            total += point
            curr += point
            if right-left+1 > len(cardPoints)-k:
                curr -= cardPoints[left]
                left += 1
            if right-left+1 == len(cardPoints)-k:
                result = min(result, curr)
        return total-result",O(n)
"pri=998244353
dp=[[[0 for i in range(2001)] for i in range(1001)] for i in range(2)]
n,k=map(int,input().split())

for i in range(1,n+1):
    if(i==1):
        dp[0][i][1]=2
        dp[1][i][2]=2

        continue;
    for j in range(1,(2*i)+1):
        dp[0][i][j]=(dp[0][i-1][j])+(dp[0][i-1][j-1])+(2*(dp[1][i-1][j]))

        dp[0][i][j]%=pri
        dp[1][i][j]=(2*dp[0][i-1][j-1])+(dp[1][i-1][j])+(dp[1][i-1][j-2])
        dp[0][i][j]%=pri
        dp[1][i][j]%=pri
y=dp[0][n][k]+dp[1][n][k]
y%=pri
print(y)
",np
"class Solution(object):
    def isAdditiveNumber(self, num):
        def add(a, b):
            res, carry, val = """", 0, 0
            for i in range(max(len(a), len(b))):
                val = carry
                if i < len(a):
                    val += int(a[-(i + 1)])
                if i < len(b):
                    val += int(b[-(i + 1)])
                carry, val = val / 10, val % 10
                res += str(val)
            if carry:
                res += str(carry)
            return res[::-1]

        for i in range(1, len(num)):
            for j in range(i + 1, len(num)):
                s1, s2 = num[0:i], num[i:j]
                if (len(s1) > 1 and s1[0] == '0') or \
                   (len(s2) > 1 and s2[0] == '0'):
                    continue

                expected = add(s1, s2)
                cur = s1 + s2 + expected
                while len(cur) < len(num):
                    s1, s2, expected = s2, expected, add(s2, expected)
                    cur += expected
                if cur == num:
                    return True
        return False",O(n ^ 3)
"nab=input().split()
l=input().split()
nab=[int(i) for i in nab]
l=[int(i) for i in l]
l.sort()
if(l[nab[2]-1]==l[nab[2]]):
    print(0)
else:
    print(l[nab[2]]-l[nab[2]-1])
",O(nlogn)
"import sys

input = sys.stdin.readline

t = 1

while t:
    t -= 1

    n = int(input())
    a = list(map(int, input().split()))
    b = sorted(a)

    diffs = []
    for i in range(n):
        if a[i] != b[i]:
            diffs.append(i)

    if len(diffs) > 2:
        print(""NO"")
    elif not diffs:
        print(""YES"")
    else:
        i, j = diffs
        if a[i] == b[j] and b[i] == a[j]:
            print(""YES"")
        else:
            print(""NO"")
",O(nlogn)
"n,m=[int(x) for x in input().split()]
v=[]
h=[]
for i in range(n):
    x=int(input())
    v.append(x)
for i in range(m):
    x,y,z=[int(x) for x in input().split()]
    if x==1:
        h.append(y)
h.sort()
v.sort()
m=len(h)
n=len(v)
if n==0 or v[n-1]!=1000000000:
    v.append(1000000000)
    n+=1
mina=9999999999999
j=0
for i in range(n):
    while(j<m and h[j]<v[i]):
        j+=1

    mina=min(mina,i+m-j)
print(mina)",O(nlogn)
"n=int(input())
s=list(input())
t=list(input())

cnt=0
ans=[]
f1=0
for i in range(n):
    if s[i]==t[i]:
        continue
    f=0
    for j in range(i+1,n):
        if s[j]==t[i]:
            f=1
            for k in range(j,i,-1):
                s[k-1],s[k]=s[k],s[k-1]
                ans.append(k)
            break
    if f==0:
        print(-1)
        exit()

print(len(ans))
print(*ans)",O(n ^ 2)
"n = int(input())
arr = list(map(int, input().split()))
arr.sort()
if arr[-1] == 1:
    arr[-1] = 2
else:
    arr[-1] = 1
arr.sort()
print(*arr)
",O(nlogn)
"def binar(a,st,d):
    if st==0:
        return 1

    elif st==1:
        return a%d

    return (   binar(a**2%d,st//2,d) *  binar(a, st%2,d)   )%d

x,k=map(int,input().split())

if x==0:
	print(0)
	exit()

res= ((x*binar(2,k+1,1000000007)) - (binar(2,k,1000000007))+1)% 1000000007
print(res)",O(logn)
"class Solution2(object):
    def arrangeCoins(self, n):
        def check(mid, n):
            return mid*(mid+1) <= 2*n

        left, right = 1, n
        while left <= right:
            mid = left + (right-left)//2
            if not check(mid, n):
                right = mid-1
            else:
                left = mid+1
        return right",O(logn)
"n, m, K = map(int, input().split())
wh = [[0]*m for i in range(n)]
wv = [[0]*m for i in range(n)]

for i in range(n):
    t = list(map(int, input().split()))
    for j in range(m-1):
        wh[i][j] = t[j]

for i in range(n-1):
    t = list(map(int, input().split()))
    for j in range(m):
        wv[i][j] = t[j]

f = [[[int(1e8)]* 11 for j in range(m)] for i in range(n)]

for i in range(n):
    for j in range(m):
        f[i][j][0] = 0

for k in range(1, K//2+1):
    for i in range(n):
        for j in range(m):
            if i > 0:
                f[i][j][k] = min(f[i][j][k], f[i-1][j][k-1]+wv[i-1][j])
            if j < m-1:
                f[i][j][k] = min(f[i][j][k], f[i][j+1][k-1]+wh[i][j])
            if i < n-1:
                f[i][j][k] = min(f[i][j][k], f[i+1][j][k-1]+wv[i][j])
            if j > 0:
                f[i][j][k] = min(f[i][j][k], f[i][j-1][k-1]+wh[i][j-1])

for i in range(n):
    for j in range(m):
        if K%2 == 1:
            print(-1)
        else:
            dp = [int(1e8)]*(K//2+1)
            dp[0] = 0
            for k in range(1, K//2+1):
                for l in range(0, k):
                    dp[k] = min(dp[k], dp[l]+f[i][j][k-l]*2)

            print(dp[K//2])
",O(n ^ 3)
"a,b = (map(int,input().split()))
print((b+a-1)//a)
",O(1)
"import math
import sys
import collections
import bisect
import time
import random
from itertools import permutations
def get_ints():return map(int, sys.stdin.readline().strip().split())
def get_list():return list(map(int, sys.stdin.readline().strip().split()))
def get_string():return sys.stdin.readline().strip()
for t in range(1):
    n=int(input())
    arr=get_list()
    unique=set(arr)
    poss=False
    for i in arr:
        for j in range(32):
            if i+(2**j) in unique and i-(2**j) in unique:
                print(3)
                print(i,i+2**j,i-2**j)
                poss=True
                break
        if poss:
            break
    if poss:
        break
    for i in arr:
        for j in range(32):
            if i+(2**j) in unique:
                print(2)
                print(i,i+2**j)
                poss=True
                break
        if poss:
            break
    if poss:
        break
    print(1)
    print(arr[0])",O(nlogn)
"import math

s = input()
t = input()
p1, p2, m1, m2, q = 0, 0, 0, 0, 0
for i in s:
 if i == '+':
  p1 += 1
 else:
  m1 += 1
for i in t:
 if i == '+':
  p2 += 1
 elif i == '-':
  m2 += 1
 else:
  q += 1
dp, dm = p1 - p2, m1 - m2
if dp < 0 or dm < 0:
 print(0.0)
else:
 ans = (math.factorial(q) / (math.factorial(dp) * math.factorial(dm))) / math.pow(2, q)
 print(ans)",np
"import sys
import math
input = sys.stdin.readline
from functools import cmp_to_key;

def pi():
    return(int(input()))
def pl():
    return(int(input(), 16))
def ti():
    return(list(map(int,input().split())))
def ts():
    s = input()
    return(list(s[:len(s) - 1]))
def invr():
    return(map(int,input().split()))
mod = 1000000007;
f = [];
def fact(n,m):
    global f;
    f = [1 for i in range(n+1)];
    f[0] = 1;
    for i in range(1,n+1):
        f[i] = (f[i-1]*i)%m;

def fast_mod_exp(a,b,m):
    res = 1;
    while b > 0:
        if b & 1:
            res = (res*a)%m;
        a = (a*a)%m;
        b = b >> 1;
    return res;

def inverseMod(n,m):
    return fast_mod_exp(n,m-2,m);

def ncr(n,r,m):
    if n < 0 or r < 0 or r > n: return 0;
    if r == 0: return 1;
    return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m;

def main():
    C();

def D():
    [n,m,k] = ti();
    w = [[] for i in range(n)];
    for i in range(n):
        w[i] = ts();

    mn = [[0 for j in range(k+1)] for i in range(n+1)];
    for i in range(1,n+1):
        for j in range(k+1):
            c = 0;
            st,en = -1,-1;
            for x in range(m):
                if w[i-1][x] == '1':
                    if c == j and st == -1: st = x;
                    if c < j: c += 1;
                    if c == j: en = x;
            mn[i][j] = en-st+1 if st != -1 and en != -1 else 0;
            st,en = -1,-1;
            c = 0;
            for x in range(m-1,-1,-1):
                if w[i-1][x] == '1':
                    if c == j and st == -1: st = x;
                    if c < j: c += 1;
                    if c == j: en = x;
            if st != -1 and en != -1 >= 0:
                mn[i][j] = min(mn[i][j], st-en+1);

    dp = [[9999999999999999 for j in range(k+1)] for i in range(n+1)];
    for i in range(k+1):
        dp[0][i] = 0;
    for i in range(1,n+1):
        for j in range(k+1):
            for x in range(k+1):
                if j-x >= 0:
                    dp[i][j] = min(dp[i][j], dp[i-1][j-x]+mn[i][x]);

    print(dp[n][k]);

def getCount(n):
    x = 1;
    count = 0;
    while n > 0:
        if n & 1 == 1:
            count += 1;
        n = n >> 1;
    return count;

def C():
    try:
        n = ts();
        k = pi();
        if k == 0:
            print(1);
            return;
        dp = [0 for i in range(1010)];
        for i in range(1010):
            if i == 0 or i == 1:
                continue;
            dp[i] = dp[getCount(i)]+1;
        fact(1010,mod);

        ans = 0;
        s = n;
        count = 0;
        for i in range(len(s)):
            if s[i] == '0': continue;
            for j in range(max(count,1),1010):
                if dp[j] == k-1:
                    ans = (ans+ncr(len(s)-i-1,j-count,mod))%mod;
                    if i == 0 and k == 1: ans = (ans+mod-1)%mod;
            count += 1;
        count = 0;
        for i in range(len(s)):
            if s[i] == '1': count += 1;
        if dp[count] == k-1: ans = (ans+1)%mod;

        print(ans);
    except: print(sys.exc_info()[0]);

main();",O(n)
"l=list(map(int,input().split()))
l.sort()
x1=l[0]
x2=l[1]
x3=l[2]
if l[0]==1 or (l[0]==2 and l[1]==4 and l[2]==4) or (l[0]==3 and l[1]==3 and l[2]==3) or (l[0]==2 and l[1]==2):
    print(""YES"")
else:
    print(""NO"")",O(1)
"mecces, burgerKing, both, groupSize = map(int,input().strip().split(' '))
mecces -= both
burgerKing -= both
notPassed = groupSize - sum((mecces,burgerKing,both))
if notPassed > 0 and burgerKing >= 0 and mecces >= 0:
    print(notPassed)
else:
    print(-1)",O(1)
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush

from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:

    sys.stdin = open(""input.txt"", ""r"")

except:
    pass
def pmat(A):
    for ele in A:
        print(*ele,end=""\n"")

n=L()[0]
A=sorted(L())
if A==[1]*n:
    print(*A[:n-1],2)
else:
    print(1,*A[:-1])

endtime = time.time()
",O(nlogn)
"import math
import os
import random
import re
import sys
import functools
from operator import itemgetter, attrgetter
from collections import Counter

if __name__ == '__main__':
    Y = lambda: list(map(int, input().split()))
    P = lambda: map(int, input().split())
    N = lambda: int(input())

    a, b, c, n = P()

    if a < c or b < c:
        r = -1
    else:
        r = n - (a + b - c)
    print(-1 if r <= 0 else r)",O(1)
"import math
def solve():
    words = input().split()
    people = int(words[0])
    planes_each = int(words[1])
    per = int(words[2])
    sheets = int(words[3])
    sheets_per_person = math.ceil(planes_each/per)
    needed = sheets_per_person*people
    packs = math.ceil(needed/sheets)
    print(packs)

solve()",O(1)
"fact=[1]
temp=1
MOD=10**9+7
for i in range(1,10**5+5):
    temp*=i
    temp%=MOD
    fact+=[temp]
def bino(a,b):
    up=fact[a]
    down=pow(fact[b]*fact[a-b],MOD-2,MOD)
    return (up*down)%MOD

def find(A):
    MOD=10**9+7

    dp=[0]*(10**5+2)
    for x in A:
        dp[x]+=1
    for i in range(2,len(dp)):
        for j in range(2,len(dp)):
            if i*j>len(dp)-1:
                break
            dp[i]+=dp[i*j]
    for i in range(2,len(dp)):
        dp[i]=(pow(2,dp[i],MOD)-1)%MOD

    for i in range(len(dp)-1,1,-1):
        for j in range(2,len(dp)):
            if i*j>=len(dp):
                break
            dp[i]-=dp[i*j]
            dp[i]%=MOD

    ans=0
    for i in range(2,len(dp)):
        ans+=dp[i]
        ans%=MOD

    return (pow(2,len(A),MOD)-ans-1)%MOD
input()
print(find(list(map(int,input().strip().split(' ')))))
",np
"def nr(): return nrs()[0]
def nrs(): return [int(i) for i in input().split()]

def get_prime(n):
	res = []
	for i in range(2,n):
		is_prime = True
		for x in res:
			if i % x == 0:
				is_prime = False
				break
		if is_prime: res.append(i)
	return res

prime = get_prime(3162)

def get_mask (num):

	dv = []
	for p in prime:
		c = 0
		while num % p == 0:
			c += 1
			num = num // p
		if c % 2 == 1:
			dv.append(p)
		if num < p * p:
			break

	for x in dv:
		num *= x

	return num

for _ in range(nr()):
	N, K = nrs()
	A = nrs()
	dp = [N] * (K + 1)
	dp[0] = 1
	used = [{}] * (K + 1)
	for a in A:
		a = get_mask(a)
		for j in range(K, -1, -1):
			if dp[j] == N: continue
			if a in used[j]:
				if j < K and dp[j + 1] > dp[j]:
					dp[j + 1] = dp[j]
					used[j + 1] = used[j]
				dp[j] += 1
				used[j] = {}
			used[j][a] = 1
	print(min(dp))
",O(n ^ 3)
"def I(): return(list(map(int,input().split())))
n,l,r,x=I()
c=I()
l1=list(range(2**n))
ans=0
for j in l1:
	s=0
	num=0
	ma=0
	mi=100000000
	for i in range(n):
		if (j & 1<<i):
			num+=1
			s+=c[i]
			ma=max(c[i],ma)
			mi=min(c[i],mi)

	if s<=r and l<=s and(ma-mi>=x) and num>=2 :
		ans+=1
print(ans)
",np
"import sys
import math
import bisect
from sys import stdin, stdout
from math import gcd, floor, sqrt, log
from collections import defaultdict as dd
from bisect import bisect_left as bl, bisect_right as br
from collections import Counter
from collections import defaultdict as dd

flush = lambda: stdout.flush()
stdstr = lambda: stdin.readline()
stdint = lambda: int(stdin.readline())
stdpr = lambda x: stdout.write(str(x))
stdmap = lambda: map(int, stdstr().split())
stdarr = lambda: list(map(int, stdstr().split()))

mod = 1000000007

def sieve(n):

    prime = [True for _ in range(n+1)]
    p = 2

    while(p*p <= n):
        if(prime[p] == True):

            for i in range(p*p, n+1, p):
                prime[i] = False

        p += 1

    return prime

n,k = stdmap()

all = sieve(n)

primes = []

for i in range(1, len(all)):
    if(all[i] == True):
        primes.append(i)

s = Counter(primes)

res = 0

for i in range(len(primes)-1):
    toCheck = primes[i]+primes[i+1]+1

    if(toCheck in s):
        res += 1

if(res >= k):
    print(""YES"")
else:
    print(""NO"")
",O(n)
"import sys

def read():
	return sys.stdin.readline()

def main():
	n = int(read())
	a = list(map(int, read().split()))
	a.sort()
	k = 0
	used = [0] * n
	for i in range(n):
		if used[i]:
			continue
		k += 1
		for j in range(i, n):
			if a[j] % a[i] == 0:
				used[j] = True
	print(k)

if __name__ == '__main__':
	main()
",O(n ^ 2)
"import sys
import bisect
from bisect import bisect_left as lb
input_=lambda: sys.stdin.readline().strip(""\r\n"")
from math import log
from math import gcd
from math import atan2,acos
from random import randint
sa=lambda :input_()
sb=lambda:int(input_())
sc=lambda:input_().split()
sd=lambda:list(map(int,input_().split()))
sflo=lambda:list(map(float,input_().split()))
se=lambda:float(input_())
sf=lambda:list(input_())
flsh=lambda: sys.stdout.flush()

mod=10**9+7
gp=[]
cost=[]
dp=[]
mx=[]
ans1=[]
ans2=[]
special=[]
specnode=[]
a=0
kthpar=[]
def dfs(root,par):
    if par!=-1:
        dp[root]=dp[par]+1
    for i in range(1,20):
        if kthpar[root][i-1]!=-1:
            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]
    for child in gp[root]:
        if child==par:continue
        kthpar[child][0]=root
        dfs(child,root)
ans=0
def hnbhai(t):
    n=sb()
    p=[]
    for i in range(n):
        p.append(sflo())

    dp=[0]*(1<<n)
    dp[1]=1
    for i in range(2,1<<n):
        for j in range(1,n):
            for k in range(0,j):
                if (i>>j)&1 and (i>>k)&1:
                    dp[i]=max(dp[i],dp[i^(1<<j)]*p[k][j]+dp[i^(1<<k)]*p[j][k])

    print(dp[-1])
for _ in range(1):
    hnbhai(_+1)
",np
"class Solution5(object):
    def singleNumber(self, A):
        one, two, three = 0, 0, 0
        for x in A:
            one, two, three = (~x & one) | (x & ~one & ~two & ~three), (~x & two) | (x & one), (~x & three) | (x & two)
        return two",O(n)
"import collections
import time
import os
import sys
import bisect
import heapq
from typing import List

L, R = map(int, input().split())

for i in range(64, -1, -1):
    if L & (1 << i) != R & (1 << i):
        print((1 << (i+1)) - 1)
        exit(0)
print(0)",O(logn)
"class Solution_TLE(object):
    def houseOfCards(self, n):
        dp = [[0]*(n+1) for _ in range((n+1)//3+1)] 
        dp[0][0] = 1
        for t in range(1, (n+1)//3+1):
            for i in range(3*t-1, n+1):
                dp[t][i] = sum(dp[j][i-(3*t-1)] for j in range(t))
        return sum(dp[t][n] for t in range((n+1)//3+1))",O(n ^ 2)
"n = int(input())
b = list(map(int, input().split()))
ff = []
ss = []
for i in  b[::-1]:
    q = i
    f = q // 2
    if q % 2:
        s = f + 1
    else:
        s = f
    if len(ff) == 0:
        ff = [f]
        ss = [s]
    else:
        if f > ff[-1] or s < ss[-1]:
            d = max(f - ff[-1], ss[-1] - s)
            f -= d
            s += d
        ff.append(f)
        ss.append(s)
print(*(ff[::-1] + ss))",O(n)
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1

        while l <= r:
            mid = (l + r) // 2
            if target == nums[mid]:
                return mid

            if nums[l] <= nums[mid]:
                if target > nums[mid] or target < nums[l]:
                    l = mid + 1
                else:
                    r = mid - 1

            else:
                if target < nums[mid] or target > nums[r]:
                    r = mid - 1
                else:
                    l = mid + 1
        return -1
",O(logn)
"class Solution(object):
    def distributeCandies(self, n, limit):
        def nCr(n, r): 
            if not 0 <= r <= n:
                return 0
            if n-r < r:
                r = n-r
            c = 1
            for k in range(1, r+1):
                c *= n-k+1
                c //= k
            return c
        
        def nHr(n, r):
            return nCr(n+(r-1), r-1)
    
        R = 3
        return sum((-1 if r%2 else 1) * nCr(R, r) * nHr(n-r*(limit+1), R)for r in range(R+1))",O(1)
"import sys, os.path
if(os.path.exists('input.txt')):
	sys.stdin = open(""input.txt"",""r"")

t = int(input())
last = []
current = []

for i in range(t):
	last.append(str(input()))
for i in range(t):
	current.append(str(input()))

for i in range(len(last)):
	if last[i] in current:
		current[current.index(last[i])] = ""*""
		last[i] = ""*""

last.sort()
current.sort()

total = 0
for i in range(len(last)):
	if last[i] == current[i]:
		continue
	else:
		total+=1

print(total)
",O(n)
"from sys import exit

def bad():
    print(""NO"")
    exit()

node = 1
def make_branch(u, d, deg, g, n, k):
    global node
    while deg[u] < k and d > 0 and node < n:
        node += 1
        deg[u] += 1
        deg[node] = 1
        g[u].append(node)
        make_branch(node, d - 1, deg, g, n, k)

def main():
    global node
    n, d, k = map(int, input().split())
    if d >= n or (k == 1 and n > 2):
        bad()

    g = [[] for _ in range(n + 5)]
    deg = [0 for _ in range(n + 5)]

    for i in range(1, d + 1):
        g[i].append(i + 1)
        deg[i] += 1
        deg[i + 1] += 1

    node = d + 1

    LD = 1
    RD = d - 1
    for u in range(2, d + 1):
        make_branch(u, min(LD, RD), deg, g, n, k)
        LD += 1
        RD -= 1

    used = [False for _ in range(n + 5)]
    q = [[1, 1]]
    used[1] = True
    while len(q) > 0:
        u, p = q.pop()
        for v in g[u]:
            if v != p:
                used[v] = True
                q.append([v, u])

    for i in range(1, n + 1):
        if used[i] == False:
            bad()

    print(""YES"")
    for u in range(1, n + 1):
        for v in g[u]:
            print(u, v)

main()
",O(n ^ 2)
"class Solution(object):
    def kItemsWithMaximumSum(self, numOnes, numZeros, numNegOnes, k):
        return min(numOnes, k)-max(k-numOnes-numZeros, 0)",O(1)
"from sys import stdin, stdout

def main():
    p = 998244353
    n = int(stdin.readline())
    a = list(readline())
    answer = a[-1]
    pow_ = 1
    for i in range(n - 1, 0, -1):
        answer = (answer + a[i - 1] * (2 + n - i) * pow_ % p) % p
        pow_ = pow_ * 2 % p
    return answer

def readline():
    return map(int, stdin.readline().strip().split())

if __name__ == '__main__':
    stdout.write(str(main()) + '\n')
",O(n)
"import math

n, k = input().split("" "")

n = int(n)
k = int(k)

variableone = 2 * (n + k)

variabletwo = (-3 + math.sqrt(9 - 4 * 1 * (-1 * variableone))) / 2

variabletwo = int(variabletwo)

y = n - variabletwo

print(y)
",O(logn)
"class Solution(object):
    def getMaximumXor(self, nums, maximumBit):
        result = [0]*len(nums)
        mask = 2**maximumBit-1
        for i in range(len(nums)):
            mask ^= nums[i]
            result[-1-i] = mask
        return result",O(n)
"def solve():
    n = int(input())
    for d in [2,4]:
        if n % d != 0:
            continue
        temp = int((n//d) ** (0.5))
        temp -= 1
        while temp*temp < n//d:
            temp += 1
        if temp*temp == n//d:
            print(""YES"")
            return
    print(""NO"")
for _ in range(int(input())):
    solve()
",O(1)
"import math
from collections import defaultdict
ml=lambda:map(int,input().split())
ll=lambda:list(map(int,input().split()))
ii=lambda:int(input())
ip=lambda:list(input())

n,k=ml()
ans=0;
for i in range(1,1000001):
    val=(i*(i+1))//2
    if(val-(n-i)==k):
        ans=n-i
print(ans)",O(logn)
"yellow, blue = map(int, input().split())
y, g, b = map(int, input().split())

count = 0

yt = y * 2 + g
bt = g + b * 3

yc = yellow - yt
if yc < 0:
    count += abs(yc)

bc = blue - bt
if bc < 0:
    count += abs(bc)

print(count)
",O(1)
"import sys
input = sys.stdin.readline

class sieve:
  def __init__(self, n):
    self.n = n
    self.sv = [1] * (n + 1)
    self.sv[0] = 0
    self.sv[1] = 0
    for i in range(2, n + 1):
      if self.sv[i]:
        for j in range(i * 2, n + 1, i):
          self.sv[j] = 0
  def isprime(self, x):
    if x > self.n:
      return False
    return self.sv[x] == 1
  def factorize(self, x):
    res = []
    for i in range(2, int(x ** 0.5) + 1):
      if self.sv[i]:
        while x % i == 0:
          x //= i
          res.append(i)
    if x != 1:
      res.append(x)
    return res
  def modlcm(self, a, mod):
    res = [0] * (self.n + 1)
    ex = set()
    for i in range(len(a)):
      f = self.factorize(a[i])
      for j in f:
        if j > self.n:
          ex.add(j)
          continue
        res[j] = max(f.count(j), res[j])
    rres = 1
    for i in range(self.n + 1):
      if res[i] != 0:
        rres *= pow(i, res[i], mod)
        rres %= mod
    for i in ex:
      rres *= i
      rres %= mod
    return rres

sv = sieve(10 ** 4)
for _ in range(int(input())):
  n, k = map(int, input().split())
  a = list(map(int, input().split()))
  for i in range(n):
    x = a[i]
    q = sv.factorize(x)
    s = [1]
    while len(q):
      y = q.pop()
      if y == s[-1]:
        s.pop()
        a[i] //= y ** 2
      else: s.append(y)
  s = [set() for _ in range(k + 1)]

  dp = [n] * (k + 1)
  dp[0] = 0

  for i in range(n):
    for j in range(k, -1, -1):
      if dp[j] == n: continue
      if a[i] in s[j]:
        if j + 1 <= k and dp[j + 1] > dp[j]:
          dp[j + 1] = dp[j]
          s[j + 1] = s[j]
        dp[j] += 1
        s[j] = set()
        s[j].add(a[i])
      else:
        s[j].add(a[i])

  for j in range(k + 1): dp[j] += len(s[j]) > 0
  print(min(dp))
",O(n ^ 3)
"if __name__ == '__main__':
    n, s = map(int, input().split())
    a = []
    for _ in range(n):
        h, m = map(int, input().split())
        a.append(h * 60 + m)
    if a[0] != 0 and a[0] > s:
        print(0, 0)
    else:
        a.append(a[n - 1] + 2 * s + 3)
        for i in range(1, n + 1):
            if a[i] - (a[i - 1] + 2 + s) >= s:
                print((a[i - 1] + s + 1)//60, (a[i - 1] + s + 1)%60)
                break
",O(n)
"class Solution(object):
    def strongPasswordChecker(self, s):
        missing_type_cnt = 3
        if any('a' <= c <= 'z' for c in s):
            missing_type_cnt -= 1
        if any('A' <= c <= 'Z' for c in s):
            missing_type_cnt -= 1
        if any(c.isdigit() for c in s):
            missing_type_cnt -= 1

        total_change_cnt = 0
        one_change_cnt, two_change_cnt, three_change_cnt = 0, 0, 0
        i = 2
        while i < len(s):
            if s[i] == s[i-1] == s[i-2]:
                length = 2
                while i < len(s) and s[i] == s[i-1]:
                    length += 1
                    i += 1

                total_change_cnt += length / 3
                if length % 3 == 0:
                    one_change_cnt += 1
                elif length % 3 == 1:
                    two_change_cnt += 1
                else:
                    three_change_cnt += 1
            else:
                i += 1

        if len(s) < 6:
            return max(missing_type_cnt, 6 - len(s))
        elif len(s) <= 20:
            return max(missing_type_cnt, total_change_cnt)
        else:
            delete_cnt = len(s) - 20

            total_change_cnt -= min(delete_cnt, one_change_cnt * 1) / 1
            total_change_cnt -= min(max(delete_cnt - one_change_cnt, 0), two_change_cnt * 2) / 2
            total_change_cnt -= min(max(delete_cnt - one_change_cnt - 2 * two_change_cnt, 0), three_change_cnt * 3) / 3

            return delete_cnt + max(missing_type_cnt, total_change_cnt)",O(n)
"n, s = map(int, input().strip().split())

num = ''
div = 9

if s//10 != 0:

    div = 9
    while (s//div)//10 != 0:
        div = div*10+9
    while div:
        rem = str(s//div)
        if int(rem) > 9:
            num = str(int(num)+1) + '0'*len(str(div))
            div = 0
            s = 0
            break
        else:
            num += rem
        s = s%div
        div //= 10
    num += str(s)
else:
    num = str(s)
mini = int(num)
if mini%10 != 0:
    mini += 10
    mini -= mini%10

print(max(0, n-mini+1))
",O(logn)
"n, k = map(int, input().split())
l, r = -1, k+1
while l+1 < r:
	mid = l + r >> 1
	val = (k - mid + 1 + k) * mid // 2 - (mid - 1)
	if val < n:
		l = mid
	else:
		r = mid
print(-1 if r == k+1 else r)
",O(logn)
"import sys,os,io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import defaultdict

n,m = [int(i) for i in input().split()]
a = []
mi = -1
ma = 10**9
for i in range (n):
    a.append([int(j) for j in input().split()])

ans = []
while(mi<ma):
    mid = (mi+ma+1)//2
    masks = {}
    for i in range (n):
        currMask = 0
        for j in range (m):
            if a[i][j] >= mid:
                currMask +=  1<<j
        masks[currMask] = i
    req = (1<<m) - 1
    possible = 0
    for i in masks:
        for j in masks:
            if i|j == req:
                possible = 1
                ans = [masks[i]+1,masks[j]+1]
                break
        if possible:
            break
    if possible:
        mi = mid
    else:
        ma = mid - 1
print(*ans)",np
"t=int(input())
for i in range(t):
    n,k=map(int,input().split())
    if n>32:
        print(""YES"",n-1)
    else:
        max_splits=(4**n-1)//3
        if k>max_splits or (n,k)==(2,3):
            print(""NO"")
        else:
            done=False
            for i in range(n):
                if k<2**(i+2)-i-3:
                    print(""YES"",n-i)
                    done=True
                    break
            if not done:
                print(""YES"",0)",O(logn)
"import sys
import io, os
import math
gcd=math.gcd
ceil=math.ceil

input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
mod1=(10**9)+7
mod2=998244353
def strinp(testcases):
    k=5
    if(testcases==-1 or testcases==1):
        k=1
    f=str(input())
    f=f[2:len(f)-k]
    return f
def alp(a):
    return (ord(a)-ord(""a""))
def main():
    arr=list(map(int, input().split()))
    n=arr[0]
    m=arr[1]
    k=arr[2]
    lrw=[0]*n
    for i in range(n):
        lrw[i]=list(map(int, input().split()))
    udw=[0]*(n-1)
    for i in range(n-1):
        udw[i]=list(map(int, input().split()))
    if(k%2==1):
        a=[-1]*m
        for i in range(n):
            print(*a)
        sys.exit()
    dp1=[[0 for i in range(m)] for j in range(n)]
    dp2=[[0 for i in range(m)] for j in range(n)]
    inf=10**10
    dis=(k//2)
    for h in range(dis):
        for i in range(n):
            for j in range(m):
                a=inf
                b=inf
                c=inf
                d=inf
                if(j>0):
                    a=lrw[i][j-1]+dp2[i][j-1]
                if(j<m-1):
                    b=lrw[i][j]+dp2[i][j+1]
                if(i>0):
                    c=udw[i-1][j]+dp2[i-1][j]
                if(i<n-1):
                    d=udw[i][j]+dp2[i+1][j]
                dp1[i][j]=min(a,b,c,d)
        dp2=dp1
        dp1=dp1=[[0 for a in range(m)] for b in range(n)]
    for i in range(n):
        for j in range(m):
            dp2[i][j]*=2
    for i in range(n):
        print(*dp2[i])

if __name__ == '__main__':
    main()",O(n ^ 3)
"class Solution(object):
    def maxBoxesInWarehouse(self, boxes, warehouse):
        boxes.sort(reverse=True)
        result = 0
        for h in boxes:
            if h > warehouse[result]:
                continue
            result += 1
            if result == len(warehouse):
                break
        return result",O(nlogn)
"def check(st):
    count = 1
    i = 1
    pre = st[0]
    maxi = 0
    pre_indx = 0
    indx = [0 for i in range(n)]
    while i<n:
        if pre != st[i]:
            count+=1
        else:
            indx[pre_indx] =count
            count=1
            pre_indx=i
        pre =st[i]
        i+=1
    indx[pre_indx] =count
    return indx

st=input()
n=len(st)
actual_indx=check(st)
reverse_indx=check(st[::-1])
if st[0] ==st[-1]:
    print(max(actual_indx))
else:
    print(min(n,max(max(actual_indx[1:]),actual_indx[0] +reverse_indx[0])))",O(n)
"class Solution(object):
    def convertToBase7(self, num):
        if num < 0:
            return '-' + self.convertToBase7(-num)
        result = ''
        while num:
            result = str(num % 7) + result
            num //= 7
        return result if result else '0'",O(1)
"class Solution(object):
    def removeComments(self, source):
        in_block = False
        result, newline = [], []
        for line in source:
            i = 0
            while i < len(line):
                if not in_block and i+1 < len(line) and line[i:i+2] == '/*':
                    in_block = True
                    i += 1
                elif in_block and i+1 < len(line) and line[i:i+2] == '*/':
                    in_block = False
                    i += 1
                elif not in_block and i+1 < len(line) and line[i:i+2] == '//':
                    break
                elif not in_block:
                    newline.append(line[i])
                i += 1
            if newline and not in_block:
                result.append("""".join(newline))
                newline = []
        return result",O(n)
"import math
n, r = list(map(int, input().split(' ')))
l = 2 * r * math.sin(math.pi/n)
R = l * r / (-l + 2*r)
print(R)",O(1)
"class Solution2(object):
    def maxA(self, N):
        if N < 7:
            return N
        dp = list(range(N+1))
        for i in range(7, N+1):
            dp[i % 6] = max(dp[(i-4) % 6]*3, dp[(i-5) % 6]*4)
        return dp[N % 6]",O(n)
"class Solution(object):
    def canMakeArithmeticProgression(self, arr):
        m = min(arr)
        d = (max(arr)-m)//(len(arr)-1)
        if not d:
            return True
        i = 0
        while i < len(arr):
            if arr[i] == m+i*d:
                i += 1
            else:
                j, r = divmod(arr[i]-m, d)
                if r or j >= len(arr) or arr[i] == arr[j]:
                    return False
                arr[i], arr[j] = arr[j], arr[i]
        return True",O(n)
"import sys
if locals()['__file__'][-2:] == 'py':
    sys.stdin = open('in.txt', 'r')
n = int(input())
a = []
for i in range(1, n + 1):
    l, r = map(int, input().split())
    a.append([l, -r, i])
a.sort()
ma = a[0][1]
nma = a[0][2]
for i in range(1, n):
    if a[i][1] >= ma:
        print(a[i][2], nma)
        exit()
    else:
        ma = a[i][1]
        nma = a[i][2]
print(-1, -1)
",O(nlogn)
"num = input()
num_list = []
for i in range(len(num)):
  num_list.append(int(num[i]))
myMod = (10 ** 9) + 7
length = len(num_list)
f = [0] * (length + 1)
t = [1] * (length + 1)
for i in range(length):
    f[i+1] = (f[i] * 10 + 1) % myMod
    t[i+1] = (t[i] * 10) % myMod
ans = 0
for i in range(1, 10):
    dp = [0] * (length + 1)
    for j in range(length):
        dp[j+1] = (dp[j] * i + (10 - i) * (dp[j] * 10 + t[j])) % myMod
    c = 0
    ctr = 0
    for k in num_list:
        z = min(i, k)
        o = k - z
        ans += o * (dp[length-1-ctr] * t[c+1] + f[c+1] * t[length-1-ctr]) % myMod
        ans += z * (dp[length-1-ctr] * t[c] + f[c] * t[length-1-ctr]) % myMod
        ans %= myMod
        c += k >= i
        ctr += 1
    ans += f[c]
    if ans >= myMod:
        ans -= myMod
print(ans)
",O(n ^ 2)
"class Solution(object):

    def __init__(self, k):
        self.__start = 0
        self.__size = 0
        self.__buffer = [0] * k

    def enQueue(self, value):
        if self.isFull():
            return False
        self.__buffer[(self.__start+self.__size) % len(self.__buffer)] = value
        self.__size += 1
        return True

    def deQueue(self):
        if self.isEmpty():
            return False
        self.__start = (self.__start+1) % len(self.__buffer)
        self.__size -= 1
        return True

    def Front(self):
        return -1 if self.isEmpty() else self.__buffer[self.__start]

    def Rear(self):
        return -1 if self.isEmpty() else self.__buffer[(self.__start+self.__size-1) % len(self.__buffer)]

    def isEmpty(self):
        return self.__size == 0

    def isFull(self):
        return self.__size == len(self.__buffer)",O(1)
"n,k=map(int,input().split())
s=input()

i=-1
for j in range(n-1):
    if s[:j+1]==s[n-j-1:]:
        i=j
add=s[i+1:]
for j in range(k-1):
    s+=add
print(s)",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase
import math
from queue import Queue
import collections
import itertools
import bisect
import heapq

import random

def main():
    pass

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while (n > 1):
        n //= 2
        p += 1
    return (p)

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n = n / i
    if n > 2:
        l.append(int(n))
    return (l)

def primeFactorsCount(n):
    cnt=0
    while n % 2 == 0:
        cnt+=1
        n = n // 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            cnt+=1
            n = n // i
    if n > 2:
        cnt+=1
    return (cnt)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)

def countcon(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if (s[i] == ch):
            c += 1
        else:
            break
    return (c)

def lis(arr):
    n = len(arr)
    lis = [1] * n
    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
    maximum = 0
    for i in range(n):
        maximum = max(maximum, lis[i])
    return maximum

def isSubSequence(str1, str2):
    m = len(str1)
    n = len(str2)
    j = 0
    i = 0
    while j < m and i < n:
        if str1[j] == str2[i]:
            j = j + 1
        i = i + 1
    return j == m

def maxfac(n):
    root = int(n ** 0.5)
    for i in range(2, root + 1):
        if (n % i == 0):
            return (n // i)
    return (n)

def p2(n):
    c = 0
    while (n % 2 == 0):
        n //= 2
        c += 1
    return c

def seive(n):
    primes = [True] * (n + 1)
    primes[1] = primes[0] = False
    i = 2
    while (i * i <= n):
        if (primes[i] == True):
            for j in range(i * i, n + 1, i):
                primes[j] = False
        i += 1
    pr = []
    for i in range(0, n + 1):
        if (primes[i]):
            pr.append(i)
    return pr

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p

def denofactinverse(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (pow(fac, m - 2, m))

def numofact(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (fac)

def sod(n):
    s = 0
    while (n > 0):
        s += n % 10
        n //= 10
    return s

n=int(input())
l=list(map(int,input().split()))
inv=0
for i in range(1,n):
    for j in range(0,i):
        if(l[j]>l[i]):
            inv+=1

for i in range(0,int(input())):
    f,r=map(int,input().split())
    p=(r-f+1)//2

    inv+=p%2

    if(inv%2):
        print(""odd"")
    else:
        print(""even"")
",O(n ^ 2)
"import os
import sys
from math import *
from collections import *
from fractions import *
from bisect import *
from heapq import*
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]

def possible(x):
    days=n-x
    tot=days*(days+1)//2

    return tot-x<=k

n,k=value()

low=0
high=n

while(low<=high):

    mid=(low+high)//2

    if(possible(mid)):
        high=mid-1
    else:
        low=mid+1

print(low)
",O(logn)
"debug = 0
BIG = 10 ** 9 + 1

input = raw_input

def prof(f):
    return f

def report(f):
    def new_f(x):
        res = f(x)

        return res

    return new_f if debug else f

def mcheck(a, pairs):
    m = len(a[0])
    allm = 2 ** m - 1

    subs = {i: {i} for i in range(allm + 1)}

    for i in range(allm + 1):
        for j in range(i):
            if i | j == i:
                subs[i].add(j)

    mx = [max(aa) for aa in a]

    @prof
    def check(v):
        masks = {0: -1}
        done = [False] * (allm + 1)
        for i, aa in enumerate(a):
            if mx[i] < v:
                continue
            c = sum(1 << b for b in range(len(aa)) if aa[b] >= v)

            if not done[c]:
                for cc in subs[c]:
                    if allm - cc in masks:
                        other = masks[allm - c]
                        pairs[v] = i, other
                        return True
                    masks[cc] = i
                    done[cc] = True

        return False

    return check

@prof
def go():
    n, m = map(int, input().split())

    a = []

    uniq = set()
    for _ in range(n):
        aa = tuple(map(int, input().split()))

        a.append(aa)
        uniq.update(aa)

    uniq = sorted(uniq)
    pairs = {0: (0, 0)}
    check = mcheck(a, pairs)
    l = 0
    r = len(uniq) - 1
    while l != r:
        if debug: print(l, r)
        if l + 1 == r:
            if check(uniq[r]):
                l = r
            else:
                r = l
            continue
        c = (l + r) // 2
        if check(uniq[c]):
            l = c
        else:
            r = c

    l = uniq[l]
    if debug: print(l, pairs[l])
    if l not in pairs:
        check(l)
    a = pairs[l][0]
    b = pairs[l][1]
    if b == -1:
        b = a

    print(""%d %d"" % (a + 1, b + 1))

go()
",np
"from collections import deque
N,M=map(int,input().split())
table=[]

for i in range(M):
    s,t,c=map(int,input().split())
    s,t=s-1,t-1
    table.append((s,t,c))

def check(k):
    Lin=[0]*N
    edge=[[] for i in range(N)]
    for s,t,c in table:
        if c>k:
            Lin[t]+=1
            edge[s].append(t)
    Haco=deque()
    ans=[]
    for i in range(N):
        if Lin[i]==0:
            ans.append(i)
            Haco.append(i)
    while Haco:
        x = Haco.pop()
        for y in edge[x]:
            Lin[y]-=1
            if Lin[y]==0:
                ans.append(y)
                Haco.append(y)
    return ans
ma=10**9+7
mi=-1
while ma-mi>1:
    mid=(ma+mi)//2
    if len(check(mid))==N:
        ma=mid
    else:
        mi=mid
ans=check(ma)

dd={}
for i in ans:
    dd[ans[i]]=i
num=0
answer=[]

for i in range(M):
    s, t, c=table[i]
    if dd[s]>dd[t] and c<=ma:
        answer.append(i+1)
        num+=1
print(ma,num)
print(' '.join(map(str,answer)))
",O(nlogn)
"class Solution(object):
    def isPossible(self, nums):
        pre, cur = float(""-inf""), 0
        cnt1, cnt2, cnt3 = 0, 0, 0
        i = 0
        while i < len(nums):
            cnt = 0
            cur = nums[i]
            while i < len(nums) and cur == nums[i]:
                cnt += 1
                i += 1

            if cur != pre + 1:
                if cnt1 != 0 or cnt2 != 0:
                    return False
                cnt1, cnt2, cnt3 = cnt, 0, 0
            else:
                if cnt < cnt1 + cnt2:
                    return False
                cnt1, cnt2, cnt3 = max(0, cnt - (cnt1 + cnt2 + cnt3)), \
                                   cnt1, \
                                   cnt2 + min(cnt3, cnt - (cnt1 + cnt2))
            pre = cur
        return cnt1 == 0 and cnt2 == 0",O(n)
"import collections



class Solution(object):
    def minOperations(self, nums):
        def ceil_divide(a, b):
            return (a+b-1)//b

        cnt = collections.Counter(nums)
        return sum(ceil_divide(x, 3) for x in cnt.values()) if all(x >= 2 for x in cnt.values()) else -1",O(n)
"class Solution(object):
    def closestMeetingNode(self, edges, node1, node2):
        def dfs(node):
            lookup = {}
            i = 0
            while node != -1:
                if node in lookup:
                    break
                lookup[node] = i
                i += 1
                node = edges[node]
            return lookup
        
        lookup1, lookup2 = dfs(node1), dfs(node2)
        intersect = set(lookup1.keys())&set(lookup2.keys())
        return min(intersect, key=lambda x: (max(lookup1[x], lookup2[x]), x)) if intersect else -1",O(n)
"class Solution(object):
    def findCircleNum(self, M):
        class UnionFind(object):
            def __init__(self, n):
                self.set = list(range(n))
                self.count = n

            def find_set(self, x):
               if self.set[x] != x:
                   self.set[x] = self.find_set(self.set[x]) 
               return self.set[x]

            def union_set(self, x, y):
                x_root, y_root = list(map(self.find_set, (x, y)))
                if x_root != y_root:
                    self.set[min(x_root, y_root)] = max(x_root, y_root)
                    self.count -= 1

        circles = UnionFind(len(M))
        for i in range(len(M)):
            for j in range(len(M)):
                if M[i][j] and i != j:
                    circles.union_set(i, j)
        return circles.count",O(n ^ 2)
"def solve(matrix, col, N, M):
    if col == M:

        ans = 0
        for row in matrix:
            if len(row) == 1:
                ans += row[0]
            else:
                ans += max(*row)

        return ans

    if N == 1:
        return solve(matrix, col + 1, N, M)

    ans = solve(matrix, col + 1, N, M)
    for _ in range(N-1):
        tmp = matrix[0][col]
        for n in range(1, N):
            matrix[n-1][col] = matrix[n][col]
        matrix[N-1][col] = tmp

        local_ans = solve(matrix, col + 1, N, M)
        if local_ans > ans:
            ans = local_ans

    return ans

def main():
    T = int(input())
    for t in range(T):
        N, M = list(map(lambda x: int(x), input().split()))

        matrix = []
        for n in range(N):
            matrix.append(
                list(map(lambda x: int(x), input().split()))
            )

        elements = []
        for n in range(N):
            for m in range(M):
                elements.append((matrix[n][m], m))

        elements.sort(reverse=True)

        candidates = []
        for t in elements:
            if t[1] not in candidates:
                candidates.append(t[1])
                if len(candidates) == N:
                    break

        simplified = []
        for n in range(N):
            row = []
            for m in candidates:
                row.append(matrix[n][m])
            simplified.append(row)

        ans = solve(simplified, 0, N, min(N, M))
        print(ans)

main()
",np
"from sys import exit
N, M = map(int, input().split())
B = list(map(int, input().split()))
G = list(map(int, input().split()))
B.sort()
mB = B[-1]
m2B = B[-2]
mG = min(G)
if mB > mG:
    print(-1)
    exit()
if mB == mG:
    print(sum(B)*M + sum(G) - mB * M)
    exit()
print(sum(B)*M + sum(G) - mB * M + mB - m2B)",O(nlogn)
"import sys
n=int(input())

if n<=3:
    print(0)
    sys.exit()

score=0
import math
def score(x):
    ANS=0
    xr=math.ceil(math.sqrt(x))

    LIST=[]
    for i in range(1,xr+3):
        if x%i==0:
            LIST.append(i)
            LIST.append(x//i)

    LIST=sorted(list(set(LIST)))

    for l in LIST[1:-1]:
        ANS+=x//l

    return ANS

ANS=0
for i in range(4,n+1):
    ANS+=score(i)

print(ANS*4)
",O(n)
"import collections


class Solution(object):
    def checkWays(self, pairs):
        adj = collections.defaultdict(set)
        for x, y in pairs:
            adj[x].add(y)
            adj[y].add(x)
        n, mul = len(adj), False
        lookup = set()
        for node in sorted(iter(adj.keys()), key=lambda i: len(adj[i]), reverse=True):
            lookup.add(node)
            parent = 0
            for x in adj[node]:
                if x not in lookup:
                    continue
                if parent == 0 or len(adj[x]) < len(adj[parent]):
                    parent = x
            if parent:
                if any(True for x in adj[node] if x != parent and x not in adj[parent]):
                    return 0
                mul |= len(adj[parent]) == len(adj[node])
            elif len(adj[node]) != n-1:
                return 0
        return 1 + mul",O(nlogn)
"class Solution_Wrong_Greedy_SortedList(object):
    def minimumIncompatibility(self, nums, k):
        def greedy(nums, k, is_reversed):
            count = collections.Counter(nums)
            if max(count.values()) > k:
                return -1
            ordered_set = sortedcontainers.SortedList(iter(count.keys()))
            freq_to_nodes = collections.defaultdict(collections.OrderedDict)
            for x in ordered_set:
                freq_to_nodes[count[x]][x] = count[x]
            stks = [[] for _ in range(k)] 
            curr = 0
            while ordered_set: 
                if len(stks)-curr in freq_to_nodes: 
                    for x in freq_to_nodes[len(stks)-curr].keys(): 
                        for i in range(curr, len(stks)):
                            stks[i].append(x)
                        count.pop(x)
                        ordered_set.remove(x)
                    freq_to_nodes.pop(len(stks)-curr)
                to_remove = []
                direction = (lambda x:x) if not is_reversed else reversed
                for x in direction(ordered_set):
                    stks[curr].append(x)
                    freq_to_nodes[count[x]].pop(x)
                    if not freq_to_nodes[count[x]]:
                        freq_to_nodes.pop(count[x])
                    count[x] -= 1 
                    if not count[x]:
                        count.pop(x)
                        to_remove.append(x)
                    else:
                        freq_to_nodes[count[x]][x] = count[x]
                    if len(stks[curr]) == len(nums)//k:
                        curr += 1
                        break
                for x in to_remove:
                    ordered_set.remove(x) 
            return sum([max(stk)-min(stk) for stk in stks])

        return min(greedy(nums, k, False), greedy(nums, k, True))",O(nlogn)
"class Solution(object):
    def maxAscendingSum(self, nums):
        result = curr = 0
        for i in range(len(nums)): 
            if not (i and nums[i-1] < nums[i]):
                curr = 0
            curr += nums[i]
            result = max(result, curr)
        return result",O(n)
"r,g,b = list(map(int,input().split()))
dp = [ [ [-1]*(b+1) for i in range(g+1) ] for j in range(r+1) ]
ra = sorted(list(map(int,input().split())),reverse=True)
ga = sorted(list(map(int,input().split())),reverse=True)
ba = sorted(list(map(int,input().split())),reverse=True)

def solve(i,j,k) :

    if dp[i][j][k] != -1 :
        return dp[i][j][k]

    if i==r :
        if j==g or k==b :
            return 0
        dp[i][j][k] = ga[j] * ba[k] + solve(i,j+1,k+1)

    elif j==g :
        if i==r or k==b:
            return 0
        dp[i][j][k] = ra[i] * ba[k] + solve(i+1,j,k+1)

    elif k==b :
        if j==g or i==r:
            return 0
        dp[i][j][k] = ga[j] * ra[i] + solve(i+1,j+1,k)

    else :
        dp[i][j][k] = max(ra[i]*ga[j] + solve(i+1,j+1,k),ra[i]*ba[k] + solve(i+1,j,k+1),ba[k]*ga[j] + solve(i,j+1,k+1))

    return dp[i][j][k]

print(solve(0,0,0))",O(n ^ 3)
"import collections


class Solution(object):
    def findMinHeightTrees(self, n, edges):
        if n == 1:
            return [0]

        neighbors = collections.defaultdict(set)
        for u, v in edges:
            neighbors[u].add(v)
            neighbors[v].add(u)

        pre_level, unvisited = [], set()
        for i in range(n):
            if len(neighbors[i]) == 1: 
                pre_level.append(i)
            unvisited.add(i)

        while len(unvisited) > 2:
            cur_level = []
            for u in pre_level:
                unvisited.remove(u)
                for v in neighbors[u]:
                    if v in unvisited:
                        neighbors[v].remove(u)
                        if len(neighbors[v]) == 1:
                            cur_level.append(v)
            pre_level = cur_level

        return list(unvisited)",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from bisect import bisect_right
n, x, y = map(int, input().split(' '))
s=[0]*n
e=[0]*n
v=[0]*n
c=0
for i in range(n):
    s[i],e[i]=map(int, input().split(' '))
    c+=x+(e[i]-s[i])*y
s.sort()
e.sort()
for i in range(n-2,-1,-1):
    k=bisect_right(s,e[i])
    while (k < n)  and (v[k]==1) and (s[k]-e[i]) * y < x :
        k+=1
    if k==n:
        continue
    if (s[k]-e[i]) * y < x :
        v[k] = 1
        c+=(s[k]-e[i])*y-x

print(c%(10**9+7))",O(nlogn)
"import sys

n, l, r, x = map(int, input().split())
temp = []
temp = list(map(int, input().split()))

temp.sort()
ans = 0

for i in range(1 << n):
    score = 0
    _min = sys.maxsize
    _max = -sys.maxsize
    for j in range(n):
        if i & (1 << j) > 0:
            _min = min(_min, temp[j])
            _max = max(_max, temp[j])
            score += temp[j]
    if score >= l and score <= r and _max-_min >= x:
        ans += 1

print(ans)
",np
"n, capacity = map(int,input().split())
a = [(0, 0)]*n

for i in range(n):
    x, y = map(int,input().split())
    a[i] = (x, y)

a.sort(key=lambda x: max(0, x[0] - x[1]))

current_sum = 0; i = n - 1; ans = 0
for x in a:
    current_sum += x[0]

while i >= 0 and current_sum > capacity:
    ans += 1
    current_sum -= max(0, a[i][0] - a[i][1])
    i -= 1

if current_sum <= capacity:
    print(ans)
else:
    print(-1)",O(nlogn)
"n = int(input())
arr = list(map(int, input().split()))
tracker = [[-1] * (n+1) for _ in range(2024)]

d = [[] for _ in range(n)]
for j, v in enumerate(arr):
	tracker[v][j] = j
	d[j].append(j)

for v in range(1, 2024):
	for i in range(n):
		j = tracker[v][i]
		h = tracker[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			tracker[v+1][i] = h
			d[i].append(h)

a = [_ for _ in range(1, n+1)]
for s in range(n):
	for tracker in d[s]:
		a[tracker] = min(a[tracker], a[s-1]+1 if s > 0 else 1)
print(a[n-1])",O(n ^ 3)
"
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        s, b = sorted([p.val, q.val])
        while not s <= root.val <= b:
            root = root.left if s <= root.val else root.right
        return root

",O(n)
"import sys
import math
import itertools
import functools
import collections
import operator
import fileinput
import copy

ORDA = 97
def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r
def divs(n, start=2):
    r = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if (n % i == 0):
            if (n / i == i):
                r.append(i)
            else:
                r.extend([i, n // i])
    return r
def divn(n, primes):
    divs_number = 1
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t
def prime(n):
    if n == 2: return True
    if n % 2 == 0 or n <= 1: return False
    sqr = int(math.sqrt(n)) + 1
    for d in range(3, sqr, 2):
        if n % d == 0: return False
    return True
def convn(number, base):
    newnumber = 0
    while number > 0:
        newnumber += number % base
        number //= base
    return newnumber
def cdiv(n, k): return n // k + (n % k != 0)

s = input()
lens = len(s)
max_ = 0
for i in range(1, lens):
    d = {}
    for j in range(lens - i + 1):
        if s[j: j + i] in d:
            d[s[j: j + i]] += 1
        else:
            d[s[j: j + i]] = 1
    maxd = max(d.values())
    if max(d.values()) > 1:
        max_ = i
print(max_)
",O(n ^ 3)
"l, r = map(int, input().split())
target, final = l ^ r, 1
while target:
    target >>= 1
    final <<= 1
print(final - 1)
",O(logn)
"n,a,b=map(int,input().split())
l=[int(x) for x in input().split()]
l.sort()
print(l[b]-l[b-1])",O(nlogn)
"import sys
import logging
logging.root.setLevel(level=logging.DEBUG)
import re

s = sys.stdin.readline().strip()

from collections import defaultdict
substr = defaultdict(int)
for left in range(len(s)):
    for right in range(left+1,len(s)+1):
        substr[s[left:right]] += 1
max_len = 0
for segment,times in substr.items():
    if times >= 2:
        max_len = max(max_len,len(segment))
print(max_len)
",O(n ^ 3)
"class Solution(object):
    def minimumMoves(self, s):
        result = i = 0
        while i < len(s):
            if s[i] == 'X':
                result += 1
                i += 3
            else:
                i += 1
        return result",O(n)
"import sys
readline = sys.stdin.readline

def popcount(i):
    assert 0 <= i < 0x100000000
    i = i - ((i >> 1) & 0x55555555)
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333)
    return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24

N, M = map(int, readline().split())

Ar = [tuple(map(int, readline().split())) for _ in range(N)]

pc = [popcount(i) for i in range(1<<(M+1))]

inf = 1<<31
maxi = [0]*(1<<M)

for i in range(N):
    a = Ar[i]
    dp = [0]*(1<<M)
    for S in range(1, 1<<M):
        p = pc[S]
        if p == 1:
            k = S.bit_length() - 1
            dp[S] = a[k]
        else:
            dp[S] = min(dp[-S&S], dp[S^(-S&S)])
        maxi[S] = max(maxi[S], dp[S])
for i in range(M):
    for j in range(1<<M):
        if not j & (1<<i):
            maxi[j] = max(maxi[j], maxi[j|(1<<i)])

D = (1<<M)-1
ans = maxi[D]
aS, bS = D, D
for S in range(1<<M):
    candi = min(maxi[S], maxi[D^S])
    if candi > ans:
        aS, bS = S, D^S
        ans = candi

Ans = [None]*2
pre = False
fro = False

for i in range(N):
    a = Ar[i]
    resa = inf
    resb = inf
    for j in range(M):
        if (1<<j)&aS:
            resa = min(resa, a[j])
        else:
            resb = min(resb, a[j])
    if resa >= ans:
        pre = True
        Ans[0] = i+1
    if resb >= ans:
        fro = True
        Ans[1] = i+1
    if pre and fro:
        break
print(*Ans)
",np
"class Solution3(object):
    def rotateString(self, A, B):
        return len(A) == len(B) and B in A*2",O(n ^ 2)
"n, k = [int(i) for i in input().split()]
p = [int(i) for i in input().split()]
ans = [-1] * (max(p) + 1)
ans[0] = 0
for i in range(n):
	if ans[p[i]] < 0:
		position = p[i] - k + 1
		for j in range(max(0,p[i] - k + 1), p[i] + 1):
			if ans[j] < 0:
				position = j
				break
		j = max(0, position - 1)
		key = ans[j]
		count = 0
		while j >= 0:
			if ans[j] != key:
				position1 = j + 1
				break
			j -= 1
			count += 1
		if count + p[i] + 1 - position > k:
			key = position
		for j in range(position, p[i] + 1):
			ans[j] = key

for i in range(n):
	if i != len(p) - 1:
		wk1 = "" ""
	else:
		wk1 = ""\n""
	print(ans[p[i]], end = wk1)
",O(n ^ 2)
"class UnionFind(object): 
    def __init__(self, n):
        self.set = list(range(n))
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        return True



class Solution(object):
    def maximumSafenessFactor(self, grid):
        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))
        def bfs():
            dist = [[0 if grid[r][c] == 1 else -1 for c in range(len(grid[0]))] for r in range(len(grid))]
            q = [(r, c) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c]]
            d = 0
            while q:
                new_q = []
                for r, c in q:
                    for dr, dc in DIRECTIONS:
                        nr, nc = r+dr, c+dc
                        if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and dist[nr][nc] == -1):
                            continue
                        dist[nr][nc] = d+1
                        new_q.append((nr, nc))
                q = new_q
                d += 1
            return dist

        dist = bfs()
        buckets = [[] for _ in range((len(grid)-1)+(len(grid[0])-1)+1)]
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                buckets[dist[r][c]].append((r, c))
        lookup = [[False]*len(grid[0]) for _ in range(len(grid))]
        uf = UnionFind(len(grid)*len(grid[0]))
        for d in reversed(range(len(buckets))):
            for r, c in buckets[d]:
                for dr, dc in DIRECTIONS:
                    nr, nc = r+dr, c+dc
                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and lookup[nr][nc] == True):
                        continue
                    uf.union_set(nr*len(grid[0])+nc, r*len(grid[0])+c)
                lookup[r][c] = True
            if uf.find_set(0*len(grid[0])+0) == uf.find_set((len(grid)-1)*len(grid[0])+(len(grid[0])-1)):
                break
        return d",O(n ^ 2)
"N, M = map(int, input().split())

grid = []
for _ in range(N):
    grid.append(list(input()))

def check(grid, i, j, sx, sy):
    if i - sx >= 0 and j - sy >= 0 and i + 2 - sx < N and j + 2 - sy < M:
        i -= sx
        j -= sy
        v = grid[i][j] == '
        return v

    return False

prev = False
for m in range(M):
    for n in range(N):
        if grid[n][m] == '
            if not (check(grid, n, m, 0, 0) or check(grid, n, m, 1, 0) or check(grid, n, m, 2, 0) or check(grid, n, m, 0, 1) or check(grid, n, m, 2, 1) or check(grid, n, m, 0, 2) or check(grid, n, m, 1, 2) or check(grid, n, m, 2, 2)):
                print(""NO"")
                exit(0)

print(""YES"")
",O(n ^ 2)
"n, s = map(int, input().split())
ans = s
f = []
t = []
for i in range(n):
    f, t = map(int, input().split())
    if(t>(s-f)):
        ans +=  t - (s-f)
        s += t - (s-f)

print(ans)",O(n)
"class Solution2(object):
    def numberOfWays(self, num_people):
        MOD = 10**9+7
        dp = [0]*(num_people//2+1)
        dp[0] = 1
        for k in range(1, num_people//2+1):
            for i in range(k):
                dp[k] = (dp[k] + dp[i]*dp[k-1-i]) % MOD
        return dp[num_people//2]",O(n ^ 2)
"from math import floor
from sys import stdin

CONST = 9

def solve(k):
    i = 0
    while k > CONST * (10 ** i) * (i + 1):
        k -= floor(CONST * (10 ** i)) * (i + 1)
        i += 1
    num_digits = i + 1
    num = floor((k - 1) / num_digits)
    num += floor(10 ** (i))
    print(('{}'.format(num))[(k - 1) % num_digits])

if __name__ == '__main__':
    for line in stdin:
        solve(int(line.rstrip()))",O(logn)
"import os
import sys
from io import BytesIO, IOBase
import heapq as h
from bisect import bisect_left, bisect_right
import time

from types import GeneratorType
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict as dd, deque as dq, Counter as dc
import math, string

start_time = time.time()

def getInts():
    return [int(s) for s in input().split()]

def getInt():
    return int(input())

def getStrs():
    return [s for s in input().split()]

def getStr():
    return input()

def listStr():
    return list(input())
def getMat(n):
    return [getInts() for _ in range(n)]
def get_ints():return map(int, sys.stdin.readline().split())

n,k=map(int,input().split())
knight=list(map(int,input().split()))
coins=list(map(int,input().split()))
d={};ans=[0]*n
for i in range(n):
  knight[i]=[knight[i],i]
for i in coins:
  d[i]=d.get(i,0)+1
c=coins[:]

knight=sorted(knight,key=lambda x:x[0])

ans2=[];ans=coins[:]
if k==0:print(*ans)
else:
 for i in range(n):
  ans1=0
  if len(ans2)<k:ans1=sum(ans2)
  else:ans2=sorted(ans2)[-k:];ans1+=sum(ans2)

  ans[knight[i][1]]+=ans1
  ans2.append(coins[knight[i][1]])
 print(*ans)
",O(nlogn)
"n, m, K=map(int, input().split())
edgesh=[[0 for i in range(m-1)] for k in range(n)]

edgesv=[[0 for i in range(m)] for k in range(n-1)]

for mm in range(n):
    edgesh[mm]=list(map(int, input().split("" "")))
for mm in range(n-1):
    edgesv[mm]=list(map(int, input().split("" "")))
dp=[[[10**10 for tro in range(K+1)] for i in range(m)] for mm in range(n)]
for k in range(0, K+1, 2):
 for i in range(n):
  for j in range(m):
    if(k==0):
      dp[i][j][k]=0
    elif(i==0 and j==0):
      dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2])
    elif(i==0 and j==m-1):
      dp[i][j][k]=min(2*edgesh[i][j-1]+dp[i][j-1][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2])
    elif(i==0):
      dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2], 2*edgesh[i][j-1]+dp[i][j-1][k-2])
    elif(j==0 and i==n-1):
      dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2])
    elif(j==0):
      dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2])
    elif(i==n-1 and j==m-1):
      dp[i][j][k]=min(2*edgesh[i][j-1]+dp[i][j-1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2])
    elif(i==n-1):
      dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2], 2*edgesh[i][j-1]+dp[i][j-1][k-2])
    elif(j==m-1):
      dp[i][j][k]=min(2*edgesh[i][j-1]+dp[i][j-1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2])
    else:
      dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2], 2*edgesh[i][j-1]+dp[i][j-1][k-2])
for i in range(n):
  for j in range(m):
   if(dp[i][j][K]>=10**10):
    print(-1, end="" "")
   else:
    print(dp[i][j][K], end="" "")
  print()",O(n ^ 3)
"class Solution(object):
    def permute(self, n, k):
        result = []
        cnt = [1]*n
        for i in range(len(cnt)-1):
            cnt[i+1] = min(cnt[i]*((i+2)//2), k)
        lookup = [False]*n
        for i in range(n):
            for j in range(n):
                if not (not lookup[j] and ((i == 0 and n%2 == 0) or (j+1)%2 == (1 if not result else (result[-1]%2)^1))):
                    continue
                if k <= cnt[n-1-i]:
                    break
                k -= cnt[n-1-i]
            else:
                return []
            lookup[j] = True
            result.append(j+1)
        return result",O(n ^ 2)
"import sys, math

def mp():
    return list(map(int, input().split()))

def main():
    n, k = mp()
    a = [2, 5, 8]
    s = 0
    for i in a:
        s += (n * i - 1) // k + 1
    print(s)

debug = 0
if debug:
    file = open(""input.txt"", ""r"")
    input = file.readline
main()
if debug:
    file.close()",O(1)
"class Solution:
    def checkValidString(self, s: str) -> bool:
        left = []
        star = []
        for i, ch in enumerate(s):
            if ch == '(':
                left.append(i)
            elif ch == '*':
                star.append(i)
            else:
                if not left and not star:
                    return False
                if left:
                    left.pop()
                else:
                    star.pop()

        while left and star:
            if left.pop() > star.pop():
                return False
        return not left
",O(n)
"def findValue(n,m):

	return n*(n+1)//2 - m*(m+1)//2 - (n-m-1)

n,k = map(int,input().split())

maxi = k*(k+1)//2 - k + 1

if n==1:
	print(0)
elif  n>maxi:
	print(-1)
else:
	begin = 2
	end = k

	while (begin<=end):

		mid = (begin+end)//2
		value = findValue(k,mid)

		if value==n:
			MID=mid
			break
		elif value>n:
			begin = mid+1
		else:
			MID=mid
			end=mid-1

	remaining = n-findValue(k,MID)

	if remaining ==0:
		print(k-MID)
	else:
		print(k-MID+1)
",O(logn)
"class Solution3(object):
    def maxJumps(self, arr, d):
        left, decreasing_stk = list(range(len(arr))), []
        for i in range(len(arr)):
            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
                if i - decreasing_stk[-1] <= d:
                    left[i] = decreasing_stk[-1]
                decreasing_stk.pop()
            decreasing_stk.append(i)
        right, decreasing_stk = list(range(len(arr))), []
        for i in reversed(range(len(arr))):
            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
                if decreasing_stk[-1] - i <= d:
                    right[i] = decreasing_stk[-1]
                decreasing_stk.pop()
            decreasing_stk.append(i)

        segment_tree = SegmentTree(len(arr))
        for _, i in sorted([x, i] for i, x in enumerate(arr)):
            segment_tree.update(i, i, segment_tree.query(left[i], right[i]) + 1)
        return segment_tree.query(0, len(arr)-1)",O(nlogn)
"import math
import random


class Solution(object):
    def minimizeError(self, prices, target):
        def kthElement(nums, k, compare=lambda a, b: a < b):
            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left <= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == k:
                    return
                elif new_pivot_idx > k:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1
        
        errors = []
        lower, upper = 0, 0
        for i, p in enumerate(map(float, prices)):
            lower += int(math.floor(p))
            upper += int(math.ceil(p))
            if p != math.floor(p):
                errors.append(p-math.floor(p))
        if not lower <= target <= upper:
            return ""-1""

        lower_round_count = upper-target
        kthElement(errors, lower_round_count)
        result = 0.0
        for i in range(len(errors)):
            if i < lower_round_count:
                result += errors[i]
            else:
                result += 1.0-errors[i]
        return ""{:.3f}"".format(result)",O(n)
"n = int(input())
a = list(map(int,input().split()))

for i in range(n):
    if a[i] >= 0:
        a[i] = -a[i]-1

if n%2:
    m = min(a)
    for i in range(n):
        if a[i] == m:
            a[i] = -a[i]-1
            break

print(*a)
",O(n)
"def readline(): return tuple(map(int, input().split()))
def readlines(count): return (readline() for __ in range(count))

def main():
    n, = readline()
    segments = sorted(readline() + (idx + 1,) for idx in range(n))

    prev = (-1, -1, -1)
    for segment in segments:
        assert prev[0] <= segment[0]
        if prev[0] == segment[0]:
            assert prev[1] <= segment[1]
            print(prev[2], segment[2])
            break
        elif prev[1] >= segment[1]:
            print(segment[2],  prev[2])
            break
        prev = segment
    else:
        print(-1, -1)

main()
",O(nlogn)
"def func(k, a):
    if len(a) == 1:
        return 1
    if k == 1:
        return len(a)
    s = set(a)
    for x in sorted(a):
        if x in s and k * x in s:
            s.remove(k * x)
    return len(s)

def read_ints():
    return [int(x) for x in input().split(' ')]

def main():
    n, k = read_ints()
    a = read_ints()
    assert n == len(a)
    print(func(k, a))

if __name__ == '__main__':
    main()
",O(nlogn)
"class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        prev, curr = None, head

        while curr:
            temp = curr.next
            curr.next = prev
            prev = curr
            curr = temp
        return prev
",O(n)
"import collections



class Solution(object):
    def frogPosition(self, n, edges, t, target):
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)

        stk = [(t, 1, 0, 1)]
        while stk:
            new_stk = []
            while stk:
                t, node, parent, choices = stk.pop()
                if not t or not (len(G[node])-(parent != 0)):
                    if node == target:
                        return 1.0/choices
                    continue
                for child in G[node]:
                    if child == parent:
                        continue
                    new_stk.append((t-1, child, node,
                                    choices*(len(G[node])-(parent != 0))))
            stk = new_stk
        return 0.0",O(n)
"class Solution:
    def climbStairs(self, n: int) -> int:
        one, two = 1, 1

        for i in range(n - 1):
            temp = one
            one = one + two
            two = temp

        return one
",O(n)
"import os,sys
from io import BytesIO, IOBase

def bit_count(x):
    ans = 0
    while x:
        x &= x-1
        ans += 1
    return ans

def main():
    n = input().strip()
    x = len(n)
    k = int(input())
    if n == '1':
        print(int(k==0))
        exit()
    if not k:
        print(1)
        exit()
    mod = 10**9+7
    dp = [0]*(x+1)
    dp[1] = 1
    for i in range(2,x+1):
        dp[i] = dp[bit_count(i)]+1
    dp1 = [[0]*(x+1) for _ in range(x+1)]

    for i in range(x+1):
        dp1[i][0] = 1
    for i in range(1,x+1):
        for j in range(1,i+1):
            dp1[i][j] = (dp1[i-1][j-1]+dp1[i-1][j])%mod
    ans = 0
    cou = n.count('1')
    for i in range(1,x+1):
        if dp[i] != k:
            continue
        se = i
        for j in range(x):
            if n[j] == '0':
                continue
            ans = (ans+dp1[x-1-j][se]-(se==1 and k==1))%mod
            se -= 1
            if se < 0:
                break
        if cou == i:
            ans = (ans+1)%mod
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",O(n)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, = getIntList()

zl = getIntList()
zr = getIntList()

zt = [ (zl[i] + zr[i], i) for i in range(N) ]
zt.sort()
za = [0 for i in range(N) ]
now = N
for i in range(N):
    if i>0 and zt[i-1][0] <zt[i][0]:
        now-=1
    za[ zt[i][1] ] = now

for i in range(N):
    l = 0
    r = 0
    for j in range(i):
        if za[j] > za[i]:
            l+=1
    for j in range(i+1, N):
        if za[j] > za[i]:
            r+=1
    if zl[i] != l or zr[i] != r:
        print('NO')
        sys.exit()
print('YES')
for i in range(N):
    print(za[i],end = ' ')
",O(n ^ 2)
"import sys
import string
from math import gcd
import getpass
import math
from decimal import Decimal

def ria():
    return [int(i) for i in input().split()]

if getpass.getuser() != 'frohenk':
    filename = 'half'

else:
    sys.stdin = open('input.txt')

n = ria()[0]
if n == 1:
    print(1)
    exit(0)

if n == 2:
    print(1, 2)
    exit(0)

if n == 3:
    print(1, 1, 3)
    exit(0)

ar = [0] * 30

for i in range(30):
    ar[i] = n // (2 ** i) - n // (2 ** (i + 1))
sd = 0
for i in range(30):
    if sd == n - 1:
        if n==(2**i):
            print(2**i)
        else:
            print(n-n%(2**(i-1)))
        exit(0)
    for j in range(ar[i]):
        print(2 ** i, end=' ')
        sd += 1
",O(n)
"n = int(input())
a = list(input())
b = list(input())

ans = 0
i = 0
while i < n:
    if a[i] != b[i]:
        ans += 1
        if i < n - 1 and a[i] == b[i + 1] and b[i] == a[i + 1]:
            i += 1
    i += 1
print(ans)
",O(n)
"class Solution(object):
    def minTimeToType(self, word):
        return (min((ord(word[0])-ord('a'))%26, (ord('a')-ord(word[0]))%26)+1) + \
               sum(min((ord(word[i])-ord(word[i-1]))%26, (ord(word[i-1])-ord(word[i]))%26)+1
                   for i in range(1, len(word)))",O(n)
"class Solution2(object):
    def findChampion(self, n, edges):
        lookup = [False]*n
        for u, v in edges:
            lookup[v] = True
        result = -1
        for u in range(n):
            if lookup[u]:
                continue
            if result != -1:
                return -1
            result = u
        return result",O(n)
"class Solution(object):
    def pseudoPalindromicPaths (self, root):
        result = 0
        stk = [(root, 0)]
        while stk:
            node, count = stk.pop()
            if not node:
                continue
            count ^= 1 << (node.val-1)
            result += int(node.left == node.right and count&(count-1) == 0)
            stk.append((node.right, count))
            stk.append((node.left, count))
        return result",O(n)
"
import pandas as pd



def Solution(customers: pd.DataFrame) -> pd.DataFrame:
    customers.drop_duplicates(subset=[""email""], keep=""first"", inplace=True)
    return customers
",O(n)
"n, l, r, x = map(int, input().split())
d = list(map(int, input().split()))
ans = 0
for i in range(pow(2, n)-1, -1, -1):
	s = bin(i)[2:]
	while(len(s) < n):
		s = ""0""+s
	diff = 0
	t = []
	for j in range(n):
		if(s[j]=='1'):
			diff += d[j]
			t.append(d[j])
	t.sort()

	if(l <= diff <= r and t[-1]-t[0] >= x):
		ans += 1
print(ans)",np
"def maxx(n):
	return n&-n
n,q=map(int,input().split())
root=n//2+1
while q>0:
	x=int(input())
	s=input()

	for i in s:
		if i=='U' and x!=root:
			p=x+maxx(x)
			if x==p-maxx(p)//2:
				x=p
			else:
				x=x-maxx(x)
		elif i=='L':
			x=x-maxx(x)//2
		elif i=='R':
			x=x+maxx(x)//2
	q=q-1
	print(x)",np
"class Solution(object):
    def findContestMatch(self, n):
        matches = list(map(str, list(range(1, n+1))))
        while len(matches)/2:
            matches = [""({},{})"".format(matches[i], matches[-i-1]) for i in range(len(matches)/2)]
        return matches[0]",O(n)
"class Solution(object):
    def smallestMissingValueSubtree(self, parents, nums):
        def iter_dfs(adj, nums, i, lookup):
            stk = [i]
            while stk:
                i = stk.pop()
                if nums[i] in lookup:
                    continue
                lookup.add(nums[i])
                for j in adj[i]:
                    stk.append(j)

        result = [1]*len(parents)
        i = next((i for i in range(len(nums)) if nums[i] == 1), -1)
        if i == -1:
            return result
        adj = [[] for _ in range(len(parents))]
        for j in range(1, len(parents)):
            adj[parents[j]].append(j)
        lookup = set()
        miss = 1
        while i >= 0:
            iter_dfs(adj, nums, i, lookup)
            while miss in lookup:
                miss += 1
            result[i] = miss
            i = parents[i]
        return result",O(n)
"n,k = map(int,input().split("" ""))
degrees = [0] * n
neighbors = [list() for x in range(n)]
for i in range(n-1):
	first,second = map(int,input().split("" ""))
	degrees[first-1] += 1
	degrees[second-1] += 1
	neighbors[first-1] += [second]
	neighbors[second-1] += [first]

curr = 0
for i in range(n):
	if degrees[i] == 1:
		curr = i+1
		break
if curr == 0 or len(neighbors[curr-1]) == 0:
	print(""No"")
	exit()
curr = neighbors[curr-1][0]

def check(prev,parent,curr,level,degrees,neighbors,k):

	if level == 0:
		return len(parent) == 1 and degrees[curr-1] == 1,[]
	checked = []
	for neighbor in neighbors[curr-1]:

		if len(prev) != 0 and prev[0] == neighbor:
			checked += [neighbor]
			continue
		if len(parent) != 0 and parent[0] == neighbor:
			continue
		result,garbage = check([],[curr],neighbor,level-1,degrees,neighbors,k)
		if result:
			checked += [neighbor]
		else:

			if len(parent) == 0:
				parent += [neighbor]
			else:
				return False,[]
	if len(checked) > 2 and len(parent) == 0 and level == k:

		return True,[]
	elif len(checked) > 2 and len(parent) == 1 and level != k:

		return True,parent
	else:

		return False,[]

prev = []
parent = []
counter = 1
while(counter <= k):
	result,parent = check(prev,[],curr,counter,degrees,neighbors,k)
	if not(result):
		print(""No"")
		exit()
	if counter == k:
		print(""Yes"")
		exit()
	prev = [curr]
	curr = parent[0]
	counter += 1
",O(nlogn)
"import collections
from sortedcontainers import SortedList



class Solution(object):
    def sumCounts(self, nums):
        MOD = 10**9+7
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = (self.__bit[i]+val) % MOD
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret = (ret+self.__bit[i]) % MOD
                    i -= (i & -i)
                return ret

        def update(accu, d):
            i = sl.bisect_left(idxs[x][-1])
            accu = (accu + d*(len(nums)*(2*len(sl)-1) - (2*i+1)*idxs[x][-1] - 2*(bit.query(len(nums)-1)-bit.query(idxs[x][-1])))) % MOD
            bit.add(idxs[x][-1], d*idxs[x][-1])
            return accu

        idxs = collections.defaultdict(list)
        for i in reversed(range(len(nums))):
            idxs[nums[i]].append(i)
        result = 0
        sl = SortedList(idxs[x][-1] for x in idxs)
        accu = (len(nums)*len(sl)**2) % MOD
        for i, x in enumerate(sl):
            accu = (accu-(2*i+1)*x) % MOD
        bit = BIT(len(nums))
        for x in sl:
            bit.add(x, x)
        for x in nums:
            result = (result+accu) % MOD 
            accu = update(accu, -1)
            del sl[0]
            idxs[x].pop()
            if not idxs[x]:
                continue
            sl.add(idxs[x][-1])
            accu = update(accu, +1)
        assert(accu == 0)
        return result",O(nlogn)
"class Solution(object):
    def minimumPerimeter(self, neededApples):
        a, b, c, d = 4.0, 6.0, 2.0, float(-neededApples)
        p = (3*a*c-b**2)/(3*a**2) 
        q = (2*b**3-9*a*b*c+27*a**2*d)/(27*a**3) 
        assert((q/2)**2+(p/3)**3 > 0) 
        x = (-q/2 + ((q/2)**2+(p/3)**3)**0.5)**(1.0/3) + \
            (-q/2 - ((q/2)**2+(p/3)**3)**0.5)**(1.0/3)
        return 8*int(math.ceil(x - b/(3*a)))",O(1)
"string = input()
totalmax = 0;
for x in range(len(string)):
    curr = """"
    for y in string[x:]:
        curr +=y;
        if string[x:].rfind(curr) != string[x:].find(curr):
            totalmax = max(totalmax, len(curr))
            continue
print(totalmax)",O(n ^ 3)
"class Solution2(object):
    def largestGoodInteger(self, num):
        return max(num[i] if num[i] == num[i+1] == num[i+2] else '' for i in range(len(num)-2))*3",O(n)
"class Solution2(object):
    def catMouseGame(self, graph):
        HOLE, MOUSE_START, CAT_START = list(range(3))
        DRAW, MOUSE, CAT = list(range(3))
        def parents(m, c, t):
            if t == CAT:
                for nm in graph[m]:
                    yield nm, c, MOUSE^CAT^t
            else:
                for nc in graph[c]:
                    if nc != HOLE:
                        yield m, nc, MOUSE^CAT^t

        color = collections.defaultdict(int)
        degree = {}
        ignore = set(graph[HOLE])
        for m in range(len(graph)):
            for c in range(len(graph)):
                degree[m, c, MOUSE] = len(graph[m])
                degree[m, c, CAT] = len(graph[c])-(c in ignore)
        q1 = collections.deque()
        q2 = collections.deque()
        for i in range(len(graph)):
            if i == HOLE:
                continue
            color[HOLE, i, CAT] = MOUSE
            q1.append((HOLE, i, CAT))
            for t in [MOUSE, CAT]:
                color[i, i, t] = CAT
                q2.append((i, i, t))
        while q1:
            i, j, t = q1.popleft()
            for ni, nj, nt in parents(i, j, t):
                if color[ni, nj, nt] != DRAW:
                    continue
                if t == CAT:
                    color[ni, nj, nt] = MOUSE
                    q1.append((ni, nj, nt))
                    continue
                degree[ni, nj, nt] -= 1
                if not degree[ni, nj, nt]:
                    color[ni, nj, nt] = MOUSE
                    q1.append((ni, nj, nt))
        while q2:
            i, j, t = q2.popleft()
            for ni, nj, nt in parents(i, j, t):
                if color[ni, nj, nt] != DRAW:
                    continue
                if t == MOUSE:
                    color[ni, nj, nt] = CAT
                    q2.append((ni, nj, nt))
                    continue
                degree[ni, nj, nt] -= 1
                if not degree[ni, nj, nt]:
                    color[ni, nj, nt] = CAT
                    q2.append((ni, nj, nt))
        return color[MOUSE_START, CAT_START, MOUSE]",O(n ^ 3)
"class Solution(object):
    def distMoney(self, money, children):
        if money < children*1:
            return -1
        money -= children*1
        q, r = divmod(money, 7)
        return min(q, children) - int(q > children or (q == children and r != 0) or (q == children-1 and r == 3))",O(1)
"import collections
import itertools


class Solution(object):
    def mostVisitedPattern(self, username, timestamp, website):
        lookup = collections.defaultdict(list)
        A = list(zip(timestamp, username, website))
        A.sort()
        for t, u, w in A:
            lookup[u].append(w)
        count = sum([collections.Counter(set(itertools.combinations(lookup[u], 3))) for u in lookup], collections.Counter())
        return list(min(count, key=lambda x: (-count[x], x)))",O(n ^ 3)
"import sys
sys.setrecursionlimit(200000)
input=sys.stdin.readline

def solve(r,g,b,R,G,B):
    if (r==0 and g==0) and (r==0 and b==0) and (g==0 and b==0):
        return 0
    if z[r][g][b]!=-1:
        return z[r][g][b]
    d,e,f=0,0,0
    if r!=0 and g!=0:
        d=R[r-1]*G[g-1]+solve(r-1,g-1,b,R,G,B)
    if r!=0 and b!=0:
        e=R[r-1]*B[b-1]+solve(r-1,g,b-1,R,G,B)
    if b!=0 and g!=0:
        f=B[b-1]*G[g-1]+solve(r,g-1,b-1,R,G,B)
    z[r][g][b]=max(d,e,f)
    return z[r][g][b]

r,g,b=map(int,input().rstrip().split())
R=sorted(map(int,input().rstrip().split()))
G=sorted(map(int,input().rstrip().split()))
B=sorted(map(int,input().rstrip().split()))
z=[[[ -1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
print(solve(r,g,b,R,G,B))",O(n ^ 3)
"class Solution2(object):
    def rearrangeArray(self, nums):
        nums.sort()
        mid = (len(nums)-1)//2
        nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1]
        return nums",O(nlogn)
"import os
from io import BytesIO, IOBase
import sys
from collections import defaultdict, deque, Counter
from math import sqrt, pi, ceil, log, inf, gcd, floor
from itertools import combinations, permutations
from bisect import *
from fractions import Fraction
from heapq import *
from random import randint

def main():
    n=int(input())
    a=list(map(int,input().split()))
    dp=[[0 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        dp[i][i]=a[i]
    for i in range(n-2,-1,-1):
        for j in range(i+1,n,1):
            for k in range(i,j,1):
                if dp[i][k] and dp[i][k]==dp[k+1][j]:
                    dp[i][j]=dp[i][k]+1
    b=[10**10]*(n+1)
    b[0]=0
    for i in range(1,n+1):
        for j in range(i):
            if dp[j][i-1]:
                b[i]=min(b[i],b[j]+1)
    print(b[n])

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(n ^ 3)
"x,k=map(int,input().split())
MOD = pow(10,9)+7
def repow(n):
  global MOD
  if n == 1:
    return 2
  if n%2 == 0:
    return pow(repow(n//2),2)%MOD
  else:
    return (2*pow(repow(n//2),2))%MOD

if 0 < k and 0 < x:
  if MOD <= k:
    while MOD <= k:
      k = (k // MOD) + (k % MOD)
  tmp = (2*x-1)%MOD
  print((tmp*repow(k)+1)%MOD)
else:
  print(2*x%MOD)
",O(logn)
"def inp():
    return map(int, input().split())

def sum_range(n):
    return (n * (n + 1)) // 2

def bs(st, en):
    while (st < en):
        mid = st + (en - st) // 2
        s1 = s - sum_range(mid - 1)

        if s1 == n:
            return (k - mid) + 1
        elif s1 > n:
            st = mid + 1
        else:
            en = mid
    return (k - st) + 2

n, k = inp()
n -= 1
k -= 1
s = sum_range(k)

if n+1 == 1:
    print(0)
elif n <= k:
    exit(print(1))
elif n > s:
    print(-1)
else:
    print(bs(1, k))
",O(logn)
"l,r=map(int,input().split(' '))

def gcd(a ,b):
    if(b==0):return a
    return gcd(b,a%b)

for a in range(l,r+1):
    for b in range(a+1,r+1):
        for c in range(b+1,r+1):
            if(gcd(a,b)==1 and gcd(b,c)==1 and gcd(a,c)!=1):
                print(a,b,c)
                exit()

print(-1)
",O(1)
"n = int(input())
x1, y1 = map(int, input().split())
x2, y2 = map(int, input().split())
x3, y3 = map(int, input().split())
if (x2 < x1 and x3 < x1 or x2 > x1 and x3 > x1) and (y2 < y1 and y3 < y1 or y2 > y1 and y3 > y1):
    print(""YES"")
else:
    print(""NO"")
",O(1)
"

class Solution(object):
    def minimumRemoval(self, beans):
        beans.sort()
        return sum(beans) - max(x*(len(beans)-i)for i, x in enumerate(beans))
",O(nlogn)
"class Solution2(object):
    def beautifulSplits(self, nums):
        dp = [[0]*len(nums) for _ in range(len(nums))]
        for i in reversed(range(len(nums))):
            for j in range(i+1, len(dp)):
                dp[i][j] = 1+(dp[i+1][j+1] if j+1 < len(nums) else 0) if nums[i] == nums[j] else 0
        result = 0
        for i in range(1, len(nums)-1):
            for j in range(i+1, len(nums)):
                if (dp[0][i] >= i and j-i >= i) or dp[i][j] >= j-i:
                    result += 1
        return result",O(n ^ 2)
"n = int(input())
l = [*map(int, input().split())]

p = [0] * n
for i in range(n): p[l[i] - 1] = i

res = ['?'] * n

for e in range(n, 0, -1):
    i = p[e - 1]
    res[i] = 'B'
    for j in range(i % e, n, e):
        if i != j and l[i] <= l[j] and res[j] == 'B':
            res[i] = 'A'
            break
print(''.join(res))",O(n ^ 2)
"class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        mp = defaultdict(int)
        res = 0

        for num in nums:
            if not mp[num]:
                mp[num] = mp[num - 1] + mp[num + 1] + 1
                mp[num - mp[num - 1]] = mp[num]
                mp[num + mp[num + 1]] = mp[num]
                res = max(res, mp[num])
        return res
",O(n)
"import sys

reader = (map(int, line.split()) for line in sys.stdin)
input = reader.__next__

n, m = input()
arrays = []
for i in range(n):
    arrays.append(list(input()))

full = (1 << m) - 1
L = -1
R = 10 ** 9 + 1
while L + 1 < R:
    check = (L + R) >> 1

    masks = {}
    for i, arr in enumerate(arrays):
        curr = 0
        for val in arr:
            curr <<= 1
            if val >= check:
                curr |= 1
        masks[curr] = i

    isValid = False
    for k1 in masks:
        for k2 in masks:
            if k1 | k2 == full:
                ans0 = masks[k1]
                ans1 = masks[k2]
                isValid = True
                break
        if isValid:
            break

    if isValid:
        L = check
    else:
        R = check

print(ans0 + 1, ans1 + 1)
",np
"from sys import stdin

memo = {}
def max_splits(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    if n in memo:
        return memo[n]
    result = 4 * max_splits(n - 1) + 1
    memo[n] = result
    return result

t = int(stdin.readline())
for i in range(t):
    n, k = [int(s) for s in stdin.readline().strip().split()]

    min_splits = 1
    path_count = 3

    if n > 75:
        print(""YES"", n - 1)
        continue

    square_size = n - 1
    max_buffer = max_splits(square_size)

    while min_splits + path_count <= k and square_size > 0:
        min_splits += path_count
        max_buffer += (4 * path_count - (2 * path_count + 1)) * max_splits(square_size - 1)
        path_count = 2 * path_count + 1
        square_size -= 1

    if min_splits <= k <= min_splits + max_buffer:
        print(""YES"", square_size)
    else:
        print(""NO"")
",O(logn)
"import sys
def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def rinput():   return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))

n=iinput()
d={}
for i in range(n - 1):
    u,v=rinput()
    d.setdefault(u,[]).append(v)
    d.setdefault(v,[]).append(u)
node=1
for key in d:
    if(len(d[key])>len(d[node])):
        node=key
ans=[]
visited=[0]*n
visited[node-1]=1
for c in d[node]:
    while(True):
        visited[c-1]=1
        if(len(d[c])==1):
            ans.append([node,c])
            break
        for child in d[c]:
            if(visited[child-1]!=1):
                c=child
                break
if(sum(visited)==n):
    print(""Yes"")
    print(len(ans))
    for c in ans:
        print(*c)
else:
    print(""No"")",O(n)
"a=int(input())
b=str(a)
c=[]
for i in range(2,a+1):
    if(a%i==0):
        c.append(i)

l=0
for j in c:
    r=str(j)
    t=len(r)
    o=0
    for p in r:
        if(p==""4"" or p==""7""):
            o=o+1
    if(o==t):
        l=l+1
if(l>0):
    print(""YES"")
else:
    print(""NO"")
",O(1)
"import sys
import math
from collections import defaultdict,deque

input = sys.stdin.readline
def inar():
    return [int(el) for el in input().split()]
def main():
    n,m=inar()
    tup=[]
    sm=0
    for i in range(n):
        a,b=inar()
        sm+=a
        diff=a-b
        tup.append([diff,a,b])
    tup.sort(reverse=True)
    ans=0
    i=0
    while sm>m and i<n:
        sm-=tup[i][1]
        sm+=tup[i][2]
        i+=1
        ans+=1
    if sm<=m:
        print(ans)
    else:
        print(-1)

if __name__ == '__main__':
    main()
",O(nlogn)
"import collections
import random
from functools import reduce



class Solution(object):
    def countKSubsequencesWithMaxBeauty(self, s, k):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def nCr(n, k):
            if not (0 <= k <= n):
                return 0
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        cnt = collections.Counter(s)
        if len(cnt) < k:
            return 0
        freqs = list(cnt.values())
        nth_element(freqs, k-1, lambda a, b: a > b)
        n = freqs.count(freqs[k-1])
        r = sum(freqs[i] == freqs[k-1] for i in range(k))
        return reduce(lambda a, b: a*b%MOD, (freqs[i] for i in range(k)), 1)*nCr(n, r)%MOD",O(n)
"import sys
input=sys.stdin.readline
n,s=map(int,input().split())
l=0;r=n+1
while r-l>1:
    x=(l+r)//2
    cs=0
    m=x
    while m>0:
        cs+=m%10
        m//=10
    if x-cs>=s:
        r=x
    else:
        l=x
print(n-l)",O(logn)
"n = int(input())
a = list(map(int, input().split()))

max_mod = 0
max_i = -1
for i in range(n):
	if a[i] >= 0:
		a[i] = -a[i] - 1
	if -a[i] > max_mod:
		max_mod = -a[i]
		max_i = i

if n % 2 == 1:
	a[max_i] = -a[max_i] - 1

print(' '.join(list(map(str, a))))
",O(n)
"class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        stack = []

        leftMost = [-1] * n
        for i in range(n):
            while stack and heights[stack[-1]] >= heights[i]:
                stack.pop()
            if stack:
                leftMost[i] = stack[-1]
            stack.append(i)

        stack = []
        rightMost = [n] * n
        for i in range(n - 1, -1, -1):
            while stack and heights[stack[-1]] >= heights[i]:
                stack.pop()
            if stack:
                rightMost[i] = stack[-1]
            stack.append(i)

        maxArea = 0
        for i in range(n):
            leftMost[i] += 1
            rightMost[i] -= 1
            maxArea = max(maxArea, heights[i] * (rightMost[i] - leftMost[i] + 1))
        return maxArea
",O(n)
"class Solution(object):
    def reverseWords(self, s):
        def reverse(s, begin, end):
            for i in range((end - begin) // 2):
                s[begin + i], s[end - 1 - i] = s[end - 1 - i], s[begin + i]

        s, i = list(s), 0
        for j in range(len(s) + 1):
            if j == len(s) or s[j] == ' ':
                reverse(s, i, j)
                i = j + 1
        return """".join(s)",O(n)
"n, m = map(int,input().split())
X = []
for i in range(n):
    a = input()
    U = [char for char in a]
    X.append(U)
nums = []
for i in range(m):
    t = 0
    for j in range(n):
        t += int(X[j][i])
    nums.append(t)

for i in range(n):
    ok = True
    for j in range(m):
        if X[i][j] == '1':
            if nums[j]>1:
                continue
            else:
                ok = False
    if ok == True:
        print(""YES"")
        quit()
print(""NO"")",O(n ^ 2)
"import math
def islucky(x):
    digits = set(list(str(x)))
    return (len(digits) == 2 and (""4"" in digits and ""7"" in digits)) or (len(digits) == 1 and (""4"" in digits or ""7"" in digits))
a = int(input())
lucky = islucky(a)
for i in range(2, math.ceil(math.sqrt(a))+1):
    if a % i == 0:

        if islucky(i) or islucky(a // i):
            lucky = True
            break

print(""YES"" if lucky else ""NO"")",O(1)
"n = int(input())
arr = list(map(int, input().strip().split()))
k = min(arr)
h = max(arr)
s = 0
for i in arr:
    if i >= 0:
        s += i
    else:
        s -= i

if n == 1:
    print(arr[0])
elif ((k < 0 and h >= 0)):
    print(s)
else:
    if (k >= 0):
        print(s - 2 * k)
    else:
        print(s + 2 * h)",O(n)
"import io
import os

import sys
from functools import lru_cache
from collections import defaultdict

sys.setrecursionlimit(10 ** 5)

def solve(N, A):

    valToLeftRight = defaultdict(lambda: defaultdict(set))

    valToRightLeft = defaultdict(lambda: defaultdict(set))

    for i, x in enumerate(A):
        valToLeftRight[x][i].add(i)
        valToRightLeft[x][i].add(i)

    maxVal = 1000 + 10
    for val in range(maxVal):
        for l, rights in valToLeftRight[val - 1].items():
            for r in rights:

                l2 = r + 1
                if l2 in valToLeftRight[val - 1]:
                    for r2 in valToLeftRight[val - 1][l2]:
                        assert l <= r
                        assert r + 1 == l2
                        assert l2 <= r2
                        valToLeftRight[val][l].add(r2)
                        valToRightLeft[val][r2].add(l)

                r2 = l - 1
                if r2 in valToRightLeft[val - 1]:
                    for l2 in valToRightLeft[val - 1][r2]:
                        assert l2 <= r2
                        assert r2 == l - 1
                        assert l <= r
                        valToLeftRight[val][l2].add(r)
                        valToRightLeft[val][r].add(l2)

    intervals = defaultdict(list)
    for val in range(maxVal):
        for l, rights in valToLeftRight[val].items():
            for r in rights:

                intervals[l].append(r)

    @lru_cache(maxsize=None)
    def getBest(left):

        if left == N:
            return 0
        best = float(""inf"")
        for right in intervals[left]:

            best = min(best, 1 + getBest(right + 1))
        return best

    return getBest(0)

def tup(l, r):

    return l * 16384 + r

def untup(t):

    return divmod(t, 16384)

def solve(N, A):

    cache = {}

    def f(lr):
        if lr not in cache:
            l, r = untup(lr)

            if r - l == 1:
                return tup(1, A[l])
            best = tup(float(""inf""), float(""inf""))
            for i in range(l + 1, r):

                lSplit = f(tup(l, i))
                rSplit = f(tup(i, r))
                lLen, lVal = untup(lSplit)
                rLen, rVal = untup(rSplit)
                if lLen != 1 or rLen != 1:

                    best = min(best, tup(lLen + rLen, 9999))
                else:
                    if lVal == rVal:

                        best = min(best, tup(1, lVal + 1))
                    else:

                        best = min(best, tup(2, 9999))
            cache[lr] = best

        return cache[lr]

    ans = untup(f(tup(0, N)))[0]

    return ans

if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    N, = list(map(int, input().split()))
    A = list(map(int, input().split()))
    ans = solve(N, A)
    print(ans)",O(n ^ 3)
"n,m=map(int,input().split())
a=list(map(int,input().split()))
k=0
ans=-1
for i in range(n-1):
    while k<n-1 and a[k+1] - a[i]<=m:
        k+=1
    if i<k-1:
        ans=max(ans,(a[k]-a[i+1]) / (a[k]-a[i]))
print(ans)",O(nlogn)
"def is_prime(num):
    if num > 1:
        for i in range(2, num):
            if (num % i) == 0:
               return  False
        else:
            return True
    else:
        return False

n = int(input())
temp = 0
first = 0
second = 0
if n % 2 == 0:
    temp = int(n/2)
    first = temp
    second = n - temp
    while is_prime(first) or is_prime(second):
        first -= 1
        second += 1
        if first + second == n and (not is_prime(first) and not is_prime(second)):
            break
else:
    temp = int(n / 2)
    first = temp
    second = n - first
    while is_prime(first) or is_prime(second):
        first -= 1
        second += 1
        if first + second == n and (not is_prime(first) and not is_prime(second)):
            break
print(first,end="" "")
print(second)",O(1)
"import collections


class Solution(object):
    def checkAlmostEquivalent(self, word1, word2):
        k = 3
        cnt1, cnt2 = collections.Counter(word1), collections.Counter(word2)
        return all(abs(cnt1[c]-cnt2[c]) <= k for c in set(list(cnt1.keys())+list(cnt2.keys())))",O(n)
"from math import sqrt,gcd,ceil,floor,log,factorial
from itertools import permutations,combinations
from collections import Counter, defaultdict

def dist(x1,x2):
    return abs(x1-x2)

def power2(n):
    return ceil(log(n,2)) == floor(log(n,2))

n=int(input())
x = list(map(int,input().split()))

flag1,flag2,flag3=0,0,0
d=Counter(x)

for i in x:
    for po in range(0,31):
        if d[i-pow(2,po)]>0 and d[i+pow(2,po)]>0:
            print(3)
            print(i,i-pow(2,po),i+pow(2,po))
            flag1=1
            break

    if flag1==1:
        break

if flag1==0:
    for i in x:
        for po in range(0,31):
            if d[i-pow(2,po)]>0:
                print(2)
                print(i,i-pow(2,po))
                flag2=1
                break

            elif d[i+pow(2,po)]>0:
                print(2)
                print(i,i+pow(2,po))
                flag2=1
                break

        if flag2==1:
            break

    if flag2==0:
        print(1)
        print(max(x))
",O(nlogn)
"import sys

def chain_reaction(n, beacons):
    table = [0] * n

    for i in range(n):
        position = beacons[i][0]
        power = beacons[i][1]
        destroyed = 0
        r = position - power
        b = 0

        lo = 0
        hi = len(beacons) - 1
        while lo <= hi:
            mid = int(lo + (hi - lo) / 2)
            pos = beacons[mid][0]
            if beacons[mid][0] < r:
                lo = mid + 1
            else:
                hi = mid - 1

        destroyed += table[hi]

        destroyed += (i - (hi + 1))
        table[i] = destroyed

    options = []
    for i in range(n):
        cost = (n - i) + table[i - 1]
        options.append(cost)
    min_cost = min(options)

    return min(table[n - 1], min_cost)

n = int(sys.stdin.readline().strip())
beacons = []
for i in range(n):
    a, b = [int(x) for x in sys.stdin.readline().strip().split("" "")]
    beacons.append((a, b))
beacons.sort()
print(chain_reaction(n, beacons))",O(n)
"from sys import stdin, stdout
from math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial

def get(l, r):
    if l > r:
        return 0

    if l & 1:
        return (-l - r) * (r - l + 2) // 4
    else:
        return (l + r) * (r - l + 2) // 4

def solution(l, r):
    l1, l2, r1, r2 = l, l, r, r

    if l & 1:
        l2 += 1
    else:
        l1 += 1

    if r & 1:
        r2 -= 1
    else:
        r1 -= 1

    return get(l1, r1) + get(l2, r2)

q = int(stdin.readline())
for i in range(q):
    l, r = map(int, stdin.readline().split())
    stdout.write(str(solution(l, r)) + '\n')",O(1)
"class Solution2(object):
    def trap(self, A):
        result = 0
        top = 0
        for i in range(len(A)):
            if A[top] < A[i]:
                top = i

        second_top = 0
        for i in range(top):
            if A[second_top] < A[i]:
                second_top = i
            result += A[second_top] - A[i]

        second_top = len(A) - 1
        for i in reversed(range(top, len(A))):
            if A[second_top] < A[i]:
                second_top = i
            result += A[second_top] - A[i]

        return result",O(n)
"import sys
import math as mt
import bisect
input=sys.stdin.readline

t=1
def ncr_util():
    inv[0]=inv[1]=1
    fact[0]=fact[1]=1
    for i in range(2,300001):
        inv[i]=(inv[i%p]*(p-p//i))%p
    for i in range(1,300001):
        inv[i]=(inv[i-1]*inv[i])%p
        fact[i]=(fact[i-1]*i)%p
def solve():
    a=1
    b=2*n+3
    c=n+n**2-2*k
    x1=b+int(mt.sqrt(b**2-4*a*c))
    x2=b-int(mt.sqrt(b**2-4*a*c))
    if x1%2==0 and x1//2<=n:
        return x1//2
    return x2//2

for _ in range(t):

    n,k=(map(int,input().split()))

    print(solve())
",O(logn)
"class Solution(object):
    def minimizeResult(self, expression):
        def stoi(s, i, j):
            result = 0
            for k in range(i, j):
                result = result*10+(ord(s[k])-ord('0'))
            return result

        best = None
        min_val = float(""inf"")
        pos = expression.index('+')
        left, right = stoi(expression, 0, pos), stoi(expression, pos+1, len(expression))
        base1, base2_init = 10**pos, 10**(len(expression)-(pos+1)-1)
        for i in range(pos):
            base2 = base2_init
            for j in range(pos+1, len(expression)):
                a, b = divmod(left, base1)
                c, d = divmod(right, base2)
                val = max(a, 1)*(b+c)*max(d, 1)
                if val < min_val:
                    min_val = val
                    best = (i, j)
                base2 //= 10
            base1 //= 10
        return """".join(itertools.chain((expression[i] for i in range(best[0])),
                                       '(', (expression[i] for i in range(best[0], best[1]+1)), ')',
                                       (expression[i] for i in range(best[1]+1, len(expression)))))",O(n ^ 2)
"class Solution(object):
    def minProcessingTime(self, processorTime, tasks):
        K = 4
        processorTime.sort()
        tasks.sort(reverse=True)
        result = 0
        for i in range(len(processorTime)):
            for j in range(K):
                result = max(result, processorTime[i]+tasks[i*K+j])
        return result",O(nlogn)
"S = input()
sLen, ans = len(S), 0
for i in range(sLen):
    for till1 in range(i + 1, sLen):
        till2 = till1 + 1
        for j in range(i + 1, sLen):
            if till2 > sLen:
                break
            sub1 = S[i:till1]
            sub2 = S[j:till2]
            subLen = len(sub1)
            if sub1 == sub2 and ans < subLen:
                ans = subLen
            till2 += 1

print(ans)
",O(n ^ 3)
"class Solution(object):
    def productExceptSelf(self, nums):
        if not nums:
            return []

        left_product = [1 for _ in range(len(nums))]
        for i in range(1, len(nums)):
            left_product[i] = left_product[i - 1] * nums[i - 1]

        right_product = 1
        for i in range(len(nums) - 2, -1, -1):
            right_product *= nums[i + 1]
            left_product[i] = left_product[i] * right_product

        return left_product",O(n)
"n = input()
s = input()
n = int(n)
print('1'*min(s.count('1'), 1)+'0'*s.count('0'))",O(n)
"class Solution(object):
    def maxSumAfterOperation(self, nums):
        prev_with_square = prev_without_square = 0
        result = 0
        for num in nums:
            without_square = max(num, num+prev_without_square)
            with_square = max(num*num, num*num+prev_without_square, num+prev_with_square)
            result = max(result, with_square)
            prev_with_square, prev_without_square = with_square, without_square
        return result",O(n)
"import itertools



class Solution2(object):
    def canSortArray(self, nums):
        def popcount(x):
            return bin(x).count(""1"")
        
        def pairwise(it):
            a, b = tee(it)
            next(b, None)
            return zip(a, b)

        return all(max(a) <= min(b) for a, b in pairwise(list(it) for key, it in groupby(nums, popcount)))",O(n)
"class Solution(object):
    def maximizeSweetness(self, sweetness, K):
        def check(sweetness, K, x):
            curr, cuts = 0, 0
            for s in sweetness:
                curr += s
                if curr >= x:
                    cuts += 1
                    curr = 0
            return cuts >= K+1

        left, right = min(sweetness), sum(sweetness)//(K+1)
        while left <= right:
            mid = left + (right-left)//2
            if not check(sweetness, K, mid):
                right = mid-1
            else:
                left = mid+1
        return right",O(nlogn)
"a,b = list(map(int, input().split()))

x = a ^ b

ans = 1
while x > 0:

	x //= 2
	ans *= 2

print(ans -1)",O(logn)
"def case(mid):
    res=0
    for k,x in enumerate(str(mid)):
        res+=int(x)
    return res
n,s=map(int,input().split())
i,j=0,n
while i+1<j:
    mid=(i+j)//2
    result=case(mid)
    if mid-case(mid)<s:i=mid
    else:j=mid
if i-case(i)>=s:print(n-i+1)
else:
    if j==n:
        if j-case(j)>=s:print(1)
        else:print(0)
    else:print(n-j+1)",O(logn)
"class Solution(object):
    def canAliceWin(self, n):
        c = 10
        l = int(((2*c+1)-((2*c+1)**2-8*n)**0.5)/2)
        return l%2 == 1",O(1)
"class Solution(object):
    def mergeTriplets(self, triplets, target):
        result = [0]*3
        for t in triplets:
            if all(t[i] <= target[i] for i in range(3)):
                result = [max(result[i], t[i]) for i in range(3)]
        return result == target",O(n)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

T, = getIntList()

MAXN = 10**18 + 10
def getUpper(N):
    z = 1
    r = 0
    for i in range(N):
        r+=z
        z*=4
        if r>MAXN:
            break
    return r
for _ in range(T):
    N,K = getIntList()
    tk = K
    z = 1
    for i in range(N):
        tk -= z
        z*= 4
        if tk<0: break
    if tk>0:
        print('NO')
        continue
    nowcut =  0
    nt = 1
    nowupper = 0
    ok = False
    for i in range(N):
        nt *=2
        nowcut += nt-1

        if nowcut >K: break
        t = (nt *2 - 3)
        tu  = t * getUpper(N-1-i)
        nowupper += tu
        dprint('bound', nowcut, nowcut+nowupper)
        if nowcut<=K<= nowcut+nowupper:
            ok = True
            break
    if ok:
        print('YES', N-1-i)
    else:
        print(""NO"")
",O(logn)
"def d(n):
    ret = 0
    n = list(str(n))
    for i in range(len(n)):
        ret += int(n[i])
    return ret

def main():
    n, s = map(int, input().split())

    l, h = 0, n
    for i in range(2000):

        m = (l + h) // 2
        if m - d(m) >= s:
            h = m
        else:
            l = m

    for i in range(-100, 100):
        t = m + i

        if t < 0 or t > n:
            continue
        if abs(t - d(t)) >= s:
            print(n - t + 1)
            exit()
    print(0)

if __name__ == '__main__':
    main()
",O(logn)
"t = input()

n = len(t)

maxi = 0

for i in range(n):
    s = t[i]
    if t.count(s) > 1:
        maxi = max(maxi, 1)
    nr = 1
    for j in range(i + 1, n):
        s += t[j]
        nr += 1
        g = 0
        for h in range(n - nr + 1):
            if s == t[h:h + nr]:
                g += 1
        if g > 1:
            maxi = max(nr,maxi)

print(maxi)",O(n ^ 3)
"class Solution(object):
    def videoStitching(self, clips, T):
        if T == 0:
            return 0
        result = 1
        curr_reachable, reachable = 0, 0
        clips.sort()
        for left, right in clips:
            if left > reachable:
                break
            elif left > curr_reachable:
                curr_reachable = reachable
                result += 1
            reachable = max(reachable, right)
            if reachable >= T:
                return result
        return -1",O(nlogn)
"rd = lambda: map(int, input())
def f(n, t):
    a = sum(i + j & 1 == x for i in range(n) for j, x in enumerate(rd()))
    if t < 3:
        rd()
    return a
n = int(input())
m = sorted([f(n, i) for i in range(4)])
print(2 * n * n + m[0] + m[1] - m[2] - m[3])
",O(n ^ 2)
"class Solution(object):
    def countGoodRectangles(self, rectangles):
        result = mx = 0
        for l, w in rectangles:
            side = min(l, w)
            if side > mx:
                result, mx = 1, side
            elif side == mx:
                result += 1
        return result",O(n)
"class Solution2(object):
    def __init__(self):
        self.__lookup = {(0, 0):0, (1, 1):2, (1, 0):3} 

    def minKnightMoves(self, x, y):
        def dp(x, y):
            x, y = abs(x), abs(y)
            if x < y:
                x, y = y, x
            if (x, y) not in self.__lookup: 
                self.__lookup[(x, y)] = min(dp(x-1, y-2), dp(x-2, y-1)) + 1
            return self.__lookup[(x, y)]
        return dp(x, y)",O(n ^ 2)
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

n,k=map(int,input().split())
s=list(map(str, input()))
dic={}
for i in range(n):
    if s[i]==""("":
        arrStack.my_push([i,""(""])
    else:
        if arrStack.my_peak()[1]==""("":
            index=arrStack.my_peak()[0]
            dic[index]=1
            dic[i]=1
            k-=2
            arrStack.my_pop()
    if k==0:
        break
ans =""""
for i in range(n):
    if i in dic:
        ans+=s[i]
print(ans)
",O(n)
"class Solution(object):
    def stoneGameVI(self, aliceValues, bobValues):
        sorted_vals = sorted(((a, b) for a, b in zip(aliceValues, bobValues)), key=sum, reverse=True)
        return cmp(sum(a for a, _ in sorted_vals[::2]), sum(b for _, b in sorted_vals[1::2]))",O(nlogn)
"class Solution2(object):
    def maximumLength(self, nums):
        return max(sum(x%2 == 0 for x in nums),
                   sum(x%2 == 1 for x in nums),
                   sum(nums[i]%2 != nums[i+1]%2 for i in range(len(nums)-1))+1)",O(n)
"from math import fabs
n = int(input())
nots = [int(s) for s in input().split()]
map = [0]
ampl = 0
possible = True
zer = False
f_s = True

for i in range(len(nots) - 1):
    if nots[i] == nots[i + 1]:
        if ampl != 0:
            map.append(ampl)
            if ampl <= -5 or ampl >= 5: possible = False
        map.append(0)
        zer = True
        ampl = 0
    else:
        if nots[i] < nots[i + 1]:
            if ampl < 0 and f_s != True:
                map.append(ampl)
                if ampl == -5: possible = False
                ampl = 1
            else:
                ampl += 1
        else:
            if ampl > 0 and f_s != True:
                map.append(ampl)
                if ampl == 5: possible = False
                ampl = -1
            else:
                ampl += -1
    f_s = False
if ampl != 0:
    map.append(ampl)
    if ampl == -5 or ampl == 5: possible = False
if len(nots) == 1:
    map.append(0)
map.append(0)

if possible == True:
    if zer == True:
        l = len(map)
        for i in range(1, l - 1):
            if map[i] == 0:
                if map[i - 1] == 4: map[i] = -1
                if map[i - 1] == -4: map[i] = 1
                if map[i + 1] == 4: map[i] = -1
                if map[i + 1] == -4: map[i] = 1

        for i in range(1, l-1):
            if map[i] == 0:
                if map[i - 1] >= 0 and map[i + 1] >= 0: map[i] = -1
                if map[i - 1] > 0 and map[i + 1] < 0: map[i] = 1
                if map[i - 1] < 0 and map[i + 1] > 0: map[i] = -1
                if map[i - 1] <= 0 and map[i + 1] <= 0: map[i] = 1

        fin = []
        ampl = map[1]
        for i in range(1, l - 1):
            if map[i] * map[i + 1] > 0:
                ampl += map[i + 1]
            if map[i] * map[i + 1] < 0:
                fin.append(ampl)
                if ampl >= 5 or ampl <= -5: possible = False
                ampl = map[i + 1]
        fin.append(ampl)

        if possible == True:
            fin[-1] = int(fabs( fin[-1] ) / fin[-1] * (fabs( fin[-1] ) + 1))
            appl = []
            for i in range( len(fin) ):
                if fin[i] > 0:
                    for j in range(1, fin[i] + 1):
                        appl.append(j)
                if fin[i] < 0:
                    for j in range(5, 5 + fin[i], -1):
                        appl.append(j)

    else:
        appl = []
        try:
            map[-2] = int(fabs(map[-2]) / map[-2] * (fabs(map[-2]) + 1))
        except ZeroDivisionError:
            appl = [1]
        for i in range(len(map)):
            if map[i] > 0:
                for j in range(1, map[i] + 1):
                    appl.append(j)
            if map[i] < 0:
                for j in range(5, 5 + map[i], -1):
                    appl.append(j)

    for finger in appl:
        print(finger, end = ' ')
if possible == False:
    print(-1)
",O(n ^ 2)
"n, s = map(int, input().split())
ans = s // n
s %= n
if s != 0:
    ans += 1
print(ans)
",O(1)
"from copy import copy

a = list(map(int, input().split()))

ans = 0
for i in range(14):
    b = copy(a)
    b[i] = 0

    for j in range(1, 14 + 1):
        b[(i + j) % 14] += (a[i] - 1) // 14 + ((a[i] - 1) % 14 + 1 > j - 1)

    ans = max(ans, sum(el * (el % 2 == 0) for el in b))

print(ans)
",O(1)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def deleteDuplicates(self, head):
        cur = head
        while cur:
            runner = cur.__next__
            while runner and runner.val == cur.val:
                runner = runner.__next__
            cur.next = runner
            cur = runner
        return head

    def deleteDuplicates2(self, head):
        if not head: return head
        if head.__next__:
            if head.val == head.next.val:
                head = self.deleteDuplicates2(head.__next__)
            else:
                head.next = self.deleteDuplicates2(head.next)
        return head",O(n)
"MAX = 100001
parent = []

def makeSet():
    global parent
    parent = [i for i in range(MAX + 1)]

def findSet(u):
    global parent
    if u != parent[u]:
        parent[u] = findSet(parent[u])
    return parent[u]

def unionSet(u, v):
    up = findSet(u)
    vp = findSet(v)
    parent[up] = vp

makeSet()
n, a, b = map(int, input().split())
p = list(map(int, input().split()))
pos = dict()
for i in range(n):
    pos[p[i]] = i + 1

for i in range(n):
    unionSet(i + 1, pos.get(a - p[i], n + 1))
    unionSet(i + 1, pos.get(b - p[i], 0))

A = findSet(0)
B = findSet(n + 1)

if A != B:
    print('YES')
    for i in range(1, n + 1):
        if findSet(i) == B:
            print('1', end = "" "")
        else:
            print('0', end = "" "")
else:
    print('NO')
",O(n)
"class Codec:

    def serialize(self, root: Optional[TreeNode]) -> str:
        res = []

        def dfs(node):
            if not node:
                res.append(""N"")
                return
            res.append(str(node.val))
            dfs(node.left)
            dfs(node.right)

        dfs(root)
        return "","".join(res)

    def deserialize(self, data: str) -> Optional[TreeNode]:
        vals = data.split("","")
        self.i = 0

        def dfs():
            if vals[self.i] == ""N"":
                self.i += 1
                return None
            node = TreeNode(int(vals[self.i]))
            self.i += 1
            node.left = dfs()
            node.right = dfs()
            return node

        return dfs()
",O(n)
"def main():
    A,B = list(map(int, input().strip().split()))
    yellow,green,blue = list(map(int, input().strip().split()))

    yelreq = 0
    blureq = 0

    yelreq = 2*yellow

    yelreq += green
    blureq += green

    blureq += 3*blue

    reqs = 0
    if A<yelreq:
        reqs += yelreq - A
    if B<blureq:
        reqs += blureq - B

    print(reqs)

main()
",O(1)
"class Solution(object):
    def maximumPossibleSize(self, nums):
        result = prev = 0
        for x in nums:
            if prev <= x:
                prev = x
                result += 1
        return result",O(n)
"class Solution(object):
    def minOperations(self, nums):
        result = prev = 0
        for curr in nums:
            if prev < curr:
                prev = curr
                continue
            prev += 1
            result += prev-curr                
        return result",O(n)
"from collections import Counter
n, m = map(int, input().split())
c = Counter(input().split()).values()
d = 1
while sum(ci//d for ci in c) >= n:
    d += 1
print(d - 1)
",O(nlogn)
"class Solution(object):
    def maxSatisfaction(self, satisfaction):
        satisfaction.sort(reverse=True)
        result, curr = 0, 0
        for x in satisfaction:
            curr += x
            if curr <= 0:
                break
            result += curr
        return result",O(nlogn)
"import collections


class Solution(object):
    def splitPainting(self, segments):
        counts = collections.defaultdict(int)
        for s, e, c in segments:
            counts[s] += c
            counts[e] -= c
        points = sorted(x for x in counts.items())

        result = []
        overlap = prev = 0
        for curr, cnt in points:
            if overlap:
                result.append([prev, curr, overlap])
            overlap += cnt
            prev = curr
        return result",O(nlogn)
"class Solution2(object):
    def subsequenceCount(self, nums):
        MOD = 10**9+7
        dp = [0]*2
        for x in nums:
            dp = [(dp[i]+dp[i^(x%2)]+int(x%2 == i))%MOD for i in range(2)]
        return dp[1]",O(n)
"def solve(d, n, k):
    mv = sum(d[0:k])
    v = mv
    for i in range(1, n-k+1):
        mv = mv + d[i+k-1] - d[i-1]
        v = min(v, mv)
    return v

for _ in range(int(input())):
    n, k = tuple(map(int, input().split()))
    s = input()
    st = 'RGB' * (n//3 + 3)
    diff1, diff2, diff3 = [0 for _ in range(n)], [0 for _ in range(n)], [0 for _ in range(n)]

    for i in range(n):
        if s[i] != st[i]: diff1[i] = 1
        if s[i] != st[i+1]: diff2[i] = 1
        if s[i] != st[i+2]: diff3[i] = 1

    print(min(solve(diff1, n, k), solve(diff2, n, k), solve(diff3, n, k)))",O(n)
"class Solution(object):
    def maximalSquare(self, matrix):
        if not matrix:
            return 0

        m, n = len(matrix), len(matrix[0])
        size = [[0 for j in range(n)] for i in range(2)]
        max_size = 0

        for j in range(n):
            if matrix[0][j] == '1':
                size[0][j] = 1
            max_size = max(max_size, size[0][j])

        for i in range(1, m):
            if matrix[i][0] == '1':
                size[i % 2][0] = 1
            else:
                size[i % 2][0] = 0
            for j in range(1, n):
                if matrix[i][j] == '1':
                    size[i % 2][j] = min(size[i % 2][j - 1], \
                                         size[(i - 1) % 2][j], \
                                         size[(i - 1) % 2][j - 1]) + 1
                    max_size = max(max_size, size[i % 2][j])
                else:
                    size[i % 2][j] = 0

        return max_size * max_size",O(n ^ 2)
"def main():
    from sys import stdin
    w, h, n = map(int, stdin.readline().split())
    res, vrt, hor = [], [], []
    vh = (vrt, hor)
    for i, s in enumerate(stdin.read().splitlines()):
        x = int(s[2:])
        flag = s[0] == 'V'
        vh[flag].append(i)
        res.append([x, flag])
    dim = []
    for tmp, m in zip(vh, (h, w)):
        tmp.sort(key=lambda e: res[e][0])
        u = [None, [0]]
        dim.append(u)
        j = z = 0
        for i in tmp:
            x = res[i][0]
            if z < x - j:
                z = x - j
            j = x
            v = [u, res[i]]
            u.append(v)
            u = v
            res[i].append(u)
        v = [u, [m], None]
        u.append(v)
        dim.append(v)
        if z < m - j:
            z = m - j
        dim.append(z)
    l, r, wmax, u, d, hmax = dim
    whmax = [wmax, hmax]
    for i in range(n - 1, -1, -1):
        x, flag, link = res[i]
        u = whmax[flag]
        res[i] = u * whmax[not flag]
        link[0][2] = link[2]
        link[2][0] = link[0]
        v = link[2][1][0] - link[0][1][0]
        if u < v:
            whmax[flag] = v
    print('\n'.join(map(str, res)))

if __name__ == '__main__':
    main()
",O(nlogn)
"string = input()
l, r = string.split()
l = int(l)
r = int(r)
p = l ^ r
x = 1
while x <= p:
    x = x << 1
print(x-1)
",O(logn)
"import sys
def I(): return int(sys.stdin.readline().rstrip())
def MI(): return map(int,sys.stdin.readline().rstrip().split())
def LI(): return list(map(int,sys.stdin.readline().rstrip().split()))
def LI2(): return list(map(int,sys.stdin.readline().rstrip()))
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())
def LS2(): return list(sys.stdin.readline().rstrip())

N = I()
A = LI()
mod = 10**9+7

m = 20
M = 1 << m
F = [0]*M
for a in A:
    F[a] += 1

def zeta_transform(F,n):

    N = 1 << n
    res = F[:]
    for i in range(n):
        k = 1 << i
        for j in range(N):
            if not j & k:
                res[j] += res[j^k]
    return res

G = zeta_transform(F,m)
power = [1]
for _ in range(N):
    power.append((power[-1]*2) % mod)

def bit_count(n):
    c = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555)
    c = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333)
    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c >> 4) & 0x0f0f0f0f0f0f0f0f)
    c = (c & 0x00ff00ff00ff00ff) + ((c >> 8) & 0x00ff00ff00ff00ff)
    c = (c & 0x0000ffff0000ffff) + ((c >> 16) & 0x0000ffff0000ffff)
    c = (c & 0x00000000ffffffff) + ((c >> 32) & 0x00000000ffffffff)
    return c

ans = 0
for i in range(M):
    bc = bit_count(i)
    a = power[G[i]]
    if bc % 2 == 0:
        ans += a
    else:
        ans -= a
    ans %= mod

print(ans)
",np
"class Solution2(object):
    def lengthOfLastWord(self, s):
        return len(s.strip().split("" "")[-1])",O(n)
"n, p, l, r = map(int, input().split())
if l == 1 and r == n:
    print(0)
elif l == 1:
    print(abs(p-r) + 1)
elif r == n:
    print(abs(p-l) + 1)
else:
    print(min(abs(p-l), abs(p-r)) + r - l + 2)",O(1)
"n=int(input())
l=[int(x) for x in input().strip().split()]
l1=sorted(l)
c=0
for i in range(n):
    if(l[i]!=l1[i]):
        c+=1
if(c<=2):
    print(""YES"")
else:
    print(""NO"")",O(nlogn)
"class Solution(object):
    def specialArray(self, nums):
        MAX_NUM = 1000
        count = [0]*(MAX_NUM+1)
        for num in nums:
            count[num] += 1
        n = len(nums)
        for i in range(len(count)):
            if i == n:
                return i
            n -= count[i]
        return -1",O(n)
"n = int(input())
a = list(map(int, input().split()))

c = 0

for i in range(1, n-1):
    if a[i] > a[i-1] and a[i] > a[i+1]:
        c +=1
    if a[i] == a[i-1] or a[i] == a[i+1]:
        print('NO')
        exit()
    if a[i] <= a[i-1] and a[i] <= a[i+1]:
        print('NO')
        exit()
if c>1:
    print('NO')
else:
    print('YES')",O(n)
"from sys import stdin,stdout

mod=10**9+7
t=1
for _ in range(t):
    a=input()
    b=input()
    n=len(a)
    m=len(b)
    dp=[[0 for i in range(2)] for j in range(m+1)]
    dp[1][0]=int(b[0])^1
    dp[1][1]=int(b[0])
    for i in range(2,m+1):
        dp[i][0]=dp[i-1][0]+(int(b[i-1])^1)
        dp[i][1]=dp[i-1][1]+int(b[i-1])
    ans=0
    for i in range(n):
        count0=dp[m-n+i+1][0]-dp[i][0]
        count1=dp[m-n+i+1][1]-dp[i][1]
        ans+=count0*int(a[i])+count1*(int(a[i])^1)
    print(ans)",O(n)
"class Solution:
    def myPow(self, x: float, n: int) -> float:
        if x == 0:
            return 0
        if n == 0:
            return 1

        res = 1
        for i in range(abs(n)):
            res *= x
        return res if n >= 0 else 1 / res
",O(n)
"n = int(input())

b = [int(_) for _ in input().split()]

e = [[-1] * (n+1) for _ in range(2024)]

d = [[] for _ in range(n)]

for i, v in enumerate(b):
	e[v][i] = i
	d[i].append(i)

for v in range(1, 2024):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)

a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])",O(n ^ 3)
"q = int(input())
for i in range(q):
    a, b, k = map(int, input().split())
    if a < b:
        a, b, = b, a
    if a > k:
        print(-1)
    elif a % 2 == b % 2 != k % 2:
        print(k - 2)
    elif (a + b) % 2 != 0:
        print(k - 1)
    else:
        print(k)
",O(1)
"class TreeNode(object):
    def __init__(self, x):
        pass


class Solution(object):
    def lowestCommonAncestor(self, root, nodes):
        def iter_dfs(root, lookup):
            result = [0]
            stk = [(1, (root, result))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if not node or node in lookup:
                        ret[0] = node
                        continue
                    ret1, ret2 = [None], [None]
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    if ret1[0] and ret2[0]:
                        ret[0] = node
                    else:
                        ret[0] = ret1[0] or ret2[0]
            return result[0]
        
        return iter_dfs(root, set(nodes))",O(n)
"k = int(input())
if k <= 9:
    print(k)
else:
    length = len(str(k))
    s = """"
    num = 0

    for i in range(length - 1):
        num += (9*(10**i))*(i + 1)
        temp = num + (9*(10**(i + 1)))*(i + 2)
        if temp > k:
            length = i + 2
            break

    for i in range(length - 1):
        s = s + ""1""

    previous_value = 9 * int(s)
    try_value = k - num

    if try_value % length == 0:
        div_value = try_value // length
        temp_string = str(previous_value + div_value)
        print(temp_string[len(temp_string) - 1])
    else:
        div_value = (try_value // length) + 1
        temp_string = str(previous_value + div_value)
        differ = (div_value * length) - try_value
        print(temp_string[len(temp_string) - differ - 1])",O(logn)
"from collections import defaultdict,deque
from heapq import heappush, heappop
import sys
import math
import bisect
def LI(): return [int(x) for x in sys.stdin.readline().split()]
def I(): return int(sys.stdin.readline())
def LS():return [list(x) for x in sys.stdin.readline().split()]
def S():
    res = list(sys.stdin.readline())
    if res[-1] == ""\n"":
        return res[:-1]
    return res
def IR(n):
    return [I() for i in range(n)]
def LIR(n):
    return [LI() for i in range(n)]
def SR(n):
    return [S() for i in range(n)]
def LSR(n):
    return [LS() for i in range(n)]

sys.setrecursionlimit(1000000)
mod = 1000000007

def A():
    n = I()
    a = LI()
    a.sort()
    f = [1]*n
    p = 0
    ans = 0
    while p < n:
        while p < n and not f[p]:
            p += 1
        if p == n:
            break
        ans += 1
        for i in range(n):
            if a[i]%a[p] == 0:
                f[i] = 0
    print(ans)
    return

def B():

    return

def C():

    return

def D():

    return

def E():

    return

def F():

    return

def G():

    return

def H():

    return

if __name__ == ""__main__"":
    A()
",O(n ^ 2)
"import sys
input=sys.stdin.buffer.readline
n=int(input())
arr=list(map(int,input().split()))
gap=n//2
count =0
while gap >=1:
    for j in range(gap ,n):
        i= j-gap
        while i >=0:
            if arr[i +gap] >arr[i]:
                break
            else:
                arr[i +gap],arr[i] =arr[i] ,arr[i +gap]
                count +=1
            i-=gap
    gap//=2
if count % 2== 3*n %2:
    print(""Petr"")
else:
    print(""Um_nik"")
",O(nlogn)
"n, k, A = map(int, input().rstrip().split())
senators = []
mx_bribe = 0

for i in range(n):
    lvl, loy = map(int, input().rstrip().split())
    senators.append((lvl, loy))
    mx_bribe += (100 - loy) // 10

bribe = [0] * n

def calc(votes):
    bsum, cnt, p = 0, 0, 1.0
    for i, s in enumerate(senators):
        if votes & (1 << i):
            p *= (s[1] + bribe[i]) / 100
            cnt += 1
        else:
            p *= (100 - s[1] - bribe[i]) / 100
            bsum += s[0]

    if cnt > (n / 2):
        return p
    else:
        return p * A / (A + bsum)

def dfs(cur, rk):
    if cur >= n:
        if rk > 0:
            return 0.0
        sm = 0.0
        for i in range(1 << n):
            sm += calc(i)

        return sm

    mx = 0.0
    for i in range(rk + 1):
        if i * 10 + senators[cur][1] > 100:
            break
        bribe[cur] = i * 10
        tmp = dfs(cur+1, rk-i)
        mx = max(tmp, mx)
    return mx

print(dfs(0, min(k, mx_bribe)))
",np
"a = int(input())
print(25)",O(1)
"class DFS:
    def __init__(self):
        self.G= []
        self.leave_tree= []

    def take_input(self):
        k = int(input())
        if(k>1):
            graph =[int(node)-1 for (node) in input().split(' ')]
            self.G = [[] for _ in range(len(graph)+1)]
            for i in range(len(graph)):
                self.G[graph[i]].append(i+1)
            self.visited = [0]*k
            self.leave_tree = [0]*k
            for i in range(k-1,-1,-1):
                if len(self.G[i])==0:
                    self.leave_tree[i]=1
                else:
                    for j in self.G[i]:
                        self.leave_tree[i]+=self.leave_tree[j]
            self.leave_tree.sort()
            print(*self.leave_tree)
        else:
            print(k)

x = DFS()
x.take_input()
",O(nlogn)
"class Solution:
    def goodNodes(self, root: TreeNode) -> int:

        def dfs(node, maxVal):
            if not node:
                return 0

            res = 1 if node.val >= maxVal else 0
            maxVal = max(maxVal, node.val)
            res += dfs(node.left, maxVal)
            res += dfs(node.right, maxVal)
            return res

        return dfs(root, root.val)
",O(n)
"def cnt(s,t):
    i,c=0,0
    while(s.count(t)):
        s=s[s[i:].index(t)+1:]
        c+=1
    return c
s=(input())
n=len(s)
ln=0
for i in range(n):
    for j in range(i,n):
        if(j-i+1<=ln):
            continue
        if(cnt(s,s[i:j+1])>=2):
            ln=max(ln,j-i+1)
print(ln)
",O(n ^ 3)
"t = int(input())
for i in range(t):
    n = int(input())
    ai = list(map(int,input().split()))
    ai.sort()
    print(min(n-2,ai[-2]-1))
",O(nlogn)
"n, m = map(int, input().split())
a = map(int, input().split())
b = list(map(int, input().split()))
for x in a:
    if x in b:
        print(x, end=' ')
",O(n ^ 2)
"n,A,B,C,T=map(int,input().split())
t=list(map(int,input().split()))
if(B>C):
    print(n*A)
else:
    c=0
    t.sort()
    for i in t:
        c+=(T-i)*(C-B)+A
    print(c)",O(n)
"class Solution(object):
    def scoreOfParentheses(self, S):
        result, depth = 0, 0
        for i in range(len(S)):
            if S[i] == '(':
                depth += 1
            else:
                depth -= 1
                if S[i-1] == '(':
                    result += 2**depth
        return result",O(n)
"class Solution2(object):
    def canBeEqual(self, s1, s2):
        return (((s1[0] == s2[0] and s1[2] == s2[2]) or (s1[0] == s2[2] and s1[2] == s2[0])) and
                ((s1[1] == s2[1] and s1[3] == s2[3]) or (s1[1] == s2[3] and s1[3] == s2[1])))",O(1)
"from collections import Counter

if __name__ == ""__main__"":
    n, k = map(int, input().split())
    s = input()
    c = Counter(s)
    min_symbols = min(c[chr(ord(""A"") + i)] for i in range(k))
    print(min_symbols * k)
",O(n)
"pfs=[i*i for i in range(1,3163)]
p=[i for i in range(0,10000001)]
for i in range(1,10000001):
    if(p[i]==i):
        for j in pfs:
            if(i*j>10000000): break
            p[i*j]=i
t=int(input())
for lll in range(0,t):
    n,k=map(int,input().split())
    zc=list(map(int,input().split()))
    s=[p[zc[i]] for i in range(0,len(zc))]
    dp=[n]*(k+1)
    dp[0]=1
    ys=[{}]*(n+1)
    for i in range(0,len(s)):
        for j in range(k,-1,-1):
            if(dp[j]==n): continue
            if(ys[j].get(s[i],-1)!=-1):
                if(j<k and dp[j]<dp[j+1]):
                    dp[j+1]=dp[j]
                    ys[j+1]=ys[j]
                dp[j]+=1
                ys[j]={}
            ys[j][s[i]]=1
    print(min(dp))",O(n ^ 3)
"l, r = map(int, input().split())

print(0 if l == r else 2 ** len(bin(l ^ r)[2:]) - 1)",O(logn)
"def main():
    pieces_Dimension = int(input())
    piece1 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece2 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece3 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece4 = ''.join(input() for _ in range(pieces_Dimension))

    brokenPieces = (piece1, piece2, piece3, piece4)
    nSquares = pieces_Dimension*pieces_Dimension
    squares = '01'*(nSquares//2) + '0'

    return nSquaresToRecolorIn(brokenPieces, nSquares, squares)

def nSquaresToRecolorIn(brokenPieces, nSquares, squares):
    possible_nSquares = [sum(piece[i] != squares[i] for i in range(nSquares)) for piece in brokenPieces]
    possible_nSquares.sort()

    return 2*nSquares + possible_nSquares[0] + possible_nSquares[1] - possible_nSquares[2] - possible_nSquares[3]

if __name__ == '__main__':
    print(main())
",O(n ^ 2)
"n, m, k = map(int, input().split())
*a, = map(int, input().split())
dp = [-1] * (n + 15)
for i in range(n):
    s, mx = a[i], max(0, a[i])
    for j in range(i - 1, max(-1, i - m), -1):
        s += a[j]
        mx = max(mx, s)
    dp[i] = max(0, dp[i - m] + s - k, mx - k)
print(max(dp))",O(n ^ 2)
"import sys

n,k = map(int, input().split())
k -= 1
lo,hi = 0,int(1e9)
while lo < hi:
	m = (lo + hi + 1) // 2
	if 1 + k*(k+1)//2 - m*(m+1)//2 >= n:
		lo = m;
	else:
		hi = m - 1
if 1 + k*(k+1)//2 - lo*(lo+1)//2 >= n:
	lo = k - lo
else:
	lo = -1
print(lo)",O(logn)
"n = int(input())
sequence = [int(x) for x in input().split()]
firstOrderStatistics = min(sequence)
if sequence.count(firstOrderStatistics) == len(sequence):
    print(""NO"")
else:
    sequence = sorted(sequence)
    secondOrderStatistics = sequence[0]
    for i in sequence:
        if(i > secondOrderStatistics):
            secondOrderStatistics = i
            break
    print(secondOrderStatistics)",O(nlogn)
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]

z, zz = fast, lambda: (map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())

def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer, end='\n'): stdout.write(str(answer) + end)

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]

n,m=zzz()
arr = zzz()
s = sum(arr)
idx = [[] for i in range(m)]
for i in range(n):
    idx[arr[i]%m].append(i)

j=0
for i in range(m):
    while len(idx[i])>n//m:
        while True:
            if j<i:j+=1
            elif len(idx[j%m])>=n//m:
                j+=1
            else:break
        last = idx[i].pop()
        arr[last]+=(j-i)%m
        idx[j%m].append(last)
print(sum(arr)-s)
print(*arr)
",O(n)
"class Solution(object):
    def isPerfectSquare(self, num):
        left, right = 1, num
        while left <= right:
            mid = left + (right - left) / 2
            if mid >= num / mid:
                right = mid - 1
            else:
                left = mid + 1
        return left == num / left and num % left == 0",O(logn)
"import collections
import fractions


class Solution(object):
    def interchangeableRectangles(self, rectangles):
        count = collections.defaultdict(int)
        for w, h in rectangles:
            g = fractions.gcd(w, h) 
            count[(w//g, h//g)] += 1
        return sum(c*(c-1)//2 for c in count.values())",O(n)
"n = int(input())
l = list(map(int,input().split()))
l=sorted(l)
if l[-1]==1:
    l[-1]=2
else:
    l[-1]=1
l=sorted(l)
print(*l)",O(nlogn)
"import sys
import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

n, m = map(int, input().split())

MAX = 0
MIN = 10**18
for i in range(n):
    l = i*(i+1)//2
    r = (n-1-i)*(n-1-i+1)//2
    MAX= max(MAX, l+r)
    MIN = min(MIN, l+r)

ans = 0
for i in range(m):
    x, d = map(int, input().split())
    ans += n*x
    if d  >= 0:
        ans += d*MAX
    else:
        ans += d*MIN
print(ans/n)
",O(n)
"import sys
N, M = map(int, input().split())

Ans = [None]*(N*M)
for i in range(1, N*M+1):
    if i % 2:
        a, b = divmod(i//2, M)
    else:
        a, b = divmod(N*M - i//2, M)
    Ans[i-1] = (a+1, b+1)
for a in Ans:
    sys.stdout.write('{} {}\n'.format(*a))",O(n ^ 2)
"import collections
import time
import os
import sys
import bisect
import heapq
from typing import List

class Node:
    val = None

    def __init__(self, val):
        self.val = val
        self.left = Node
        self.right = None

def solve(W, H, N, A):
    xs = [0] + [v for t, v in A if t == 0] + [W]
    ys = [0] + [v for t, v in A if t == 1] + [H]
    xs.sort()
    ys.sort()

    xlist = Node(0)
    h = xlist
    xnodes = {0: h}
    maxw = max([xs[i+1] - xs[i] for i in range(len(xs)-1)] or [0])
    maxh = max([ys[i+1] - ys[i] for i in range(len(ys)-1)] or [0])
    for v in xs[1:]:
        n = Node(v)
        xnodes[v] = n
        h.right = n
        n.left = h
        h = n

    ylist =  Node(0)
    h = ylist
    ynodes = {0: h}
    for v in ys[1:]:
        n = Node(v)
        ynodes[v] = n
        h.right = n
        n.left = h
        h = n

    ans = []
    maxarea = maxh * maxw
    for t, v in reversed(A):
        ans.append(maxarea)
        if t == 0:
            node = xnodes[v]
            w = node.right.val - node.left.val
            maxw = max(maxw, w)
        else:
            node = ynodes[v]
            h = node.right.val - node.left.val
            maxh = max(maxh, h)
        node.left.right = node.right
        node.right.left = node.left
        maxarea = maxh * maxw

    return ans[::-1]

def solve2(W, H, N, A):
    ws = [(-W, 0, W)]
    hs = [(-H, 0, H)]
    iw, ih = set(), set()
    ans = []

    xs, ys = [0, W], [0, H]
    for t, v in A:
        if t == 0:
            bisect.insort_left(xs, v)
            i = bisect.bisect_left(xs, v)
            l, m, r = xs[i-1], xs[i], xs[i+1]
            iw.add((l-r, l, r))
            heapq.heappush(ws, (l - m, l, m))
            heapq.heappush(ws, (m - r, m, r))
            while ws[0] in iw:
                heapq.heappop(ws)
        else:
            bisect.insort(ys, v)
            i = bisect.bisect_left(ys, v)
            l, m, r = ys[i-1], ys[i], ys[i+1]
            ih.add((l-r, l, r))
            heapq.heappush(hs, (l - m, l, m))
            heapq.heappush(hs, (m - r, m, r))
            while hs[0] in ih:
                heapq.heappop(hs)
        w, h = ws[0], hs[0]
        ans.append(w[0] * h[0])

    return ans

W, H, N = map(int,input().split())
A = []
for i in range(N):
    a, b = input().split()
    c = 0 if a == 'V' else 1
    A.append((c, int(b)))

print('\n'.join(map(str, solve(W, H, N, A))))",O(nlogn)
"import collections
import itertools
import heapq



class Solution(object):
    def mostFrequentIDs(self, nums, freq):
        result = []
        cnt = collections.Counter()
        max_heap = []
        for x, f in zip(nums, freq):
            cnt[x] += f
            heapq.heappush(max_heap, (-cnt[x], x))
            while max_heap and -max_heap[0][0] != cnt[max_heap[0][1]]:
                heapq.heappop(max_heap)
            result.append(-max_heap[0][0] if max_heap else 0)
        return result",O(nlogn)
"from sortedcontainers import SortedList



class Solution2(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")

        right = [NEG_INF]*len(prices)
        sl = SortedList()
        for i in reversed(range(len(prices))):
            j = sl.bisect_left((-prices[i],))
            if j-1 >= 0:
                right[i] = sl[j-1][1]
            if not (j-1 < 0 or sl[j-1][1] < profits[i]):
                continue
            sl.add((-prices[i], profits[i]))
            j = sl.bisect_left((-prices[i], profits[i]))
            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:
                del sl[j+1]
        result = NEG_INF
        sl = SortedList()
        for i in range(len(prices)):
            j = sl.bisect_left((prices[i],))
            if j-1 >= 0:
                result = max(result, sl[j-1][1]+profits[i]+right[i])
            if not (j-1 < 0 or sl[j-1][1] < profits[i]):
                continue
            sl.add((prices[i], profits[i]))
            j = sl.bisect_left((prices[i], profits[i]))
            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:
                del sl[j+1]
        return result if result != NEG_INF else -1",O(nlogn)
"import math
n=int(input())

a=[9]
for i in range(2,20):
    a.append(10**i   - 10**(i-1) )
b=[0]
for i in range(1,20):
    b.append(b[-1]+ i*a[i-1])
for i in range(20):
    if n<=b[i]:
        break
p=b[i-1]
k=n-p

ans=10**(i-1) - 1 + math.ceil(k/(i))

if k%i==0:
    print(('0'+str(ans))[i])
else:
    print(('0'+str(ans))[k%i])",O(logn)
"class Solution(object):
    def countDistinct(self, s):
        count = 0
        trie = {}
        for i in range(len(s)):
            curr = trie
            for j in range(i, len(s)):
                if s[j] not in curr:
                    count += 1
                    curr[s[j]] = {}
                curr = curr[s[j]]
        return count",O(n ^ 2)
"class Solution:
    def hasDuplicate(self, nums: List[int]) -> bool:
        seen = set()
        for num in nums:
            if num in seen:
                return True
            seen.add(num)
        return False
",O(n)
"class edge(object):
	def __init__(self,ne,to,fl):
		self.ne=ne
		self.to=to
		self.fl=fl

def add(x,y,z):
	global tot
	tot+=1
	e.append(edge(he[x],y,z))
	he[x]=tot

def addedge(x,y,z):
	add(x,y,z)
	add(y,x,0)

def bfs():
	global deep
	deep=[0 for i in range(T+1)]
	q=[]
	q.append(S)
	deep[S]=1
	while (len(q)>0):
		x=q[0]
		del(q[0])
		i=he[x]
		while (i):
			y=e[i].to
			if ((deep[y]==0)and(e[i].fl!=0)):
				deep[y]=deep[x]+1
				q.append(y)
			i=e[i].ne
	return deep[T]!=0

def dfs(x,flow):
	global deep
	if ((x==T)or(flow==0)):
		return flow
	used=0
	i=he[x]
	while (i):
		y=e[i].to
		if ((deep[y]==deep[x]+1)and(e[i].fl!=0)):
			now=dfs(y,min(flow-used,e[i].fl))
			used+=now
			e[i].fl-=now
			e[i^1].fl+=now
			if (flow==used):
				break;
		i=e[i].ne
	if (used==0):
		deep[x]=-1
	return used

def dinic():
	res=0
	while (bfs()):
		res+=dfs(S,INF)
	return res

n,m=map(int,input().split())
ans=0
weight=[0]+list(map(int,input().split()))

e=[0,0]
tot=1
S=n+m+1
T=S+1
he=[0 for i in range(T+1)]
INF=1000000007

for i in range(1,n+1):
	addedge(S,i,weight[i]);
for i in range(1,m+1):
	x,y,w=map(int,input().split())
	addedge(n+i,T,w)
	addedge(x,n+i,INF)
	addedge(y,n+i,INF)
	ans+=w
ans-=dinic()
print(ans)",O(n ^ 3)
"class Solution(object):
    def confusingNumberII(self, n):
        lookup = {""0"":""0"", ""1"":""1"", ""6"":""9"", ""8"":""8"", ""9"":""6""}
        centers = {""0"":""0"", ""1"":""1"", ""8"":""8""}
        def totalCount(n): 
            s = str(n)
            total = 0 
            p = len(lookup)**(len(s)-1)
            for i in range(len(s)+1):
                if i == len(s):
                    total += 1
                    break
                smaller = sum(int(c < s[i]) for c in lookup.keys())
                total += smaller * p
                if s[i] not in lookup:
                    break
                p //= len(lookup)
            return total-1 

        def validCountInLessLength(n): 
            s = str(n)
            valid = 0
            total = len(centers)
            for i in range(1, len(s), 2): 
                if i == 1:
                    valid += len({c for c in centers.keys() if c != '0'})
                else:
                    valid += total * (len(lookup)-1)
                    total *= len(lookup)
            total = 1
            for i in range(2, len(s), 2): 
                valid += total * (len(lookup)-1)
                total *= len(lookup)
            return valid

        def validCountInFullLength(n): 
            s = str(n)
            half_s = s[:(len(s)+1)//2]
            total = 0
            choices = centers if (len(s) % 2) else lookup
            p = int(len(lookup)**(len(half_s)-2) * len(choices))
            for i in range(len(half_s)):
                if i == len(half_s)-1:
                    total += sum(int(c < half_s[i]) for c in choices.keys() if i != 0 or c != '0')
                    if half_s[i] not in choices:
                        break
                    tmp = list(half_s)+[lookup[half_s[i]] for i in reversed(range(len(half_s)-(len(s) % 2)))]
                    total += 0 < int("""".join(tmp)) <= n
                    break
                smaller = sum(int(c < half_s[i]) for c in lookup.keys() if i != 0 or c != '0')
                total += smaller * p
                if half_s[i] not in lookup:
                    break
                p //= len(lookup)
            return total

        return totalCount(n) - validCountInLessLength(n) - validCountInFullLength(n)",O(logn)
"n = int(input())
ar = list(map(int, input().split()))
rev = ar[::-1]
from collections import Counter
def d(ar):
	me = Counter()
	s = 0
	for i in range (n) :
		s+=(i*ar[i])
		s-=(me[ar[i]] + me[ar[i]+1]*ar[i] + me[ar[i]-1]*ar[i])
		me[ar[i]]+=1
	return s
print(d(ar) - d(rev))",O(nlogn)
"import sys
import os.path
from collections import *
import math
import bisect

if (os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")

n, m, k1 = [int(x) for x in input().split()]

arr = [0 for i in range(n)]
for i in range(n):
    arr[i] = [int(x) for x in input().split()]

brr = [0 for i in range(n - 1)]
for i in range(n - 1):
    brr[i] = [int(x) for x in input().split()]

dp = [[[0 for k in range(21)] for j in range(m)] for i in range(n)]

for k in range(1, 21):
    for i in range(n):
        for j in range(m):
                if k % 2:
                    dp[i][j][k] = -1
                else:
                    dp[i][j][k] = 10 ** 9
                    if i > 0:
                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 2] + brr[i - 1][j] * 2)
                    if i < n - 1:
                        dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 2] + brr[i][j] * 2)
                    if j > 0:
                        dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 2] + arr[i][j - 1] * 2)
                    if j < m - 1:
                        dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 2] + arr[i][j] * 2)

for i in range(n):
    for j in range(m):
        print(dp[i][j][k1],end="" "")
    print()
",O(n ^ 3)
"mod=10**9+7
n=int(input())
l=[]
c=0
for i in range(n):
    l.append(input())
dp=[[0]*(n+2) for i in range(n+1)]
for i in range(n+2):
    dp[n][i]=1
for i in range(n-1,0,-1):
    s=0
    for j in range(n+1):
        s+=dp[i+1][j]
        s%=mod
        if l[i-1]=='f':
            dp[i][j]=dp[i+1][j+1]
        else:
            dp[i][j]=s

print(dp[1][0])
",O(n ^ 2)
"class Solution(object):
    def mirrorReflection(self, p, q):
        return 2 if (p & -p) > (q & -q) else 0 if (p & -p) < (q & -q) else 1",O(1)
"cnt = [0]*2
class Solution2(object):
    def countKReducibleNumbers(self, s, k):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]  
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def popcount(x):
            return bin(x).count('1')
      
        while len(s)-1 >= len(cnt): 
            cnt.append(cnt[popcount(len(cnt))]+1)
        result = curr = 0
        for i in range(len(s)):
            if s[i] != '1':
                continue
            for c in range((len(s)-(i+1))+1):
                if cnt[curr+c] < k:
                    result = (result+nCr(len(s)-(i+1), c))%MOD
            curr += 1
        return (result-1)%MOD",O(n ^ 2)
"a,k=map(int,input().split())
p=[]
for n in range(2,a+1):
	for i in range(2,int(n**0.5)+1):
		if n%i==0:
			break
	else:
		p.append(n)
c=0
for i in range(0,len(p)-1):
	n=p[i]+p[i+1]+1
	for i in range(2,int(n**0.5)+1):
		if n%i==0:
			break
	else:
		if n<=a:
			c+=1
if c>=k:
	print(""YES"")
else:
	print(""NO"")
",O(n)
"n = int(input())
if n == 0:
    print(0, 0, 0)
else:
    a, b = 0, 1
    while a + b != n:
        a, b = b, a + b
    print(0, a, b)",O(1)
"def read(type = 1):
    if type:
        file = open(""input.dat"", ""r"")
        n = int(file.readline())
        a = list(map(int, file.readline().split()))
        b = file.readline()
        file.close()
    else:
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        b = input().strip()
    return n, a, b

def solve():
    sol = 0
    e = 0
    big = 0
    g = 0
    for i in range(n):
        if b[i] == ""W"":
            big = 1
            sol += 3 * a[i]
            e += a[i]
        if b[i] == ""G"":
            sol += 5 * a[i]
            e += a[i]
            g += 2*a[i]
        if b[i] == ""L"":
            sol += a[i]
            e -= a[i]
            if e < 0:
                if big:
                    sol -= 3 * e
                else:
                    sol -= 5 * e
                e = 0
        g = min(e,g)
    if e:
        sol -= 2*g
        sol -= (e-g)
    return int(sol)

n, a, b = read(0)
sol = solve()
print(sol)",O(n)
"class Solution(object):
    def digitsCount(self, d, low, high):
        def digitsCount(n, k):
            pivot, result = 1, 0
            while n >= pivot:
                result += (n//(10*pivot))*pivot + \
                           min(pivot, max(n%(10*pivot) - k*pivot + 1, 0))
                if k == 0:
                    result -= pivot
                pivot *= 10
            return result+1
        
        return digitsCount(high, d) - digitsCount(low-1, d)",O(logn)
"def sfy(n):
    if n == 1: return [1]
    elif n == 2: return [1, 2]
    elif n == 3: return [1, 1, 3]
    else:
        if n % 2 == 0: return [1]*(n//2) + [2*x for x in sfy(n//2)]
        else:
            return [1]*(1 + n//2) + [2*x for x in sfy(n//2)]
print("" "".join([str(x) for x in sfy(int(input()))]))
",O(nlogn)
"n,m,a,b = map(int,input().split())

if n%m==0:
    print(0)
else:
    k = n%m
    print(min(k*b,(m-k)*a))",O(n)
"dat = """".split('')
d1, d2 = """", ""!&|()xyz""
for i in range(int(input())):
	s = dat[eval(""0b"" + ''.join(list(reversed(input()))))]
	for i in range(8): s = s.replace(d1[i], d2[i])
	print(s)
",O(n ^ 2)
"t=int(input())
for ca in range(t):
    asd=input().split()
    n=int(asd[0])
    k=int(asd[1])
    if n>=40:
        print(""YES ""+str(n-1))
    else:
        ans=-1
        for m in range(1,n+1):
            asd=(4**m-1)//3
            asd2=(2**m-1)**2
            asd2*=(4**(n-m)-1)//3
            asd+=asd2
            if asd>=k and m*m<=k:
                ans=n-m
                break
        if ans==-1:
            print(""NO"")
        else:
            print(""YES ""+str(ans))
",O(n)
"import math
mod=10**9 + 7

def calcpower(num,power,mod):

    if(power==0):
        return 1

    a=[num,]
    temp=num
    for i in range(int(math.log(power,2))):

        temp*=temp
        temp=temp%mod
        a.append(temp%mod)

    power=bin(power)[2:]

    power=power[::-1]
    res=1
    for i in range(len(power)):
        if(int(power[i])):
            res=(res*a[i])%mod
    return res%mod
import sys

x,k=map(int,input().split())

if(x==0):
    print(0)
    sys.exit()
if(k==0):
    print(2*x%mod)
    sys.exit()
ans=(2*x-1)*calcpower(2,k,mod)+1

print(ans%mod)",O(logn)
"import sys

lines = sys.stdin.readlines()

def read_a_num(line):
    n = int(line.strip())
    return n

def read_a_str(line):
    line = line.strip()
    return line

def check_ticket(digits):
    for target in range(900):
        seg_i = 0
        seg_sum = 0
        next_flag = False
        for d in digits:
            int_d = int(d)
            if int_d > target:
                next_flag = True
                break
            elif seg_sum + int_d > target:
                if next_flag:
                    break
                next_flag = True
                continue
            elif int_d == target or seg_sum + int_d == target:
                seg_i += 1
                seg_sum = 0
            else:
                seg_sum += int_d

        if next_flag:
            continue

        if seg_i >= 2 and seg_sum == 0:
            return True

    return False

digits = read_a_str(lines[1])
if check_ticket(digits):
    print(""yes"")
else:
    print(""no"")
",O(n ^ 2)
"n,k=map(int,input().split())
if n>=k:
    print((k-1)//2)
elif n*2>k:
    print(n-k//2)

else:
    print(0)",O(1)
"import collections
import operator
from functools import reduce



class Solution(object):
    def countTheNumOfKFreeSubsets(self, nums, k):
        def count(x):
            y = x
            while y-k in cnt:
                y -= k
            dp = [1, 0] 
            for i in range(y, x+1, k):
                dp = [dp[0]+dp[1], dp[0]*((1<<cnt[i])-1)]
            return sum(dp)

        cnt = collections.Counter(nums)
        return reduce(operator.mul, (count(i) for i in cnt.keys() if i+k not in cnt))",O(n)
"import itertools


class Solution(object):
    def maxSumRangeQuery(self, nums, requests):
        def addmod(a, b, mod): 
            a %= mod
            b %= mod
            if mod-a <= b:
                b -= mod
            return a+b
        
        def mulmod(a, b, mod): 
            a %= mod
            b %= mod
            if a < b:
                a, b = b, a
            result = 0
            while b > 0:
                if b%2 == 1:
                    result = addmod(result, a, mod)
                a = addmod(a, a, mod)
                b //= 2
            return result

        MOD = 10**9+7

        count = [0]*len(nums)
        for start, end in requests:
            count[start] += 1
            if end+1 < len(count):
                count[end+1] -= 1
        for i in range(1, len(count)):
            count[i] += count[i-1]
        nums.sort()
        count.sort()
        result = 0
        for i, (num, c) in enumerate(zip(nums, count)):
            result = (result+num*c)%MOD
        return result",O(nlogn)
"import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd
from itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from bisect import bisect, bisect_left, insort, insort_left
from heapq import heappush, heappop
from functools import reduce, lru_cache
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
def TUPLE(): return tuple(map(int, input().split()))
def ZIP(n): return zip(*(MAP() for _ in range(n)))
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
mod = 10 ** 9 + 7

N = INT()
xw = [LIST() for _ in range(N)]

rl = []
for x, w in xw:
    rl.append((x-w, x+w))

rl.sort(key = lambda x: (x[1], x[0]))

ans = 0
tmp = -INF

for r, l in rl:
    if r < tmp:
        continue
    ans += 1
    tmp = l

print(ans)
",O(nlogn)
"class Solution(object):
    def minInsertions(self, s):
        def longestCommonSubsequence(text1, text2):
            if len(text1) < len(text2):
                return self.longestCommonSubsequence(text2, text1)
            dp = [[0 for _ in range(len(text2)+1)] for _ in range(2)]
            for i in range(1, len(text1)+1):
                for j in range(1, len(text2)+1):
                    dp[i%2][j] = dp[(i-1)%2][j-1]+1 if text1[i-1] == text2[j-1] \
                                 else max(dp[(i-1)%2][j], dp[i%2][j-1])
            return dp[len(text1)%2][len(text2)]

        return len(s)-longestCommonSubsequence(s, s[::-1])",O(n ^ 2)
"class Solution3(object):
    def canSortArray(self, nums):
        def popcount(x):
            return bin(x).count(""1"")
    
        left = 0
        for right in range(len(nums)):
            if right+1 != len(nums) and popcount(nums[right+1]) == popcount(nums[right]):
                continue
            nums[left:right+1] = sorted(nums[left:right+1])
            left = right+1
        return all(nums[i] <= nums[i+1] for i in range(len(nums)-1))",O(nlogn)
"input_1 = input()
input_2 = input()

line_1 = [i for i in str(input_1)]
line_2 = [i for i in str(input_2)]

no = 0
for i in range(len(line_1) - 1):
    if line_1[i] != 'X' and line_2[i] != 'X':
        if line_1[i + 1] != 'X':
            no += 1
            line_1[i] = 'X'
            line_2[i] = 'X'
            line_1[i + 1] = 'X'

        elif line_2[i + 1] != 'X':
            no += 1
            line_1[i] = 'X'
            line_2[i] = 'X'
            line_2[i + 1] = 'X'

    elif line_1[i] != 'X' and line_1[i + 1] != 'X' and line_2[i + 1] != 'X':
        no += 1
        line_1[i] = 'X'
        line_1[i + 1] = 'X'
        line_2[i + 1] = 'X'

    elif line_2[i] != 'X' and line_1[i + 1] != 'X' and line_2[i + 1] != 'X':
        no += 1
        line_2[i] = 'X'
        line_1[i + 1] = 'X'
        line_2[i + 1] = 'X'

print(no)
",O(1)
"from os import path
from io import BytesIO, IOBase
import sys
from heapq import heappush,heappop
from functools import cmp_to_key as ctk
from collections import deque,Counter,defaultdict as dd
from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right
from itertools import permutations
from datetime import datetime
from math import ceil,sqrt,log,gcd
def ii():return int(input())
def si():return input().rstrip()
def mi():return map(int,input().split())
def li():return list(mi())
abc='abcdefghijklmnopqrstuvwxyz'
mod=1000000007

inf = float(""inf"")
vow=['a','e','i','o','u']
dx,dy=[-1,1,0,0],[0,0,1,-1]

def bo(i):
    return ord(i)-ord('0')

file = 1
def ceil(a,b):
    return (a+b-1)//b

def solve():

    l,r = mi()
    s1 = bin(l)[2:]
    s2 = bin(r)[2:]
    if len(s1) != len(s2):
      print((1<<len(s2))-1)
      return

    x = 0
    for i in range(62,-1,-1):
      if ((l>>i)&1)^((r>>i)&1):
        x +=(1<<(i+1))
        x -=1
        break
    print(x)

if __name__ ==""__main__"":

    if(file):

       if path.exists('input.txt'):
           sys.stdin=open('input.txt', 'r')
           sys.stdout=open('output.txt','w')
       else:
           input=sys.stdin.readline
    solve()
",O(logn)
"def solution(n, k, arr):
    ret = []
    grp = [None for _ in range(256)]
    for i in arr:
        if grp[i]:
            continue
        l = None
        j = 1
        for j in range(1, k):
            if i - j < 0:
                break
            if grp[i - j] is not None:
                l = i - j
                break
        if l is not None and grp[l] > i - k:
            grp[i] = grp[l]
        else:
            ll = l + 1 if l else max(0, i - k + 1)
            for j in range(ll, i + 1):
                grp[j] = ll
    for i in arr:
        ret.append(grp[i])
    return ret

n, k = map(int, input().split())
arr = list(map(int, input().split()))
print(' '.join(map(str, solution(n, k, arr))))
",O(n ^ 2)
"import sys
N, M = map(int, input().split())

Ans = [(0, 0) for  _ in range(N*M)]
for i in range(1, N*M+1):
    if i % 2:
        a, b = divmod(i//2, M)
    else:
        a, b = divmod(N*M - i//2, M)
    Ans[i-1] = (a+1, b+1)
for a in Ans:
    sys.stdout.write('{} {}\n'.format(*a))",O(n ^ 2)
"class Solution(object):
    def addMinimum(self, word):
        return 3*(sum(i-1 < 0 or word[i-1] >= word[i] for i in range(len(word))))-len(word)",O(n)
"class Solution(object):
    def validSquare(self, p1, p2, p3, p4):
        def dist(p1, p2):
            return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2

        lookup = set([dist(p1, p2), dist(p1, p3),\
                      dist(p1, p4), dist(p2, p3),\
                      dist(p2, p4), dist(p3, p4)])
        return 0 not in lookup and len(lookup) == 2",O(1)
"import collections


class Solution2(object):
    def longestSubarray(self, nums, limit):
        max_dq, min_dq = collections.deque(), collections.deque()
        result, left = 0, 0
        for right, num in enumerate(nums):
            while max_dq and nums[max_dq[-1]] <= num:
                max_dq.pop()
            max_dq.append(right)
            while min_dq and nums[min_dq[-1]] >= num:
                min_dq.pop()
            min_dq.append(right)
            while nums[max_dq[0]]-nums[min_dq[0]] > limit: 
                if max_dq[0] == left:
                    max_dq.popleft()
                if min_dq[0] == left:
                    min_dq.popleft()
                left += 1
            result = max(result, right-left+1)
        return result",O(n)
"class Solution:
    def binary_search(self, l: int, r: int, nums: List[int], target: int) -> int:
        if l > r:
            return -1
        m = l + (r - l) // 2

        if nums[m] == target:
            return m
        if nums[m] < target:
            return self.binary_search(m + 1, r, nums, target)
        return self.binary_search(l, m - 1, nums, target)

    def search(self, nums: List[int], target: int) -> int:
        return self.binary_search(0, len(nums) - 1, nums, target)
",O(logn)
"import collections


class UnionFind(object): 
    def __init__(self, vals):
        self.set = list(range(len(vals)))
        self.rank = [0]*len(vals)
        self.cnt = [collections.Counter({v:1}) for v in vals]  

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y, v): 
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return 0 
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        cx, cy = self.cnt[x][v], self.cnt[y][v] 
        self.cnt[y] = collections.Counter({v:cx+cy}) 
        return cx*cy 



class Solution(object):
    def numberOfGoodPaths(self, vals, edges):
        edges.sort(key=lambda x: max(vals[x[0]], vals[x[1]]))
        uf = UnionFind(vals)
        return len(vals)+sum(uf.union_set(i, j, max(vals[i], vals[j])) for i, j in edges)",O(nlogn)
"def c(a, b, l, ans, pro):
    if l != 0:
        n = a[:]
        mx = None
        pro1 = pro
        prosh = set()
        for i in range(l):
            pro = pro1
            if a[i] == prosh:
                continue
            elif (a[i] <= b[0] and pro):
                n.pop(i)
                prosh = a[i]
                if pro == True:
                    if a[i] < b[0]:
                        pro = False
                m = c(n, b[1:], l-1, ans+str(a[i]), pro)
                n = a[:]
                if m != None:
                    if mx == None:
                        mx = int(m)
                    elif mx < int(m):
                        mx = int(m)
            elif not(pro):
                a.sort(reverse = True)
                a = list(map(str, a))
                return ans +''.join(a)
            else:
                break
        return mx
    else:
        return ans
a = input()
b = input()
l = len(a)
if len(a) != len(b):
    a = list(a)
    a.sort()
    print(''.join(a[::-1]))
else:
    a = list(map(int, a))
    b = list(map(int, b))
    a.sort()
    n = a[:]
    mx = 0
    prosh = -1
    for i in range(l):
        if a[i] == prosh:
            continue
        elif a[i] != 0 and a[i] <= b[0]:
            n.pop(i)
            prosh = a[i]
            pro = False
            if a[i] == b[0]:
                pro = True
            m = c(n, b[1:], l-1, str(a[i]), pro)
            n = a[:]
            if m != None:
                if mx < int(m):
                    mx = int(m)
        elif a[i] > b[0]:
            break
    print(mx)",O(n ^ 3)
"kol = int(input())

dic = {'purple': 'Power',
       'green': 'Time',
       'blue': 'Space',
       'orange': 'Soul',
       'red': 'Reality',
       'yellow': 'Mind'}

r = []
g = []
missing = 6 - kol

for k in range(kol):
    rocks = input()
    r.append(rocks)

for key in dic:
    if r.count(key) == 0:
        g.append(dic[key])

print(missing)

for stone in g:
    print(stone)",O(1)
"def getN():
    return int(input())
def getList():
    return list(map(int, input().split()))

from collections import deque

n, m = getList()
nums = getList()
mxnum = max(nums)
d = deque(nums)

qr = []
for i in range(m):
    qr.append(getN())

log = []

rot = 0
while(True):

    a = d.popleft()
    b = d.popleft()
    log.append((a, b))
    if a > b:
        a, b = b, a

    d.append(a)
    d.appendleft(b)

    rot += 1

    if b == mxnum:
        break

for q in qr:
    if q <= rot:
        print(log[q - 1][0], log[q - 1][1])
    else:
        res = q -  rot - 1
        print(b, d[res % (n-1) + 1  ])
",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from heapq import heapify,heappush as hp,heappop as hpop
def check(x,y):
    if 0<=x<=n-1 and 0<=y<=m-1:
        return True
    return False
n,m,k=map(int,input().split())
l1=[]
l2=[]
for i in range(n):
    l1.append(list(map(int,input().split())))
for  i in range(n-1):
    l2.append(list(map(int,input().split())))
inf=10**18
dp=[[[inf]*21 for i in range(m)] for j in range(n)]
for i in range(n):
    for j in range(m):
        if check(i,j+1):
            dp[i][j][1]=min(l1[i][j],dp[i][j][1])
        if check(i,j-1):
            dp[i][j][1]=min(l1[i][j-1],dp[i][j][1])
        if check(i+1,j):
            dp[i][j][1]=min(l2[i][j],dp[i][j][1])
        if check(i-1,j):
            dp[i][j][1]=min(l2[i-1][j],dp[i][j][1])
for x in range(2,k//2+1):
    for i in range(n):
        for j in range(m):
            if check(i,j+1):
                dp[i][j][x]=min(l1[i][j]+dp[i][j+1][x-1],dp[i][j][x])
            if check(i,j-1):
                dp[i][j][x]=min(l1[i][j-1]+dp[i][j-1][x-1],dp[i][j][x])
            if check(i+1,j):
                dp[i][j][x]=min(l2[i][j]+dp[i+1][j][x-1],dp[i][j][x])
            if check(i-1,j):
                dp[i][j][x]=min(l2[i-1][j]+dp[i-1][j][x-1],dp[i][j][x])

ans=[[-1]*m for i in range(n)]
if not k%2:
    for i in range(n):
        for j in range(m):
            ans[i][j]=2*dp[i][j][k//2]
for i in ans:
    print(*i)
",O(n ^ 3)
"import random


class Solution_TLE(object):
    def getStrongest(self, arr, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def partition_around_pivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left <= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == n:
                    return
                elif new_pivot_idx > n:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1
        
        nth_element(arr, (len(arr)-1)//2)
        m = arr[(len(arr)-1)//2]
        nth_element(arr, k, lambda a, b: abs(a-m) > abs(b-m) if abs(a-m) != abs(b-m) else a > b)
        return arr[:k]",O(n)
"from heapq import heappush, heappop
n = int(input())
L = list(map(int, input().split()))
T = input()

ans = sum(L)

Q = []

for l, t in zip(L, T):
    if t == 'G':
        heappush(Q, (2, 2 * l))
        heappush(Q, (5, float('inf')))
    elif t == 'W':
        heappush(Q, (1, 2 * l))
        heappush(Q, (3, float('inf')))

    need_stamina = l
    while need_stamina > 0:
        cost, quantity = heappop(Q)
        if need_stamina > quantity:
            ans += quantity * cost
            need_stamina -= quantity
        else:
            ans += need_stamina * cost
            heappush(Q, (cost, quantity - need_stamina))
            need_stamina = 0

print(ans)
",O(nlogn)
"class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        maxArea = 0
        stack = []

        for i, h in enumerate(heights):
            start = i
            while stack and stack[-1][1] > h:
                index, height = stack.pop()
                maxArea = max(maxArea, height * (i - index))
                start = index
            stack.append((start, h))

        for i, h in stack:
            maxArea = max(maxArea, h * (len(heights) - i))
        return maxArea
",O(n)
"class Solution(object):
    def generateTheString(self, n):
        result = ['a']*(n-1)
        result.append('a' if n%2 else 'b')
        return """".join(result)",O(n)
"import collections
import re


class Solution(object):
    def countOfAtoms(self, formula):
        parse = re.findall(r""([A-Z][a-z]*)(\d*)|(\()|(\))(\d*)"", formula)
        stk = [collections.Counter()]
        for name, m1, left_open, right_open, m2 in parse:
            if name:
              stk[-1][name] += int(m1 or 1)
            if left_open:
              stk.append(collections.Counter())
            if right_open:
                top = stk.pop()
                for k, v in top.items():
                  stk[-1][k] += v * int(m2 or 1)

        return """".join(name + (str(stk[-1][name]) if stk[-1][name] > 1 else '') \
                       for name in sorted(stk[-1]))",O(n)
"from collections import Counter
import sys
input = sys.stdin.readline
n = int(input())
a = map(int, input().split())
mod = 998244353
d = Counter(a)
d[0] = 0
b = list(d.items())
b.sort()
m = len(b)
ba = [0] * m
cn = [0] * (m + 1)
k = h = 0
for i, x in enumerate(b):
    while h < m and x[0] >= b[h][0] * 2:
        h += 1
    ba[i] = h - 1
    while k < m and x[0] * 2 > b[k][0]:
        k += 1
    cn[k] += x[1]
for i in range(m):
    cn[i+1] += cn[i]
dp = [0] * m
dp[0] = 1
b = [x[1] for x in b]
for i in range(n):
    ndp = [0] * m
    for j in range(1, m):
        if cn[j] >= i - 1:
            ndp[j] = dp[j] * (cn[j] - i + 1) % mod
        dp[j] += dp[j-1]
        if dp[j] >= mod:
            dp[j] -= mod
    for j in range(1, m):
        ndp[j] += dp[ba[j]] * b[j]
        ndp[j] %= mod
    dp = ndp
print(sum(dp) % mod)",O(n ^ 3)
"class Solution2(object):
    def triangularSum(self, nums):
        result = 0
        nCr = 1
        for i in range(len(nums)):
            result = (result+nCr*nums[i])%10
            nCr *= (len(nums)-1)-i
            nCr //= i+1
        return result",O(n)
"class Solution(object):
    def rotate(self, matrix):
        n = len(matrix)

        for i in range(n):
            for j in range(n - i):
                matrix[i][j], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[i][j]

        for i in range(n / 2):
            for j in range(n):
                matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]

        return matrix",O(n ^ 2)
"l1=l2=-1
r1=r2=1<<30
for i in range(int(input())):
 l,r=map(int,input().split())
 if l>l1:il,l1,l2=i,l,l1
 elif l>l2:l2=l
 if r<r1:ir,r1,r2=i,r,r1
 elif r<r2:r2=r
print(max(0,(r2-l2,max(r1-l2,r2-l1))[il!=ir]))",O(n)
"class Solution(object):
    def removeDigit(self, number, digit):
        i = next((i for i in range(len(number)-1) if digit == number[i] < number[i+1]), len(number)-1)
        if i+1 == len(number):
            i = next((i for i in reversed(range(len(number))) if digit == number[i]))
        return number[:i]+number[i+1:]",O(n)
"from collections import defaultdict
from itertools import accumulate
import sys
input = sys.stdin.readline

inf = 100000000000000000
mod = 998244353

n, m ,k= map(int, input().split())
M=[]
S=[]
F=[]
for i in range(n):
    M.append(input().strip())
for i in range(m):
    tmp1, tmp2 = input().split()
    S.append(tmp1)
    F.append(int(tmp2)-1)

TRAN_dict=defaultdict(int)
TRAN_dict['_']=0
for i in range(97,97+26):
    TRAN_dict[chr(i)]=i-96;

def cal(X):
    base=1
    number=0
    for x in X:
        number=number*base+TRAN_dict[x]
        base*=27
    return number

STONE=defaultdict(int)
for i in range(n):
    STONE[cal(list(M[i]))]=i

def check(X,result):
    number=cal(X)
    if number in STONE.keys():
        result.append(STONE[number])

bian=[[] for i in range(n)]
du=[0]*n

for i in range(m):
    gain=[]
    for digit in range(1<<k):
        now=list(S[i])
        tmp=bin(digit)
        tmp=tmp[2:]
        tmp='0'*(k-len(tmp))+tmp
        for j in range(k):
            if tmp[j]=='1':
                now[j]='_'
        check(now,gain)
    if F[i] not in gain:
        print(""NO"")
        sys.exit(0)
    for x in gain:
        if x!=F[i]:
            bian[F[i]].append(x)
            du[x]+=1

from collections import deque
QUE=deque()
for i in range(n):
    if du[i]==0:
        QUE.append(i)
TOP_SORT=[]
while QUE:
    now=QUE.pop()
    TOP_SORT.append(now)
    for to in bian[now]:
        du[to]-=1
        if du[to]==0:
            QUE.append(to)
if len(TOP_SORT)==n:
    print(""YES"")
    print(*[i+1 for i in TOP_SORT])
else:
    print(""NO"")
",np
"a = list(map(int, input().split()))
n = a[0]
k = a[1]
s = input()
m = int(-1)
for i in range(0, n - 1):
    ff = int(0)
    for j in range(0, i + 1):
        if s[j] != s[n - i - 1 + j]:
            ff = 1
            break;
    if ff == 0:
        m = i
print(s, end="""")
for i in range(1, k):
    for j in range(m + 1, n):
        print(s[j], end="""")
",O(n ^ 2)
"from sys import stdin,stdout
from collections import Counter
nmbr=lambda:int(stdin.readline())
lst = lambda: list(map(int,stdin.readline().split()))
for _ in range(1):
    n,k=lst()
    a=lst()
    d={};r=l=-2
    for i in range(n):
        d[a[i]]=d.get(a[i],0)+1
        if len(d)==k:
            r=i
            break
    for i in range(r+1):
        if d[a[i]]==1:
            l=i
            break
        d[a[i]]-=1
    print(l+1,r+1)",O(n)
"n, s = map(int, input().split())
print((s + n - 1) // n)
",O(1)
"class Solution(object):
    def maxValue(self, n, x):
        check = (lambda i: str(x) > n[i]) if n[0] != '-' else (lambda i: str(x) < n[i])
        for i in range(len(n)):
            if check(i):
                break
        else:
            i = len(n)
        return n[:i] + str(x) + n[i:]",O(n)
"import  math
s=str(input())
s2=str(input())
p,m,res,ans,temp,i=0,0,0,0,0,0
p=s.count(""+"")
m=s.count(""-"")
q=s2.count(""+"")
w=s2.count(""-"")
pr,mr=p-q,m-w
if pr <0 or mr<0:
    print(""%.12f""%0)
else:
    temp=pr+mr
    if temp==0:
        print('%.12f'%1)
    else:
        i=pow(2,temp)
        res=math.factorial(temp)/(math.factorial(pr)*math.factorial(mr))
        ans=res/i
        print(""%.12f""%ans)
",np
"casas, tubos = map(int, input().strip().split())

def bs(c, t):
    l, r = 0, t-1
    while l <= r:
        mid = l+r >> 1
        if ((2*t - mid - 1)*mid)//2+1 < c:
            l = mid+1
        else:
            r = mid-1
    return r+1

res = bs(casas, tubos)
print(-1 if res == tubos else res)
",O(logn)
"x=input()
a=0
for i in range(len(x)):
    for j in range(i,len(x)):
        if x[i:j] in x[i+1:]:
            if len(x[i:j])>a:
                a=len(x[i:j])
print(a)
",O(n ^ 3)
"class Solution(object):
    def numberOfCuts(self, n):
        return 0 if n == 1 else n if n%2 else n//2",O(1)
"r,g,b=map(int,input().split())
s1=[int(x) for x in input().split()]
s2=[int(x) for x in input().split()]
s3=[int(x) for x in input().split()]
s1.sort()
s2.sort()
s3.sort()
s1=s1[::-1]
s2=s2[::-1]
s3=s3[::-1]
s1=[0]+s1
s2=[0]+s2
s3=[0]+s3

dp=[]
for i in range(r+5):
    H=[]
    for j in range(g+5):
        h=[]
        for k in range(b+5):
            h.append(0)
        H.append(h)
    dp.append(H)

for i in range(0,r+1):
    for j in range(0,g+1):
        for k in range(0,b+1):
            t1,t2,t3,t4,t5,t6 = 0,0,0,0,0,0
            if(i-1>=0 and j-1>=0):
                t1 = dp[i-1][j-1][k] + (s1[i]*s2[j])
            if(i-1>=0 and k-1>=0):
                t2 = dp[i-1][j][k-1] + (s1[i]*s3[k])
            if(k-1>=0 and j-1>=0):
                t3 = dp[i][j-1][k-1] + (s2[j]*s3[k])
            if(i-1>=0):
                t4 = dp[i-1][j][k]
            if(j-1>=0):
                t5 = dp[i][j-1][k]
            if(k-1>=0):
                t6 = dp[i][j][k-1]

            dp[i][j][k] = max(t1,t2,t3,t4,t5,t6)

print(dp[r][g][b])
",O(n ^ 3)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

T, = getIntList()

MAXN = 10**18 + 10
def getUpper(N):
    z = 1
    r = 0
    for i in range(N):
        r+=z
        z*=4
        if r>MAXN:
            break
    return r
for _ in range(T):
    N,K = getIntList()
    tk = K
    z = 1
    for i in range(N):
        tk -= z
        z*= 4
        if tk<0: break
    if tk>0:
        print('NO')
        continue
    nowcut =  0
    nt = 1
    nowupper = 0
    ok = False
    for i in range(N):
        nt *=2
        nowcut += nt-1

        if nowcut >K: break
        t = (nt *2 - 3)
        tu  = t * getUpper(N-1-i)
        nowupper += tu
        dprint('bound', nowcut, nowcut+nowupper)
        if nowcut<=K<= nowcut+nowupper:
            ok = True
            break
    if ok:
        print('YES', N-1-i)
    else:
        print(""NO"")
",O(n ^ 2)
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]

z, zz = fast, lambda: (map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())

def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer, end='\n'): stdout.write(str(answer) + end)

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]

n = int(z())
arr = set(zz())

def solve():
    for i in arr:
        for k in range(31):
            if i - (1 << k) in arr and i + (1 << k) in arr:
                return [i - (1 << k), i, i + (1 << k)]
    for i in arr:
        for k in range(31):
            if i + (1 << k) in arr:
                return [i, i + (1 << k)]

    for i in arr:
        return [i]

lst = solve()

print(len(lst))
for i in lst:
    output(i,' ')",O(nlogn)
"class Solution(object):
    def findSubarrays(self, nums):
        lookup = set()
        for i in range(len(nums)-1):
            if nums[i]+nums[i+1] in lookup:
                return True
            lookup.add(nums[i]+nums[i+1])
        return False",O(n)
"class Solution(object):
    def minSubArrayLen(self, s, nums):
        start = 0
        sum = 0
        min_size = float(""inf"")
        for i in range(len(nums)):
            sum += nums[i]
            while sum >= s:
                min_size = min(min_size, i - start + 1)
                sum -= nums[start]
                start += 1

        return min_size if min_size != float(""inf"") else 0",O(n)
"l,r=map(int,input().split())
al=[]
ar=[]
while(r):
    p=r%2
    ar.append(p)
    r=r//2
while(l):
    p=l%2
    al.append(p)
    l=l//2
if len(ar)!=len(al):
    ans=(2**len(ar))-1
else:
    n=len(ar)
    s=0
    k=0
    for i in range(n-1,-1,-1):
        if ar[i]!=al[i]:
            k=i+1
            break
    ans=(2**k)-1
    if k==0:
        ans=0
print(ans)",O(logn)
"class Solution(object):
    def myPow(self, x, n):
        result = 1
        abs_n = abs(n)
        while abs_n:
            if abs_n & 1:
                result *= x
            abs_n >>= 1
            x *= x

        return 1 / result if n < 0 else result",O(logn)
"class Solution3(object):
    def minCost(self, nums, cost):
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        prefix = [0]*(len(cost)+1)
        left = 0
        for i in range(len(cost)):
            if i-1 >= 0:
                left += prefix[i]*(nums[idxs[i]]-nums[idxs[i-1]])
            prefix[i+1] = prefix[i]+cost[idxs[i]]
        result = float(""inf"")
        suffix = right = 0
        for i in reversed(range(len(cost))):
            if i+1 < len(idxs):
                right += suffix*(nums[idxs[i+1]]-nums[idxs[i]])
            result = min(result, left+right)
            if i-1 >= 0:
                left -= prefix[i]*(nums[idxs[i]]-nums[idxs[i-1]])
            suffix += cost[idxs[i]]
        return result",O(nlogn)
"n,k = map(int, raw_input().split())

def area(height):
    return n * height

def bin_search(low, high):
    if (high == low):
        return high
    if high - low == 1:
        if area(low) >= k:
            return low
        return high
    midd = (high + low) // 2
    if area(midd) > k:
        return bin_search(low, midd)
    return bin_search(midd, high)

print(bin_search(0, 1000000000000000000))",O(logn)
"class Solution2(object):
    def invertTree(self, root):
        if root is not None:
            nodes = []
            nodes.append(root)
            while nodes:
                node = nodes.pop()
                node.left, node.right = node.right, node.left
                if node.left is not None:
                    nodes.append(node.left)
                if node.right is not None:
                    nodes.append(node.right)

        return root",O(n)
"class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        for i in range(len(numbers)):
            l, r = i + 1, len(numbers) - 1
            tmp = target - numbers[i]
            while l <= r:
                mid = l + (r - l)//2
                if numbers[mid] == tmp:
                    return [i + 1, mid + 1]
                elif numbers[mid] < tmp:
                    l = mid + 1
                else:
                    r = mid - 1
        return []
",O(nlogn)
"import sys, math, queue

MOD = 998244353
sys.setrecursionlimit(1000000)

n, m, k = map(int, input().split())
a = list(map(int, input().split()))

dp = [[-10**20 for i in range(m)] for i in range(n)]
dp[0][0] = a[0]-k

for i in range(1, n):
	for j in range(m):
		if j == 0:
			dp[i][j] = max(dp[i-1][m-1]+a[i], a[i])-k
		else:
			dp[i][j] = dp[i-1][j-1]+a[i]

ans = 0
for i in range(n):
	ans = max(ans, max(dp[i]))
print(ans)",O(n ^ 2)
"import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
l,r=list(map(int,input().split()))
if l==r:
    print(0)
else:
    a=bin(l)[2:]
    b=bin(r)[2:]
    x=len(a)
    y=len(b)
    if x!=y:
        ans=0
        for i in range(y):
            ans+=(2**i)
        print(ans)
    else:
        for i in range(x):
            if a[i]!=b[i]:
                ind=i
                break
        l=x-ind
        ans=0
        for i in range(l):
            ans+=(2**i)
        print(ans)
",O(logn)
"def some_random_function():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function5():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

import os,sys
from io import BytesIO,IOBase

def main():
    n,m,k = map(int,input().split())
    hor = [list(map(int,input().split()))+[10**20+1] for _ in range(n)]
    ver = [list(map(int,input().split())) for _ in range(n-1)]+[[10**20+1]*m]
    if k&1:
        for _ in range(n):
            print(*[-1]*m)
        exit()
    dp = [[0]*m for _ in range(n)]
    dx,dy = [0,0,1,-1],[1,-1,0,0]
    for _ in range(k//2):
        dp1 = [[10**20]*m for _ in range(n)]
        for i in range(n):
            for j in range(m):
                for kk in range(4):
                    x1,y1 = i+dx[kk],j+dy[kk]
                    if kk < 2:
                        ed = hor[i][j-(kk==1)]
                    else:
                        ed = ver[i-(kk==3)][j]
                    if ed != 10**20+1:
                        dp1[i][j] = min(dp1[i][j],2*ed+dp[x1][y1])
        dp = dp1
    for i in dp:
        print(*i)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def some_random_function1():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function2():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function3():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function4():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function6():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function7():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function8():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

if __name__ == '__main__':
    main()",O(n ^ 3)
"MOD = 1000000007
def modpow(x, p):

    result = 1
    while p > 0:

        if p % 2 == 1:
            result = (result * x) % MOD

        p = p // 2

        x = (x * x) % MOD

    return result

n, k = map(int, input().split())
k+=1
if n == 0:
	print(0)
else:

	ans =  (((modpow(2, k))*(n%MOD))%MOD-(modpow(2, k-1)-1)%MOD)%MOD
	print(ans)",O(logn)
"class Solution(object):
    def bestHand(self, ranks, suits):
        LOOKUP = ["""", ""High Card"", ""Pair"", ""Three of a Kind"", ""Three of a Kind"", ""Three of a Kind""]
        if all(suits[i] == suits[0] for i in range(1, len(suits))):
            return ""Flush""
        cnt = [0]*13
        for x in ranks:
            cnt[x-1] += 1
        return LOOKUP[max(cnt)]",O(1)
"class Solution(object):
    def largestPerimeter(self, A):
        A.sort()
        for i in reversed(range(len(A) - 2)):
            if A[i] + A[i+1] > A[i+2]:
                return A[i] + A[i+1] + A[i+2]
        return 0",O(nlogn)
"n,m=map(int, input().split())
nums = list(map(int, input().split()))

left = {}
right = {}

leftl = 0
leftm = 0

rightl = 0
rightm = 0

start = nums.index(m)

ans = 1

for i in range(start-1,-1,-1):
    if nums[i]>m:
        leftm += 1
    else:
        leftl += 1

    if leftl == leftm:
        ans += 1
    elif leftl+1 == leftm:
        ans += 1

    temp = leftm - leftl
    if temp in left.keys():
        left[temp] += 1
    else:
        left[temp] = 1

for i in range(start+1,n,1):
    if nums[i]>m:
        rightm += 1
    else:
        rightl += 1

    if rightl == rightm:
        ans += 1
    elif rightl+1 == rightm:
        ans += 1

    temp = rightm-rightl
    if temp in right.keys():
        right[temp] += 1
    else:
        right[temp] = 1
for i in left.keys():
    poss = (-1)*i
    if poss in right.keys():
        ans += right[poss]*left[i]

    if poss+1 in right.keys():
        ans += right[poss+1]*left[i]

print(ans)
",O(nlogn)
"class Solution(object):
    def getCommon(self, nums1, nums2):
        i = j = 0
        while i < len(nums1) and j < len(nums2):
            if nums1[i] < nums2[j]:
                i += 1
            elif nums1[i] > nums2[j]:
                j += 1
            else:
                return nums1[i]
        return -1",O(n)
"class Solution(object):
    def longestConsecutive(self, root):
        self.max_len = 0

        def longestConsecutiveHelper(root):
            if not root:
                return 0

            left_len = longestConsecutiveHelper(root.left)
            right_len = longestConsecutiveHelper(root.right)

            cur_len = 1
            if root.left and root.left.val == root.val + 1:
                cur_len = max(cur_len, left_len + 1)
            if root.right and root.right.val == root.val + 1:
                cur_len = max(cur_len, right_len + 1)

            self.max_len = max(self.max_len, cur_len)

            return cur_len

        longestConsecutiveHelper(root)
        return self.max_len",O(n)
"class Solution(object):
    def houseOfCards(self, n):
        dp = [0]*(n+1) 
        dp[0] = 1
        for t in range(1, (n+1)//3+1):
            for i in reversed(range(3*t-1, n+1)):
                dp[i] += dp[i-(3*t-1)]
        return dp[n]",O(n ^ 2)
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math

alphabets = list('abcdefghijklmnopqrstuvwxyz')

def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))
def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def power_set(L):

    cardinality=len(L)
    n=2 ** cardinality
    powerset = []

    for i in range(n):
        a=bin(i)[2:]
        subset=[]
        for j in range(len(a)):
            if a[-j-1]=='1':
                subset.append(L[j])
        powerset.append(subset)

    powerset_orderred=[]
    for k in range(cardinality+1):
        for w in powerset:
            if len(w)==k:
                powerset_orderred.append(w)

    return powerset_orderred
def fastPlrintNextLines(a):

    print('\n'.join(map(str,a)))

def sortByFirstAndSecond(A):
    A = sorted(A,key = lambda x:x[0])
    A = sorted(A,key = lambda x:x[1])
    return list(A)

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"")
else:
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
t = 1

for _ in range(t):
    n,k = li()
    if k<=n:
        print((k-1)//2)
    else:
        print(max((2*n-k+1)//2,0))
",O(1)
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n = inp()
s = []
for _ in range(4):
    tmp = [input() for i in range(n)]
    if _<3: input()
    s.append(tmp)
res = INF
for pt in itertools.combinations(range(4),2):
    cnt = 0
    for k in range(4):
        f = 1 if k in pt else 0
        for i in range(n):
            for j in range(n):
                if (i+j+f)%2 != int(s[k][i][j]): cnt += 1
    res = min(res, cnt)
print(res)",O(n ^ 2)
"class Solution(object):
    def orderlyQueue(self, S, K):
        if K == 1:
            return min(S[i:] + S[:i] for i in range(len(S)))
        return """".join(sorted(S))",O(n ^ 2)
"class Solution(object):
    def reformatNumber(self, number):
        number = list(number)
        src_len = 0
        for c in number: 
            if c.isdigit():
                number[src_len] = c
                src_len += 1
        dst_len = src_len + (src_len-1)//3
        if dst_len > len(number): 
            number.extend([0]*(dst_len-len(number)))
        while dst_len < len(number):
            number.pop()
        curr = dst_len-1
        for l, i in enumerate(reversed(range(src_len)), (3-src_len%3)%3):
            if l and l%3 == 0: 
                number[curr] = '-'
                curr -= 1
            number[curr] = number[i]
            curr -= 1
        if dst_len >= 3 and number[dst_len-2] == '-': 
            number[dst_len-3], number[dst_len-2] = number[dst_len-2], number[dst_len-3]            
        return """".join(number)",O(n)
"A,B=map(int,input().split())
x,y,z=map(int,input().split())
summ=0
y1=0
b1=0
y1=(x*2)+y

b1=y+(3*z)

summ=0
if y1>A:
	summ+=y1-A
if b1>B:
	summ+=b1-B
print(summ)",O(1)
"import math

no_of_moves , no_of_candy = map(int,input().split())

total_candy = now_candy = 1
now_moves = 1

if(no_of_moves == 0 or (no_of_moves ==1 and no_of_candy == 1)):
    print(0)
else:
    while True:

        now_candy = now_candy + 1
        total_candy += now_candy
        now_moves += 1
        if(total_candy -(no_of_moves - now_moves) == no_of_candy):
            break

    print(no_of_moves - now_moves)",O(logn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def isCousins(self, root, x, y):
        def dfs(root, x, depth, parent):
            if not root:
                return False
            if root.val == x:
                return True
            depth[0] += 1
            prev_parent, parent[0] = parent[0], root
            if dfs(root.left, x, depth, parent):
                return True
            parent[0] = root
            if dfs(root.right, x, depth, parent):
                return True
            parent[0] = prev_parent
            depth[0] -= 1
            return False
        
        depth_x, depth_y = [0], [0]
        parent_x, parent_y = [None], [None]
        return dfs(root, x, depth_x, parent_x) and \
               dfs(root, y, depth_y, parent_y) and \
               depth_x[0] == depth_y[0] and \
               parent_x[0] != parent_y[0]",O(n)
"import math

if __name__ == '__main__':

	n,q = [int(x) for x in raw_input().split()]
	qq = str(raw_input())
	s = [ int(x) for x in qq]
	prefix = [0]*n
	prefix[0]= s[0]
	temp = [0]*(n+1)
	temp[0]=1
	mod = (pow(10,9)//1)+7
	for i in range(1,n):
		prefix[i] += prefix[i-1] + s[i]
		temp[i] =( 2*(temp[i-1]%mod) )%mod

	temp[n] = (2*(temp[n-1]%mod))%mod
	ansarr=[]
	while q> 0:
		q-=1
		l,r = [int(x)-1 for x in raw_input().split()]
		a = prefix[r]-prefix[l]+s[l]
		d = r-l+1
		val1 = temp[d]
		val2 = temp[d-a]

		ansarr.append((val1-val2)%mod)
	print('\n'.join(map(str, ansarr)))",O(n)
"n,k = list(map(int,input().split()))
limit = 998244353

if k > 2*n:
    print(0)
elif k == 1 or k == 2*n:
    print(2)
else:
    same = [0] * (k+1)
    same[1] = 2

    diff = [0] * (k+1)
    diff[2] = 2

    for i in range(2, n+1):
        for j in range(min(k, 2*i), 1, -1):

            same[j] = same[j] + 2*diff[j] + same[j-1]
            same[j] %= limit

            diff[j] = diff[j] + 2*same[j-1] + diff[j-2]
            diff[j] %= limit

    print((same[k] + diff[k]) % limit)",np
"_=input()
n=input()
num=int(n)

list_n=list(n)
list_n_int=list(map(int,n))

lower=max(list_n_int)
total=sum(list_n_int)
upper=int(total/2)

flag=False
if lower == 0:
    print(""YES"")
else:
    for i in range(lower,upper+1):
        flag=True
        p=0
        temp=0
        each=i
        seg=total/each
        if seg.is_integer():
            while p < len(n):

                temp+=list_n_int[p]
                if temp < each:
                    p+=1
                elif temp == each:
                    temp=0
                    p+=1
                else:
                    flag=False
                    break
            if flag:
                print(""YES"")
                break
        else:
            flag=False
    if not flag:
        print(""NO"")
",O(n ^ 2)
"def valid(k, mid):
    return (2*k - mid - 1) * mid // 2 + 1

def binary_search(n, k):
    l, r = 0, k-1
    while (l <= r):
        mid = l+r >> 1
        if (valid(k, mid) < n):
            l = mid+1
        else:
            r = mid-1
    return l

def main():
    n, k = map(int, input().split())
    res = binary_search(n, k)
    print(-1 if res == k else res)

main()
",O(logn)
"import sys
input = sys.stdin.readline
Q = int(input())
D = {""R"":0, ""G"":1, ""B"":2}
for _ in range(Q):
    N, K = map(int, input().split())
    S = input()
    mi = K
    for i in range(3):
        d = 0
        for j in range(N):
            if D[S[j]] != (i+j) % 3:
                d += 1
            if j >= K and D[S[j-K]] != (i+j-K) % 3:
                d -= 1
            if j >= K-1:
                mi = min(mi, d)
    print(mi)
",O(n)
"n,s = map(int,input().split())
if s>=n:
    print('0')
else:
    for i in range(s,n+2):
        l=0
        for j in str(i):
            l+=int(j)
        if i-l>=s:
            break
    print(n-i+1)",O(logn)
"w,h,n=map(int,input().split())
l=[-1]*(w+1)
r=[-1]*(w+1)
t=[-1]*(h+1)
b=[-1]*(h+1)

l[0]=0
b[0]=0
t[h]=h
r[w]=w

V=[0]*(n)
H=[0]*(n)
for i in range(n):
    line,index=input().split()
    index=int(index)
    if line==""V"":
        r[index]=w
        V[i]=index
    else:
        t[index]=h
        H[i]=index

left=0
mxw=0
for i in range(1,w+1):
    if r[i]!=-1:
        l[i]=left
        r[left]=i
        mxw=max(mxw,i-left)
        left=i

bottom=0
mxh=0
for i in range(1,h+1):
    if t[i]!=-1:
        b[i]=bottom
        t[bottom]=i
        mxh=max(mxh,i-bottom)
        bottom=i

ans=[0]*(n)
ans[n-1]=mxh*mxw

for i in range(n-1,0,-1):
    if V[i]!=0:
        mxw=max(mxw,r[V[i]]-l[V[i]])
        r[l[V[i]]]=r[V[i]]
        l[r[V[i]]]=l[V[i]]

    else:
        mxh=max(mxh,t[H[i]]-b[H[i]])
        b[t[H[i]]]=b[H[i]]
        t[b[H[i]]]=t[H[i]]

    ans[i-1]=mxh*mxw

for i in range(n):
    print(ans[i])",O(nlogn)
"from sys import stdin
input=lambda : stdin.readline().strip()
lin=lambda :list(map(int,input().split()))
iin=lambda :int(input())
main=lambda :map(int,input().split())
from math import ceil,sqrt,factorial,log
from collections import deque
from bisect import bisect_left
def gcd(a,b):
	a,b=max(a,b),min(a,b)
	while a%b!=0:
		a,b=b,a%b
	return b
def solve():
	a,b,c=main()
	x,y,z=lin(),lin(),lin()
	x.sort(reverse=True)
	y.sort(reverse=True)
	z.sort(reverse=True)
	ans=0
	dp=[[[0 for i in range(c+2)] for i in range(b+2)] for i in range(a+1)]
	for i in range(a+1):
		for j in range(b+1):
			for k in range(c+1):
				if i<a and j<b:
					dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+x[i]*y[j])
				if i<a and k<c:
					dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+x[i]*z[k])
				if k<c and j<b:
					dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+z[k]*y[j])
				ans=max(ans,dp[i][j][k])
	print(ans)
qwe=1

for _ in range(qwe):
	solve()
",O(n ^ 3)
"def maxXORInRange(L, R):
    LXR = L ^ R

    msbPos = 0
    while (LXR):
        msbPos += 1
        LXR >>= 1

    maxXOR, two = 0, 1

    while (msbPos):
        maxXOR += two
        two <<= 1
        msbPos -= 1

    return maxXOR

L, R = map(int, input().split())
print(maxXORInRange(L, R))
",O(logn)
"def smallest(d):
    out = """"
    for j in range(0, 10):
        out += (""%d"" % j)*d[j]
    return out

def largest(d):
    out = """"
    for j in range(9, -1, -1):
        out += (""%d"" % j)*d[j]
    return out

sa = input()
sb = input()
b = int(sb)

h = int(sa)
digits_a = [0]*10
while h > 0:
    digits_a[h % 10] += 1
    h //= 10

out = """"
if len(sb) > len(sa):
    print(largest(digits_a))
    exit()

out = 0
for i in range(len(sa)-1, -1, -1):
    for j in range(9, -1, -1):
        if digits_a[j] == 0:
            continue

        if j < (b % (10 ** (i+1))) // (10 ** i):
            digits_a[j] -= 1
            if out > 0:
                print(""{}{}{}"".format(out, j, largest(digits_a)))
                exit()
            else:
                print(""{}{}"".format(j, largest(digits_a)))
                exit()

        if j == (b % (10 ** (i+1))) // (10 ** i):
            if i == 0:
                out = 10*out + j
                print(out)
                exit()
            digits_a[j] -= 1
            if int(smallest(digits_a)) <= b % (10 ** i):
                out = 10*out + j
                break
            else:
                digits_a[j] += 1

print(out)
",O(n ^ 3)
"def read4(buf):
    global file_content
    i = 0
    while i < len(file_content) and i < 4:
        buf[i] = file_content[i]
        i += 1

    if len(file_content) > 4:
        file_content = file_content[4:]
    else:
        file_content = """"
    return i

class Solution(object):
    def read(self, buf, n):
        read_bytes = 0
        buffer = [''] * 4
        for i in range((n+4-1)//4):
            size = min(read4(buffer), n-read_bytes)
            buf[read_bytes:read_bytes+size] = buffer[:size]
            read_bytes += size
        return read_bytes",O(n)
"class Solution(object):
    def minCut(self, s):
        lookup = [[False for j in range(len(s))] for i in range(len(s))]
        mincut = [len(s) - 1 - i for i in range(len(s) + 1)]

        for i in reversed(range(len(s))):
            for j in range(i, len(s)):
                if s[i] == s[j]  and (j - i < 2 or lookup[i + 1][j - 1]):
                    lookup[i][j] = True
                    mincut[i] = min(mincut[i], mincut[j + 1] + 1)

        return mincut[0]",O(n ^ 2)
"n = int(input())
d = {}
for i in range(n):
    a,b = map(int,input().split())
    d[a] = b
m = int(input())
for i in range(m):
    a,b = map(int,input().split())
    if d.get(a)==None:
        d[a] = b
    else:
        if b>d[a]:
            d[a] = b
ans = 0
for i in d:
    ans+=d[i]
print(ans)
",O(nlogn)
"class vec():
    def __init__(self, x, y=None):
        if y is None:
            x, y = x
        self.x = x
        self.y = y
    def __mod__(self, other):
        return self.x*other.y - self.y*other.x
    def __sub__(self, other):
        return vec(self.x - other.x, self.y - other.y)
    def __repr__(self):
        return 'vec({}, {})'.format(self.x, self.y)

def lines_cross(a, b, c, d):
    ab, ac, ad = b - a, c - a, d - a
    cd, ca, cb = d - c, a - c, b - c
    return (ab % ac) * (ab % ad) <= 0 and (cd % ca) * (cd % cb) <= 0

def rot(a):
    return vec(a.x-a.y, a.x+a.y)

ax, ay, bx, by, cx, cy, dx, dy = map(int, input().split())
kx, ky, lx, ly, mx, my, nx, ny = map(int, input().split())
c, b, d, a = map(vec, sorted([(ax, ay), (bx, by), (cx, cy), (dx, dy)]))
m, n, l, k = map(vec, sorted([(kx, ky), (lx, ly), (mx, my), (nx, ny)]))
res = False
s1 = [a, b, c, d]
s2 = [k, l, m, n]
for i in range(4):
    for j in range(4):
        if lines_cross(s1[i], s1[(i+1)%4], s2[j], s2[(j+1)%4]):
            res = True
            break
    if res:
        break
if all([b.x <= p.x <= a.x and c.y <= p.y <= b.y for p in [k, l, m ,n]]):
    res = True
if all([rot(l).x <= rot(p).x <= rot(k).x and rot(m).y <= rot(p).y <= rot(l).y for p in [a, b, c ,d]]):
    res = True
print('YES' if res else 'NO')",O(1)
"class Solution(object):
    def getMinDistance(self, nums, target, start):
        for i in range(len(nums)):
            if (start-i >= 0 and nums[start-i] == target) or \
               (start+i < len(nums) and nums[start+i] == target):
                break
        return i",O(n)
"n,k=map(int,input().split())
if(k%2==0):
    print(""YES"")
    print('.'*n)
    print('.'+'
    print('.'+'
    print('.'*n)
else:
    print(""YES"")
    print('.'*n)
    if(k<=n-2):
        print('.'*((n-k)//2)+'
        print('.'*n)
    else:
        print('.'+'
        print('.'+'
    print('.'*n)
",O(n)
"from queue import Queue
n = int(input())
g = [set() for i in range(n+1)]
for i in range(n-1):
    u, v = map(int, input().split())
    g[u].add(v)
    g[v].add(u)

a = list(map(int, input().split()))
if a[0] != 1:
    print(""No"")
    exit()
ptr = 0
i = 1

while i < n:
    par = a[ptr]
    while len(g[par]) != 0:
        if a[i] not in g[par]:
            print(""No"")
            exit()
        else:
            g[par].remove(a[i])
            g[a[i]].remove(par)
        i += 1
    ptr += 1
print(""Yes"")
",O(n ^ 2)
"import sys
from array import array
from typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

def main():
    n, m = map(int, input().split())
    mat = [array('i', map(int, input().split())) for _ in range(n)]
    bit = [1 << i for i in range(m)]
    fullbit = (1 << m) - 1

    def solve(x: int) -> Tuple[int, int]:
        dp = {sum(bit[j] for j, y in enumerate(mat[i]) if y >= x): i for i in range(n)}
        keys = tuple(dp.keys())

        for i in range(len(keys)):
            for j in range(i, len(keys)):
                if keys[i] | keys[j] == fullbit:
                    return dp[keys[i]], dp[keys[j]]

        return -1, -1

    ok, ng = 0, 10**9 + 1
    ans_i, ans_j = 1, 1

    while abs(ok - ng) > 1:
        mid = (ok + ng) >> 1
        x, y = solve(mid)
        if x == -1:
            ng = mid
        else:
            ok = mid
            ans_i, ans_j = x + 1, y + 1

    print(ans_i, ans_j)

if __name__ == '__main__':
    main()
",np
"from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__

class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):

    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):

    self.out.append(str(text))

  def writeLine(self, text):

    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

def bootstrap(f, stack=[]):

  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc

class MDArray(object):

  def __init__(self, dimensions, initial_value=0):

    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):

    return self.arr[self._index(indexes)]

  def set(self, indexes, value):

    self.arr[self._index(indexes)] = value
    return value

def encode(row, col, n, m):
  return row * m + col

def solve(node, remain, adj, dp):
  if remain == 0:
    return 0
  key = (node, remain)
  mem = dp.get(key)
  if mem != -1:
    return mem

  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))
  dp.set(key, ans)
  return ans

def main(inp, out):

  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = [-1] * (n*m*(k/2+1))

  for i in range(n*m):
    dp[i] = 0

  for t in range(1, k/2+1):
    for i in range(n*m):
      ans = min(map(lambda x: dp[x[0]+((t-1)*n*m)] + x[1], adj[i]))
      dp[i+(t*n*m)] = ans

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(dp[node+(k/2*n*m)] * 2)
    out.writeLine(' '.join(map(str, ans)))

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",O(n ^ 3)
"class Solution(object):
    def percentageLetter(self, s, letter):
        return 100*s.count(letter)//len(s)",O(n)
"class Solution(object):
    def numberOfWays(self, n, m, k, source, dest):
        MOD = 10**9+7
        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b % MOD for a, b in zip(row, col)) % MOD for col in ZB] for row in A]
 
        def matrix_expo(A, K):
            result = [[int(i == j) for j in range(len(A))] for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        T = [[0, m-1, n-1,           0],
             [1, m-2,   0,         n-1],
             [1,   0, n-2,         m-1],
             [0,   1,   1, (n-2)+(m-2)]]
        dp = [0]*4 
        if source == dest:
            dp[0] = 1
        elif source[0] == dest[0]:
            dp[1] = 1
        elif source[1] == dest[1]:
            dp[2] = 1
        else:
            dp[3] = 1
        dp = matrix_mult([dp], matrix_expo(T, k))[0] 
        return dp[0]",O(logn)
"class Solution(object):
    def isPalindrome(self, s):
        i, j = 0, len(s) - 1
        while i < j:
            while i < j and not s[i].isalnum():
                i += 1
            while i < j and not s[j].isalnum():
                j -= 1
            if s[i].lower() != s[j].lower():
                return False
            i, j = i + 1, j - 1
        return True",O(n)
"n, x = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]
s = set(a)
mv = 999
if len(s) < n:
    print(0)
else:
    for i in a:
        if i & x != i and i & x in s:
            print(1)
            break
    else:
        k = [i & x for i in a]
        if len(set(k)) < n:
            print(2)
        else:
            print(-1)
",O(n)
"import math,io,os,sys

n,s=map(int,input().split())
c=0
i=n
for i in range(s,min(s+1000,n+1)):
    if i-sum(map(int,str(i)))>=s:
        c+=1
c+=max(0,n-i)
print(c)
",O(logn)
"t = int(input())

def get_max(n):
    ans = 0
    while n:
        ans = 4 * ans + 1
        n = n - 1
        if ans > 10**19:
            break
    return ans

for _ in range(t):
    n, k = map(int, input().split())
    if n == 1:
        if k == 1:
            print(""YES 0"")
        else:
            print(""NO"")
    elif n == 2:
        if k <= 2:
            print(""YES 1"")
        elif k != 3 and k <= 5:
            print(""YES 0"")
        else:
            print(""NO"")
    else:
        siz = n - 1
        l = 1
        cnt = 3
        while siz:
            if l <= k < l+cnt:
                print(""YES {}"".format(siz))
                break
            l = l + cnt
            cnt = 2 * cnt + 1
            siz = siz - 1
        else:
            if k <= get_max(n):
                print(""YES 0"")
            else:
                print(""NO"")
",O(n)
"import abc 
from abc import ABCMeta, abstractmethod 


class Node(metaclass=ABCMeta):
    @abstractmethod
    def evaluate(self):
        pass


import operator


class Solution(Node):
    ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}
    
    def __init__(self, val):
        self.val = val
        self.left = None 
        self.right = None
    
    def evaluate(self):
        result = [0]
        stk = [(1, (self, result))]
        while stk:
            step, args = stk.pop()
            if step == 1:
                node, ret = args
                if node.val.isdigit():
                    ret[0] = int(node.val)
                    continue
                ret1, ret2 = [0], [0]
                stk.append((2, (node, ret1, ret2, ret)))
                stk.append((1, (node.right, ret2)))
                stk.append((1, (node.left, ret1)))
            elif step == 2:
                node, ret1, ret2, ret = args
                ret[0] = Solution.ops[node.val](ret1[0], ret2[0])
        return result[0]


class TreeBuilder(object):
    def buildTree(self, postfix):
        stk = []
        for c in postfix:
            if c.isdigit():
                stk.append(Solution(c))
            else:
                node = Solution(c)
                node.right = stk.pop()
                node.left = stk.pop()
                stk.append(node)                
        return stk.pop()",O(n)
"class Solution(object):
    def isDecomposable(self, s):
        if len(s)%3 != 2:
            return False
        for left in range(0, len(s), 3):
            if any(s[i] != s[i-1] for i in range(left+1, min(left+3, len(s)))):
                break            
        for right in reversed(range(left+1, len(s), 3)):
            if any(s[i] != s[i+1] for i in reversed(range(max(right-2, left), right))):
                break
        return right-left == 1",O(n)
"class Solution2(object):
    def subarrayGCD(self, nums, k):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        result = 0
        for i in range(len(nums)):
            g = 0
            for j in range(i, len(nums)):
                if nums[j]%k:
                    break
                g = gcd(g, nums[j])
                result += int(g == k)
        return result",O(n ^ 2)
"from operator import xor

r = list(map(int, input().split()))

ms = xor(r[0], r[1])

max = 0
sum = 1

while ms > 0:
    ms >>= 1
    max += sum
    sum <<= 1

print(max)
",O(logn)
"import sys
input = sys.stdin.readline

test=int(input())
for tests in range(test):
    S=input().strip()
    t=input().strip()

    LENS=len(S)
    LENT=len(t)
    flag=0

    for i in range(1,LENT+1):
        t1=t[:i]
        t2=t[i:]

        DP=[-1]*(len(t1)+1)
        DP[0]=0

        for s in S:
            for j in range(len(t1),-1,-1):
                if 0<=DP[j]<len(t2) and s==t2[DP[j]]:
                    DP[j]+=1

                if s==t1[j-1]:
                    DP[j]=max(DP[j],DP[j-1])

        if DP[-1]==len(t2):
            print(""YES"")
            flag=1
            break
    else:
        print(""NO"")
",O(n ^ 3)
"import math
for _ in range(1):
    n,k=map(int,input().split())
    l=list(map(int,input().split()))
    ans=0
    for i in range(n):
	    c=0
	    sum1=0
	    for j in range(i, n):
		    sum1 += l[j]
		    c+=1
		    if c >= k:
			    ans=max(ans,sum1/c)
print(ans)
",O(n ^ 2)
"class Solution(object):
    def countSmaller(self, nums):
        def countAndMergeSort(num_idxs, start, end, counts):
            if end - start <= 0: 
                return

            mid = start + (end - start) // 2
            countAndMergeSort(num_idxs, start, mid, counts)
            countAndMergeSort(num_idxs, mid + 1, end, counts)
            r = mid + 1
            tmp = []
            for i in range(start, mid + 1):
                while r <= end and num_idxs[r][0] < num_idxs[i][0]:
                    tmp.append(num_idxs[r])
                    r += 1
                tmp.append(num_idxs[i])
                counts[num_idxs[i][1]] += r - (mid + 1)

            num_idxs[start:start+len(tmp)] = tmp

        num_idxs = []
        counts = [0] * len(nums)
        for i, num in enumerate(nums):
            num_idxs.append((num, i))
        countAndMergeSort(num_idxs, 0, len(num_idxs) - 1, counts)
        return counts",O(nlogn)
"a=list(map(int,input().split()))
t=a[0]
d=a[1]
arr=list(map(int,input().split()))
count=0
for i in range(t-1):
    if(arr[i+1]-arr[i]==2*d):
        count+=1
    elif(arr[i+1]-arr[i]>2*d):
        count+=2
print(count+2)",O(n)
"import sys
input = lambda: sys.stdin.readline().strip()
from math import ceil

def mismatch(s1, s2):
    cnt = 0
    for i in range(len(s1)):
        if s1[i]!=s2[i]: cnt+=1
    return cnt

T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    check = ''
    for i in range(ceil((k+2)/3)):
        check+='RGB'
    ls = []
    for i in range(3):
        ls.append(check[i:i+k])
    s = input()
    m = n
    for i in range(n-k+1):
        for j in ls:
            m = min(m, mismatch(s[i:i+k], j))
    print(m)
",O(n ^ 2)
"class Solution(object):
    def transformArray(self, arr):
        def is_changable(arr):
            return any(arr[i-1] > arr[i] < arr[i+1] or 
                       arr[i-1] < arr[i] > arr[i+1]
                       for i in range(1, len(arr)-1))
        
        while is_changable(arr):
            new_arr = arr[:]
            for i in range(1, len(arr)-1):
                new_arr[i] += arr[i-1] > arr[i] < arr[i+1]
                new_arr[i] -= arr[i-1] < arr[i] > arr[i+1]
            arr = new_arr
        return arr",O(n ^ 2)
"n, m, v = map(lambda x: int(x) + 1, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))
dp = []
for i in range(n):
    dp.append([])
    for j in range(m):
        dp[i].append([0] * v)
a.sort(reverse=1)
b.sort(reverse=1)
c.sort(reverse=1)
a = [0] + a
b = [0] + b
c = [0] + c
ans = 0
for i in range(n):
    for j in range(m):
        for k in range(v):
            if i == j == k == 0:
                continue
            if i == j == 0 or i == k == 0 or j == k == 0:
                continue
            if i == 0:
                dp[i][j][k] = dp[i][j - 1][k - 1] + \
                              b[j] * c[k]
            elif j == 0:
                dp[i][j][k] = dp[i - 1][j][k - 1] + \
                              a[i] * c[k]
            elif k == 0:
                dp[i][j][k] = dp[i - 1][j - 1][k] + \
                              a[i] * b[j]
            else:
                dp[i][j][k] = max(dp[i - 1][j - 1][k] + a[i] * b[j],
                                  dp[i - 1][j][k - 1] + a[i] * c[k],
                                  dp[i][j - 1][k - 1] + b[j] * c[k])
            ans = max(ans, dp[i][j][k])
print(ans)
",O(n ^ 3)
"class Solution(object):
    def waysToMakeFair(self, nums):
        prefix = [0]*2
        suffix = [sum(nums[i] for i in range(k, len(nums), 2)) for k in range(2)]
        result = 0
        for i, num in enumerate(nums):
            suffix[i%2] -= num
            result += int(prefix[0]+suffix[1] == prefix[1]+suffix[0])
            prefix[i%2] += num
        return result",O(n)
"n = int(input())
a = [int(x) for x in input().split()]

a_reverse = a.copy()
status = []
for i in range(n):
    a_reverse[a[i]-1] = i
    status.append(None)

pos = a_reverse[n-1]
status[pos] = False
fails = set()
fails.add(pos)
for i in range(n-1,0,-1):
    i_ = i-1
    pos = a_reverse[i_]
    for k in range((pos+1)%i-1,n,i):
        if k == pos:
            continue
        if k in fails:
            status[pos] = True
            break
    if not status[pos]:
        status[pos] = False
        fails.add(pos)

for i in status:
    if i == True:
        result=result+""A""
    else:
        result=result+""B""

print(result)
",O(n ^ 2)
"import sys
import math

def main():
    i = sys.stdin.readlines()

    n = int(i[0].strip())
    points = []
    for pi in range(n):
        p = i[pi + 1]
        x, y = p.strip().split()
        points.append([int(x), int(y)])

    if n < 5:
        print('YES')
        return

    st = [False] * n

    def run(first, second):
        dx = first[0] - second[0]
        dy = first[1] - second[1]

        for i, p in enumerate(points):
            if st[i]:
                continue
            if dx == 0:
                if p[0] == first[0]:
                    st[i] = True
            elif dy == 0:
                if p[1] == first[1]:
                    st[i] = True
            else:

                if ((p[0] - first[0]) * dy) == (p[1] - first[1]) * dx:
                    st[i] = True

    def check(fi, si):
        for i in range(n):
            st[i] = i == fi or i == si

        run(points[fi], points[si])

        fi = None
        si = None
        for i in range(n-1):
            if not st[i]:
                fi = i
                for j in range(i+1, n):
                    if not st[j]:
                        si = j
                        break
                break
        if fi is None or si is None:
            return True

        st[fi] = True
        st[si] = True
        run(points[fi], points[si])
        return not (False in st)

    if check(0, 1) or check(0, 2) or check(1, 2):
        print('YES')
    else:
        print('NO')

main()",O(nlogn)
"class Solution(object):
    def clearDigits(self, s):
        s = list(s)
        j = 0
        for i, x in enumerate(s):
            if x.isdigit():
                j -= 1
                continue
            s[j] = x
            j += 1
        while len(s) > j:
            s.pop()
        return """".join(s)",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def getDirections(self, root, startValue, destValue):
        def iter_dfs(root, val):
            path = []
            stk = [(1, (root,))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node = args[0]
                    if node.val == val:
                        path.reverse()
                        return path
                    for i, child in enumerate((node.left, node.right)):
                        if not child:
                            continue
                        stk.append((3, None))
                        stk.append((1, (child,)))
                        stk.append((2, (""LR""[i],)))
                elif step == 2:
                    path.append(args[0])
                elif step == 3:
                    path.pop()
            return []
    
        src = iter_dfs(root, startValue)
        dst = iter_dfs(root, destValue)
        while len(src) and len(dst) and src[-1] == dst[-1]:
            src.pop()
            dst.pop()
        dst.reverse()
        return """".join(['U']*len(src) + dst)",O(n)
"class Solution(object):
    def numberOfRounds(self, startTime, finishTime):
        h1, m1 = list(map(int, startTime.split("":"")))
        h2, m2 = list(map(int, finishTime.split("":"")))
        start = h1*60+m1
        finish = h2*60+m2
        if start > finish:
            finish += 1440
        return max(finish//15-(start+15-1)//15, 0)",O(1)
"import math as mt
import sys
input=sys.stdin.readline
I=lambda:list(map(int,input().split()))
n,m=I()
a=[I() for i in range(n)]
ans=[]
lo=0
hi=10**9
def vanguda(mid: int) -> bool:
    global ans
    f={}
    for i in range(n):
        bi=0
        for j in range(m):
            if a[i][j]>=mid:
                bi+=1
            bi<<=1
        f[bi>>1]=i
    for aa,bb in f.items():
        for cc,dd in f.items():
            if aa|cc==(2**m-1):
                ans =bb+1,dd+1
                return True
    return False

while lo<=hi:
	mid=(lo+hi)//2
	if vanguda(mid):
		lo=mid+1
	else:
		hi=mid-1
print(*ans)
",np
"
import collections


class Solution(object):
    def groupThePeople(self, groupSizes):
        groups, result = collections.defaultdict(list), []
        for i, size in enumerate(groupSizes):
            groups[size].append(i)
            if len(groups[size]) == size:
                result.append(groups.pop(size))
        return result
",O(n)
"from math import gcd
def t_prime(n):
    if n == 1:        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:            return False
    return True
primes = [i for i in range(2,10**5) if t_prime(i)];pset = set(primes);n, k = map(int, input().split());l = list(map(int, input().split()))
if k == 1: print(0);exit()
for i in range(n):
    for j in range(i):
        u, v = l[i], l[j];poss = gcd(u,v);poss2 = max(u,v)//poss;smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:primes.append(smol);pset.add(smol)
powers = set();count = 0;outLs = [];pgood = []
for p in primes:
    curr = [];    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:            v2 //= p
        if v2 == 1:   curr.append(v);   powers.add(v)
    if len(curr) > 1: count += len(curr);     outLs.append(curr);  pgood.append(p)
order = [(len(lis), lis) for lis in outLs];order.sort(key = lambda x: x[0])
if len(order) == 0:    print(0); exit()
if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1;    need = -1;    last = []
    for v in l:
        if v in powers:            continue
        v2 = v;        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):  extra = v;     last = primesn;    need = len(last);   assert need >= 2
    if need == -1 or 2 * need + 1 > k:  print(0);   exit()
    other = [];    out = [extra]
    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:   works = True;           break
        if works:       out.append(a);   out.append(b)
        else:       other.append(a);      other.append(b)
    assert len(out) == 2 * need + 1;    assert (k - 2 * need - 1) % 2 == 0; ret = out + other[:(k - 2*need - 1)];    assert len(ret) == k; print(' '.join(map(str,ret)));    exit()
out = [];need = k
for i in range(len(order)):
    assert need != 1

    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0

assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:        break
    if v in powers:        continue
    v2 = v
    for p in pgood:
        while v2 % p == 0:            v2 //= p
    if v2 == 1:        out.append(v);        need -= 1

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)",np
"def go():
    n = int(input())
    for i in range(n):
        a, b, d = [int(i) for i in input().split(' ')]
        if a > d or b > d:
            print(-1)
        elif a % 2 == b % 2:
            if a % 2 == d % 2:
                print(d)
            else:
                print(d - 2)
        else:
            if a % 2 == b % 2:
                if d % 2 == a % 2:
                    print(d)
                else:
                    print(d - 2)
            else:
                print(d - 1)
go()
",O(1)
"from sys import stdin

def read_lines(sep=' ', input_type=None):

    _lines = stdin.readlines()
    cast = input_type is not None
    lines = []
    for line in _lines:
        line = line[:-1].split(sep)
        if cast:
            line = [input_type(x) for x in line]
        lines.append(line)
    return lines

import math

if __name__ == '__main__':

    lines = read_lines(input_type=int)

    n,m = lines[0][0], lines[1][0]

    if n <= math.log2(m):
        print(m % (2**n))
    else:
        print(m)
",O(1)
"n, l, r, x = map(int, input().split())
c = list(map(int, input().split()))

from itertools import combinations
ways_to_choose = 0
for length in range(2, n + 1):
    for p in combinations(c, length):
        problemset = sorted(p)
        if l <= sum(problemset) <= r and problemset[-1] - problemset[0] >= x:
            ways_to_choose += 1

print(ways_to_choose)
",np
"import sys

def main():

    n,k=map(int,sys.stdin.readline().strip().split())
    arr=list(map(int,sys.stdin.readline().strip().split()))
    arr.sort(reverse=True)
    dic={}
    for a in arr:
        if a*k not in dic:
            dic[a]=1

    print(len(dic))

main()",O(nlogn)
"l,r=map(int,input().split())
x=l^r
a=2
if(l==r):
    print(0)
else:
    while(a<=x):
        a=a*2

    print(a-1)",O(logn)
"import collections



class Solution(object):
    def findMatrix(self, nums):
        result = []
        cnt = collections.Counter()
        for x in nums:
            if cnt[x] == len(result):
                result.append([])
            result[cnt[x]].append(x)
            cnt[x] += 1
        return result",O(n)
"s=input()
o=len(s)
k=0
for i in range(o):
    r={0}
    for j in range(o-i+1):
        if s[j:j+i] in r:k=max(i,k)
        else:r.add(s[j:j+i])
print(k)",O(n ^ 3)
"class Solution(object):
    def fillCups(self, amount):
        return max(max(amount), (sum(amount)+1)//2)",O(1)
"import collections



class Solution(object):
    def maximumRobots(self, chargeTimes, runningCosts, budget):
        result = left = curr = 0
        dq = collections.deque()
        for right in range(len(chargeTimes)):
            while dq and chargeTimes[dq[-1]] <= chargeTimes[right]:
                dq.pop()
            dq.append(right)
            curr += runningCosts[right]
            if chargeTimes[dq[0]]+(right-left+1)*curr > budget:
                if dq[0] == left:
                    dq.popleft()
                curr -= runningCosts[left]
                left += 1
        return right-left+1",O(n)
"def find(x):
    if root==x:
        u=root
    else:
        i=0
        s=2**i
        while x%s==0:
            i+=1
            s=2**i
        s=s//2
        y=i+1
        if (x-s)%(2**y)!=0:
            u=x-s
        else:
            u=x+s
    return u
n,q=list(map(int,input().split()))
root=(n+1)//2
for j in range(q):
    n1=int(input())
    str1=input()
    for j in range(len(str1)):
        up=find(n1)
        if str1[j]=='U':
            n1=(up)
        elif n1%2==0:
            if str1[j]=='L':
                if n1!=root:
                    n1=(n1-abs((up-n1)//2))
                else:
                    n1=(n1-n1//2)
            elif str1[j]=='R':
                if n1!=root:
                    n1=(n1+abs((up-n1)//2))
                elif n1%2==0:
                    n1=n1+n1//2
    print(n1)",np
"import sys
import math

n, k = list(map(int, sys.stdin.readline().strip().split()))
a = (2 * n + 3 - math.sqrt((2*n+3)**2 - 4 * (n**2 + n - 2 * k))) // 2
print(int(a))",O(1)
"def check(x, y):
    return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y])

n = int(input())
a = [list(input()) for i in range(n)]
b = [list(input()) for i in range(n)]
for i in range(4):
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = b[::-1]
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = [s[::-1] for s in b]
    c = [['' for t in range(n)] for u in range(n)]
    for t in range(n):
        for u in range(n):
            c[t][u] = b[u][n - t - 1]
    b = c[:]
    if check(a, b):
        print('Yes')
        exit(0)
print('No')",O(n ^ 2)
"a = [int(i) for i in list(input())]
b = [int(i) for i in list(input())]

if (len(a)<len(b)):
	a.sort(reverse=True)
	ans = 0
	for i in range(len(a)):
		ans = ans*10+a[i]
	print(ans)
else:

	ans = 0
	n = len(a)
	count = [0]*10
	for i in range(n):
		count[a[i]] += 1
	i = 0
	while (i<n):
		x = b[i]
		if (count[x]>0):
			ans = ans*10+x
			count[x] -= 1
			i += 1
		else:
			break
	if (i==n):
		print(ans)
		exit(0)
	x = b[i]
	flag = False
	for j in range(x-1,-1,-1):
		if (count[j]>0):
			ans = ans*10+j
			count[j] -= 1
			flag = True
			break
	if (flag) :
		for j in range(9,-1,-1):
			while (count[j]>0):
				ans = ans*10+j
				count[j] -= 1
	else:
		while (not flag):
			t = ans%10
			ans = ans//10
			count[t] += 1
			for i in range(t-1,-1,-1):
				if (count[i]>0):
					count[i] -= 1
					flag = True
					ans = ans*10 + i
					break
		for j in range(9,-1,-1):
			while (count[j]>0):
				ans = ans*10+j
				count[j] -= 1
	print(ans)
",O(n ^ 3)
"from collections import deque as de
import math
import re
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping
from itertools import groupby as gb
from fractions import Fraction as fr
from bisect import bisect_left as bl, bisect_right as br

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))

class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()

def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def binarytodecimal(n):
    return int(n,2)

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))
    return prime_factors

def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def getProduct(n):

    product = 1

    while (n != 0):
        product = product * (n % 10)
        n = n // 10

    return product

def dupconscount(nums):
    element = []
    freque = []
    if not nums:
        return element
    running_count = 1
    for i in range(len(nums)-1):
        if nums[i] == nums[i+1]:
            running_count += 1
        else:
            freque.append(running_count)
            element.append(nums[i])
            running_count = 1
    freque.append(running_count)
    element.append(nums[i+1])
    return element,freque

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

def ceildiv(x,y):
    return (x+y-1)//y

def di():return map(int, input().split())
def ii():return int(input())
def li():return list(map(int, input().split()))
def si():return list(map(str, input()))
def indic():
    dic = {}
    for index, value in enumerate(input().split()):
        dic[int(index)+1] = int(value)
    return dic

n,p=di()
a=li()
fir=a[0]
sec=sum(a)-fir
ans=(fir%p)+(sec%p)
for i in range(1,n):
    fir+=a[i]
    sec-=a[i]
    temp=(fir%p)+(sec%p)
    if temp >ans:
        ans=temp
print(ans)
",O(n)
"import sys

def input():
	return sys.stdin.readline().rstrip()

def input_split():
	return [int(i) for i in input().split()]

x, y, z  = input_split()
arr_x = input_split()
arr_y = input_split()
arr_z = input_split()

x += 1
y += 1
z += 1

lengths = [x,y, z]
arrs = [arr_x, arr_y, arr_z ]

for a in arrs:
	a.sort()

dp = [[[0 for k in range(z)] for j in range(y)] for i in range(x)]

for i in range(1,x):
	for j in range(1,y):

		dp[i][j][0] = dp[i-1][j-1][0] + arr_x[i-1]*arr_y[j-1]

for j in range(1, y):
	for k in range(1, z):

		dp[0][j][k] = dp[0][j-1][k-1] + arr_y[j-1]*arr_z[k-1]

for i in range(1,x):
	for k in range(1,z):

		dp[i][0][k] = dp[i-1][0][k-1] + arr_x[i-1]*arr_z[k-1]

for i in range(1, x):
	for j in range(1, y):
		for k in range(1, z):
			opt1 = dp[i-1][j-1][k] + arr_x[i-1]*arr_y[j-1]
			opt2 = dp[i][j-1][k-1] + arr_y[j-1]*arr_z[k-1]
			opt3 = dp[i-1][j][k-1] + arr_x[i-1]*arr_z[k-1]

			dp[i][j][k] = max(opt1, opt2, opt3)

ans = dp[x-1][y-1][z-1]

print(ans)
",O(n ^ 3)
"n,m=map(int,raw_input().split())
arr=[]
arr1=[]
for i in range(n):
	arr2=str(raw_input())
	arr.append(arr2)
	x1=[0]*m
	arr1.append(x1)
for i in range(n):
	for j in range(m):
		if(arr[i][j]=='
			if(arr[i][j+1]=='
				arr1[i][j]=1
				arr1[i+1][j]=1
				arr1[i+2][j]=1
				arr1[i+2][j+1]=1
				arr1[i+2][j+2]=1
				arr1[i+1][j+2]=1
				arr1[i][j+1]=1
				arr1[i][j+2]=1
flag=0

for i in range(n):
	for j in range(m):
		if(arr[i][j]==""
			flag=1
			break
	if(flag==1):
		break
if(flag==1):
	print(""NO"")
else:
	print(""YES"")",O(n ^ 2)
"class Solution(object):
    def merge(self, A, m, B, n):
        last, i, j = m + n - 1, m - 1, n - 1

        while i >= 0 and j >= 0:
            if A[i] > B[j]:
                A[last] = A[i]
                last, i = last - 1, i - 1
            else:
                A[last] = B[j]
                last, j = last - 1, j - 1

        while j >= 0:
                A[last] = B[j]
                last, j = last - 1, j - 1",O(n)
"class Solution_Recu(object):
    def minTime(self, n, edges, hasApple):
        def dfs(graph, par, node, hasApple):
            result, extra = 0, int(hasApple[node])
            for nei in graph[node]:
                if nei == par:
                    continue
                count, found = dfs(graph, node, nei, hasApple)
                result += count+found
                extra |= bool(count+found)
            return result, extra
        
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        return 2*dfs(graph, -1, 0, hasApple)[0]",O(n)
"import collections


class Solution(object):
    def waysToPartition(self, nums, k):
        total = sum(nums)
        right = collections.Counter()
        prefix = 0
        for i in range(len(nums)-1):
            prefix += nums[i]
            right[prefix-(total-prefix)] += 1
        result = right[0]
        left = collections.Counter()
        prefix = 0
        for x in nums:
            result = max(result, left[k-x]+right[-(k-x)])
            prefix += x
            left[prefix-(total-prefix)] += 1
            right[prefix-(total-prefix)] -= 1
        return result",O(n)
"class Solution(object):
    def countQuadruplets(self, nums):
        result = 0
        lookup = collections.defaultdict(int)
        lookup[nums[-1]] = 1
        for c in reversed(range(2, len(nums)-1)):
            for b in range(1, c):
                for a in range(b):
                    if nums[a]+nums[b]+nums[c] in lookup:
                        result += lookup[nums[a]+nums[b]+nums[c]]
            lookup[nums[c]] += 1
        return result


import collections",O(n ^ 3)
"import math
n,k=map(int,input().split())
n-=1
k-=1
if n>(k*(k+1))//2:
    print(-1)
else:
    l=-1
    r=k+1
    while r>l+1:
        m=(l+r)//2
        if n>(m*(2*k-m+1))//2:
            l=m
        else:
            r=m
    print(r)
",O(logn)
"n, s = map(int, input().split())
mult_10 = s if not (s%10) else s+10-(s%10)
for i in range(mult_10, mult_10+100000, 10):
	if i - sum([int(c) for c in str(i)]) >= s:
		low = i
		break
print(max(n-low+1, 0))
",O(logn)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from bisect import bisect_left as bsl
def main():
    cur=9;count=1;tot=0
    num=[];cc=[]
    for s in range(11):
        num.append(cur*count)
        tot+=cur
        cc.append(tot)
        cur*=10;count+=1
    ans=[num[0]]
    for s in range(1,11):
        ans.append(ans[-1]+num[s])
    k=int(input())
    ind=min(bsl(ans,k),10)
    left=k
    if ind>0:
        left-=ans[ind-1]

    nums=left//(ind+1);rem=left%(ind+1)
    if left%(ind+1)!=0:
        nums+=1
    if ind>0:
        nums+=cc[ind-1]
    answer=[int(k) for k in str(nums)]
    print(answer[rem-1])
main()",O(logn)
"n = int(input())
a = list(map(int, input().split()))
mx = -1
ans = -1
for i in range(n):
    if a[i] > mx+1:
        ans = i+1
        break
    else:
        mx = max(mx, a[i])
print(ans)",O(n)
"import re
import sys
exit=sys.exit
from bisect import bisect_left as bsl,bisect_right as bsr
from collections import Counter,defaultdict as ddict,deque
from functools import lru_cache
cache=lru_cache(None)
from heapq import *
from itertools import *
from math import inf
from pprint import pprint as pp
enum=enumerate
ri=lambda:int(rln())
ris=lambda:list(map(int,rfs()))
rln=sys.stdin.readline
rl=lambda:rln().rstrip('\n')
rfs=lambda:rln().split()
cat=''.join
catn='\n'.join
mod=1000000007
d4=[(0,-1),(1,0),(0,1),(-1,0)]
d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]

s=rl()
n=len(s)
ans=0
for i in range(n-1):
  for j in range(i+1,n):
    for k in range(n-j):
      if s[i+k]!=s[j+k]:
        break
      ans=max(ans,1+k)

print(ans)
",O(n ^ 3)
"class Solution(object):
    def uniqueXorTriplets(self, nums):
        def fst(a, inverse):
            n = len(a)
            step = 1
            while step < n:
                for i in range(0, n, step<<1):
                    for j in range(i, i+step):
                        u, v = a[j], a[j+step]
                        a[j], a[j+step] = u+v, u-v
                step <<= 1
            if inverse:
                for i in range(n):
                    a[i] //= n
        
        a = [0]*(1<<max(nums).bit_length())
        for x in nums:
            a[x] += 1
        fst(a, False)
        for i in range(len(a)):
            a[i] = a[i]**3
        fst(a, True)
        return sum(x != 0 for x in a)",O(nlogn)
"def almost_difference():
    n = int(input())
    if n == 1:
        return 0

    dict_equal = dict()
    array = [int(el) for el in input().split()]
    ad_sum = 0
    prev_sum = 0
    for i in range(n):
        if not array[i] in dict_equal.keys():
            dict_equal[array[i]] = 0
        if not array[i]-1 in dict_equal.keys():
            dict_equal[array[i]-1] = 0
        if not array[i]+1 in dict_equal.keys():
            dict_equal[array[i]+1] = 0

        ad_sum = ad_sum + i * array[i] - prev_sum +dict_equal[array[i]+1] - dict_equal[array[i]-1]
        dict_equal[array[i]] += 1
        prev_sum += array[i]

    return ad_sum

print(almost_difference())
",O(nlogn)
"n,k = map(int, input().split())
P = list(map(int, input().split()))
C = list(map(int, input().split()))
Q = []
for i, p in enumerate(P):
    Q.append((p, i))
Q.sort()
q = []
import heapq
heapq.heapify([])
s = 0
ans = [0]*n
if k > 0:
    for p, i in Q:
        ans[i] = s+C[i]
        if len(q) == k:
            if q[0] <= C[i]:
                v = heapq.heappop(q)
                heapq.heappush(q, C[i])
                s -= v
                s += C[i]
        else:
            heapq.heappush(q, C[i])
            s += C[i]
    print(*ans)
else:
    for p, i in Q:
        ans[i] = C[i]
    print(*ans)
",O(nlogn)
"n,k=map(int,input().split())

ans=k//n
if(k%n):
    ans+=1
print(ans)",O(1)
"class Solution2(object):
    def maximumOddBinaryNumber(self, s):
        n = s.count('1')
        return """".join(['1']*(n-1)+['0']*(len(s)-n)+['1'])",O(n)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

T, = getIntList()

def isin( x,y, M):
    if M[0] <= x <= M[2] and M[1] <= y <= M[3]:
        return True
    return False

for _ in range(T):
    N, M = getIntList()
    m1 = getIntList()
    m2 = getIntList()
    zx = [0, M]
    zx += [m1[0]-1, m1[2]]
    zx += [m2[0]-1, m2[2]]
    zx.sort()
    zy = [0, N]
    zy += [m1[1]-1, m1[3]]
    zy += [m2[1]-1, m2[3]]
    zy.sort()
    totB = 0
    for i0 in range(5):
        if zx[i0] == zx[i0+1]: continue
        for i1 in range(5):
            if zy[i1] == zy[i1+1]: continue

            x0 = zx[i0]+1
            y0 = zy[i1]+1
            dprint('x0,y0', x0,y0)
            size = (zx[i0+1] - zx[i0] ) *( zy[i1+1] - zy[i1])
            if isin(x0,y0, m2):
                dprint('black')
                totB += size
            elif isin(x0,y0, m1):
                dprint('white')
                pass
            else:
                totB+= size//2
                if size%2==1:
                    if (x0+y0)%2==1:
                        dprint('extra black')
                        totB+=1
    print(N*M - totB, totB)
",O(1)
"class Solution(object):
    def deleteString(self, s):
        if all(x == s[0] for x in s):
            return len(s)
        dp2 = [[0]*(len(s)+1) for i in range(2)] 
        dp = [1]*len(s) 
        for i in reversed(range(len(s)-1)):
            for j in range(i+1, len(s)):
                dp2[i%2][j] = dp2[(i+1)%2][j+1]+1 if s[j] == s[i] else 0
                if dp2[i%2][j] >= j-i:
                    dp[i] = max(dp[i], dp[j]+1)
        return dp[0]",O(n ^ 2)
"MOD = 10**9 + 7
x, k = map(int, input().split())
y = (2*x - 1) % MOD
mult = pow(2, k, MOD)
if x:
    print((y * mult + 1) % MOD)
else:
    print(0)",O(logn)
"n = int(input())

l = []
for _ in range(n):
    k,m = map(int, input().strip().split())
    l.append((k,m))

l.sort(key=lambda x:x[0]+x[1])

last = 0
ans = 1

for i in range(1,n):
   if l[i][0] - l[i][1] >= l[last][0] - l[last][1] and abs(l[i][0] - l[last][0]) >= l[i][1] + l[last][1] :
       last = i
       ans = ans + 1

print(ans)",O(nlogn)
"class Solution2(object):
    def kthLuckyNumber(self, k):
        return bin(k+1)[3:].replace('1', '7').replace('0', '4')",O(logn)
"def comp(arr):
    for i in range(len(arr)-1):
        for j in range(0, len(arr)-i-1):
            if(arr[j] in arr[j+1]):
                arr[j], arr[j+1] = arr[j+1], arr[j]

    return arr[::-1]

t = int(input())
ans = 1
arr = []
for j in range(t):
    arr.append(input())

arr = comp(arr);

for j in range(0,t-1):
    if arr[j] not in arr[j+1]:
        ans = 0
        break;

if(ans == 0):
    print(""NO"")

else:
    print(""YES"")
    for j in arr:
        print(j)
",O(nlogn)
"from sys import stdin
input=stdin.readline
from collections import defaultdict
def f(q):
    q.sort()
    d=defaultdict(int)
    for l,r in q:
        d[l]+=1
        d[r+1]-=1
    res=0
    prev=None
    ans=[0]*(len(q)+1)
    for i in sorted(d.keys()):

        if prev==None:

            prev=i
        else:
            ans[res]+=i-prev
            prev=i
        res+=d[i]

    return ans[1:]

n=int(input())
q=[]
for i in range(n):
    x,y=map(int,input().strip().split())
    q.append((x,y))
print(*f(q))",O(nlogn)
"n,l,r,x=map(int,input().split())
a=list(map(int,input().split()))
count=0
t=0
ans=[]
for i in range(3,(2**n)+1):
    c=i
    ans=[]
    sum=0
    while c!=0:
        c=c&(c-1)
        count+=1
    if count>1:
        for j in range(n):
            if i & (1 << j):
                sum+=a[j]
                ans.append(a[j])
        if l<=sum<=r and (max(ans)-min(ans))>=x:
            t+=1
print(t)
",np
"x = int(input())
list1 = []
for i in range(x):
    value = input()
    list1.append(value)

for i in range(x):
    value = input()
    if value in list1:
        list1.remove(value)

print(len(list1))
",O(n)
"class Solution2(object):
    def frogPosition(self, n, edges, t, target):
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)

        stk = [(t, 1, 0, 1)]
        while stk:
            t, node, parent, choices = stk.pop()
            if not t or not (len(G[node])-(parent != 0)):
                if node == target:
                    return 1.0/choices
                continue
            for child in G[node]:
                if child == parent:
                    continue
                stk.append((t-1, child, node,
                            choices*(len(G[node])-(parent != 0))))
        return 0.0",O(n)
"from sys import stdin, stdout
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))
for _ in range(1):
    n, cur, l, r=lst()
    if l==1 and r==n:
        print(0)
    elif l==1 and r!=n:
        print(abs(r-cur)+1)
    elif r==n and l!=1:
        print(abs(cur-l)+1)
    else:
        disa=abs(l-cur)
        disb=abs(r-cur)
        ans=min(disa, disb) + (r-l) +2
        print(ans)
",O(1)
"class Solution2(object):
    def summaryRanges(self, nums):
        return [re.sub('->.*>', '->', '->'.join(repr(n) for _, n in g))
            for _, g in itertools.groupby(enumerate(nums), lambda i_n: i_n[1]-i_n[0])]",O(n)
"n,m=map(int, input().split())
for i in range(n):
    mt=input()
    if mt.count('B')!=0:
        print(mt.count('B')//2+i+1,mt.count('B')//2+mt.index('B')+1)
        break",O(n ^ 2)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def deleteMiddle(self, head):
        dummy = ListNode()
        dummy.next = head
        slow = fast = dummy
        while fast.__next__ and fast.next.__next__:
            slow, fast = slow.__next__, fast.next.__next__
        slow.next = slow.next.__next__
        return dummy.__next__",O(n)
"n = int(input())
x, y = map(int, input().split())
na = abs(x - 1) + abs(y - 1)
nb = abs(n - x) + abs(n - y)
if na <= nb:
    print(""white"")
else:
    print(""black"")
",O(1)
"import sys

input=sys.stdin.readline

for _ in range(int(input())):
    n,m,k=map(int,input().split())
    n=abs(n)
    m=abs(m)
    if max(n,m)>k:
        print(""-1"")
    else:

        bad1=((n+k)%2==1)
        bad2=((m+k)%2==1)
        print(k-bad1-bad2)
",O(1)
"n=int(input())
m=str(n)
print(max(int(m),int(m[:-2]+m[-1:]),int(m[:-1])))
",O(1)
"from collections import defaultdict, deque, Counter
from sys import stdin, stdout
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

def mapin():
    return map(int, input().split())

s = list(input())
n = len(s)
l = [1]
for i in range(n-1):
    if(s[i]!= s[i+1]):
        l[-1]+=1
    else:
        l.append(1)

ans = max(l)
if(len(l)>1):
    if(s[0]!= s[-1]):
        ans = max(ans, l[0]+l[-1])

print(ans)
",O(n)
"class Solution(object):
    def minSubarray(self, nums, p):
        residue = sum(nums) % p
        if not residue:
            return 0
        result = len(nums)
        curr, lookup = 0, {0: -1}
        for i, num in enumerate(nums):
            curr = (curr+num) % p
            lookup[curr] = i
            if (curr-residue) % p in lookup:
                result = min(result, i-lookup[(curr-residue)%p])
        return result if result < len(nums) else -1",O(n)
"class Solution(object):
    def separateSquares(self, squares):
        events = []
        for x, y, l in squares:
            events.append((y, 1, l))
            events.append((y+l, -1, l))
        events.sort(key=lambda e: e[0])
        total = curr = 0.0
        prev = events[0][0]
        for y, v, l in events:
            if y != prev:
                total += (y-prev)*curr
                prev = y
            curr += l*v
        expect = total/2.0
        total = curr = 0.0
        prev = events[0][0]
        for y, v, l in events:
            if y != prev:
                if total+(y-prev)*curr >= expect:
                    break
                total += (y-prev)*curr
                prev = y
            curr += l*v
        return prev+(expect-total)/curr",O(nlogn)
"class Solution(object):
    def longestSquareStreak(self, nums):
        sorted_nums = sorted(set(nums))
        squares = {x for x in sorted_nums if x%2 < 2} 
        result = 0
        for x in sorted_nums:
            square, cnt = x**2, 1
            while square in squares:
                squares.remove(square)
                cnt += 1
                square *= square
            result = max(result, cnt)
        return result if result != 1 else -1",O(nlogn)
"import math
a,b=map(int,input().split())
c=[]
e=[]
f=0
for i in range(a):
    d=str(input())
    for j in range(b):
        if d[j]==""B"":
            c=c+[i]
            e=e+[j]
p=min(c)
p1=min(e)
p2=max(c)
plus=(max(c)-min(c))//2
p3=p+plus+1
p4=p1+plus+1
print(p3,p4)
",O(n ^ 2)
"n=int(input())
a=list(map(int,input().split()))
b=[]
maxi=0
for i in range(n):
    maxi=max(maxi,a[i]+1)
    b.append(maxi)
c=[]
count=b[-1]
for i in range(n-1,-1,-1):
    if count-1>=b[i]:
        count-=1
        c.append(count)
    else:
        c.append(count)
c=c[::-1]
ans=0
for i in range(n):
    ans+=(c[i]-a[i]-1)
print(ans)",O(n)
"import bisect
from itertools import accumulate
import os
import sys
import math
from decimal import *
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")
def isPrime(n) :
    if (n <= 1) : return False
    if (n <= 3) : return True
    if (n % 2 == 0 or n % 3 == 0) : return False
    i = 5
    while(i * i <= n) :
        if (n % i == 0 or n % (i + 2) == 0) :
            return False
        i = i + 6
    return True
def SieveOfEratosthenes(n):
    prime=[]
    primes = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):

        if (primes[p] == True):
            prime.append(p)
            for i in range(p * p, n+1, p):
                primes[i] = False
        p += 1
    return prime
def factors(n):
    fac=[]
    while(n%2==0):
        fac.append(2)
        n=n//2
    for i in range(3,int(math.sqrt(n))+2):
        while(n%i==0):
            fac.append(i)
            n=n//i
    if n>1:
        fac.append(n)
    return fac

a = input()
b = a.count('1')
a = a.replace('1','')
c = a.find('2')
if c==-1:
    a = (a+ '1'*b)
else:
    a = a[:c]+ '1'*b + a[c:]
print(a)
",O(n)
"from sys import stdin

def solve(x: int) -> bool:
    global ans
    dp = {}
    for i in range(n):
        temp = 0
        for j in range(m):
            if a[i][j] >= x:
                temp = temp | (1 << j)
        dp[temp] = i
    for aa, bb in dp.items():
        for cc, dd in dp.items():
            if aa | cc == 2 ** m - 1:
                ans = (bb + 1, dd + 1)
                return True
    return False

ans = (-1, -1)
n, m = map(int, stdin.readline().split())
a = []
for i in range(n):
    a.append(list(map(int, stdin.readline().split())))
l, r = 0, 10 ** 9
while l <= r:
    mid = (l + r) // 2
    if solve(mid):
        l = mid + 1
    else:
        r = mid - 1
print(*ans)
",np
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def getAllElements(self, root1, root2):
        def inorder_gen(root):
            result, stack = [], [(root, False)]
            while stack:
                root, is_visited = stack.pop()
                if root is None:
                    continue
                if is_visited:
                    yield root.val
                else:
                    stack.append((root.right, False))
                    stack.append((root, True))
                    stack.append((root.left, False))
            yield None
        
        result = []
        left_gen, right_gen = inorder_gen(root1), inorder_gen(root2)
        left, right = next(left_gen), next(right_gen)
        while left is not None or right is not None:
            if right is None or (left is not None and left < right):
                result.append(left)
                left = next(left_gen)
            else:
                result.append(right)
                right = next(right_gen)
        return result",O(n)
"from sys import stdin,stdout
from math import gcd,sqrt,factorial,pi,inf
from collections import deque,defaultdict
from bisect import bisect,bisect_left
from time import time
from itertools import permutations as per
from heapq import heapify,heappush,heappop,heappushpop
input=stdin.readline
R=lambda:map(int,input().split())
I=lambda:int(input())
S=lambda:input().rstrip('\r\n')
L=lambda:list(R())
P=lambda x:stdout.write(str(x)+'\n')
lcm=lambda x,y:(x*y)//gcd(x,y)
nCr=lambda x,y:(f[x]*inv((f[y]*f[x-y])%N))%N
inv=lambda x:pow(x,N-2,N)
sm=lambda x:(x**2+x)//2
N=10**9+7

n,k=R()
s=0
for i in range(k):
	x,d=R()
	s+=n*x
	if d<0:
		s+=sm(n//2)*d+sm(n//2-(n+1)%2)*d
	else:
		s+=sm(n-1)*d
print(s/n)",O(n)
"n, p = map(int, input().split())
a = list(map(int, input().split()))
t = 0
k = 0
for i in range(n):
    k += a[i]
s = 0
for i in range(0, n-1):
    s += a[i]
    t = max(t, s%p + (k - s)%p)
print(t)
",O(n)
"class Solution2(object):
    def divisorGame(self, n):
        def factors(n):
            result = [[] for _ in range(n+1)]
            for i in range(1, n+1):
                for j in range(i, n+1, i):
                    result[j].append(i)
            return result

        FACTORS = factors(n)
        dp = [False]*(n+1)
        for i in range(2, n+1):
            dp[i] = any(not dp[i-j] for j in FACTORS[i] if j != i)
        return dp[-1]",O(n ^ 2)
"import collections


class Solution(object):
    def subtreeWithAllDeepest(self, root):
        Result = collections.namedtuple(""Result"", (""node"", ""depth""))

        def dfs(node):
            if not node:
                return Result(None, 0)
            left, right = dfs(node.left), dfs(node.right)
            if left.depth > right.depth:
                return Result(left.node, left.depth+1)
            if left.depth < right.depth:
                return Result(right.node, right.depth+1)
            return Result(node, left.depth+1)

        return dfs(root).node",O(n)
"import os
import sys
from io import BytesIO ,IOBase
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def main():
    pass

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def lts(l):
    s = ''.join(map(str, l))
    return s

def stl(s):

    l = list(s)

    return l

def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans

def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1

    return (cnt)

def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)

mod = int(1e9) + 7
def ssinp(): return input()

def iinp(): return int(input())

def nninp(): return map(int ,input().split())

def llinp(): return list(map(int ,input().split()))

def p(xyz): print(xyz)
def p2(a ,b): print(a ,b)
import math

from collections import OrderedDict

import operator

n,m=nninp()
if(n>m):
    print(0)
    exit()
a=llinp()
d={}
for c in a:
    if(c in d):
        d[c]+=1
    else:
        d[c]=1
dict1=dict(sorted(d.items(),key=operator.itemgetter(1)))
ans=0
for i in range(1,105):
    temp=dict1.copy()
    n1=n
    for c in temp:
        n1=n1-(temp[c]//i)
    if(n1>0):
        print(i-1)
        exit()
",O(nlogn)
"import sys
import bisect

ls2int = lambda ls: int(''.join(map(str,ls)))
def candidates(digs, num):
    if not digs:
        return [[]]

    res = []
    i = bisect.bisect_left(digs, num[0])

    if num[0] in digs:
        for suffix in candidates(digs[:i]+digs[i+1:], num[1:]):
            res.append([digs[i]] + suffix)

    if i > 0:
        i -= 1
        res.append([digs[i]] + list(reversed(digs[:i]+digs[i+1:])))

    return res

def solution(a, b):
    digits = [int(x) for x in sorted(a)]
    ceiling = [int(x) for x in b]

    assert(len(digits) <= len(ceiling), 'solution does not exist')
    if len(digits) < len(ceiling):
        return ls2int(digits[::-1])
    return max(ls2int(ls) for ls in candidates(digits, ceiling))

a = sys.stdin.readline().strip()
b = sys.stdin.readline().strip()
print(solution(a, b))",O(n ^ 3)
"n = int(input())
data = [int(i) for i in input().split()]
data.sort()
ans = [0]*n
col = 0
for i in range(n):
    if ans[i] == 0:
        col += 1
        ans[i] = 1
        d = data[i]
        for j in range(i+1, n):
            if data[j] % d == 0:
                ans[j] = 1
print(col)
",O(n ^ 2)
"import sys

n, m, k = list(map(int, sys.stdin.readline().strip().split()))
a = list(map(int, sys.stdin.readline().strip().split()))
b = [0] * (n+1)
for i in range (1, n+1):
    b[i] = b[i-1] + m * a[i-1] - k
M = [10 ** 20] * m
ans = 0
for i in range (0, n+1):
    M[i % m] = min([M[i % m], b[i]])
    for j in range (0, m):
        if i > j:
            ans = max([ans, b[i]-M[j]-k*((m*i+m-(i-j))%m)])

print(ans // m)
",O(n ^ 2)
"n,x = list(map(int, input().split()))
a = set(map(int, input().split()))

if len(a) < n :
    print(0)
else :
    d = set()
    p = 0
    for i in a :
        d.add(i&x)
        if i&x != i and i&x in a :
            print(1)
            p = 1
            break
    if len(d) < n and p == 0 :
        print(2)
    elif p != 1 :
        print(-1)
",O(n)
"class Solution(object):

    def __init__(self, width, height):
        self.__w = width
        self.__h = height
        self.__curr = 0

    def move(self, num):
        self.__curr += num

    def getPos(self):
        n = self.__curr % (2*((self.__w-1)+(self.__h-1)))
        if n < self.__w:
            return [n, 0]
        n -= self.__w-1
        if n < self.__h:
            return [self.__w-1, n]
        n -= self.__h-1
        if n < self.__w:
            return [(self.__w-1)-n, self.__h-1]
        n -= self.__w-1
        return [0, (self.__h-1)-n]

    def getDir(self):
        n = self.__curr % (2*((self.__w-1)+(self.__h-1)))
        if n < self.__w:
            return ""South"" if n == 0 and self.__curr else ""East""
        n -= self.__w-1
        if n < self.__h:
            return ""North""
        n -= self.__h-1
        if n < self.__w:
            return ""West""
        n -= self.__w-1
        return ""South""",O(1)
"class Solution2(object):
    def upsideDownBinaryTree(self, root):
        return self.upsideDownBinaryTreeRecu(root, None)

    def upsideDownBinaryTreeRecu(self, p, parent):
        if p is None:
            return parent

        root = self.upsideDownBinaryTreeRecu(p.left, p)
        if parent:
            p.left = parent.right
        else:
            p.left = None
        p.right = parent

        return root",O(n)
"a,b,c = map(int,input().split())
arr = list(map(int,input().split()))

arr.sort()
p = 0
a-=1
while(a>=0 and c<b):
    c-=1
    p+=1
    c+=arr[a]
    a-=1
if(c<b):
    print(-1)
else:
    print(p)",O(nlogn)
"class Solution(object):
    def mostProfitablePath(self, edges, bob, amount):
        def iter_dfs():
            lookup = [[float(""-inf""), float(""inf"")] for _ in range(len(adj))]
            stk = [(1, (0, -1, 0))]
            while stk:
                step, (u, p, ah) = stk.pop()
                if step == 1:
                    stk.append((2, (u, p, ah)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        stk.append((1, (v, u, ah+1)))
                elif step == 2:
                    if len(adj[u])+(u == 0) == 1:
                        lookup[u][0] = 0
                    if u == bob:
                        lookup[u][1] = 0
                    for v in adj[u]:
                        if v == p:
                            continue
                        lookup[u][0] = max(lookup[u][0], lookup[v][0])
                        lookup[u][1] = min(lookup[u][1], lookup[v][1])
                    if ah == lookup[u][1]:
                        lookup[u][0] += amount[u]//2
                    elif ah < lookup[u][1]:
                        lookup[u][0] += amount[u]
                    lookup[u][1] += 1
            return lookup[0][0]

        adj = [[] for _ in range(len(edges)+1)]
        lookup = [False]*len(adj)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()",O(n)
"class Solution(object):
    def maxRepOpt1(self, text):
        K = 1
        result = 0
        total_count, count = collections.Counter(), collections.Counter()
        left, max_count = 0, 0
        for i in range(len(text)):
            total_count[text[i]] += 1
            count[text[i]] += 1
            max_count = max(max_count, count[text[i]])
            if i-left+1 - max_count > K:
                count[text[left]] -= 1
                left += 1
            result = max(result, min(i-left+1, total_count[text[i]]))
        return result


import itertools",O(n)
"import os.path
from math import gcd, floor, ceil
from collections import *
import sys
mod = 1000000007
INF = float('inf')
def st(): return list(sys.stdin.readline().strip())
def li(): return list(map(int, sys.stdin.readline().split()))
def mp(): return map(int, sys.stdin.readline().split())
def inp(): return int(sys.stdin.readline())
def pr(n): return sys.stdout.write(str(n)+""\n"")
def prl(n): return sys.stdout.write(str(n)+"" "")

if os.path.exists('input.txt'):
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]

def solve():
    n, m = mp()
    k = inp()
    l = li()
    q = deque()
    v = [[0]*(m+1) for i in range(n+1)]
    for i in range(0, 2*k - 1, 2):
        q.append((l[i], l[i+1]))
        v[l[i]][l[i+1]] = 1
    while q:
        a, b = q.popleft()
        for i in range(4):
            A, B = a+dx[i], b+dy[i]
            if A > 0 and A <= n and B > 0 and B <= m:
                if not v[A][B]:
                    q.append((A, B))
                    v[A][B] = 1
    print(a, b)

for _ in range(1):
    solve()
",O(n ^ 3)
"class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        res = len(nums)

        for i in range(len(nums)):
            res += i - nums[i]
        return res
",O(n)
"class Solution2(object):
    def maxProduct(self, s):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P

        import operator
        def accumulate(iterable, func=operator.add, initial=None):
            it = iter(iterable)
            total = initial
            if initial is None:
                try:
                    total = next(it)
                except StopIteration:
                    return
            yield total
            for element in it:
                total = func(total, element)
                yield total

        def fin_max_len(s):
            P = manacher(s)
            intervals = [[(i-2)//2-P[i]//2, (i-2)//2+P[i]//2] for i in range(2,len(P)-2, 2)]
            dp = [0]*len(s)
            for l, r in reversed(intervals): 
                dp[r] = r-l+1
            for i in reversed(range(len(s)-1)):
                dp[i] = max(dp[i], dp[i+1]-2)
            return list(accumulate(dp, max, 0))
        
        l1, l2 = fin_max_len(s), fin_max_len(s[::-1])[::-1]
        return max(x*y for x, y in zip(l1, l2))",O(n)
"from bisect import bisect_right
n, x, y = map(int, input().split(' '))
s=[0]*n
e=[0]*n
v=[0]*n
c=0
for i in range(n):
    s[i],e[i]=map(int, input().split(' '))
    c+=x+(e[i]-s[i])*y
s.sort()
e.sort()
for i in range(n-2,-1,-1):
    k=bisect_right(s,e[i])
    while (k < n)  and (v[k]==1) and (s[k]-e[i]) * y < x :
        k+=1
    if k==n:
        continue
    if (s[k]-e[i]) * y < x :
        v[k] = 1
        c+=(s[k]-e[i])*y-x

print(c%(10**9+7))",O(nlogn)
"from collections import defaultdict
from sys import stdin

all_in = stdin.read().splitlines()

n = int(all_in[0])
s = all_in[1:]

one = defaultdict(lambda: 0)
two = defaultdict(lambda: 0)

for el in s:
    I = 0
    min_ = 0

    for char in el:
        I += {'(': 1, ')': -1}[char]
        min_ = min(min_, I)

    if I >= 0 and min_ == 0:
        one[I] += 1

    if I <= 0 and min_ == I:
        two[I] += 1

ans = 0
for el in one.keys():
    ans += one[el] * two[-el]

print(ans)
",O(n)
"from __future__ import division
from sys import stdin, stdout

def write(x):
    stdout.write(str(x) + ""\n"")

n = int(stdin.readline())
a = map(int, stdin.readline().split())
assert n == len(a)
cap = [0] + a[:]

ones = []
others = []

for i in range(n):
    if a[i] == 1:
        ones.append(i + 1)
    else:
        others.append(i + 1)

if len(others) == 0:
    if len(ones) == 1:
        write(""YES 0"")
        write(""0"")
    else:
        write(""NO"")
    exit()

dia = len(others)
graph = []

for j in range(len(others) - 1):
    graph.append((others[j], others[j + 1]))
    cap[others[j]] -= 1
    cap[others[j + 1]] -= 1

if len(ones) > 0:
    this = ones.pop()
    graph.append((this, others[0]))
    cap[others[0]] -= 1
    dia += 1

if len(ones) > 0:
    this = ones.pop()
    graph.append((this, others[-1]))
    cap[others[-1]] -= 1
    dia += 1

done = False
for j in range(len(others)):
    while cap[others[j]] > 0:
        if len(ones) > 0:
            this = ones.pop()
            graph.append((this, others[j]))
            cap[others[j]] -= 1
        else:
            done = True
            break

    if done:
        break
if len(ones) > 0:
    write(""NO"")
else:
    write(""YES "" + str(dia - 1))
    write(len(graph))
    for a,b in graph:
        write(str(a) + "" "" + str(b))",O(n)
"def user99():
    text = 'RGB' * 2222
    for _ in range(int(input())):
        n, k = map(int, input().split())
        s = input()
        ans = 2222
        for i in range(3):
            p = text[i: k + i]

            for j in range(n - k + 1):
                diff = 0

                for l in range(j, j + k):
                    if s[l] != p[l - j]:
                        diff += 1
                ans = min(ans, diff)
        print(ans)

user99()
",O(n ^ 2)
"for _ in range(int(input())):
    s = input()
    t = input()
    if len(t) == 1:
        print(""YES"" if t in s else ""NO"")
        continue
    nxt = [[-1] * 26 for _ in range(len(s) + 1)]
    nxt[-2][ord(s[-1]) - ord('a')] = len(s) - 1
    for i in range(len(s) - 2, -1, -1):
        for c in range(26):
            nxt[i][c] = nxt[i + 1][c]
        nxt[i][ord(s[i]) - ord('a')] = i
    ans = ""NO""
    for p in range(1, len(t)):
        a = t[:p]
        b = t[p:]
        dp = [[-1] * (len(b) + 1) for _ in range(len(a) + 1)]
        dp[0][0] = 0
        for la in range(len(a) + 1):
            for lb in range(len(b) + 1):
                if dp[la][lb] != -1:
                    if la < len(a):
                        if dp[la + 1][lb] != -1:
                            if nxt[dp[la][lb]][ord(a[la]) - ord('a')] != -1:
                                if nxt[dp[la][lb]][ord(a[la]) - ord('a')] < dp[la + 1][lb] - 1:
                                    dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')]
                                    dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb])
                        else:
                            dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')]
                            dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb])
                    if lb < len(b):
                        if dp[la][lb + 1] != -1:
                            if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] != -1:
                                if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] < dp[la][lb + 1] - 1:
                                    dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')]
                                    dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1])
                        else:
                            dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')]
                            dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1])
                if dp[len(a)][len(b)] != -1:
                    ans = ""YES""
                    break
    print(ans)
",O(n ^ 3)
"n, k = map( int, input().split() )

d = n - k
d = d // 2

l = []

while n > 0:
    i = min(n,d)
    while i>0:
        l.append('1')
        i -= 1
        n -= 1
    if n > 0:
        l.append('0')
        n -= 1

print( """".join( l ) )",O(n ^ 2)
"st=input()
m=0
n=len(st)
for i in range(n):
    for j in range(i,n+1) :
        if st[i:j] in st[i+1:n] and len(st[i:j])>m:
            m=len(st[i:j])
print(m)",O(n ^ 3)
"from itertools import combinations
from sys import stdin
input = stdin.readline
intin = lambda: map(int, input().split())

n, l, r, x = intin()
*a, = intin()
print(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))",np
"class Solution2(object):
    def integerBreak(self, n):
        if n < 4:
            return n - 1

        res = [0, 1, 2, 3]
        for i in range(4, n + 1):
            res[i % 4] = max(res[(i - 2) % 4] * 2, res[(i - 3) % 4] * 3)
        return res[n % 4]",O(n)
"class Solution2(object):
    def possibleStringCount(self, word):
        result = 1
        curr = 0
        for i in range(len(word)):
            curr += 1
            if i+1 == len(word) or word[i+1] != word[i]:
                result += curr-1
                curr = 0
        return result",O(n)
"class Solution(object):
    def strangePrinter(self, s):
        def dp(s, i, j, lookup):
            if i > j:
                return 0
            if (i, j) not in lookup:
                lookup[(i, j)]  = dp(s, i, j-1, lookup) + 1
                for k in range(i, j):
                    if s[k] == s[j]:
                        lookup[(i, j)] = min(lookup[(i, j)], \
                                             dp(s, i, k, lookup) + dp(s, k+1, j-1, lookup))
            return lookup[(i, j)]

        lookup = {}
        return dp(s, 0, len(s)-1, lookup)",O(n ^ 3)
"n=int(input())
a,b=map(int,input().split())
b1,b2=map(int,input().split())
c1,c2=map(int,input().split())
b1-=a
b2-=b
c1-=a
c2-=b
if b1==0 or b2==0 or c1==0 or c2==0:print('NO')
else:
    if b1*c1<0 or b2*c2<=0:print('NO')
    else:print('YES')",O(1)
"n, k = list(map(int, input().split()))
a = list(map(int, input().split()))

a = sorted(a)

cur_v = a[0]
cur_count = 1
ans = 0

for i in range(1, len(a)):

    if a[i] > a[i-1] and a[i] > a[i-1]+k:
        ans += cur_count
        cur_count = 1
    elif a[i] == a[i-1]:
        cur_count += 1
    elif a[i] > a[i-1]:
        cur_count = 1

ans += cur_count

print(ans)",O(nlogn)
"n = int(input())
A = [int(i) for i in input().split()]
A = list(set(A))
A.sort()
if len(A)>1:
    print(A[1])
else:
    print(""NO"")
",O(nlogn)
"from math import factorial

send = input()
receive = input()

cntP = send.count(""+"")
cntN = send.count(""-"")

cnt1 = receive.count(""+"")
cnt2 = receive.count(""-"")

mark = receive.count(""?"")

total = pow(2, mark)

if cntP < cnt1 or cntN < cnt2:
    valid = 0
else:
    valid = factorial(mark) / factorial(mark - cntP + cnt1) / factorial(cntP - cnt1)
print(f""{valid / total:0.12f}"")
",np
"class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        nums.sort()
        i = 0
        while i < len(nums) - 1:
            if nums[i] == nums[i + 1]:
                i += 2
            else:
                return nums[i]
        return nums[i]
",O(nlogn)
"n,v = [int(x) for x in input().strip().split("" "")]
if v>=(n-1):
	print(n-1)
else:
	print(n-1+((n-1-v)*(n-v)//2))
",O(1)
"n = int(input())
m = int(n**.5)
a = []

for i in range(0, n, m):
    for j in range(i, min(i+m, n)):
        a.append(min(i+m, n)-j + i)

print(' '.join(str(_) for _ in a))",O(n)
"import sys
input=sys.stdin.buffer.readline

nr,ng,nb=[int(x) for x in input().split()]
r=[int(x) for x in input().split()]
g=[int(x) for x in input().split()]
b=[int(x) for x in input().split()]

r.sort()
g.sort()
b.sort()

memo=[[[-1 for _ in range(nb+1)] for __ in range(ng+1)] for ___ in range(nr+1)]
memo[0][0][0]=0
for i in range(nr):
    memo[i+1][0][0]=0
for j in range(ng):
    memo[0][j+1][0]=0
for k in range(nb):
    memo[0][0][k+1]=0
def dp(i,j,k):
    if i<-1 or j<-1 or k<-1:
        return -float('inf')
    if memo[i+1][j+1][k+1]==-1:
        memo[i+1][j+1][k+1]=max(dp(i,j-1,k-1)+g[j]*b[k],
                   dp(i-1,j-1,k)+r[i]*g[j],
                   dp(i-1,j,k-1)+r[i]*b[k]
                )
    return memo[i+1][j+1][k+1]

for i in range(max(nr,ng,nb)):
    dp(min(i,nr-1),min(i,ng-1),min(i,nb-1))

print(dp(nr-1,ng-1,nb-1))",O(n ^ 3)
"n=int(raw_input())

ans=[]
p=1
fin=n
while len(ans)<n-1:
	for i in range(fin-(n/(2**p))):
		ans.append(2**(p-1))
		fin-=1
	p+=1

if 2**(p-2) + 2**(p-1) <=n:
	ans.append(2**(p-1) + 2**(p-2))
else:
	ans.append(2**(p-1))

s="" "".join(str(x) for x in ans)

print(s)
",O(nlogn)
"n, l, r, x = map(int, input().split())
tasks = [int(i) for i in input().split()]
cnt = 0
for num in range(2 ** n):
    bin_num = bin(num)[2:]
    if len(bin_num) < n:
        bin_num = '0' * (n - len(bin_num)) + bin_num
    m = []
    for i in range(n):
        if bin_num[i] == '1':
            m.append(tasks[i])
    if sum(m) >= l and sum(m) <= r and max(m) - min(m) >= x:
        cnt += 1
print(cnt)",np
"n,a,b = map(int,input().split())
c = []
c = list(map(int,input().split()))
c.sort()
l = c[b-1]
r = 0
ok = False
for i in range (b,n-a+1):
  if c[i] > l:
    ok = True
    r = c[i]
    break
if ok == True: print(r-l)
else: print(0)",O(nlogn)
"import sys
from array import array
from typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

def main():
    n, m = map(int, input().split())
    mat = [array('i', map(int, input().split())) for _ in range(n)]
    bit = [1 << i for i in range(m)]
    max_bit = 1 << m
    fullbit = max_bit - 1

    def solve(x: int) -> Tuple[int, int]:
        dp = array('i', [-1]) * max_bit
        for i in range(n):
            dp[sum(bit[j] for j, y in enumerate(mat[i]) if y >= x)] = i

        for i in range(max_bit):
            if dp[i] == -1:
                continue
            for j in range(i, max_bit):
                if dp[j] != -1 and i | j == fullbit:
                    return dp[i], dp[j]

        return -1, -1

    ok, ng = 0, 10**9 + 1
    ans_i, ans_j = 1, 1

    while abs(ok - ng) > 1:
        mid = (ok + ng) >> 1
        x, y = solve(mid)
        if x == -1:
            ng = mid
        else:
            ok = mid
            ans_i, ans_j = x + 1, y + 1

    print(ans_i, ans_j)

if __name__ == '__main__':
    main()
",np
"n,m,k=list(map(int,input().split()))
p=[]
for _ in range(n):
    p.append(list(map(int,input().split())))
q=[]
for _ in range(n-1):
    q.append(list(map(int,input().split())))
def f(g):
    r=[[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            l=[]
            if i-1>=0:
                l.append(g[i-1][j]+q[i-1][j])
            if i+1<n:

                l.append(g[i+1][j]+q[i][j])
            if j-1>=0:
                l.append(g[i][j-1]+p[i][j-1])
            if j+1<m:
                l.append(g[i][j+1]+p[i][j])
            r[i][j]=min(l)
    return r
g=[[0]*m for _ in range(n)]
if k%2!=0:
    for i in range(n):
        for j in range(m):
            g[i][j]=-1
        print(*g[i])
else:
    for _ in range(k//2):
       g=f(g)
    for i in range(n):
        for j in range(m):
            g[i][j]*=2
        print(*g[i])
",O(n ^ 3)
"n = int(input())
u = list(map(int, input().split()))
u.sort()
ans = 0
k = 1
ok = False
for i in range(1, n):
    if u[i] == u[i - 1]:
        k += 1
        if k == 3:
            print('cslnb')
            exit()
        if k == 2:
            if ok or u[i] == 0 or u[i] - u[i - 2] == 1:
                print('cslnb')
                exit()
            ok = True
    else:
        k = 1
for i in range(n):
    ans += u[i] - i
if ans % 2 == 0:
    print('cslnb')
else:
    print('sjfnb')
",O(nlogn)
"l,r=map(int,input().split())
if(l==r):
    print(0)
else:
    if(r&(r-1)==0):
        print(r^(r-1))
    else:
        x=l^r
        p=1
        while(p<=x):
            p*=2
        print(p-1)",O(logn)
"k, n, s, p = map(int, input().split())
L = (n - 1) // s + 1
L *= k
print((L - 1) // p + 1)",O(1)
"class Solution2(object):
    def subsequenceSumOr(self, nums):
        result = cnt = 0
        for i in range(64):
            cnt >>= 1
            for x in nums:
                cnt += (x>>i)&1
            if cnt:
                result |= 1<<i
        return result",O(nlogn)
"class Solution(object):
    def minimumMoves(self, grid):
        level, q, lookup = 0, [(0, 0, False)], set()
        while q:
            next_q = []
            for r, c, is_vertical in q:
                if (r, c, is_vertical) in lookup:
                    continue
                if (r, c, is_vertical) == (len(grid)-1, len(grid)-2, False):
                    return level
                lookup.add((r, c, is_vertical))
                if not is_vertical:
                    if c+2 != len(grid[0]) and grid[r][c+2] == 0:
                        next_q.append((r, c+1, is_vertical))
                    if r+1 != len(grid) and grid[r+1][c] == 0 and grid[r+1][c+1] == 0:
                        next_q.append((r+1, c, is_vertical))
                        next_q.append((r, c, not is_vertical))
                else:
                    if r+2 != len(grid) and grid[r+2][c] == 0:
                        next_q.append((r+1, c, is_vertical))
                    if c+1 != len(grid) and grid[r][c+1] == 0 and grid[r+1][c+1] == 0:
                        next_q.append((r, c+1, is_vertical))
                        next_q.append((r, c, not is_vertical))
            q = next_q
            level += 1
        return -1",O(n ^ 2)
"class Solution2(object):
    def longestPrefix(self, s):
        M = 10**9+7
        D = 26
        def check(l, s):
            for i in range(l):
                if s[i] != s[len(s)-l+i]:
                    return False
            return True
    
        result, prefix, suffix, power = 0, 0, 0, 1
        for i in range(len(s)-1):
            prefix = (prefix*D + (ord(s[i])-ord('a'))) % M
            suffix = (suffix + (ord(s[len(s)-(i+1)])-ord('a'))*power) % M
            power = (power*D)%M
            if prefix == suffix:
                result = i+1
        return s[:result]",O(n)
"import sys
input = sys.stdin.readline
from collections import *

def judge(x):
    ins = [0]*n
    outs = defaultdict(list)

    for u, v, c in edges:
        if c>x:
            ins[v] += 1
            outs[u].append(v)

    q = deque([v for v in range(n) if ins[v]==0])
    cnt = 0

    while q:
        v = q.popleft()
        cnt += 1

        for nv in outs[v]:
            ins[nv] -= 1

            if ins[nv]==0:
                q.append(nv)

    return cnt==n

def binary_search():
    l, r = 0, 10**9+10

    while l<=r:
        m = (l+r)//2

        if judge(m):
            r = m-1
        else:
            l = m+1

    return l

n, m = map(int, input().split())
edges = []
idx = defaultdict(lambda : deque([]))

for i in range(m):
    u, v, c = map(int, input().split())
    u -= 1
    v -= 1
    edges.append((u, v, c))
    idx[10**6*u+v].append(i+1)

k = binary_search()
ins = [0]*n
outs = defaultdict(list)
removed = []

for u, v, c in edges:
    if c>k:
        ins[v] += 1
        outs[u].append(v)
    else:
        removed.append((u, v))

q = deque([v for v in range(n) if ins[v]==0])
order = [-1]*n
cnt = 0

while q:
    v = q.popleft()
    order[v] = cnt
    cnt += 1

    for nv in outs[v]:
        ins[nv] -= 1

        if ins[nv]==0:
            q.append(nv)

change = []

for u, v in removed:
    if order[v]<order[u]:
        change.append(idx[10**6*u+v].popleft())

print(k, len(change))
print(*change)",O(nlogn)
"n=int(input())
a=[0]+list(map(int,input().split()))
ans=0
for i in range(1,len(a)):
    if a[i]==-1:
        continue
    j=i
    while a[j]!=-1:
        prev=j
        j=a[j]
        a[prev]=-1
    ans+=1
if n%2==0:

    if ans%2==0:
        print(""Petr"")
    else:
        print(""Um_nik"")
else:

    if ans%2==0:
        print(""Petr"")
    else:
        print(""Um_nik"")",O(nlogn)
"from collections import deque
from sys import stdin
lines = deque(line.strip() for line in stdin.readlines())

def nextline():
    return lines.popleft()

def types(cast, sep=None):
    return tuple(cast(x) for x in strs(sep=sep))

def ints(sep=None):
    return types(int, sep=sep)

def strs(sep=None):
    return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep))

def main():

    T = int(nextline())
    for testCase in range(1, T + 1):
        n, m, k = ints()
        min_k = max(n, m)
        if min_k > k:
            print(-1)
            continue
        if (n - m) % 2 == 0:
            if k % 2 == n % 2:
                print(k)
                continue
            print(k - 2)
            continue
        print(k - 1)

if __name__ == '__main__':
    main()
",O(1)
"class Solution2(object):
    def lengthOfLIS(self, nums):
        LIS = []
        def insert(target):
            left, right = 0, len(LIS) - 1
            while left <= right:
                mid = left + (right - left) // 2
                if LIS[mid] >= target:
                    right = mid - 1
                else:
                    left = mid + 1
            if left == len(LIS):
                LIS.append(target)
            else:
                LIS[left] = target

        for num in nums:
            insert(num)

        return len(LIS)",O(nlogn)
"n=int(input())
xw=[list(map(int,input().split())) for _ in [0]*n]

ab=sorted([[x-w,x+w] for x,w in xw],key=lambda x:(x[1],x[0]))

k=ab[0][0]
cnt=0
for a,b in ab:
    if k<=a:
        cnt+=1
        k=b

print(cnt)",O(nlogn)
"class Solution(object):
    def longestIdealString(self, s, k):
        dp = [0]*26
        for c in s:
            x = ord(c)-ord('a')
            dp[x] = max(dp[i] for i in range(max(x-k, 0), min(x+k+1, 26)))+1
        return max(dp)",O(n)
"class Solution(object):
    def maxPotholes(self, road, budget):
        def inplace_counting_sort(nums, reverse=False): 
            if not nums:
                return
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()
    
        ls = []
        l = 0
        for i in range(len(road)):
            l += 1
            if i+1 == len(road) or road[i+1] != road[i]:
                if road[i] == 'x':
                    ls.append(l)
                l = 0
        inplace_counting_sort(ls)
        result = 0
        for l in reversed(ls):
            c = min(l+1, budget)
            if c-1 <= 0:
                break
            result += c-1
            budget -= c
        return result",O(n)
"import os
import sys
from io import BytesIO, IOBase

from collections import Counter

def main():
    n=int(input())
    a=list(map(int,input().split()))
    d=dict()
    z=0
    s=0
    for item in a:
        if item in d:
            d[item]+=1
            z=item
        else:
            d[item]=1
        s+=item

    if len(a)-len(d)>=2:
        print(""cslnb"")
        exit()
    if len(a)==len(d):
        z=(n*(n-1))//2
        if (s-z)%2:
            print(""sjfnb"")
        else:
            print(""cslnb"")

    else:
        if z-1 in d or z==0:
            print(""cslnb"")
        else:
            zz=(n*(n-1))//2
            if (s-zz)%2:
                print(""sjfnb"")
            else:
                print(""cslnb"")

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda: self.buffer.read().decode('ascii')
        self.readline = lambda: self.buffer.readline().decode('ascii')

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')

if __name__ == '__main__':
    main()",O(n)
"import itertools

n = int(input())
boards = []
for i in range(4):
    boards.append([])
    for j in range(n):
        boards[-1].append(list(map(int, list(input()))))
    if i < 3: input()

ans = n * n * 4

def check_board(corner, board):
    ans = 0
    for i in range(n):
        for j in range(n):
            if board[i][j] != corner:
                ans += 1
            corner = 1 - corner
    return ans

def solve(corner, p):
    ans = check_board(corner, boards[p[0]])
    ans += check_board(1- corner, boards[p[1]])
    ans += check_board(1 - corner, boards[p[2]])
    ans += check_board(corner, boards[p[3]])

    return ans

for p in itertools.permutations(range(4), 4):
    ans = min(ans, solve(1, p))
    ans = min(ans, solve(0, p))

print(ans)",O(n ^ 2)
"class Solution(object):
    def oddEvenJumps(self, A):
        def findNext(idx):
            result = [None]*len(idx)
            stack = []
            for i in idx:
                while stack and stack[-1] < i:
                    result[stack.pop()] = i
                stack.append(i)
            return result
        
        idx = sorted(list(range(len(A))), key = lambda i: A[i])
        next_higher = findNext(idx)
        idx.sort(key = lambda i: -A[i])
        next_lower = findNext(idx)

        odd, even = [False]*len(A), [False]*len(A)
        odd[-1], even[-1] = True, True
        for i in reversed(range(len(A)-1)):
            if next_higher[i]:
                odd[i] = even[next_higher[i]]
            if next_lower[i]:
                even[i] = odd[next_lower[i]]
        return sum(odd)",O(nlogn)
"arra = []
arrb = []
arr = []
s = """"
temp = 1
value = ans = n = 0

def fill(myList = [], *args):
    for i in range(n):
        arra.insert(0,0)

def check():
    for i,j in zip(arra,arrb):
        if i == j:
            return 1
        else:
            return 0

def Engine1(num):
    if num > 1:
        Engine1(num // 2)
    arra.append( num%2 )
def Engine2(num):
    if num > 1:
        Engine2(num // 2)
    arrb.append( num%2 )

a,b = map(int,input().split())
Engine1(a)
Engine2(b)

n = abs(len(arra)-len(arrb))
if(len(arra)>len(arrb)):
    fill(arrb)
if(len(arra)<len(arrb)):
    fill(arra)

for i in range(len(arra)):
    if(check() == 0):
        break
    check()
    arra.pop(0)
    arrb.pop(0)

for i in range(len(arra)):
    ans += temp
    temp *= 2
print(ans)",O(logn)
"import itertools



class Solution(object):
    def makeSimilar(self, nums, target):
        nums.sort(key=lambda x: (x%2, x))
        target.sort(key=lambda x: (x%2, x))
        return sum(abs(x-y)//2 for x, y in zip(nums, target))//2",O(nlogn)
"N = 405
n, m = map(int, input().split())
dp = [[0]*N for _ in range(N)]
c = [[1]*N for _ in range(N)]
p = [0]*N

p[0] = 1
for i in range(1, N):
    p[i] = (p[i-1]*2) % m
for i in range(1, N):
    for j in range(1, i):
        c[i][j] = (c[i-1][j-1] + c[i-1][j]) % m

dp[0][0] = 1
for i in range(2, n+2):
    for x in range(1, (n-1)//2 + 2):
        for k in range(1, i):
            dp[i][x] = (dp[i][x] + ((dp[i-k-1][x-1]*p[k-1]) % m) * c[i-x][k]) % m
ans = 0
for i in range(1, (n-1)//2 + 2):
    ans = (ans + dp[n+1][i]) % m
print(ans)",O(n ^ 3)
"import heapq



class Solution(object):
    def minOperations(self, nums, k):
        result = 0
        heapq.heapify(nums)
        while nums:
            if nums[0] >= k:
                break
            mn1 = heapq.heappop(nums)
            mn2 = heapq.heappop(nums)
            heapq.heappush(nums, 2*mn1+mn2)
            result += 1
        return result",O(nlogn)
"n=int(input())
m=int(input())
print(m%(1<<n))",O(1)
"def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]

def Binary_Search(arr , x , n):
    l ,r = 0 , n-1
    while l <= r:
        mid = l + (r - l) // 2
        if arr[mid] == x :
            return mid+1
        elif arr[mid] > x:
            r = mid - 1
        else:
            l = mid + 1
    return r + 1

n , q = MAP()
a = LIST()
b = LIST()
ps = list(accumulate(a))
ans = []

arrows = 0
for arrow in b :
    arrows += arrow
    if arrows >= ps[-1]:
        ans.append(n)
        arrows = 0
    else:
        res = Binary_Search(ps , arrows , n)
        ans.append(n - res)

for i in ans:
    print(i)
",O(nlogn)
"class Solution(object):
    def removeCoveredIntervals(self, intervals):
        intervals.sort(key=lambda x: [x[0], -x[1]])
        result, max_right = 0, 0
        for left, right in intervals:
            result += int(right > max_right)
            max_right = max(max_right, right)
        return result",O(nlogn)
"class Solution(object):
    def generateMatrix(self, n):
        matrix = [[0 for _ in range(n)] for _ in range(n)]

        left, right, top, bottom, num = 0, n - 1, 0, n - 1, 1

        while left <= right and top <= bottom:
            for j in range(left, right + 1):
                matrix[top][j] = num
                num += 1
            for i in range(top + 1, bottom):
                matrix[i][right] = num
                num += 1
            for j in reversed(range(left, right + 1)):
                if top < bottom:
                    matrix[bottom][j] = num
                    num += 1
            for i in reversed(range(top + 1, bottom)):
                if left < right:
                    matrix[i][left] = num
                    num += 1
            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1

        return matrix",O(n ^ 2)
"class Solution(object):
    def maximizeSum(self, nums, k):
        return max(nums)*k+k*(k-1)//2",O(n)
"def check(s,a):
    st=''
    for i in range(len(s)):
        st+=s[i]
    st=int(st)
    if (st>a):
        return False
    else:
        return True
a = input()
b = input()
s=[]
ans=''
for i in range(len(a)):
    s.append(a[i])
s.sort()
if (len(b)>len(a)):
    for i in range(len(s)):
        print(s[len(s)-i-1],end='')
else:
    for i in range(len(a)):
        j=0
        temp2=-1
        while ((j<len(s)-1) and (s[j+1]<=b[i])):
            j+=1
            if (s[j]!=s[j-1]):
                temp2=j-1
        temp=s[j]
        s.remove(s[j])
        if (i==len(a)-1 or check(s,int(b[i+1:len(b)])) or temp<b[i]):
            ans+=temp
            if (ans[i]<b[i]):
                for k in range(len(s)):
                    ans+=s[len(s)-k-1]
        else:
            s.append(temp)
            s.sort()
            temp2=s[temp2]
            ans+=temp2
            s.remove(temp2)
            for k in range(len(s)):
                    ans+=s[len(s)-k-1]
        if (len(ans)==len(a)):
            break
print(ans)
",O(n ^ 3)
"import collections
import itertools


class Solution(object):
    def removeSubfolders(self, folder):
        def dfs(curr, path, result):
            if ""_end"" in curr:
                result.append(""/"" + ""/"".join(path))
                return
            for c in curr:
                if c == ""_end"":
                    continue
                path.append(c)
                dfs(curr[c], path, result)
                path.pop()

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for f in folder:
            f_list = f.split(""/"")
            reduce(dict.__getitem__,
                   itertools.islice(f_list, 1, len(f_list)),
                   trie).setdefault(""_end"")
        result = []
        dfs(trie, [], result)
        return result",O(n)
"a=input()
n=len(a)
for i in range(n-1,-1,-1):
    b=sorted([a[j:j+i] for j in range(n-i+1)])
    if True in [b[j]==b[j-1] for j in range(1,n-i+1)]:
        print(i)
        break",O(n ^ 3)
"from sys import exit

n, m = map(int, input().split())
b = list(map(int, input().split()))
g = list(map(int, input().split()))
if max(b) > min(g):
    print(-1)
    exit(0)
b.sort()
res = sum(g) + sum(b[:-1]) * m
if b[-1] in g:
    print(res)
else:
    print(res + b[-1] - b[-2])
",O(nlogn)
"class Solution2(object):
    def preorder(self, root):
        def dfs(root, result):
            result.append(root.val)
            for child in root.children:
                if child:
                    dfs(child, result)
        
        result = []
        if root:
            dfs(root, result)
        return result",O(n)
"import collections


class Solution2(object):
    def majorityElement(self, nums):
        return collections.Counter(nums).most_common(1)[0][0]",O(n)
"class Solution2(object):
    def appealSum(self, s):
        result = cnt = 0
        lookup = [-1]*26
        for i, c in enumerate(s):
            cnt += i-lookup[ord(c)-ord('a')]
            lookup[ord(c)-ord('a')] = i
            result += cnt
        return result",O(n)
"class SegmentTreeNode(object):
    def __init__(self, start, end):
        self.start, self.end = start, end
        self.total = self.count = 0
        self._left = self._right = None

    def mid(self):
        return (self.start+self.end) // 2

    def left(self):
        self._left = self._left or SegmentTreeNode(self.start, self.mid())
        return self._left

    def right(self):
        self._right = self._right or SegmentTreeNode(self.mid(), self.end)
        return self._right

    def update(self, X, i, j, val):
        if i >= j:
            return 0
        if self.start == i and self.end == j:
            self.count += val
        else:
            self.left().update(X, i, min(self.mid(), j), val)
            self.right().update(X, max(self.mid(), i), j, val)
        if self.count > 0:
            self.total = X[self.end]-X[self.start]
        else:
            self.total = self.left().total + self.right().total
        return self.total


class Solution(object):
    def rectangleArea(self, rectangles):
        OPEN, CLOSE = 1, -1
        events = []
        X = set()
        for x1, y1, x2, y2 in rectangles:
            events.append((y1, OPEN, x1, x2))
            events.append((y2, CLOSE, x1, x2))
            X.add(x1)
            X.add(x2)
        events.sort()
        X = sorted(X)
        Xi = {x: i for i, x in enumerate(X)}

        st = SegmentTreeNode(0, len(X)-1)
        result = 0
        cur_x_sum = 0
        cur_y = events[0][0]
        for y, typ, x1, x2 in events:
            result += cur_x_sum * (y-cur_y)
            cur_x_sum = st.update(X, Xi[x1], Xi[x2], typ)
            cur_y = y
        return result % (10**9+7)",O(nlogn)
"n=int(raw_input())
arr=list(map(int,raw_input().split()))
dict1={}
arr1=[0]*n
for i in range(n):
	arr1[arr[i]-1]=i
for i in range(n):
	dict1[i+1]=[]
for i in range(n):
	for j in range(i-arr[i],-1,-arr[i]):
		if(arr[j]>arr[i]):
			dict1[arr[i]].append(arr[j])
	for j in range(i+arr[i],n,arr[i]):
		if(arr[j]>arr[i]):
			dict1[arr[i]].append(arr[j])
strarr=['.']*n

for i in range(n-1,-1,-1):
	if(len(dict1[arr[arr1[i]]])==0):
		strarr[arr1[i]]='B'
	else:
		if(len(dict1[arr[arr1[i]]])==1 and len(dict1[dict1[arr[arr1[i]]][0]])==0):
			strarr[arr1[i]]='A'
		else:
			flag=0
			for j in dict1[arr[arr1[i]]]:

				if(strarr[arr1[j-1]]=='B'):
					flag=1
					break
			if(flag==1):
				strarr[arr1[i]]='A'
			else:
				strarr[arr1[i]]='B'

print("""".join(x for x in strarr))
",O(n ^ 2)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

        
class Solution(object):
    def distributeCoins(self, root):
        def dfs(root, result):
            if not root:
                return 0
            left, right = dfs(root.left, result), dfs(root.right, result)
            result[0] += abs(left) + abs(right)
            return root.val + left + right - 1

        result = [0]
        dfs(root, result)
        return result[0]",O(n)
"n, m, k = map(int, input().split())
ea = [list(map(int, input().split()))for _ in range(n)]
eb = [list(map(int, input().split()))for _ in range(n-1)]
dp = [[[10**20]*m for __ in range(n)]for _ in range(k//2+1)]
dp[0] = [[0]*m for _ in range(n)]

def show_ans():
    for line in dp[-1]:
        print(' '.join(map(str, [d*2 for d in line])))

if k % 2:
    for i in range(n):
        print(' '.join(['-1']*m))
    exit()
for t in range(1, k//2+1):
    for i in range(n):
        for j in range(m):
            if i:
                dp[t][i][j] = min(dp[t][i][j], dp[t-1][i-1][j]+eb[i-1][j])
            if i < n-1:
                dp[t][i][j] = min(dp[t][i][j], dp[t-1][i+1][j]+eb[i][j])
            if j:
                dp[t][i][j] = min(dp[t][i][j], dp[t-1][i][j-1]+ea[i][j-1])
            if j < m-1:
                dp[t][i][j] = min(dp[t][i][j], dp[t-1][i][j+1]+ea[i][j])
show_ans()
",O(n ^ 3)
"n,k = map(int, input().strip().split(' '))
lst = list(map(int, input().strip().split(' ')))
s=sum(lst)
s2=0
m=0
for i in range(n-1):
    s2+=lst[i]
    s-=lst[i]
    if (s2%k)+(s%k)>m:
        m=(s2%k)+(s%k)
print(m)
",O(n)
"def resheto(a):
    numbers = list(range(0, a + 1))
    primes = set()
    for k in range(2, a + 1):
        if numbers[k] != 0:
            primes.add(k)
            for j in range(2 * k, a + 1, k):
                numbers[j] = 0
    return primes

all_primes = resheto(10**6)
n = int(input())
for i in range(2, n):
    if i not in all_primes and (n - i) not in all_primes:
        print(i, n - i)
        break",O(1)
"class Solution(object):
    def sortArrayByParity(self, A):
        i = 0
        for j in range(len(A)):
            if A[j] % 2 == 0:
                A[i], A[j] = A[j], A[i]
                i += 1
        return A",O(n)
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1

        while l < r:
            m = (l + r) // 2
            if nums[m] > nums[r]:
                l = m + 1
            else:
                r = m

        pivot = l

        def binary_search(left: int, right: int) -> int:
            while left <= right:
                mid = (left + right) // 2
                if nums[mid] == target:
                    return mid
                elif nums[mid] < target:
                    left = mid + 1
                else:
                    right = mid - 1
            return -1

        result = binary_search(0, pivot - 1)
        if result != -1:
            return result

        return binary_search(pivot, len(nums) - 1)
",O(logn)
"n = int(input())
a = list(map(int, input().split()))
if n == 1:
	print(a[0])
else:
	prod_minus = False
	for i in range(n - 1):
		if a[i] * a[i + 1] <= 0:
			prod_minus = True
			break
	Min_abs = float(""inf"")
	Sum = 0
	for num in a:
		Sum += abs(num)
		if abs(num) < Min_abs:
			Min_abs = abs(num)

	if prod_minus:
		print(Sum)
	else:
		print(Sum - 2 * Min_abs)",O(n)
"class Solution2(object):
    def countCompleteDayPairs(self, hours):
        return sum((hours[i]+hours[j])%24 == 0 for i in range(len(hours)-1) for j in range(i+1, len(hours)))",O(n ^ 2)
"n = int(input())
s = input()
t = 0
for i in s:
    if i == '+':
        t += 1
    else:
        t = max(t - 1, 0)

print(max(t, 0))
",O(n)
"t1, t2, t3 = input().split()
ans = 2
if t1 == t2 or t2 == t3 or t3 == t1:
    if t1 == t2 == t3:
        ans = 0
    else:
        ans = 1
aaa = []
for i in range(10):
    for j in range(10):
        for k in range(10):
            if k - j == j - i == 1:
                aaa.append({i, j, k})
if t1[1] == t2[1] == t3[1] and {int(t1[0]), int(t2[0]), int(t3[0])} in aaa:
    ans = 0
elif (t1[1] == t2[1] and (abs(int(t1[0]) - int(t2[0])) == 1 or abs(int(t1[0]) - int(t2[0])) == 2)) or (t1[1] == t3[1] and (abs(int(t1[0]) - int(t3[0])) == 1 or abs(int(t1[0]) - int(t3[0])) == 2)) or (t3[1] == t2[1] and (abs(int(t3[0]) - int(t2[0])) == 1 or abs(int(t3[0]) - int(t2[0])) == 2)):
    ans = min(1, ans)
print(ans)",O(1)
"import sys
def main():
    pass
def binary(n):

    return (bin(n).replace(""0b"", """"))
def decimal(s):

    return (int(s, 2))
def pow2(n):

    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)
def isPrime(n):

    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)
def lts(l):

    s = ''.join(map(str, l))
    return s
def stl(s):

    l = list(s)

    return l

def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans

mod = int(1e9) + 7
def ssinp(): return sys.stdin.readline().strip()

def iinp(): return int(input())

def nninp(): return map(int, sys.stdin.readline().strip().split())

def llinp(): return list(map(int, sys.stdin.readline().strip().split()))

def p(xyz): print(xyz)
def p2(a, b): print(a, b)
import math
from collections import OrderedDict

n=iinp()
l=[]
s={""purple"",""green"",""blue"",""orange"",""red"",""yellow""}
for i in range(n):
    inp=ssinp()
    s.remove(inp)
print(6-n)
for i in s:
    if(i==""purple""):
        print(""Power"")
    elif(i==""green""):
        print(""Time"")
    elif(i==""blue""):
        print(""Space"")
    elif (i == ""orange""):
        print(""Soul"")
    elif (i == ""red""):
        print(""Reality"")
    else:
        print(""Mind"")
",O(1)
"def f(n):
    k=2
    while k*k<=n:
        if n%k==0:
            return False
        k+=1
    return True
n,k=map(int,input().split())
a=[]
x=0
for i in range(2,n+1):
    if f(i):
        a.append(i)
for i in range(len(a)-2):
    if a[i]+a[i+1]+1 in a:
        x+=1
if x>=k:
    print('YES')
else:
    print('NO')
",O(n)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, = getIntList()

zz = ( (1,-1), (0,2), (1,-1) )
now = (0,0)
for i in range(N):
    print(now[0],now[1])
    now = ( now[0] + zz[i%3] [0] , now[1] + zz[i%3][1])
",O(n)
"import math

n, r = map(int, input().split())
angle = math.pi / n
s = math.sin(angle)

print('%.8f' % (r * s / (1 - s)))
",O(1)
"x,k=map(int,input().split())
m=10**9+7
print((x*pow(2,k+1,m) -pow(2,k,m) +1) %(m)) if x >0 else print(0)",O(logn)
"n = int(input())
print(n//2+1)",O(1)
"a,b=map(int,input().split())
if b>=a-1:
    print(a-1)
else:
    summ=b
    k=a-b
    for i in range(2,k+1):
        summ+=i
    print(summ)
",O(n)
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping
from itertools import groupby as gb
from fractions import Fraction as fr

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()
def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));
def ceildiv(x,y): return (x+y-1)//y

def datainput():
    return map(int, input().split())
def listinput():
    return list(map(int, input().split()))

n=int(input())
ans={}
while n:
    n-=1
    a,x =datainput()
    ans[a]=x
m=int(input())
while m:
    m-=1
    b,y =datainput()
    if b in ans:
        if ans[b] < y:
            ans[b]=y
    else:
        ans[b]=y
print(sum(list(ans.values())))
",O(nlogn)
"

class Solution(object):
    def doesAliceWin(self, s):
        return any(x in ""aeiou"" for x in s)
",O(n)
"import sys

v, h = list(map(lambda x: int(x), sys.stdin.readline().split(' ')))
vs = []
hs = []
for i in range(v):
	vs.append(int(sys.stdin.readline()))
vs.sort()
vs.append(10 ** 9)
for i in range(h):
	x1, x2, y = list(map(lambda x: int(x), sys.stdin.readline().split(' ')))
	if x1 == 1:
		hs.append([x1, x2, y])

def sort_x2(val):
	return val[1]

hs.sort(key=sort_x2)

hsl = len(hs)
vsl = len(vs)

res = v + h
hi = 0
for vi, v in enumerate(vs, start=0):
	while hi < hsl and hs[hi][1] < v:
		hi += 1
	res = min(res, vi + hsl - hi)

print(res)
",O(nlogn)
"class Solution:
    def isPalindrome(self, s: str) -> bool:
        l, r = 0, len(s) - 1

        while l < r:
            while l < r and not self.alphaNum(s[l]):
                l += 1
            while r > l and not self.alphaNum(s[r]):
                r -= 1
            if s[l].lower() != s[r].lower():
                return False
            l, r = l + 1, r - 1
        return True

    def alphaNum(self, c):
        return (ord('A') <= ord(c) <= ord('Z') or
                ord('a') <= ord(c) <= ord('z') or
                ord('0') <= ord(c) <= ord('9'))
",O(n)
"n=input()
l=list(map(lambda x:int(x)*2,raw_input().split("" "")))
t=list(map(lambda x:""GWL"".index(x),raw_input()))
mins=[0 for i in range(0,n+1)]
for i in range(n-1,-1,-1):
	if t[i]!=2:mins[i]=max(mins[i+1]-l[i],0)
	else:mins[i]=mins[i+1]+l[i]
curs=ans=st=0
for i in range(0,n):
	if(t[i]==0):
		curs+=l[i];ans+=l[i]*5
		if(curs>mins[i+1]):
			ol=(curs-mins[i+1])//2
			ol=min(ol,l[i])
			ans-=4*ol;curs-=2*ol
	if(t[i]==1):
		st=1;curs+=l[i];ans+=l[i]*3
	if(t[i]==2):
		if(curs<l[i]):
			ol=l[i]-curs;curs=l[i]
			ans+=ol*(3 if st else 5)
		curs-=l[i];ans+=l[i]
if curs>0:ans-=curs//2*2
print(ans//2)",O(n)
"from collections import Counter
from math import *
import sys
mod=1000000007

def pro(arr,q):
    n=len(arr)
    ans=0
    for i in range(n):
        for j in range(i+1,n):
            if(arr[i]>arr[j]):
                ans+=1

    res=ans%2
    for x,y in q:
        k= y-x + 1
        k=k//2
        k=k%2
        res= k^res
        if(res):
            print('odd')
        else:
            print('even')
n=int(input())
arr=list(map(int,input().split()))
t=int(input())
que=[]
for i in range(t):
    que.append(list(map(int,input().split())))
pro(arr,que)",O(n ^ 2)
"import sys

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')

INF = 10 ** 18
MOD = 10 ** 9 + 7

def check(x):
    T1 = T[:x] + '*'
    T2 = T[x:] + '*'
    m1 = len(T1)
    m2 = len(T2)

    dp = list2d(N+1, m1, -1)
    dp[0][0] = 0
    for i in range(N):
        s = S[i]
        for j in range(m1):
            k = dp[i][j]
            if k != -1:
                dp[i+1][j] = max(dp[i+1][j], k)
                if T1[j] == s:
                    dp[i+1][j+1] = max(dp[i+1][j+1], k)
                if T2[k] == s:
                    dp[i+1][j] = max(dp[i+1][j], k+1)
    return dp[N][m1-1] == m2-1

for _ in range(INT()):
    S = input()
    T = input()

    N = len(S)
    M = len(T)
    for x in range(M):
        if check(x):
            YES()
            break
    else:
        NO()
",O(n ^ 3)
"from sys import exit
n = int(input())
arr = [int(x) for x in input().split()]
tmp = 0
for i in range(len(arr)):
    tmp += (arr[i] - i)
arr.sort()
c = 0
for i in range(1, n):
    if arr[i] == arr[i - 1]:
        c += 1
    if i != 1 and arr[i] == arr[i - 1] and arr[i - 1] == arr[i - 2] + 1:
        print(""cslnb"")
        exit()
if c > 1 or (len(arr) >= 2 and arr[0] == arr[1] == 0):
    print(""cslnb"")
    exit()
print(""cslnb"" if tmp % 2 == 0 else ""sjfnb"")",O(nlogn)
"n, MOD = map(int, input().split())

pascal = [[1]]
for _ in range(500):
    nl = [1]
    for i in range(_):
        nl.append((pascal[-1][i] + pascal[-1][i+1]) % MOD)
    nl.append(1)
    pascal.append(nl)

mod_mul = lambda x, y: (x * y) % MOD

import __pypy__

int_add = __pypy__.intop.int_add
int_sub = __pypy__.intop.int_sub
int_mul = __pypy__.intop.int_mul

def make_mod_mul(mod=MOD):
    fmod_inv = 1.0 / mod

    def mod_mul(a, b, c=0):
        res = int_sub(int_add(int_mul(a, b), c), int_mul(mod, int(fmod_inv * a * b + fmod_inv * c)))
        if res >= mod:
            return res - mod
        elif res < 0:
            return res + mod
        else:
            return res

    return mod_mul

mod_mul = make_mod_mul()

def mod_pow(x, y):
    if y == 0:
        return 1
    res = 1
    while y > 1:
        if y & 1 == 1:
            res = mod_mul(res, x)
        x = mod_mul(x, x)
        y >>= 1
    return mod_mul(res, x)

base = [0] * (n + 1)

dp = []
for i in range(n):
    nex = base[:]
    nex[1] = mod_pow(2, i)
    for j in range(i - 1):
        bl = i-j-1
        assert bl > 0
        mul = mod_pow(2, bl - 1)
        for k in range(n):
            ct = 2 + j - k
            if ct < 0:
                assert dp[j][k] == 0
                continue
            mulr = mod_mul(mul, pascal[bl+ct][ct])
            nex[k+1] += mod_mul(mulr, dp[j][k])
            nex[k+1] %= MOD
    dp.append(nex)
print(sum(dp[-1]) % MOD)
",O(n ^ 3)
"n = int(input())
for i in range(n):
    a, b, c = [int(el) for el in input().split()]
    if ( a > c or b > c):
        print(-1)
    else:
        if (a% 2 + b % 2 == 1):
            print(c - 1)
        elif (a%2 == b%2 == c%2):
            print(c)
        else:
            print(c - 2)
",O(1)
"a,b=map(int,input().split())
x,y,z=map(int,input().split())

yell=2*x+y
blue=y+3*z
res=max(0,yell-a)+max(0,blue-b)

print(res)",O(1)
"from collections import Counter
from heapq import heapify, heappop


class Solution(object):
    def isNStraightHand(self, hand, W):
        if len(hand) % W:
            return False

        counts = Counter(hand)
        min_heap = list(hand)
        heapify(min_heap)
        for _ in range(len(min_heap)//W):
            while counts[min_heap[0]] == 0:
                heappop(min_heap)
            start = heappop(min_heap)
            for _ in range(W):
                counts[start] -= 1
                if counts[start] < 0:
                    return False
                start += 1
        return True",O(nlogn)
"class Solution(object):
    def minOperations(self, nums, k):
        lookup = [False]*k
        for i in reversed(range(len(nums))):
            if nums[i] > len(lookup) or lookup[nums[i]-1]:
                continue
            lookup[nums[i]-1] = True
            k -= 1
            if not k:
                break
        return len(nums)-i",O(n)
"R = lambda: map(int, input().split())
n, s = R()
l, r = s, 10**18 + 7

def digit(x):
    res = 0
    while x:
        res += x % 10
        x //= 10
    return res

while l < r:
    m = (l + r) // 2
    if m - digit(m) < s:
        l = m + 1
    else:
        r = m
print(max(0, n - l + 1))",O(logn)
"n, m = map(int, input().split())
a = input()
b = input()
flag = 0
for c in a:
    if(c == '*'):
        flag = 1
if(flag == 1):
    a1, a2 = a.split('*')
    Len1 = len(a1)
    Len2 = len(a2)
    b1 = b[:Len1]
    b2 = ''
    if(Len2):
        b2 = b[-Len2:]
    if(a1 == b1 and a2 == b2 and Len1 + Len2 <= len(b)):
        print('YES')
    else:
        print('NO')
else:
    if(a == b):
        print('YES')
    else:
        print('NO')",O(n)
"from collections import deque
n, d, k = map(int, input().split())
if n==1:
    print('NO')
    exit(0)
if n==2:
    if d>1:
        print('NO')
    else:
        print('YES')
        print(1, 2)
    exit(0)
if (not 2<=d<=n-1) or k==1:
    print('NO')
    exit(0)
ans = []
for i in range(d):
    ans.append((i+1, i+2))
now = d+2
for i in range(d-1):
    q = deque([(i+2, min(i, d-i-2))])
    first = True
    while q and len(ans)<n-1:
        node, depth = q.popleft()
        end = now+k-1
        if first:
            end -= 1
        for j in range(now, end):
            ans.append((node, j))
            if len(ans)==n-1:
                break
            if depth>0:
                q.append((j, depth-1))
        now = end
        first = False

if len(ans)==n-1:
    print('YES')
    for i, j in ans:
        print(i, j)
else:
    print('NO')",O(n ^ 2)
"N, mod = map(int, input().split())

two = [1] * (N+1)
fact = [1] * (N+1)
inv = [1] * (N+1)
for i in range(1, N+1):
    two[i] = two[i-1]*2 % mod
for i in range(2, N+1):
    fact[i] = fact[i-1] * i % mod
inv[N] = pow(fact[N], mod-2, mod)
for i in range(N, 0, -1):
    inv[i-1] = inv[i] * i % mod

dp = [[0] * (N+2) for _ in range(N+2)]
dp[0][0] = 1
for i in range(N):
    for j in range(i+1):
        for k in range(1, N+1):
            if i+k > N:
                break
            dp[i+k+1][j+1] += dp[i][j] * two[k-1] * inv[k] % mod
            dp[i+k+1][j+1] %= mod

ans = 0
for j in range(1, N+1):
    ans += dp[N+1][j] * fact[N-j+1] % mod
    ans %= mod
print(ans)
",O(n ^ 3)
"class Solution(object):
    def findMaxConsecutiveOnes(self, nums):
        result, local_max = 0, 0
        for n in nums:
            local_max = (local_max + 1 if n else 0)
            result = max(result, local_max)
        return result",O(n)
"def solve(n, v):
    fuel = min(n - 1, v)
    cost = fuel
    for i in range(2, n):
        if fuel >= n - 1:
            break
        fuel += 1
        cost += i
    return cost

n, v = map(int, input().split())
print(solve(n, v))
",O(n)
"class Solution(object):
    def queensAttacktheKing(self, queens, king):
        dirctions = [(-1, 0), (0, 1), (1, 0), (0, -1),
                     (-1, 1), (1, 1), (1, -1), (-1, -1)]
        result = []
        lookup = {(i, j) for i, j in queens}
        for dx, dy in dirctions:
            for i in range(1, 8):
                x, y = king[0] + dx*i, king[1] + dy*i
                if (x, y) in lookup:
                    result.append([x, y])
                    break
        return result",O(1)
"
import collections


class Solution(object):
    def predictPartyVictory(self, senate):
        n = len(senate)
        radiant, dire = collections.deque(), collections.deque()
        for i, c in enumerate(senate):
            if c == 'R':
                radiant.append(i)
            else:
                dire.append(i)
        while radiant and dire:
            r_idx, d_idx = radiant.popleft(), dire.popleft()
            if r_idx < d_idx:
                radiant.append(r_idx+n)
            else:
                dire.append(d_idx+n)
        return ""Radiant"" if len(radiant) > len(dire) else ""Dire""

",O(n)
"import sys
input=sys.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left,bisect
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
n,k=map(int,input().split())
x,y=1,n
f=0
while(x<=y):
    m=(x+y)//2
    s=0
    p=m
    while(p>0):
        s+=p%10
        p=p//10
    m1=m-1
    s1=0
    p=m1
    while(p>0):
        s1+=p%10
        p=p//10
    if m==0 or (m-s>=k and m1-s1<k):
        f=1
        break
    elif m-s<k:
        x=m+1
    else:
        y=m-1
if f:
    print(n-m+1)
else:
    print(0)
",O(logn)
"n = int(input())
summ = 1
for i in range(1, n):
    summ+=i*4
print(summ)",O(n)
"n=int(input())
m=int(input())
print(m%2**n)
",O(1)
"nab = [int(i) for i in input().split()]
n = nab[0]
a = nab[1]
b = nab[2]
h = sorted([int(i) for i in input().split()])
print(h[b] - h[b-1])
",O(nlogn)
"import collections



class Solution2(object):
    def findMaximumLength(self, nums):
        dp = prefix = prev_prefix = prev_dp = 0
        dq = collections.deque()
        for right in range(len(nums)):
            prefix += nums[right]
            while dq and dq[0][0] <= prefix:
                _, prev_prefix, prev_dp = dq.popleft()
            last, dp = prefix-prev_prefix, prev_dp+1
            while dq and dq[-1][0] >= last+prefix:
                dq.pop()
            dq.append((last+prefix, prefix, dp))
        return dp",O(n)
"from math import *

n=int(input())
A = list(map(int,input().split()))
ans =-1
maxs = 0
for j in range(n):
    if(A[j] > maxs):
        ans = j+1
        break
    else:
        maxs = max(maxs,A[j]+1)
print(ans)",O(n)
"class Solution(object):
    def minimumCost(self, cost):
        cost.sort(reverse=True)
        return sum(x for i, x in enumerate(cost) if i%3 != 2)",O(nlogn)
"class Solution2_Recu(object):
    def moveSubTree(self, root, p, q):
        def find_parents(node, parent, p, q, lookup):
            if node in (p, q):
                lookup[node] = parent
                if len(lookup) == 2:
                    return True
            for child in node.children:
                if find_parents(child, node, p, q, lookup):
                    return True
            return False

        def is_ancestor(node, q):
            for child in node.children:
                if node == q or is_ancestor(child, q):
                    return True
            return False

        lookup = {}
        find_parents(root, None, p, q, lookup)
        if p in lookup and lookup[p] == q:
            return root
        q.children.append(p)
        if not is_ancestor(p, q):
            lookup[p].children.remove(p)
        else:
            lookup[q].children.remove(q)
            if p == root:
                root = q
            else:
                lookup[p].children[lookup[p].children.index(p)] = q
        return root",O(n)
"def main():
    n = int(input())
    left = [int(x) for x in input().strip().split()]
    right = [int(x) for x in input().strip().split()]
    rank = [x + y for (x,y) in zip(left,right)]
    arr = [(n - r) for r in rank]

    for i in range(n):
        more = 0
        for j in range(i):
            if arr[j] > arr[i]:
                more += 1
        if more != left[i]:
            print('NO')
            return

    for i in range(n):
        more = 0
        for j in range(i+1,n):
            if arr[j] > arr[i]:
                more += 1
        if more != right[i]:
            print('NO')
            return

    print('YES')
    for x in arr:
        print(x, end=' ')
    print()

if __name__ == '__main__':
    main()",O(n ^ 2)
"from sys import stdin, stdout, setrecursionlimit
from math import gcd, ceil, sqrt
from collections import Counter, deque
from bisect import bisect_left, bisect_right
ii1 = lambda: int(stdin.readline().strip())
is1 = lambda: stdin.readline().strip()
iia = lambda: list(map(int, stdin.readline().strip().split()))
isa = lambda: stdin.readline().strip().split()
setrecursionlimit(100000)
mod = 1000000007

R, G, B = iia()
r, g, b = sorted(iia()), sorted(iia()), sorted(iia())
dp = [[[0 for i in range(B + 1)] \
    for j in range(G + 1)] for k in range(R + 1)]

for i in range(R + 1):
    for j in range(G + 1):
        for k in range(B + 1):
            if i > 0 and j > 0:
                dp[i][j][k] = max(dp[i][j][k], \
                    dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])
            if i > 0 and k > 0:
                dp[i][j][k] = max(dp[i][j][k], \
                    dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1])
            if j > 0 and k > 0:
                dp[i][j][k] = max(dp[i][j][k], \
                    dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1])
print(dp[-1][-1][-1])
",O(n ^ 3)
"n, m=[int(k) for k in input().split()]
w=[int(k) for k in input().split()]
w=[0]+w+[m]
c, d=[], []
res=0
for j in range(n+1):
    c.append(res)
    if j%2==0:
        res+=w[j+1]-w[j]
res=0
for j in range(n+1, -1, -1):
    if j%2==0 and j!=n+1:
        res+=w[j+1]-w[j]
    d.append(res)
d=d[::-1]
mx=d[0]
for j in range(n+1):
    mx=max(c[j]+(w[j+1]-w[j]-1)+(m-w[j+1]-d[j+1]), mx)

print(mx)",O(n)
"from sys import stdin
t = int(stdin.readline())
for _ in range(t):
    n = int(stdin.readline())
    a = round((n / 2) ** 0.5)
    b = round((n / 4) ** 0.5)
    if 2*a**2 == n or 4*b**2 == n:
        print(""YES"")
    else:
        print(""NO"")
",O(1)
"n = int(input())
m = ''.join(set(list(str(n))))
if m == '47' or m == '74' or m == '4' or m == '7':
  print('YES')
else:
  if n %4 == 0 or n %7== 0 or n %74== 0 or n %47== 0:
    print('YES')
  else:
    print(""NO"")",O(1)
"import io
import os

import sys
from functools import lru_cache
from collections import defaultdict

sys.setrecursionlimit(10 ** 5)

def solve(N, A):

    valToLeftRight = defaultdict(lambda: defaultdict(set))

    valToRightLeft = defaultdict(lambda: defaultdict(set))

    for i, x in enumerate(A):
        valToLeftRight[x][i].add(i)
        valToRightLeft[x][i].add(i)

    maxVal = 1000 + 10
    for val in range(maxVal):
        for l, rights in valToLeftRight[val - 1].items():
            for r in rights:

                l2 = r + 1
                if l2 in valToLeftRight[val - 1]:
                    for r2 in valToLeftRight[val - 1][l2]:
                        assert l <= r
                        assert r + 1 == l2
                        assert l2 <= r2
                        valToLeftRight[val][l].add(r2)
                        valToRightLeft[val][r2].add(l)

                r2 = l - 1
                if r2 in valToRightLeft[val - 1]:
                    for l2 in valToRightLeft[val - 1][r2]:
                        assert l2 <= r2
                        assert r2 == l - 1
                        assert l <= r
                        valToLeftRight[val][l2].add(r)
                        valToRightLeft[val][r].add(l2)

    intervals = defaultdict(list)
    for val in range(maxVal):
        for l, rights in valToLeftRight[val].items():
            for r in rights:

                intervals[l].append(r)

    @lru_cache(maxsize=None)
    def getBest(left):

        if left == N:
            return 0
        best = float(""inf"")
        for right in intervals[left]:

            best = min(best, 1 + getBest(right + 1))
        return best

    return getBest(0)

if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    N, = list(map(int, input().split()))
    A = list(map(int, input().split()))
    ans = solve(N, A)
    print(ans)
",O(n ^ 3)
"n,d,k=map(int,input().split())
if n==1:
  print(""NO"")
  exit()
if k==1:
  if n==2 and d==1:
    print(""YES"")
    print(1,2)
  else:
    print(""NO"")
  exit()
if n<d+1:
  print(""NO"")
  exit()
co=1
ans=[]
for i in range(1,d+1):
  ans.append((i,i+1))
  co+=1
def dfs(r,dist,co):
  if 2<=r<=d:
    t=k-2
  else:
    t=k-1
  if co==n:
    return co
  for _ in range(t):
    if dist==d:
      return co
    if co==n:
      return co
    co+=1
    ans.append((r,co))
    co=dfs(co,dist+1,co)
  return co
for i in range(2,d+1):
  co=dfs(i,max(i-1,d-i+1),co)
if co==n:
  print(""YES"")
  for j in ans:
    print(*j)
else:
  print(""NO"")",O(n ^ 2)
"class Solution3(object):
    def isValidSequence(self, root, arr):
        def dfs(node, arr, depth):
            if not node or depth == len(arr) or node.val != arr[depth]:
                return False
            if depth+1 == len(arr) and node.left == node.right:
                return True
            return dfs(node.left, arr, depth+1) or dfs(node.right, arr, depth+1)

        return dfs(root, arr, 0)",O(n)
"import sys

def get_new_edges(graph):
    n = len(graph)
    far_vertex = []
    pi = [None]*n
    visit = [False]*n
    visit[0]
    queue = [[0,0]]
    i = 0
    while True:
        if i >= len(queue): break
        current, d = queue[i]
        i += 1
        visit[current] = True
        for v in graph[current]:
            if not visit[v]:
                u = [v, d+1]
                pi[v] = current
                queue.append(u)
                if d+1 > 2:
                    far_vertex.append(u)

    far_vertex.sort(key=lambda x: -x[1])

    pos = [None]*n
    for i, e in enumerate(far_vertex):
        pos[e[0]] = i

    count = 0
    for i in range(len(far_vertex)):
        if not far_vertex[i]: continue
        vertex, depth = far_vertex[i]
        father = pi[vertex]
        count += 1
        if pos[father]:
            far_vertex[pos[father]] = None
        for u in graph[father]:
            if pos[u]:
                far_vertex[pos[u]] = None

    return count

def read_int_line():
    return map(int, sys.stdin.readline().split())

vertex_count = int(input())
graph = [[] for _ in range(vertex_count)]

for i in range(vertex_count - 1):
    v1, v2 = read_int_line()
    v1 -= 1
    v2 -= 1
    graph[v1].append(v2)
    graph[v2].append(v1)

print(get_new_edges(graph))
",O(n)
"class Solution(object):
    def isOneBitCharacter(self, bits):
        parity = 0
        for i in reversed(range(len(bits)-1)):
            if bits[i] == 0:
                break
            parity ^= bits[i]
        return parity == 0",O(n)
"
import threading
import collections


class Solution(object):
    def __init__(self, capacity):
        self.__cv = threading.Condition()
        self.__q = collections.deque()
        self.__cap = capacity

    def enqueue(self, element):
        with self.__cv:
            while len(self.__q) == self.__cap:
                self.__cv.wait()
            self.__q.append(element)
            self.__cv.notifyAll()

    def dequeue(self):
        with self.__cv:
            while not self.__q:
                self.__cv.wait()
            self.__cv.notifyAll()
            return self.__q.popleft()

    def size(self):
        with self.__cv:
            return len(self.__q)
",O(1)
"import os
import sys
from io import BytesIO, IOBase

def main():
    a=list(map(int,input().rstrip()))
    b=list(map(int,input().rstrip()))
    ans,la,lb=[],len(a),len(b)
    if la!=lb:
        print(*sorted(a,reverse=True),sep="""")
    else:
        for i in range(lb):
            if b[i] in a:
                ans.append(b[i])
                a.remove(b[i])
            else:
                while i>-1:
                    ma=-1
                    for j in a:
                        if j<b[i]:
                            ma=max(ma,j)
                    if ma!=-1:
                        ans.append(ma)
                        a.remove(ma)
                        break
                    i-=1
                    a.append(ans.pop())
                a.sort()
                while a:
                    ans.append(a.pop())
                break
        print(*ans,sep="""")

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(n ^ 3)
"import random



class Solution2(object):
    def maximizeSumOfWeights(self, edges, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target):
                i = left
                while i <= right:
                    if compare(nums[i], target):
                        nums[i], nums[left] = nums[left], nums[i]
                        left += 1
                        i += 1
                    elif compare(target, nums[i]):
                        nums[i], nums[right] = nums[right], nums[i]
                        right -= 1
                    else:
                        i += 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx])
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def dfs(u, p):
            result = 0
            diff = []
            for v, w in adj[u]:
                if v == p:
                    continue
                cnt = dfs(v, u)
                result += cnt[0]
                diff.append(max((cnt[1]+w)-cnt[0], 0))
            if k-1 < len(diff):
                nth_element(diff, k-1, lambda a, b: a > b)
            return (result+sum(diff[i] for i in range(min(k, len(diff)))), result+sum(diff[i] for i in range(min(k-1, len(diff)))))

        adj = [[] for _ in range(len(edges)+1)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        return dfs(0, -1)[0]",O(n)
"class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        curr = root

        while curr:
            if not curr.left:
                k -= 1
                if k == 0:
                    return curr.val
                curr = curr.right
            else:
                pred = curr.left
                while pred.right and pred.right != curr:
                    pred = pred.right

                if not pred.right:
                    pred.right = curr
                    curr = curr.left
                else:
                    pred.right = None
                    k -= 1
                    if k == 0:
                        return curr.val
                    curr = curr.right

        return -1
",O(n)
"import os
import sys
from io import BytesIO, IOBase
from array import array

def main():
    n,m,k=map(int,input().split())
    left=[array(""i"",map(int,input().split())) for _ in range(n)]
    down=[array(""i"",map(int,input().split())) for _ in range(n-1)]
    dp=[array(""i"",[(-1 if k&1 else 0) for _ in range(m)]) for _ in range(n)]
    if k&1==0:
        for l in range(k//2):
            dp1=[array(""i"",[10**8 for _ in range(m)]) for _ in range(n)]
            for i in range(n):
                for j in range(m):
                    if j>0:
                        dp1[i][j]=min(dp1[i][j],dp[i][j-1]+2*left[i][j-1])
                    if j<m-1:
                        dp1[i][j]=min(dp1[i][j],dp[i][j+1]+2*left[i][j])
                    if i>0:
                        dp1[i][j]=min(dp1[i][j],dp[i-1][j]+2*down[i-1][j])
                    if i<n-1:
                        dp1[i][j]=min(dp1[i][j],dp[i+1][j]+2*down[i][j])
            dp=dp1
    for i in dp:
        print(*i)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(n ^ 3)
"class Solution(object):
    def findKthBit(self, n, k):
        flip, l = 0, 2**n-1
        while k > 1:
            if k == l//2+1:
                flip ^= 1
                break
            if k > l//2:
                k = l+1-k
                flip ^= 1
            l //= 2
        return str(flip)",O(n)
"class Solution2(object):
    def isAnagram(self, s, t):
        return collections.Counter(s) == collections.Counter(t)",O(n)
"class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        res = [1] * (len(nums))

        prefix = 1
        for i in range(len(nums)):
            res[i] = prefix
            prefix *= nums[i]
        postfix = 1
        for i in range(len(nums) - 1, -1, -1):
            res[i] *= postfix
            postfix *= nums[i]
        return res
",O(n)
"class Solution2(object):
    def myPow(self, x, n):
        if n < 0 and n != -n:
            return 1.0 / self.myPow(x, -n)
        if n == 0:
            return 1
        v = self.myPow(x, n / 2)
        if n % 2 == 0:
            return v * v
        else:
            return v * v * x",O(logn)
"n,m,a,b=[int(x) for x in input().split()]
if n>m:
	if n%m==0:
		print(0)
	else:
		t1=n%m
		print(min(t1*b,(m-t1)*a))
elif n==m:
	print(0)
else:
	print(min(n*b,(m-n)*a))",O(n)
"
class Solution(object):

    def __init__(self):
        self.__overlaps = []
        self.__calendar = []


    def book(self, start, end):
        for i, j in self.__overlaps:
            if start < j and end > i:
                return False
        for i, j in self.__calendar:
            if start < j and end > i:
                self.__overlaps.append((max(start, i), min(end, j)))
        self.__calendar.append((start, end))
        return True



",O(n ^ 2)
"n, K = map(int, input().split())
mod = 998244353
if K == 1:
    print(2)
    exit()
dp = [[0]*(2**2) for i in range(K+1)]
dp[1][0] = 1
dp[2][1] = 1
dp[2][2] = 1
dp[1][3] = 1
for i in range(1, n):
    nx = [[0]*(2**2) for i in range(K+1)]
    for k in range(K+1):
        for j in range(4):
            if j == 0:
                nx[k][0] += dp[k][j]%mod
                if k+1 <= K:
                    nx[k+1][1] += dp[k][j]%mod
                    nx[k+1][2] += dp[k][j]%mod
                    nx[k+1][3] += dp[k][j]%mod
            elif j == 1:
                nx[k][0] += dp[k][j]%mod
                nx[k][1] += dp[k][j]%mod
                if k+2 <= K:
                    nx[k+2][2] += dp[k][j]%mod
                nx[k][3] += dp[k][j]%mod
            elif j == 2:
                nx[k][0] += dp[k][j]%mod
                if k+2 <= K:
                    nx[k+2][1] += dp[k][j]%mod
                nx[k][2] += dp[k][j]%mod
                nx[k][3] += dp[k][j]%mod
            else:
                if k+1 <= K:
                    nx[k+1][0] += dp[k][j]%mod
                    nx[k+1][1] += dp[k][j]%mod
                    nx[k+1][2] += dp[k][j]%mod
                nx[k][3] += dp[k][j]%mod
    dp = nx

print(sum(dp[K])%mod)
",np
"n, k = map(int, input().split())

tm = []

for _ in range(n):
    p, t = map(int, input().split())
    tm.append([p, t])

tm.sort(key=lambda x: (x[0] * -1, x[1]))
ans = tm.count(tm[k-1])
print(ans)
",O(nlogn)
"q = int(input())
for i in range(q):
    x, y, k = map(int, input().split())
    if x > y: x, y = y, x
    m = y
    d = y
    if (y - x) % 2 == 1:
        d -= 1
    if k < m:
        print(-1)
        continue
    r = k - m
    if r % 2 != 0:
        r -= 1
        if d != m:
            d += 1
        else:
            d -= 1
    d += r
    print(d)
",O(1)
"class Solution(object):
    def nthMagicalNumber(self, N, A, B):
        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a

        def check(A, B, N, lcm, target):
            return target//A + target//B - target//lcm >= N

        lcm = A*B // gcd(A, B)
        left, right = min(A, B), max(A, B)*N
        while left <= right:
            mid = left + (right-left)//2
            if check(A, B, N, lcm, mid):
                right = mid-1
            else:
                left = mid+1
        return left % (10**9 + 7)",O(logn)
"a, b = map(int, input().split())
if a == b:
    print(0)
    exit()
aa = """"
bb = """"
while a or b:
    aa += str(a % 2)
    bb += str(b % 2)
    a //= 2
    b //= 2
aa = aa[::-1]
bb = bb[::-1]

idx = 0
while aa[idx] == bb[idx]:
    idx += 1

ln = len(aa)
r = 2 ** (ln - idx) - 1
print(r)
",O(logn)
"import sys
input=sys.stdin.readline
def read():return list(map(int,input().split()))
n,m=read()
a=[]
for i in range(n):
    a.append(read())
sm=0
cur=0
for x, y in a:
    sm+=y
    cur+=x
if sm>m:
    print(-1)
    quit()
cnt=0
a.sort(key=lambda x: -x[0]+x[1])
i = 0
while cur>m and i < n:
    cur -= a[i][0]-a[i][1]
    cnt += 1
    i += 1
print(cnt)",O(nlogn)
"import collections


class Solution(object):
    def subarraysDivByK(self, A, K):
        count = collections.defaultdict(int)
        count[0] = 1
        result, prefix = 0, 0
        for a in A:
            prefix = (prefix+a) % K
            result += count[prefix]
            count[prefix] += 1
        return result",O(n)
"from sys import stdin, stdout
from math import gcd
input = stdin.buffer.readline

x, k = map(int, input().split())
if x == 0:
	print(0)
	exit()
x *= 2
mod = 1000000007
x = pow(2, k, mod) * x % mod - (pow(2, k, mod) - 1)
print(x % mod)
",O(logn)
"s=input()
n=len(s)
m=0

for i in range(n-1):
    for j in range(1,n-i):
        if s[i:i+j] in s[i+1:]:
            if j>m:
                m=j

print(m)
",O(n ^ 3)
"class Solution(object):
    def earliestFullBloom(self, plantTime, growTime):
        order = list(range(len(growTime)))
        order.sort(key=lambda x: growTime[x], reverse=True)
        result = curr = 0
        for i in order:
            curr += plantTime[i]
            result = max(result, curr+growTime[i])
        return result",O(nlogn)
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect, insort
from time import perf_counter
from fractions import Fraction
import copy
from copy import deepcopy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:

    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")
except:
    pass
def pmat(A):
    for ele in A: print(*ele,end=""\n"")

n, m = L()
k = L()[0]
a = [[0] * m for _ in range(n)]
dq = deque()
line = list(map(lambda x: int(x) - 1, L()))
for i in range(0, 2 * k, 2):
    a[line[i]][line[i + 1]] = 1
    dq.append((line[i], line[i + 1]))

x, y = -1, -1
while dq:
    x, y = dq.popleft()
    for tx, ty in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
        if 0 <= tx < n and 0 <= ty < m and not a[tx][ty]:
            a[tx][ty] = 1
            dq.append((tx, ty))

print(f'{x+1} {y+1}')
",O(n ^ 3)
"l,r = list(map(int,input().split()))
f = 0
def gcd(a,b):
    if b == 0:
        return a
    return gcd(b,a%b)
for a in range(l,r+1):
    for b in range(a+1,r+1):
        for c in range(b+1,r+1):

           if (gcd(a,b) == 1) and (gcd(b,c) == 1) and (gcd(a,c)!=1):
                print(a,b,c)
                f = 1
                break
        if f == 1:
            break
    if f == 1:
        break
else:
    print(-1)
",O(1)
"from sys import stdout

n = int(input())

if n % 4 == 2:
    print('!', -1)
    exit(0)

l = 1
r = l + n // 2

memo = [-1] * (n + 1)

def check(i):
    if memo[i] == -1:
        print('?', i)
        stdout.flush()

        memo[i] = int(input())

    return memo[i]

while r >= l:
    a = check(l)
    b = check(l + n // 2)

    if a == b:
        print('!', l)
        exit(0)

    mid = (l + r) >> 1

    c = check(mid)
    d = check(mid + n // 2)

    if c == d:
        print('!', mid)
        exit(0)

    if (a < b and c < d) or (a > b and c > d):
        l = mid + 1

    else:
        r = mid
",O(logn)
"n = int(input())
A = list(map(int, input().split()))
A.sort()
B = [0] * n
ans = 0
for i in range(n):
    if B[i] == 0:
        ans += 1
        B[i] = 1
        for j in range(n):
            if A[j] % A[i] == 0:
                B[j] = 1
print(ans)",O(n ^ 2)
"import collections



class Solution(object):
    def countBadPairs(self, nums):
        result = len(nums)*(len(nums)-1)//2
        cnt = collections.Counter()
        for i, x in enumerate(nums):
            result -= cnt[x-i]
            cnt[x-i] += 1
        return result",O(n)
"import sys

def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def rinput():   return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))

n=iinput()
print(3*n//2)",O(1)
"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**13
mod = 10**9+7
dd = [(-1,0),(0,1),(1,0),(0,-1)]
ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)

def main():
    q = I()
    rr = []

    def f(a,b,c,d):
        if a > c or b > d:
            return (0,0)
        sa = c-a + 1
        sb = d-b + 1
        g = h = (sa * sb) // 2
        if (sa*sb) % 2 == 1:
            g += 1

        if (a+b) % 2 == 0:
            return (g,h)
        return (h,g)

    def fa(a):
        return f(a[0],a[1],a[2],a[3])

    for _ in range(q):
        n,m = LI()
        wa = LI()
        ba = LI()
        wc,bc = f(1,1,n,m)
        w1,b1 = fa(wa)
        w2,b2 = fa(ba)
        w3,b3 = f(max(wa[0],ba[0]),max(wa[1],ba[1]),min(wa[2],ba[2]),min(wa[3],ba[3]))

        wc += b1
        bc -= b1
        wc -= w2
        bc += w2
        wc -= b3
        bc += b3
        rr.append('{} {}'.format(wc,bc))

    return ""\n"".join(map(str,rr))

print(main())
",O(1)
"class Solution2(object):
    def maxFrequency(self, nums, k, numOperations):
        cnt = collections.defaultdict(int) 
        for x in nums:
            cnt[x] += 1
        diff = defaultdict(int)
        for x in nums:
            diff[x] += 0
            diff[x-k] += 1
            diff[x+k+1] -= 1
        result = curr = 0
        for x, c in sorted(diff.items()):
            curr += c
            result = max(result, cnt[x]+min(curr-cnt[x], numOperations))
        return result",O(nlogn)
"class Solution(object):
    def maxProduct(self, A):
        global_max, local_max, local_min = float(""-inf""), 1, 1
        for x in A:
            local_max, local_min = max(x, local_max * x, local_min * x), min(x, local_max * x, local_min * x)
            global_max = max(global_max, local_max)
        return global_max",O(n)
"class Solution(object):
    def maximumScore(self, grid):
        prefix = [0]*(len(grid)+1)
        for i in range(len(grid)):
            prefix[i+1] = prefix[i]+grid[i][0]
        result = 0
        dp = [[0]*(len(grid)+1) for _ in range(2)]
        for j in range(1, len(grid[0])):
            new_prefix = [0]*(len(grid)+1)
            for i in range(len(grid)):
               new_prefix[i+1] = new_prefix[i]+grid[i][j]
            new_dp = [[0]*(len(grid)+1) for _ in range(2)]
            for i in range(len(grid)+1):
                for k in range(i+1):
                    new_dp[0][i] = max(new_dp[0][i], (prefix[i]-prefix[k])+dp[0][k])
                new_dp[0][i] = max(new_dp[0][i], max(dp[1]))
                for k in range(i+1, len(grid)+1):
                    new_dp[1][i] = max(new_dp[1][i], dp[1][k]+(new_prefix[k]-new_prefix[i]))
                new_dp[1][i] = max(new_dp[1][i], new_dp[0][i])
            dp, prefix = new_dp, new_prefix
        return max(dp[1])",O(n ^ 3)
"class Solution5(object):
    def lengthOfLIS(self, nums):
        dp = [] 
        for i in range(len(nums)):
            dp.append(1)
            for j in range(i):
                if nums[j] < nums[i]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp) if dp else 0",O(n ^ 2)
"import sys
lines = int(sys.stdin.readline())
dp = [0] * lines
f = 1
dp[0] = 1

for i in range(lines):
  char_in = sys.stdin.readline()[0]
  if char_in == 'f':
    f += 1
  else:

    for j in range(1, f):
      dp[j] = (dp[j] + dp[j- 1]) % 1000000007
print(dp[f - 1])",O(n ^ 2)
"class Solution2(object):
    def hIndex(self, citations):
        citations.sort(reverse=True)
        h = 0
        for x in citations:
            if x >= h + 1:
                h += 1
            else:
                break
        return h",O(nlogn)
"def l(a):
    b=bin(a)[2:]
    b=""0""*(e-len(b))+b
    d=len(b)
    for i in range(d-1,-1,-1):
        if b[i]==""1"":
            c=d-1-i
            break
    if c==0:
        return -1
    return (a-2**(c-1))

def r(a):
    b=bin(a)[2:]
    b=""0""*(e-len(b))+b
    d=len(b)
    for i in range(d-1,-1,-1):
        if b[i]==""1"":
            c=d-1-i
            break
    if c==0:
        return -1
    return (a+2**(c-1))

def u(a):
    b=bin(a)[2:]
    b=""0""*(e-len(b))+b
    d=len(b)
    for i in range(d-1,-1,-1):
        if b[i]==""1"":
            c=d-1-i
            break
    if c==d-1:
        return -1
    else:
        if b[d-1-c-1]==""0"":
            return a+(2**c)
        else:
            return a-(2**c)

n,q=list(map(int,input().split()))
e=len(bin(n)[2:])
for i in range(q):
    a=int(input())
    b=input()
    for i in range(len(b)):
        if b[i]==""U"":
            c=u(a)
            if c!=-1:
                a=c
        elif b[i]==""R"":
            c=r(a)
            if c!=-1:
                a=c
        elif b[i]==""L"":
            c=l(a)
            if c!=-1:
                a=c
    print(a)",np
"import collections



class Solution(object):
    def minimumRounds(self, tasks):
        cnt = collections.Counter(tasks)
        return sum((x+2)//3 for x in cnt.values()) if 1 not in iter(cnt.values()) else -1",O(n)
"import itertools


class Solution(object):
    def widestPairOfIndices(self, nums1, nums2):
        lookup = {0:-1}
        result = total = 0
        for i, (n1, n2) in enumerate(zip(nums1, nums2)):
            total += n1-n2
            if total not in lookup:
                lookup[total] = i
            result = max(result, i-lookup[total])
        return result",O(n)
"n, m = [int(x) for x in input().split()]

a = [int(x) for x in input().split()]

a.sort()
last = 0
total = 0
for i in range(n - 1):
    if a[i]>0 :
        total += a[i] - 1
        last = min(last + 1, a[i])

print(total + max(a[n-1] - max(1, a[n - 1] - last), 0))",O(nlogn)
"import sys,bisect,string,math,time,functools,random,fractions
from heapq import heappush,heappop,heapify
from collections import deque,defaultdict,Counter
from itertools import permutations,combinations,groupby
rep=range;R=range
def Golf():n,*t=map(int,open(0).read().split())
def I():return int(input())
def S_():return input()
def IS():return input().split()
def LS():return [i for i in input().split()]
def MI():return map(int,input().split())
def LI():return [int(i) for i in input().split()]
def LI_():return [int(i)-1 for i in input().split()]
def NI(n):return [int(input()) for i in range(n)]
def NI_(n):return [int(input())-1 for i in range(n)]
def StoLI():return [ord(i)-97 for i in input()]
def ItoS(n):return chr(n+97)
def LtoS(ls):return ''.join([chr(i+97) for i in ls])
def RA():return map(int,open(0).read().split())
def RLI(n=8,a=1,b=10):return [random.randint(a,b)for i in range(n)]
def RI(a=1,b=10):return random.randint(a,b)
def Rtest(T):
    case,err=0,0
    for i in range(T):
        inp=INP()
        a1,ls=naive(*inp)
        a2=solve(*inp)
        if a1!=a2:
            print((a1,a2),inp)
            err+=1
        case+=1
    print('Tested',case,'case with',err,'errors')
def GI(V,E,ls=None,Directed=False,index=1):
    org_inp=[];g=[[] for i in range(V)]
    FromStdin=True if ls==None else False
    for i in range(E):
        if FromStdin:
            inp=LI()
            org_inp.append(inp)
        else:
            inp=ls[i]
        if len(inp)==2:
            a,b=inp;c=1
        else:
            a,b,c=inp
        if index==1:a-=1;b-=1
        aa=(a,c);bb=(b,c);g[a].append(bb)
        if not Directed:g[b].append(aa)
    return g,org_inp
def GGI(h,w,search=None,replacement_of_found='.',mp_def={'

    mp=[boundary]*(w+2);found={}
    for i in R(h):
        s=input()
        for char in search:
            if char in s:
                found[char]=((i+1)*(w+2)+s.index(char)+1)
                mp_def[char]=mp_def[replacement_of_found]
        mp+=[boundary]+[mp_def[j] for j in s]+[boundary]
    mp+=[boundary]*(w+2)
    return h+2,w+2,mp,found
def TI(n):return GI(n,n-1)
def accum(ls):
    rt=[0]
    for i in ls:rt+=[rt[-1]+i]
    return rt
def bit_combination(n,base=2):
    rt=[]
    for tb in R(base**n):s=[tb//(base**bt)%base for bt in R(n)];rt+=[s]
    return rt
def gcd(x,y):
    if y==0:return x
    if x%y==0:return y
    while x%y!=0:x,y=y,x%y
    return y
def YN(x):print(['NO','YES'][x])
def Yn(x):print(['No','Yes'][x])
def show(*inp,end='\n'):
    if show_flg:print(*inp,end=end)

mo=10**9+7
inf=float('inf')
FourNb=[(-1,0),(1,0),(0,1),(0,-1)];EightNb=[(-1,0),(1,0),(0,1),(0,-1),(1,1),(-1,-1),(1,-1),(-1,1)];compas=dict(zip('WENS',FourNb));cursol=dict(zip('LRUD',FourNb))
l_alp=string.ascii_lowercase

read=sys.stdin.buffer.read;readline=sys.stdin.buffer.readline;input=lambda:sys.stdin.readline().rstrip()

show_flg=False
show_flg=True

ans=0

x,y,z=LI()
R=sorted(LI())[::-1]
G=sorted(LI())[::-1]
B=sorted(LI())[::-1]

dp=[[[0]*(z+1) for j in range(y+1)]for i in range(x+1)]

n=x+y+z
for t in range(0,n+1,2):
    for i in range(x+1):
        for j in range(y+1):
            k=t-i-j
            if 0<=k<=z:
                if i+1<=x and j+1<=y:dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j])
                if i+1<=x and k+1<=z:dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k])
                if j+1<=y and k+1<=z:dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+G[j]*B[k])

ans=max([dp[i][y][z]for i in range(x+1)])
ans=max(max([dp[x][i][z]for i in range(y+1)]),ans)
ans=max(max([dp[x][y][i]for i in range(z+1)]),ans)

print(ans)
",O(n ^ 3)
"a=int(input())
l=[]
total=0
for i in range(4):
    line=''

    for x in [0]*a:
        line+=input()
    l.append(line)
    input() if i!=3 else 0
l=sorted(l,key=lambda i: i[0::2].count('1')+i[1::2].count('0'))[::-1]
for z,v in enumerate(l):
    if z<2:
        for i in range(a**2):
            total += v[i]!='0' if i%2 else v[i]!='1'
    else:
        for i in range(a**2):
            total += v[i]!='1' if i%2 else v[i]!='0'
print(total)",O(n ^ 2)
"n = int(input())
print(n * n + (n - 1) **2)
",O(1)
"entrada = input().split()

l = int(entrada[0])
r = int(entrada[1])

pop = l ^ r
result = 1

while (result <= pop):
    result = result << 1

print(result - 1)
",O(logn)
"t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    if n == 1:
        print(0)
    else:
        max1 = max2 = -1
        for q in a:
            if q > max1:
                max1, max2 = q, max1
            elif q > max2:
                max2 = q
        print(max(0, min(max2-1, len(a)-2)))
",O(n)
"n,k = map(int,input().split())

def sumTillN (n) :
    return (n*(n+1))//2

minEat = 0
maxEat = n
midEat = 0

while (minEat<=maxEat):
    midEat = (minEat+maxEat)//2
    x = sumTillN(n-midEat)
    if (x==k+midEat):
        break
    elif (x>k+midEat):
        minEat = midEat+1
    else:
        maxEat = midEat-1

print(midEat)
",O(logn)
"class Solution(object):
    def maxScore(self, s):
        result, zeros, ones = 0, 0, 0
        for i in range(1, len(s)-1):
            if s[i] == '0':
                zeros += 1
            else:
                ones += 1
            result = max(result, zeros-ones)
        return result + ones + (s[0] == '0') + (s[-1] == '1')",O(n)
"class Solution(object):
    def exclusiveTime(self, n, logs):
        result = [0] * n
        stk, prev = [], 0
        for log in logs:
            tokens = log.split("":"")
            if tokens[1] == ""start"":
                if stk:
                    result[stk[-1]] += int(tokens[2]) - prev
                stk.append(int(tokens[0]))
                prev = int(tokens[2])
            else:
                result[stk.pop()] += int(tokens[2]) - prev + 1
                prev = int(tokens[2]) + 1
        return result",O(n)
"n = int(input())
dis = list(map(lambda x: int(x) << 1, input().split()))
ter = input()
st, ans = 0, 0
time = {'G': 5, 'W': 3, 'L': 1}
delta = {'G':1, 'W':1, 'L':-1}
hasWater = False
convert = 0
for i in range(n):
	st += dis[i] * delta[ter[i]]
	ans += dis[i] * time[ter[i]]

	if ter[i] == 'W':
		hasWater = True
	elif ter[i] == 'G':
		convert += dis[i]
	if st < 0:
		if hasWater:
			ans += (-st) * 3
		else:
			ans += (-st) * 5
		st = 0
	convert = min(convert, st // 2)

ans -= 4 * convert
ans -= 2 * (st // 2 - convert)
print(ans // 2)
",O(n)
"N,M=map(int,input().split())
L=[0]+[int(_) for _ in input().split()]+[M]
sumL=[0]
ans=-10**30
for i in range(1,N+1):
    sumL.append(sumL[-1]-(-1)**i*L[i])
for i in range(1,N+1):
    if L[i]>L[i-1]+1:
        ans=max(ans,2*sumL[i-1]-sumL[-1]-(-1)**(i)*(L[i]-1))
    if L[i]<L[i+1]-1:
        ans=max(ans,2*sumL[i]-sumL[-1]+(-1)**i*(L[i]+1))
if N%2==0:
    print(max(ans,sumL[-1]+M))
else:
    print(max(ans+M,sumL[-1]))",O(n)
"class Solution3(object):
    def maxOutput(self, n, edges, price):
        def iter_dfs():
            dp = [0]*n 
            stk = [(1, 0, -1)]
            while stk:
                step, u, p = stk.pop()
                if step == 1:
                    stk.append((2, u, p))
                    for v in adj[u]:
                        if v == p:
                            continue
                        stk.append((1, v, u))
                elif step == 2:
                    dp[u] = price[u]
                    for v in adj[u]:
                        if v == p:
                            continue
                        dp[u] = max(dp[u], dp[v]+price[u])
            return dp
        
        def iter_dfs2():
            result = 0
            stk = [(0, -1, 0)]
            while stk:
                u, p, curr = stk.pop()
                result = max(result, curr, dp[u]-price[u])
                top2 = [[curr, p], [0, -1]]
                for v in adj[u]:
                    if v == p:
                        continue
                    curr = [dp[v], v]
                    for i in range(len(top2)):
                        if curr > top2[i]:
                            top2[i], curr = curr, top2[i]
                for v in adj[u]:
                    if v == p:
                        continue
                    stk.append((v, u, (top2[0][0] if top2[0][1] != v else top2[1][0])+price[u]))
            return result
    
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = iter_dfs()
        return iter_dfs2()",O(n)
"n, m = map(int, input().split())
b = list(map(int, input().split()))
g = list(map(int, input().split()))
mab = max(b)
mig = min(g)
if mab > mig:
    print(-1)
    exit()

b = sorted(b, reverse=True)
g = sorted(g)
num = 0
j = 0
for i in range(n):
    k = 0
    l = 1
    while j < m and k < m - l and b[i] <= g[j]:
        if b[i] == g[j]:
            l = 0
        num += g[j]
        j += 1
        k += 1
    num += b[i] * (m - k)

print(num)",O(nlogn)
"class Solution:
    def checkValidString(self, s: str) -> bool:
        n = len(s)
        dp = [[False] * (n + 1) for _ in range(n + 1)]
        dp[n][0] = True

        for i in range(n - 1, -1, -1):
            for open in range(n):
                res = False
                if s[i] == '*':
                    res |= dp[i + 1][open + 1]
                    if open > 0:
                        res |= dp[i + 1][open - 1]
                    res |= dp[i + 1][open]
                else:
                    if s[i] == '(':
                        res |= dp[i + 1][open + 1]
                    elif open > 0:
                        res |= dp[i + 1][open - 1]
                dp[i][open] = res

        return dp[0][0]
",O(n ^ 2)
"class Solution3(object):
    def minCost(self, nums, x):
        result = [x*k for k in range(len(nums)+1)]
        for i in range(len(nums)):
            curr = nums[i]
            for k in range(len(result)):
                curr = min(curr, nums[(i+k)%len(nums)])
                result[k] += curr
        return min(result)",O(n ^ 2)
"n=int(input())
l=[4,7,47,74,44,77,447,444,474,777,747,744,477]
c=0
for i in range(len(l)):
    if n%l[i]==0:
        c=1
        break
if c==1:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"
import pandas as pd



def Solution(students: pd.DataFrame) -> pd.DataFrame:
    students.dropna(subset=[""name""], inplace=True)
    return students
",O(n)
"class Solution(object):
    def waysToSplit(self, nums):
        MOD = 10**9+7

        prefix = [0]
        for x in nums:
            prefix.append(prefix[-1]+x)

        result = left = right = 0 
        for i in range(len(nums)): 
            left = max(left, i+1)
            while left+1 < len(nums) and prefix[i+1] > prefix[left+1]-prefix[i+1]:
                left += 1
            right = max(right, left)
            while right+1 < len(nums) and prefix[right+1]-prefix[i+1] <= prefix[-1]-prefix[right+1]:
                right += 1
            result = (result + (right-left))%MOD
        return result",O(n)
"n, m = map(int, input().split())
a = []
b = []
check = True
while n >= 0:
    if check == True:
        a.append(5)
        n -= 5
        b.append(4)
        check = False
    else:
         check = True
         a.append(4)
         n -= 4
         b.append(5)

a.append(5)
b.append(5)

print(*a, sep = """")
print(*b, sep = """")
",O(1)
"d = [list(map(int, input().split())) for i in range(int(input()))]

s = 0

for k in range(1, 10001):

    p = [min(max((k - l) / (r - l + 1), 1e-20), 1) for l, r in d]

    u = v = 1

    for r in p: u *= r

    for r in p:

        v *= r

        s += (u - v) * (r - 1) / r

print(s)
",np
"class Solution2(object):

    def __init__(self):
        self.__arr = []
        self.__op = [1, 0]

    def append(self, val):
        self.__arr.append((val-self.__op[1])*pow(self.__op[0], MOD-2, MOD)%MOD) 

    def addAll(self, inc):
        self.__op[1] = (self.__op[1]+inc) % MOD

    def multAll(self, m):
        self.__op = [(self.__op[0]*m) % MOD, (self.__op[1]*m) % MOD]

    def getIndex(self, idx):
        if idx >= len(self.__arr):
            return -1
        a, b = self.__op
        return (self.__arr[idx]*a + b) % MOD",O(1)
"class Solution4(object):
    def specialArray(self, nums):
        nums.sort(reverse=True) 
        for i in range(len(nums)): 
            if nums[i] <= i:
                break
        else:
            i += 1
        return -1 if i < len(nums) and nums[i] == i else i",O(nlogn)
"import os
import sys
from math import *
from collections import *

from bisect import *
from io import BytesIO, IOBase

def vsInput():
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA = ""abcdefghijklmnopqrstuvwxyz/""
M = 1000000007
EPS = 1e-6

def Ceil(a, b):
    return a // b + int(a % b > 0)

def value():
    return tuple(map(int, input().split()))

def array():
    return [int(i) for i in input().split()]

def Int():
    return int(input())

def Str():
    return input()

def arrayS():
    return [i for i in input().split()]

n = int(input())
s = input()
ans = 0
cnt = 0
for x in s:
    if x == ""x"":
        cnt += 1
        if cnt >= 3:
            ans += 1
    else:
        cnt = 0
print(ans)
",O(n)
"from math import floor
import re

z = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""

def convert_num(x):
    output = """"
    row, col = [int(x) for x in re.split(""(\d+)"", x) if x.isnumeric()]
    while col > 0:
        y = (col - 1) % 26
        output += z[y]
        col = floor((col - 1) / 26)
    return f""{output[::-1]}{row}""

def convert_alpha(x):
    output = 0
    word = ("""".join([i for i in x if i.isalpha()]))[::-1]
    for i in range(0, len(word)):
        output += (z.index(word[i]) + 1) * 26 ** i
    ending = x[len(word) :]

    return f""R{ending}C{output}""

i = int(input())
output = """"
for x in range(i):
    hehexd = input()
    if hehexd.startswith(""R"") and hehexd[1].isnumeric() and ""C"" in hehexd:
        output += f""{convert_num(hehexd)}\n""
    else:
        output += f""{convert_alpha(hehexd)}\n""
print(output)",O(n)
"import collections
import itertools



class Solution2(object):
    def rearrangeString(self, s, k):
        if not k:
            return s
        cnts = collections.Counter(s)
        bucket_cnt = (len(s)+k-1)//k
        if not (max(cnts.values()) <= bucket_cnt and list(cnts.values()).count(bucket_cnt) <= (len(s)-1)%k+1):
            return """"
        result = [0]*len(s)
        i = 0
        for c in itertools.chain((c for c, v in cnts.items() if v == bucket_cnt),
                                 (c for c, v in cnts.items() if v <= bucket_cnt-2),
                                 (c for c, v in cnts.items() if v == bucket_cnt-1)):
            for _ in range(cnts[c]):
                result[i] = c
                i += k
                if i >= len(result):
                    i = i%k+1
        return """".join(result)",O(n)
"import math,sys,bisect,heapq,os
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate
from functools import lru_cache

int1 = lambda x: int(x) - 1
def input(): return sys.stdin.readline().rstrip('\r\n')

aj = lambda: list(map(int, input().split()))
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]

def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])

def solve():
	G = defaultdict(list)

	def addEdge(a,b):
		G[a].append(b)

	def Kahn(N):
	    in_degree = [0]*(N+1)
	    for i in G.keys():
	        for j in G[i]:
	            in_degree[j] += 1
	    queue = deque()
	    for i in range(1,N+1):
	        if in_degree[i] == 0:
	            queue.append(i)
	    cnt =0
	    top_order = []
	    while queue:
	        u = queue.popleft()
	        top_order.append(u)
	        for i in G.get(u,[]):
	            in_degree[i] -= 1
	            if in_degree[i] == 0:
	                queue.append(i)
	        cnt += 1
	    if cnt != N:
	        Y(0);exit(0)
	    else:
	        Y(1);print(*top_order)

	n,m,k = aj()
	mark= {}
	for i in range(n):
		s = input()
		mark[s] = i+1

	B = []
	for i in range(2**k):
		f = bin(i)[2:]
		f = '0'*(k - len(f)) + f
		B.append(f)

	for i in range(m):
		s,mt = input().split("" "")
		mt = int(mt)
		st = set()
		for j in B:
			ss = ['']*k
			for l in range(k):
				if j[l] == '1':
					ss[l] = s[l]
				else:
					ss[l] = '_'
			ss = """".join(ss)
			if ss in mark:
				st.add(mark[ss])

		if mt not in st:
			Y(0);exit(0)
		st.discard(mt)
		for j in st:
			addEdge(mt,j)

	Kahn(n)

try:

	sys.stdin = open('input.txt', 'r')
	sys.stdout = open('output.txt', 'w')
except:
	pass

solve()",np
"n, s = list(map(int, input().split()))

def sum_of_digits(n):
	ans = 0
	for c in str(n):
		ans += int(c)
	return ans
m = s + 10 - s%10

while m - sum_of_digits(m) < s:
	m += 10
if m <= n:
	print(n - m + 1)
else:
	print(0)
",O(logn)
"n, m = map(int, input().split())
ans = m // n + min(1, m % n)
print(ans)",O(1)
"import collections


class Solution2(object):
    def findBottomLeftValue(self, root):
        last_node, q = None, collections.deque([root])
        while q:
            last_node = q.popleft()
            q.extend([n for n in [last_node.right, last_node.left] if n])
        return last_node.val",O(n)
"n, m, k, l = map(int, input().split())
if k + l > n:
    print(-1)
else:
    x = (k + l) // m + (1 if (k + l) % m != 0 else 0)
    if x * m > n:
        print(-1)
    else:
        print(x)
",O(1)
"a=input()
b=int(a)+1
if b==1 :
    print(""0"")
elif b%2==0 :
    print(b//2)
elif b%2!=0 :
    print(b)",O(1)
"import sys

input=sys.stdin.readline

n=int(input())

c=list(map(int,input().split()))
ans=0

for i in range(n):

    f=c.pop(0)
    g=c.index(f)
    c.pop(g)
    ans+=g

print(ans)",O(n ^ 2)
"class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        nums = [1] + nums + [1]
        dp = {}
        def dfs(l, r):
            if l > r:
                return 0
            if (l, r) in dp:
                return dp[(l, r)]

            dp[(l, r)] = 0
            for i in range(l, r + 1):
                coins = nums[l - 1] * nums[i] * nums[r + 1]
                coins += dfs(l, i - 1) + dfs(i + 1, r)
                dp[(l, r)] = max(dp[(l, r)], coins)
            return dp[(l, r)]

        return dfs(1, len(nums) - 2)
",O(n ^ 3)
"class Solution2(object):
    def maximalRectangle(self, matrix):
        if not matrix:
            return 0

        result = 0
        m = len(matrix)
        n = len(matrix[0])
        L = [0 for _ in range(n)]
        H = [0 for _ in range(n)]
        R = [n for _ in range(n)]

        for i in range(m):
            left = 0
            for j in range(n):
                if matrix[i][j] == '1':
                    L[j] = max(L[j], left)
                    H[j] += 1
                else:
                    L[j] = 0
                    H[j] = 0
                    R[j] = n
                    left = j + 1

            right = n
            for j in reversed(range(n)):
                if matrix[i][j] == '1':
                    R[j] = min(R[j], right)
                    result = max(result, H[j] * (R[j] - L[j]))
                else:
                    right = j

        return result",O(n ^ 2)
"class Solution(object):
    def soupServings(self, N):
        def dp(a, b, lookup):
            if (a, b) in lookup:
                return lookup[a, b]
            if a <= 0 and b <= 0:
                return 0.5
            if a <= 0:
                return 1.0
            if b <= 0:
                return 0.0
            lookup[a, b] = 0.25 * (dp(a-4, b, lookup) +
                                   dp(a-3, b-1, lookup) +
                                   dp(a-2, b-2, lookup) +
                                   dp(a-1, b-3, lookup))
            return lookup[a, b]

        if N >= 4800:
            return 1.0
        lookup = {}
        N = (N+24)//25
        return dp(N, N, lookup)",O(n ^ 2)
"from math import factorial

s1 = input()
s2 = input()

finPos=0
for c in s1:
	if c=='+': finPos+=1
	else: finPos-=1

stPos=0
for c in s2:
	if c=='+': stPos+=1
	elif c=='-': stPos-=1

n=s2.count('?')
diff=abs(finPos-stPos)
if diff > n:
	print(0)
elif n&1 != diff&1:
	print(0)
else:
	i=0
	for i in range(n//2,n):
		if i*2-n == diff: break
	if i*2-n != diff: i+=1

	print((factorial(n)/(factorial(n-i)*factorial(i)))/(1<<n))",np
"class Solution(object):

    def encode(self, strs):
        encoded_str = """"
        for s in strs:
            encoded_str += ""%0*x"" % (8, len(s)) + s
        return encoded_str


    def decode(self, s):
        i = 0
        strs = []
        while i < len(s):
            l = int(s[i:i+8], 16)
            strs.append(s[i+8:i+8+l])
            i += 8+l
        return strs",O(n)
"n = int(input())
a = list(map(int,input().split()))
fl = False
ans = True
for i in range(n-1):
    if a[i+1]>a[i]:
        if fl:
            ans = False
    else:
        fl = True
if ans:
    print('YES')
else:
    print('NO')",O(n)
"import sys
input = sys.stdin.readline

n,m,k=map(int,input().split())
A=list(map(int,input().split()))
A.append(n+1)
COMP=[]
NOW=0
for a in A:
    if a-NOW-1!=0:
        if a-NOW-1>2*k:
            COMP.append([(a-NOW-1)%k+k,0])
        else:
            COMP.append([a-NOW-1,0])
    COMP.append([1,1])
    NOW=a

COMP.pop()

ANS=0
NOW_PAGE=0
NOW_SCORE=0

pa=0
LEN=len(COMP)
while pa<LEN:
    i,j=COMP[pa]

    if NOW_PAGE+i<=k:
        NOW_PAGE += i
        NOW_SCORE += j
        pa+=1

    else:
        if NOW_SCORE>0:

            COMP[pa][0]-=k-NOW_PAGE
            NOW_PAGE=k-NOW_SCORE

            ANS+=1
            NOW_SCORE=0

        else:
            if NOW_PAGE==k:
                NOW_PAGE=0

            else:
                COMP[pa][0]-=k-NOW_PAGE
                NOW_PAGE=k-NOW_SCORE

if NOW_SCORE>0:
    ANS+=1

print(ANS)
",O(n)
"import itertools



class Solution(object):
    def minimumCosts(self, regular, express, expressCost):
        result = []
        dp = [0, expressCost] 
        for r, e in zip(regular, express):
            dp = [min(dp[0]+r, dp[1]+e), min(dp[0]+(r+expressCost), dp[1]+e)]
            result.append(min(dp[0], dp[1]))
        return result",O(n)
"a=''.join(reversed(sorted(input())))
b=int(input())
r=''
while len(a)>0:
    for i in range(len(a)):
        n=r+a[i]+''.join(sorted(a[:i]+a[i+1:]))
        if int(n)<=b:
            r+=a[i]
            a=a[:i]+a[i+1:]
            break
print(r)",O(n ^ 3)
"def bigNumber(n, s):
  for i in range(s, n + 1):
    sumVal = 0
    num = i
    while num:
      sumVal += num % 10
      num //= 10
    if i - sumVal >= s:
      print(n - i + 1)
      return
  print(0)

n, s = (int(x) for x in input().split())
bigNumber(n,s)
",O(logn)
"class Solution(object):
    def lexicalOrder(self, n):
        result = []

        i = 1
        while len(result) < n:
            k = 0
            while i * 10**k <= n:
                result.append(i * 10**k)
                k += 1

            num = result[-1] + 1
            while num <= n and num % 10:
                result.append(num)
                num += 1

            if not num % 10:
                num -= 1
            else:
                num /= 10

            while num % 10 == 9:
                num /= 10

            i = num+1

        return result",O(n)
"import sys
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
ns = lambda: readline().rstrip()
ni = lambda: int(readline().rstrip())
nm = lambda: map(int, readline().split())
nl = lambda: list(map(int, readline().split()))

r, g, b = nm()
R = nl()
G = nl()
B = nl()
dp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)
R.insert(0, 0)
G.insert(0, 0)
B.insert(0, 0)
dp[0][0][0], ans = 0, 0
for i in range(0, r+1):
    for j in range(0, g+1):
        for k in range(0, b+1):
            if i==0 and j==0 and k==0:continue
            if i and j and dp[i - 1][j - 1][k] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j])
            if k and j and dp[i][j - 1][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j])
            if i and k and dp[i - 1][j][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k])
            ans = max(ans, dp[i][j][k])
print(ans)",O(n ^ 3)
"class Solution(object):
    def minimumSwaps(self, nums):
        min_idx = min(range(len(nums)), key=nums.__getitem__)
        max_idx = max(reversed(range(len(nums))), key=nums.__getitem__)
        return ((len(nums)-1)-max_idx)+min_idx-int(max_idx < min_idx)",O(n)
"n = int(input())
l = list(map(int,input().split()))
c1 = 0
c2 = 0
for i in l:
    if i % 2 == 0:
        c1+=1
    else:
        c2+=1

for i in range(len(l)-1,-1,-1):
    if l[i] % 2 == 0:
        lasteven = i
        break
for i in range(len(l)-1,-1,-1):
    if l[i] % 2 != 0:
        lastodd = i
        break
if c1 == 1:
    print(lasteven + 1)
else:
    print(lastodd + 1)
",O(n)
"import sys
input=sys.stdin.readline
s=list(input().rstrip())
n=len(s)
s.extend(s)
cnt=0
c=1
for i in range(len(s)-1):
  if s[i]!=s[i+1]:
    c+=1
  else:
    cnt=max(c,cnt)
    c=1
cnt=max(cnt,c)
print(min(cnt,n))",O(n)
"n, k = map(int, input().split())

a = 1
b = -(2*n+3)
c = (n*n+n-2*k)

d = int((b*b - 4*a*c) ** 0.5)

s1 = (-b + d) // (2 * a)
s2 = (-b - d) // (2 * a)
if s1 >= 0 and s1 <= n:
    print(s1)
else:
    print(s2)
",O(1)
"from sys import stdin, setrecursionlimit
from bisect import bisect_right

setrecursionlimit(15000)

def get_gdict(arr):
	gdict = dict()
	for i in range(len(arr)):
		if arr[i] in gdict:
			gdict[arr[i]] += 1
		else:
			gdict[arr[i]] = 1
	return gdict

def initial_check(barr, garr):
	for i in garr:
		if i < barr[-1]:
			return False
	return True

n, m = list(map(int, stdin.readline().split()))
barr = list(map(int, stdin.readline().split()))
garr = list(map(int, stdin.readline().split()))
barr.sort()
garr.sort()
ans = 0
gdict = get_gdict(garr)
if initial_check(barr, garr):
	count  = m
	b = n - 1
	g = m - 1
	while count  > 0:
		tempb = [barr[b]] * (m)

		for i in range(len(tempb)):
			if count <= 0:
				for j in range(i, m):
					ans += tempb[b]
				break

			if tempb[i] in gdict:
				gdict[tempb[i]] -= 1
				ans += (tempb[i])
				count -= 1
				if gdict[tempb[i]] == 0:
					del gdict[tempb[i]]
			else:
				if i == 0:
					ans += (tempb[i])
					continue
				for k in range(g, -1, -1):
					if garr[k] in gdict:
						ans += garr[g]
						g = k - 1
						count -= 1
						break

		b -= 1

	while b >= 0:
		ans += m * (barr[b])
		b -= 1
	print(ans)

else:
	print(-1)",O(n ^ 3)
"class Solution(object):
    def countMatches(self, items, ruleKey, ruleValue):
        rule = {""type"":0, ""color"":1, ""name"":2}
        return sum(item[rule[ruleKey]] == ruleValue for item in items)",O(n)
"m = 1000000007
x, k = map(int, input().split())
up = (x * pow(2, k + 1, m)) % m
down = pow(2, k, m) - 1
if (x == 0):
    print(0)
else:
    print((up - down) % m)",O(logn)
"MOD=1000000007
def pow2(n):
    if n==0:
        return 1
    t=pow2(n//2)%MOD
    m=(t*t)%MOD
    if n%2==1:
        m=(m*2)%MOD
    return m
x,k=map(int,input().split())
if x==0:
    print(0)
    exit()
t=pow2(k)*(2*x-1)%MOD
print((t+1)%MOD)
",O(logn)
"def init_input():
    import os
    from sys import stdin
    it = iter(os.read(stdin.fileno(), 10 ** 7).split())
    return lambda: next(it).decode(), lambda: int(next(it)), lambda: float(next(it))
ns, ni, nf = init_input()

MOD = 10 ** 9 + 7

n, q = ni(), ni()
s = 'x' + ns()
c = [0] * (n + 1)
for i in range(1, n + 1):
    c[i] = c[i - 1] + (s[i] == '1')

p2 = [1] * (2 * n + 1)
for i in range(1, 2 * n + 1):
    p2[i] = p2[i - 1] * 2 % MOD

out = []
for qq in range(q):
    l, r = ni(), ni()
    o = c[r] - c[l - 1]
    z = (r - l + 1) - o
    ans = (p2[o + z] - 1 - p2[z] + 1) % MOD
    out.append(ans)
print(*out, sep='\n')
",O(n)
"class Solution2(object):
    def lastMarkedNodes(self, edges):
        def increase(x):
            return (x[0]+1, x[1])

        def bfs():
            dp = [[(0, u)]*2 for u in range(len(adj))]
            new_root = -1
            degree = list(map(len, adj))
            q = [u for u in range(len(degree)) if degree[u] == 1]
            while q:
                new_q = []
                for u in q:
                    if degree[u] == 0:
                        new_root = u
                        continue
                    degree[u] -= 1
                    for v in adj[u]:
                        if degree[v] == 0:
                            continue
                        curr = increase(dp[u][0])
                        for i in range(len(dp[v])):
                            if curr > dp[v][i]:
                                curr, dp[v][i] = dp[v][i], curr
                        degree[v] -= 1
                        if degree[v] == 1:
                            new_q.append(v)
                q = new_q
            return dp, new_root

        def bfs2(root):
            result = [-1]*len(adj)
            q = [(root, -1, (0, -1))]
            while q:
                new_q = []
                for u, p, curr in q:
                    result[u] = max(dp[u][0], curr)[1]
                    for v in adj[u]:
                        if v == p:
                            continue
                        new_q.append((v, u, increase(max(dp[u][dp[u][0][1] == dp[v][0][1]], curr))))
                q = new_q
            return result

        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp, u = bfs()
        return bfs2(u)",O(n)
"n,t=int(input()),1
while n>0:
        if n!=3:
            k=n//2+n%2
            print((str(t)+' ')*k,end= '')
            n-=k
            t*=2
        else:
            print(t,t,t*3)
            n=0
",O(1)
"class Solution2(object):
    def canBeEqual(self, target, arr):
        target.sort(), arr.sort()
        return target == arr",O(nlogn)
"n = int(input())-1
c = 0
for i in range(11):
	c += 9*(i+1)* 10**i
	if c > n:
		n -= (c - 9*(i+1)* 10**i)
		v = n // (i+1)
		print(str(10**i + v)[n%(i+1)])
		break
",O(logn)
"import sys
readline = sys.stdin.readline

N = int(readline())
M = float(readline())
A = list(map(int, readline().split()))
B = list(map(int, readline().split()))
B = B[1:] + [B[0]]
C = []
for a, b in zip(A[::-1], B[::-1]):
    C.append(b)
    C.append(a)

if 1 in C:
    print(-1)
else:
    M0 = M
    for c in C:
        M += M/(c-1)

    print(M-M0)",O(n)
"from sys import stdin
input=stdin.readline
from collections import defaultdict
def f(d,n):
    res=0
    prev=None
    ans=[0]*(n+1)
    for i in sorted(d.keys()):

        if prev==None:
            prev=i
        else:
            ans[res]+=i-prev
            prev=i
        res+=d[i]
    return ans[1:]

n=int(input())
d=defaultdict(int)
for i in range(n):
    x,y=map(int,input().strip().split())
    d[x]+=1
    d[y+1]-=1
print(*f(d,n))",O(nlogn)
"a,b,c,n=map(int,input().split())
if n-a-b+c>=1:
    if a<c or b<c:
        print(-1)
    else:
        print(n-a-b+c)
else:
    print(-1)",O(1)
"n, k = map(int, input().split())
a = list(map(int, input().split()))
s = []
for q in range(n-1):
    s.append([a[q+1]-a[q], q])
s.sort(reverse=True)
d = {q[1] for q in s[:k-1]}
ans = 0
q1 = a[0]
for q in range(n-1):
    if q in d:
        ans += a[q]-q1
        q1 = a[q+1]
print(ans+a[-1]-q1)
",O(nlogn)
"n, k= map(int, input().split())
A = list(map(int, input().split()))
C = [0] * 100001

l = 0
r = 0
p = 0

while r<n and p < k:
    C[A[r]] += 1
    if C[A[r]] == 1:
        p += 1
    r += 1
if p != k:
    print('-1', '-1')
else:
    while p == k:
        C[A[l]] -= 1
        if C[A[l]] == 0:
            p -= 1
        l +=1

    l -= 1

    print(l+1,r)",O(n)
"import itertools
import heapq


class Solution(object):
    def mincostToHireWorkers(self, quality, wage, K):
        result, qsum = float(""inf""), 0
        max_heap = []
        for r, q in sorted([float(w)/q, q] for w, q in zip(wage, quality)):
            qsum += q
            heapq.heappush(max_heap, -q)
            if len(max_heap) > K:
                qsum -= -heapq.heappop(max_heap)
            if len(max_heap) == K:
                result = min(result, qsum*r)
        return result",O(nlogn)
"M = 1000000007
x, k  = map(int,input().split())
if x==0:
    print(0)
else:
    print(((pow(2,k+1,M)*x)%M - pow(2,k,M) +1 ) % M)
",O(logn)
"class Solution(object):
    def smallestRangeII(self, A, K):
        A.sort()
        result = A[-1]-A[0]
        for i in range(len(A)-1):
            result = min(result,
                         max(A[-1]-K, A[i]+K) -
                         min(A[0]+K, A[i+1]-K))
        return result",O(nlogn)
"class Solution(object):
    def findUnsortedSubarray(self, nums):
        n = len(nums)
        left, right = -1, -2
        min_from_right, max_from_left = nums[-1], nums[0]
        for i in range(1, n):
            max_from_left = max(max_from_left, nums[i])
            min_from_right = min(min_from_right, nums[n-1-i])
            if nums[i] < max_from_left: right = i
            if nums[n-1-i] > min_from_right: left = n-1-i",O(n)
"class Solution(object):
    def longestPalindrome(self, s):
        def preProcess(s):
            if not s:
                return ['^', '$']
            T = ['^']
            for c in s:
                T +=  [
            T += [
            return T

        T = preProcess(s)
        P = [0] * len(T)
        center, right = 0, 0
        for i in range(1, len(T) - 1):
            i_mirror = 2 * center - i
            if right > i:
                P[i] = min(right - i, P[i_mirror])
            else:
                P[i] = 0

            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:
                P[i] += 1

            if i + P[i] > right:
                center, right = i, i + P[i]

        max_i = 0
        for i in range(1, len(T) - 1):
            if P[i] > P[max_i]:
                max_i = i
        start = (max_i - 1 - P[max_i]) // 2
        return s[start : start + P[max_i]]",O(n)
"n,k = map(int,input().split())
a = list(map(int,input().split()))
t = []
for i in range(1,n):
    t.append(a[i]-a[i-1])
t.sort()
print(sum(t[:n-k]))
",O(nlogn)
"n=int(input())
s=input()

h=s.count('H')
s=s+s
print(min(s[i:i+h].count('T') for i in range(n)))
",O(n)
"import sys
input = sys.stdin.buffer.readline

n,k=map(int,input().split())
arr=[int(x) for x in input().split()]

x=0
dp=[]
for i in range(n):
    x=x+arr[i]
    dp.append(x)

ans=0
for i in range(n):
    for j in range(i+k-1,n):
        ans=max(ans,((dp[j]-dp[i])+arr[i])/(j-i+1))
print(ans)",O(n ^ 2)
"from math import *
import sys

input = sys.stdin.readline

def bin_search(arr, n):

	pos = -1

	for i in range(35, -1, -1):
		jump = (1 << i)

		if (pos + jump) >= len(arr):
			continue

		if arr[pos + jump] <= n-1:
			pos += jump

	return len(arr) - pos - 1

def main():
	n, m = [int(x) for x in input().split(' ')]

	vert = []
	for i in range(n):
		vert.append(int(input()))

	hor = []
	for i in range(m):
		col1, col2, row = [int(x) for x in input().split(' ')]

		if col1 != 1:
			continue

		hor.append((col2))

	vert.append(1000000000)

	vert = sorted(vert)
	hor = sorted(hor)

	best = int(1e10)

	for i in range(len(vert)):
		cur_ans = bin_search(hor, vert[i]) + i
		best = min(best, cur_ans)

	print(best)

if __name__ == ""__main__"":
	main()",O(nlogn)
"class Solution3(object):
    def sumOfNumberAndReverse(self, num):
        return any(x+int(str(x)[::-1]) == num for x in range(num//2, num+1))",O(nlogn)
"n, m, k = map(int, input().split())
a = list(map(int, input().split()))
sa = [0]*n

ans = 0

for i in range(n):
    sa[i] = a[i] - k
    s = a[i]
    for j in range(i-1, max(-1, i-m-1), -1):
        sa[i] = max(sa[i], sa[j] + s - k)
        s += a[j]
    if i < m:
        sa[i] = max(sa[i], s - k)
    sa[i] = max(sa[i], 0)
    ans = max(ans, sa[i])

print(ans)
",O(n ^ 2)
"class Solution(object):
    def applyOperations(self, nums):
        for i in range(len(nums)-1):
            if nums[i] == nums[i+1]:
                nums[i], nums[i+1] = 2*nums[i], 0
        i = 0
        for x in nums:
            if not x:
                continue
            nums[i] = x
            i += 1
        for i in range(i, len(nums)):
            nums[i] = 0
        return nums",O(n)
"

class Solution(object):
    def getEncryptedString(self, s, k):
        return """".join(s[(i+k)%len(s)] for i in range(len(s)))
",O(n)
"a = int(input())
lister = input().split()
lister = [int(i) for i in lister]

ans = dict()

def findans(n):
	if n in ans:
		return ans[n]
	mod = n%lister[n]
	ok = True
	if n + lister[n] >= a and n - lister[n] < 0:
		ok = False
	else:
		for i in range(mod, a, lister[n]):
			if i != n and lister[i] > lister[n]:
				ok = ok and findans(i)

		ok = not(ok)

	ans[n] = ok
	return ok

for i in range(len(lister)):
	findans(i)

level = []
for i in range(a):
	if ans[i] == True:
		level.append('A')
	else:
		level.append('B')

print(''.join(level))",O(n ^ 2)
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque

n, k = map(int,input().split())
s = input()

def judge(needed):

    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0

    effect = [[inf]*(n+1) for j in range(k)]

    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
            effect[j][i] = effect[j][i+4-4]

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index])

        minstate[state] = minimum

    if minstate[-1]<=n:  return True
    return False

front = 0
rear = n//k+1

while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)

    if flag:
        front = mid + 1
    else:
        rear = mid

print(front-1)
",np
"n, m = map(int, input().split())

top = [-1, -1]
bottom = [-1, -1]

for i in range(n):
    s = input()
    left = s.find('B')
    if left != -1:
        right = s.rfind('B')
        c = (right - left) // 2 + 1
        print(i + c, left + c)
        break
",O(n ^ 2)
"class Solution3(object):
    def hIndex(self, citations):
        return sum(x >= i + 1 for i, x in enumerate(sorted(citations, reverse=True)))",O(nlogn)
"class Solution(object):
    def getDescentPeriods(self, prices):
        result = l = 0
        for i in range(len(prices)):
            l += 1
            if i+1 == len(prices) or prices[i]-1 != prices[i+1]:
                result += l*(l+1)//2
                l = 0
        return result",O(n)
"n=int(input());print(sum(i for i in range(1+n%2!=1,n+1,2)))",O(n)
"class Solution(object):
    def findClosest(self, x, y, z):
        return list(range(3))[cmp(abs(y-z), abs(x-z))]",O(1)
"class Solution(object):
    def minMeetingRooms(self, intervals):
        result, curr = 0, 0
        line = [x for i, j in intervals for x in [[i, 1], [j, -1]]]
        line.sort()
        for _, num in line:
            curr += num
            result = max(result, curr)
        return result",O(nlogn)
"n = int(input())
print(25)",O(1)
"from sortedcontainers import SortedList



class Solution2(object):
    def maximumSegmentSum(self, nums, removeQueries):
        removed_idxs = SortedList([-1, len(nums)])
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        segments = SortedList([prefix[-1]])
        result = []
        for q in removeQueries: 
            removed_idxs.add(q)
            i = removed_idxs.bisect_left(q)
            left, right = removed_idxs[i-1], removed_idxs[i+1]
            segments.remove(prefix[right]-prefix[left+1])
            segments.add(prefix[q]-prefix[left+1])
            segments.add(prefix[right]-prefix[q+1])
            result.append(segments[-1])
        return result",O(nlogn)
"n, m = map(int, input().split())
b = list(map(int, input().split()))
g = list(map(int, input().split()))
b.sort()
g.sort()
if b[-1] > g[0]:
    print(-1)
    import sys
    sys.exit(0)
a = 0
a += sum(g) - g[0]
if g[0] == b[-1]:
    a += g[0]
    a += m * sum(b[:-1])
    print(a)
else:
    a += g[0]
    a += m * sum(b[:-2]) + (m - 1) * b[-2] + b[-1]
    print(a)
",O(nlogn)
"class Solution(object):
    def findTilt(self, root):
        def postOrderTraverse(root, tilt):
            if not root:
                return 0, tilt
            left, tilt = postOrderTraverse(root.left, tilt)
            right, tilt = postOrderTraverse(root.right, tilt)
            tilt += abs(left-right)
            return left+right+root.val, tilt

        return postOrderTraverse(root, 0)[1]",O(n)
"from collections import deque
with open(""input.txt"",""r"") as input_file:
    with open(""output.txt"",""a"") as output_file:
        N,M = map(int,input_file.readline().split())
        K = int(input_file.readline())
        T = list(map(int,input_file.readline().split()))
        graph = [[0] * (M + 1) for _ in range(N + 1)]
        queue = deque()
        for i in range(0, 2 * K - 1, 2):
            graph[T[i]][T[i + 1]] = 1
            queue.append((T[i], T[i + 1]))
        x, y = 0, 0
        while queue:
            x, y = queue.popleft()
            x_moves = [x - 1, x + 1, x, x]
            y_moves = [y, y, y - 1, y + 1]
            for i in range(len(x_moves)):
                if 0 < x_moves[i] <= N and 0 < y_moves[i] <= M:
                    if graph[x_moves[i]][y_moves[i]] == 0:
                        x = x_moves[i]
                        y = y_moves[i]
                        graph[x_moves[i]][y_moves[i]] = 1
                        queue.append((x_moves[i], y_moves[i]))
        output_file.write(f""{x} {y}"")",O(n ^ 3)
"from sys import stdin
input=stdin.readline
def check(mid,a,limit):
	res=[]
	s=0
	for r,t,id in a:
		if r>=mid and t+s<=limit:
			res.append(id+1)
			s+=t
		elif t+s>limit:
			break
		if len(res)==mid:
			break

	return res

def f(a,limit):
	a.sort(key=lambda s:s[1])
	ans=None
	lo=0
	hi=len(a)+1
	while lo<=hi:
		mid=(lo+hi)//2
		res=check(mid,a,limit)
		if len(res)>=mid:
			lo=mid+1
			ans=(res,mid)
		else:
			hi=mid-1
	print(ans[1])
	print(ans[1])
	print(*ans[0])

n,limit=map(int,input().strip().split())
q=[]
for i in range(n):
	x,y=map(int,input().strip().split())
	q.append((x,y,i))
f(q,limit)",O(nlogn)
"q=int(input())
for i in range(q):
	n,k=map(int,input().split())
	s=input()
	m=10**4
	for j in range(n):
		if j+k<=n:
			l1=[""R"",""G"",""B""]
			m1,m2,m3=0,0,0
			for i in range(j,j+k):
				if l1[(i-j)%3]!=s[i]:
					m1+=1
			for i in range(j,j+k):
				if l1[(i+1-j)%3]!=s[i]:
					m2+=1
			for i in range(j,j+k):
				if l1[(i+2-j)%3]!=s[i]:
					m3+=1
			m=min(m,m1,m2,m3)
		else:
			break
	print(m)",O(n ^ 2)
"import sys

input=sys.stdin.readline
def  f(r,g,b,n,m,k):

    if((n>=1 and m>=1) or (k>=1 and m>=1) or(n>=1 and k>=1)):

        a1=mat[n][m][k]
        if(a1!=-1):
            return a1
        else:
            a1=0
            b1=0
            c1=0

            if(n>=1 and m>=1):

                a1=r[n-1]*g[m-1] + f(r,g,b,n-1,m-1,k)
            if(k>=1 and m>=1):
                b1=b[k-1]*g[m-1] + f(r,g,b,n,m-1,k-1)
            if(n>=1 and k>=1):
                c1=r[n-1]*b[k-1] + f(r,g,b,n-1,m,k-1)

            mat[n][m][k]=max(a1,b1)
            mat[n][m][k]=max(mat[n][m][k],c1)

            return mat[n][m][k]
    return 0

n,m,k=list(map(int,input().split("" "")))
mat=[[[-1 for i in range(k+1)] for j in range(m+1)]for z in range(n+1)]

r=list(map(int,input().split("" "")))
g=list(map(int,input().split("" "")))
b=list(map(int,input().split("" "")))
r.sort()
g.sort()
b.sort()

d={}
print(f(r,g,b,n,m,k))",O(n ^ 3)
"class Solution(object):
    def smallestNumber(self, pattern):
        result = []
        for i in range(len(pattern)+1):
            if not (i == len(pattern) or pattern[i] == 'I'):
                continue
            for x in reversed(list(range(len(result)+1, (i+1)+1))):
                result.append(x)
        return """".join(map(str, result))",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def buildTree(self, inorder, postorder):
        lookup = {}
        for i, num in enumerate(inorder):
            lookup[num] = i
        return self.buildTreeRecu(lookup, postorder, inorder, len(postorder), 0, len(inorder))

    def buildTreeRecu(self, lookup, postorder, inorder, post_end, in_start, in_end):
        if in_start == in_end:
            return None
        node = TreeNode(postorder[post_end - 1])
        i = lookup[postorder[post_end - 1]]
        node.left = self.buildTreeRecu(lookup, postorder, inorder, post_end - 1 - (in_end - i - 1), in_start, i)
        node.right = self.buildTreeRecu(lookup, postorder, inorder, post_end - 1, i + 1, in_end)
        return node",O(n)
"class Solution2(object):
    def fillCups(self, amount):
        mx, total = max(amount), sum(amount)
        return mx if sum(amount)-mx <= mx else (total+1)//2",O(1)
"import collections
from functools import cmp_to_key

import sys
def getIntList():
    return list(map(int, input().split()))

n,a,b = getIntList()
a0 = a
b0 = b
if a0>b0:
    a0,b0 = b,a
if n==2 and (a0,b0) == (1,1):
    print('NO')
    sys.exit()
if n==3 and (a0,b0) == (1,1):
    print('NO')
    sys.exit()
if a>1 and b>1:
    print('NO')
    sys.exit()

mat = [['0' for y in range(n)]for x in range(n)]
mat1 = [['1' for y in range(n)]for x in range(n)]
if b==1:
    for x in range(n-a):
        mat[x][x+1] = '1'
        mat[x+1][x] = '1'
else:
    mat = mat1
    for x in range(n):
        mat[x][x] = '0'
    for x in range(n-b):
        mat[x][x+1] = '0'
        mat[x+1][x] = '0'

print('YES')
for x in range(n):
    print(''.join(mat[x]))
",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n,q=map(int,input().split())
x=n+1
l=0
while x>1:
    x//=2
    l+=1
for i in range(q):
    a=int(input())
    s=input()
    for j in s:
        lv=1
        a1=a
        while a1%2==0:
            a1=a1//2
            lv+=1
        x=2**lv
        q=x//2
        p=q//2
        y=(a-q)//x+1
        if j=='U':
            if lv==l:
                pass
            else:
                if y%2:
                    a=(2*a+x)//2
                else:
                    a=(2*a-x)//2
        elif j=='L':
            if lv==1:
                pass
            else:
                z=2*(y-1)
                a=p+z*q
        else:
            if lv==1:
                pass
            else:
                z=2*(y-1)
                a=p+(z+1)*q
    print(a)
",np
"class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [1000000] * n
        dp[-1] = 0

        for i in range(n - 2, -1, -1):
            end = min(n, i + nums[i] + 1)
            for j in range(i + 1, end):
                dp[i] = min(dp[i], 1 + dp[j])
        return dp[0]
",O(n ^ 2)
"n, m = map(int, input().split())
a = [0] + list(map(int, input().split()))
a.sort()
ans = 0
h = a[-1]
for i in range(n, 0, -1):
	if a[i - 1] < h - 1:
		ans = ans + a[i] - h + a[i - 1]
		h = a[i - 1]
	else:
		ans = ans + a[i] - 1
		h = h - 1
print(ans)",O(nlogn)
"n,m=map(int,input().split())
a=list(map(int,input().split()))
b=list(map(int,input().split()))

def next(k,a):
    i=k+1
    while a[i]!=1: i+=1
    return i

ans=[0]*(m+1)

k=-1
k=next(k,b)
ans[1]=k
for i in range(2,m+1):
    kk=next(k,b)
    for j in range(k+1,kk):
        if a[j]-a[k]<=a[kk]-a[j]:
            ans[i-1]+=1
        else:
            ans[i]+=1
    k=kk

ans[m]+=(n+m-1-k)

for i in range(1,m+1):
    print(ans[i],end=' ')
",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase

def main():
    n, MOD = map(int, input().split())
    factorial = [1]
    for i in range(2, n + 1):
        factorial.append(factorial[-1] * i % MOD)
    for i in range(len(factorial)):
        factorial[i] = pow(factorial[i], MOD - 2, MOD)
    DP = []
    for i in range(n):
        DP.append([0] * n)
    for i in range(n):
        DP[i][0] = pow(2, i, MOD) * factorial[i]
        for j in range(1, i // 2 + 1):
            for k in range(0, i - 1):
                DP[i][j] += DP[k][j - 1] * pow(2, i - k - 2, MOD) * factorial[i - k - 2]
            DP[i][j] %= MOD
    ans = 0
    for i in range(len(factorial)):
        factorial[i] = pow(factorial[i], MOD - 2, MOD)
    for i in range(n):
        ans += DP[n - 1][i] * factorial[n - i - 1]
    print(ans % MOD)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(n ^ 3)
"def A(n):
	return (4**n-1)//3

L = 31

T = int(input())
for _ in range(T):
	n,k = [int(_) for _ in input().split()]

	if n > L:
		print(""YES"",n-1)
		continue

	if k > A(n):
		print(""NO"")
		continue

	E = 1
	M = 0
	R = 0
	while n >= 0:
		M += E

		I = 2*E-1
		E = 2*E+1

		n -= 1
		R += I*A(n)

		if M <= k and k <= M+R: break

	if n >= 0: print(""YES"",n)
	else: print(""NO"")
",O(n)
"class Solution(object):
    def maxFrequencyScore(self, nums, k):
        nums.sort()
        result = left = curr = 0
        for right in range(len(nums)):
            curr += nums[right]-nums[(left+right)//2]
            if not curr <= k:
                curr -= nums[((left+1)+right)//2]-nums[left]
                left += 1
        return right-left+1",O(nlogn)
"from operator import itemgetter

n = int(input())
if n == 1:
    print(1)
else:
    pi = list(map(int,input().split()))
    ai = [1] * (n+1)
    ai[0] = 10**9
    for i in pi:
        ai[i] = 0
    for i in range(n-2,-1,-1):
        ai[pi[i]] += ai[i+2]
    ai.sort()
    for i in range(n):
        print(ai[i],end="" "")
",O(n)
"from operator import itemgetter

def main():
    n,m=map(int,input().split( ))
    a=[]
    for _ in range(m):
        x,y=map(int,input().split( ))
        x-=1;y-=1
        a.append((x,y))
    a=sorted(a,key=itemgetter(0,1))

    ans=[-1]*n
    for l,r in a:

        if ans[l]==-1:

            flag=1

            for i in range(l,r+1):
                if flag:
                    ans[i]=1
                else:
                    ans[i]=0
                flag^=1
        else:

            flag=1
            x=ans[l]
            for i in range(l,r+1):

                if flag:
                    ans[i]=x
                else:
                    ans[i]=x^1
                flag^=1
    for i in range(n):
        if ans[i]==-1:
            ans[i]=0

    ans=map(str,ans)
    print(''.join(ans))
main()",O(n)
"MOD=1000000007

x,k=map(int,raw_input().split())

if x>0:
	ans=(pow(2,k+1,MOD)*x)%MOD
	ans=(ans-pow(2,k,MOD))%MOD
	ans=(ans+1)%MOD
else:
	ans=0

print(ans)",O(logn)
"class Solution(object):
    def findLonely(self, nums):
        cnt = collections.Counter(nums)
        return [x for x in nums if cnt[x] == 1 and x-1 not in cnt and x+1 not in cnt]",O(n)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def reverseKGroup(self, head, k):
        dummy = ListNode(-1)
        dummy.next = head

        cur, cur_dummy = head, dummy
        length = 0

        while cur:
            next_cur = cur.__next__
            length = (length + 1) % k

            if length == 0:
                next_dummy = cur_dummy.__next__
                self.reverse(cur_dummy, cur.__next__)
                cur_dummy = next_dummy

            cur = next_cur

        return dummy.__next__

    def reverse(self, begin, end):
            first = begin.__next__
            cur = first.__next__

            while cur != end:
                first.next = cur.__next__
                cur.next = begin.__next__
                begin.next = cur
                cur = first.__next__",O(n)
"n = int(input())
a = [int(i) for i in input().split()]

total = sum(a)
final = n * (n-1) // 2
repeated = []
count = {}

for i in a:
    try:
        count[i] += 1
        repeated.append(i)
    except KeyError:
        count[i] = 1

moves = total - final

if len(repeated) > 1:
    print('cslnb')

elif 0 in repeated:
    print('cslnb')

elif len(repeated) == 1 and repeated[0] - 1 in a:
    print('cslnb')

else:
    if moves % 2 == 0 or moves <= 0:
        print('cslnb')
    else:
        print('sjfnb')
",O(n)
"import os
import sys

from collections import *

from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M=998244353
EPS=1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]

n=Int()
a=array()

series = [1]
fact = 1
for i in range(n+1):
    series.append(((series[-1]*2)%M + fact)%M)
    fact = (fact*2)%M

ind = n-1
ans=0

for i in range(n):
    ans = (ans + (a[i]*series[ind])%M )%M
    ind-=1

print(ans)
",O(n)
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"")
else:
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

def solve():
    n = ii()
    d = defaultdict(lambda:0)
    d1 = defaultdict(lambda:0)
    for i in range(n):
        x,y = li()
        d[x-1]-=1
        d[y]+=1

    x = list(d.keys())
    x.sort()
    r = x[-1]

    c=d[r]
    temp=1
    for i in range(len(x)-2,-1,-1):
        l = x[i]+1
        d1[c]+=r-l+temp

        c+=d[x[i]]
        r=l
        temp=0

    for i in range(1,n+1):
        print(d1[i],end="" "")
    print()

t = 1

for _ in range(t):
    solve()
",O(nlogn)
"kk=lambda:map(int, input().split())
ll=lambda:list(kk())
n,l,r,d=kk()
p,t=ll(),0
for v in range(2**n):
	s = []
	for i in range(n):
		if v&(2**i):
			s.append(p[i])
	if l <= sum(s)<=r and max(s)-min(s) >= d: t+=1
print(t)",np
"a = list(map(int, input().split()))

ans = 0
for i in range(len(a)):
    x = a[i]
    b = [j for j in a]
    b[i] = 0
    for j in range(len(a)):
        b[j] += x // 14

    for j in range(1, x % 14 + 1):
        b[(i + j) % 14] += 1

    ans_now = 0
    for j in b:
        if j % 2 == 0:
            ans_now += j
    ans = max(ans_now, ans)
print(ans)",O(1)
"n = int(input())

t = list(map(int,input().split()))

p = sum(t)
import math

a = math.ceil(p/2)

u=0
for j in range(n):
    u+=t[j]
    if u>=a:
        print(j+1)
        break
",O(n)
"class Solution2(object):
    def getPermutationIndex(self, perm):
        MOD = 10**9+7
        fact = [1]*2            
        def factorial(n):
            while len(fact) <= n: 
                fact.append(fact[-1]*len(fact) % MOD)
            return fact[n]

        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = (self.__bit[i]+val) % MOD
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret = (ret+self.__bit[i]) % MOD
                    i -= (i & -i)
                return ret

        result = 0
        bit = BIT(len(perm))
        for i, x in enumerate(perm):
            result = (result+(((((x-1)-bit.query((x-1)-1))%MOD)*factorial((len(perm)-1)-i))%MOD))%MOD
            bit.add(x-1, +1)
        return result",O(nlogn)
"def maxXORInRange(L, R):
    LXR = L ^ R
    msbPos = 0
    while(LXR):

        msbPos += 1
        LXR >>= 1
    maxXOR, two = 0, 1

    while (msbPos):

        maxXOR += two
        two <<= 1
        msbPos -= 1

    return maxXOR
L, R = map(int,input().split())
print(maxXORInRange(L, R))
",O(logn)
"num=int(input())

b=input()

if b=='0' or b=='1':
    print(b)

else:
    s=len(list(filter(lambda x:x=='0',b)))

    print('1'+'0'*s)",O(n)
"import sys

def second_largest(numbers):
    count = 0
    m1 = m2 = float('-inf')
    for x in numbers:
        count += 1
        if x > m2:
            if x >= m1:
                m1, m2 = x, m1
            else:
                m2 = x
    return m2 if count >= 2 else None

n, m = map(int, input().split())
boys = list(map(int, input().split()))
girls = list(map(int, input().split()))
firstMax = max(boys)
secondMax = second_largest(boys)
minGrills = min(girls)
minSum = 0
if firstMax > minGrills:
    print(-1)
    sys.exit()
elif firstMax == minGrills:
    minSum = m * (sum(boys) - firstMax) + sum(girls)
elif n == 1:
    print(-1)
    sys.exit()
else:
    minSum = m * sum(boys) + sum(girls) - (m-1) * firstMax - secondMax
print(minSum)
",O(n)
"def sum_from1(k):
      return (k*(k+1))//2
def sum_of_subtraction(p,k):
      if p<=1:
            return sum_from1(k)
      else:
            return sum_from1(k)-sum_from1(p-1)
n,k=map(int,input().split())
if n==1:
      print(0)
elif n<=k:
      print(1)
else:
      n-=1
      k-=1
      if n>sum_from1(k):
            print(-1)
      else:
            s=1
            e=k

            while s<e:
                  mid=(s+e)//2
                  r=sum_of_subtraction(mid,k)

                  if r==n:
                        print(k-mid+1)
                        break
                  elif r>n:
                        s=mid+1
                  else:
                        e=mid
            else:
                  print(k-s+2)
",O(logn)
"from random import randint

mod = 10**9 + 7
d = {}
n, m, l = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))
def go(i, j, k):
    val = i * 40401 + j * 201 + k
    ret = 0
    if val in d:
        return d[val]
    elif i < n and j < m and k < l:
        ret = max(a[i] * b[j] + go(i + 1, j + 1, k), b[j] * c[k] + go(i, j + 1, k + 1), c[k] * a[i] + go(i + 1, j, k + 1))
    elif i < n and j < m:
        ret = a[i] * b[j] + go(i + 1, j + 1, k)
    elif j < m and k < l:
        ret = b[j] * c[k] + go(i, j + 1, k + 1)
    elif k < l and i < n:
        ret = c[k] * a[i] + go(i + 1, j, k + 1)
    d[val] = ret
    return ret

a.sort(reverse = True)
b.sort(reverse = True)
c.sort(reverse = True)
print(go(0, 0, 0))
",O(n ^ 3)
"from sys import stdin, stdout
def modinv(n,p):
    return pow(n,p-2,p)
def ncr(n,r,p,f):
    t=((f[n])*(modinv(f[r],p)%p)*(modinv(f[n-r],p)%p))%p
    return t
mod=(10**9)+7
def GCD(x, y):
   while(y):
       x, y = y, x % y
   return x
def BS(arr, l, r, x):
    if r >= l:
        mid = l + (r - l)/2
        if arr[mid] == x:
            return mid
        elif arr[mid] > x:
            return BS(arr, l, mid-1, x)
        else:
            return BS(arr, mid+1, r, x)
    else:
        return -1
from bisect import bisect_left as bl
from bisect import bisect_right as br
import itertools
import math
from Queue import Queue as Q

def main():
    n=input()
    p=[]
    f=[0]*(n+1)
    for i in range(n):
        l,r=map(int,stdin.readline().split())
        p.append([l,""l""])
        p.append([r,""r""])
    p.sort(key=lambda x:x[0])
    o=1
    c=0
    w=[]
    for i in range(1,len(p)):
        if(p[i][0]==p[i-1][0]):
            if(p[i][1]==""l""):
                o+=1
            else:
                c+=1
        else:
            w.append([p[i-1][0],o,c])
            o,c=0,0
            if(p[i][1]==""l""):
                o=1
            else:
                c=1
    w.append([p[-1][0],o,c])
    s=0
    i=0
    r=-1
    while(i<len(w)):
        f[s]+=w[i][0]-r-1
        f[s+w[i][1]]+=1
        s+=w[i][1]-w[i][2]
        r=w[i][0]
        i+=1
    for i in range(1,n+1):
        stdout.write(str(f[i])+"" "")
if __name__ == '__main__':
    main()
",O(nlogn)
"n, m = map(int, input().split())
a = input()
b = input()
flag = 0
for c in a:
    if(c == '*'):
        flag = 1
if(flag == 1):
    a1, a2 = a.split('*')
    Len1 = len(a1)
    Len2 = len(a2)
    b1 = b[:Len1]
    b2 = ''
    if(Len2):
        b2 = b[-Len2:]

    if(a1 == b1 and a2 == b2 and Len1 + Len2 <= len(b)):
        print('YES')
    else:
        print('NO')
else:
    if(a == b):
        print('YES')
    else:
        print('NO')
",O(n)
"class Trie(object):
    def __init__(self):
        self.__root = {}
        
    def insert(self, num):
        node = self.__root
        for i in reversed(range(32)):
            curr = (num>>i) & 1
            if curr not in node:
                node[curr] = {""_count"":0}
            node = node[curr]
            node[""_count""] += 1
                
    def query(self, num, limit):
        node, result = self.__root, 0
        for i in reversed(range(32)):
            curr = (num>>i) & 1
            bit = (limit>>i) & 1
            if bit:
                if curr in node:
                    result += node[0^curr][""_count""] 
            if bit^curr not in node:
                break
            node = node[bit^curr]
        return result


class Solution2(object):
    def countPairs(self, nums, low, high):
        result = 0
        trie = Trie()
        for x in nums:
            result += trie.query(x, high+1)-trie.query(x, low)
            trie.insert(x)
        return result",O(n)
"import collections


class Solution(object):
    def minWindow(self, s, t):
        count, remain = collections.Counter(t), len(t)
        i, left, right = 0, -1, -1
        for j, c in enumerate(s):
            remain -= count[c] > 0
            count[c] -= 1
            if remain:
                continue
            while count[s[i]] < 0: 
                count[s[i]] += 1
                i += 1
            if right == -1 or j-i+1 < right-left+1:
                left, right = i, j
        return s[left:right+1]",O(n)
"import sys
import math
from collections import defaultdict,deque

input = sys.stdin.readline
def inar():
    return [int(el) for el in input().split()]
def main():
    t=int(input())
    tup=[]
    for _ in range(t):
        l,r=inar()
        tup.append([l,r])
    tup.sort()
    l=tup[0][0]
    r=tup[0][1]
    prefix=[[l,r]]
    for i in range(1,t):
        if l>tup[i][1] or r<tup[i][0]:
            prefix.append([-1,-1])
            for j in range(i+1,t):
                prefix.append([-1, -1])
            break

        l=max(l,tup[i][0])
        r=min(r,tup[i][1])
        prefix.append([l,r])
    l = tup[-1][0]
    r = tup[-1][1]
    suffix = []
    for i in range(t):
        suffix.append([-1,-1])
    suffix[-1][0]=l
    suffix[-1][1]=r
    for i in range(t-2,-1,-1):
        if l > tup[i][1] or r < tup[i][0]:
            break

        l = max(l, tup[i][0])
        r = min(r, tup[i][1])
        suffix[i][0]=l
        suffix[i][1]=r
    ans=0
    for i in range(t):
        if i==0:
            ans=max(ans,abs(suffix[i+1][0]-suffix[i+1][1]))
            continue
        if i==t-1:
            ans=max(ans,abs(prefix[i-1][0]-prefix[i-1][1]))
            continue
        prefix_l=prefix[i-1][0]
        prefix_r=prefix[i-1][1]
        suffix_l=suffix[i+1][0]
        suffix_r=suffix[i+1][1]
        l=max(prefix_l,suffix_l)
        r=min(prefix_r,suffix_r)
        ans=max(ans,max(0,r-l))
    print(ans)

if __name__ == '__main__':
    main()
",O(n)
"import math
def getdt():
    return map(int, input().split())
def calc(v0, v, a, x):
    t = (v - v0) / a
    x0 = v0 * t + 0.5 * a * t * t
    if x0 >= x:
        return (x, (math.sqrt(v0 * v0 + 2 * a * x) - v0) / a)
    return (x0, t)
def go(v0, v, a, x):
    x0, t = calc(v0, v, a, x)
    return t + (x - x0) / v
a, v = getdt()
l, d, w = getdt()
if w > v:
    w = v
x, t = calc(0, w, a, d)
if x == d:
    print(go(0, v, a, l))
else:
    print(t + go(w, v, a, (d - x) * 0.5) * 2 + go(w, v, a, l - d))
",O(1)
"from collections import Counter


class Solution2(object):
    def lengthOfLongestSubstringTwoDistinct(self, s):
        counter = Counter()
        left, max_length = 0, 0
        for right, char in enumerate(s):
            counter[char] += 1
            while len(counter) > 2:
                counter[s[left]] -= 1
                if counter[s[left]] == 0:
                    del counter[s[left]]
                left += 1
            max_length = max(max_length, right-left+1)
        return max_length",O(n)
"class Solution(object):
    def reductionOperations(self, nums):
        nums.sort()
        result = curr = 0
        for i in range(1, len(nums)): 
            if nums[i-1] < nums[i]:
                curr += 1
            result += curr
        return result",O(nlogn)
"n,l,r,x=map(int,input().split())
c=list(map(int,input().split()))
ans=0
for i in range(0,2**n):
    v=[]
    for j in range(n):
        if i & (1<<j):v.append(c[j])
    if sum(v)>=l and sum(v)<=r and (max(v)-min(v)>=x): ans+=1
print(ans)",np
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]

z, zz = fast, lambda: (map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())

def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer, end='\n'): stdout.write(str(answer) + end)

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]

n,m=zzz()
arr = zzz()
s = sum(arr)
idx = [[] for i in range(m)]
for i in range(n):
    idx[arr[i]%m].append(i)
j=0
for i in range(m):
    while len(idx[i])>n//m:
        while j<i or len(idx[j%m])>=n//m:j+=1
        last = idx[i].pop()
        arr[last]+=(j-i)%m
        idx[j%m].append(last)
print(sum(arr)-s)
print(*arr)
",O(n)
"class Solution(object):
    def minFlipsMonoIncr(self, S):
        flip0, flip1 = 0, 0
        for c in S:
            flip0 += int(c == '1')
            flip1 = min(flip0, flip1 + int(c == '0'))
        return flip1",O(n)
"def find(a,b):
    cc=2
    for i in range(1,(1<<len(a))):
        sx=0
        minn=100000000
        maxn=-1
        for j in range(0,len(a)):
            if(i &(1<<j)):
                sx+= a[j];
                minn = min(minn, a[j])
                maxn = max(maxn, a[j])
        if(sx>=b[1] and sx<=b[2] and (maxn-minn)>=b[3]):
            cc+=1
    if(cc<2):
        return 2
    else:
        return cc-2

b=list(map(int,input().split()))
a=list(map(int,input().split()))
print(find(a,b))
",np
"class Solution(object):
    def guessNumber(self, n):
        left, right = 1, n
        while left <= right:
            mid = left + (right - left) / 2
            if guess(mid) <= 0:
                right = mid - 1
            else:
                left = mid + 1
        return left",O(logn)
"inp = list(map(int, input().strip().split()))
moves = inp[0]
candiesAtTheEnd = inp[1]

def find(moves, candiesAtTheEnd):
  result = -1
  start = 0
  end = moves-1
  while result!=candiesAtTheEnd:

    mid=((end-start+1)//2)+start

    pluses=moves-mid
    minuses=mid

    result=((pluses+1)/2)*pluses
    result=result-minuses

    if result==candiesAtTheEnd:
      return minuses
    elif result>candiesAtTheEnd:
      start=mid
    else:
      end=mid

result_final=find(moves,candiesAtTheEnd)
print(result_final)
",O(logn)
"n,tnow=map(int,input().split())
left=int("""".join([""1"" for i in range(n)]),2)
arr=[]
dp={}
for i in range(n):
    a,b=map(int,input().split())
    arr.append([a,b])
def recur(tnow,prevgenre,left):
    key=str(left)+""_""+str(prevgenre)
    if tnow==0:
        return 1
    elif key in dp:
        return dp[key]
    else:
        ans=0
        for i in range(n):
            if (left&(1<<i))!=0:
                if arr[i][0]<=tnow and arr[i][1]!=prevgenre:
                    left=left&(~(1<<i))
                    ans+=recur(tnow-arr[i][0],arr[i][1],left)
                    left=left|(1<<i)
        dp[key]= ans
        return ans

print(recur(tnow,4,left)%(10**9+7))
",np
"from sys import stdin
n = int(stdin.readline()) + 1
if n == 1:
    print(0)
else:
    print(n//2 if n%2 == 0 else n)",O(1)
"n=int(input())
d={""purple"":""Power"",""green"":""Time"",""blue"":""Space"",""orange"":""Soul"",""red"":""Reality"",""yellow"":""Mind""}
l=[]
for i in range(n):
    s=input()
    l.append(s)
print(6-n)
for i in d:
    if i not in l:
        print(d[i])",O(1)
"class Solution(object):
    def minArraySum(self, nums, k, op1, op2):
        nums.sort()

        left = next((i for i in range(len(nums)) if nums[i] >= k), len(nums))
        right = next((i for i in range(len(nums)) if nums[i] >= 2*k-1), len(nums))

        lookup, cnt = [False]*len(nums), 0
        for j in reversed(range(right, len(nums))):
            if not op1:
                break
            op1 -= 1
            nums[j] = (nums[j]+1)//2
            if op2:
                op2 -= 1
                nums[j] -= k
        else:
            j = right-1

        for i in range(left, j+1):
            if not op2:
                break
            op2 -= 1
            if k%2 == 1 and nums[i]%2 == 0:
                lookup[i] = True
            nums[i] -= k
        else:
            i = j+1
    
        for j in reversed(range(i, j+1)):
            if not op1:
                break
            op1 -= 1
            if k%2 == 1 and nums[j]%2 == 1:
                cnt += 1
            nums[j] = (nums[j]+1)//2
        else:
            j = i-1

        arr = sorted((nums[idx], idx) for idx in range(i))
        for _ in range(op1):
            x, idx = arr.pop()
            nums[idx] = (x+1)//2
            if cnt and lookup[idx]:
                cnt -= 1
                nums[idx] -= 1
        return sum(nums)",O(nlogn)
"import sys, math, queue, bisect

MOD = 998244353
sys.setrecursionlimit(1000000)

n = int(input())
if n < 10:
    print(n)
    exit()
d = 1
while n > 9*d*pow(10, d-1):
    n -= 9*d*pow(10, d-1)
    d += 1
x = pow(10, d-1) + (n-1)//d
p = n % d
x = str(x).zfill(d)
print(x[p-1])",O(logn)
"import sys, string

def swap(i, j):
    temp = a[i]
    a[i] = a[j]
    a[j] = temp

n = int(sys.stdin.readline())
a = list(sys.stdin.readline().rstrip())
b = list(sys.stdin.readline().rstrip())
res_a = dict().fromkeys(list(string.ascii_lowercase), 0)
res_b = dict().fromkeys(list(string.ascii_lowercase), 0)

for i in a:
    res_a[i] += 1
for i in b:
    res_b[i] += 1

can = True
for i in res_a:
    if res_a[i] != res_b[i]:
        can = False
        break
if not can:
    print(-1)
else:
    ans = []
    for i in range(n):
        if a[i] == b[i]:
            continue
        else:
            idx = -1
            for j in range(i + 1, n):
                if a[j] == b[i]:
                    idx = j
                    break
            for j in range(idx, i, -1):
                ans.append(j)
                swap(j, j - 1)
    print(len(ans))
    print(' '.join(map(str, ans)))
",O(n ^ 2)
"class Solution2(object):
    def rearrangeArray(self, nums):
        def pos():
            for x in nums:
                if x > 0:
                    yield x
        
        def neg():
            for x in nums:
                if x < 0:
                    yield x
        
        gen_pos = pos()
        gen_neg = neg()
        return [next(gen_pos) if i%2 == 0 else next(gen_neg)  for i in range(len(nums))]",O(n)
"import sys

class fenwick():

    def __init__(self, n):
        self.n = n
        self.data = [0]*(n+1)

    def to_sum(self, i):

        s = 0
        while i > 0:
            s += self.data[i]
            i -= (i & -i)
        return s

    def add(self, i, x):

        while i <= self.n:
            self.data[i] += x
            i += (i & -i)

    def get(self, i, j):

        return self.to_sum(j)-self.to_sum(i-1)

def input():
    return sys.stdin.buffer.readline()

n = int(input())
permutation = list(map(int, input().split()))
seq = [(permutation[i], i + 1) for i in range(n)]
seq.sort(reverse=True)

m = int(input())
query = [tuple(map(int, input().split())) for i in range(m)]

WHOLE_INVERSION = 0
fenwick_1 = fenwick(n)

for value, index in seq:
    WHOLE_INVERSION += fenwick_1.get(1, index)
    fenwick_1.add(index, 1)

for l, r in query:
    d = r - l + 1
    WHOLE_INVERSION += d*(d-1)//2
    if WHOLE_INVERSION % 2 != 0:
        print(""odd"")
    else:
        print(""even"")
",O(n ^ 2)
"with open(""input.txt"",""r"") as in_file:
    with open(""output.txt"",""a"") as out_file:
        N,M = map(int,in_file.readline().split())
        K = int(in_file.readline())
        map_max_dist = [[5000 for i in range(M)] for j in range(N)]
        inputs = list(map(int,in_file.readline().split()))
        p = 0
        while(p<=K*2-2):
            x,y = inputs[p]-1,inputs[p+1]-1
            for r in range(N):
                for c in range(M):
                    dist = abs(x-r)+abs(y-c)
                    if dist<map_max_dist[r][c]:
                        map_max_dist[r][c] = dist
            p+=2
        max_val = 0
        max_index = (0,0)
        i,j = 0,0
        for i in range(N):
            for j in range(M):
                if(map_max_dist[i][j]>max_val):
                    max_val = map_max_dist[i][j]
                    max_index = (i,j)
        out_file.write(""{} {}"".format(max_index[0]+1,max_index[1]+1))
",O(n ^ 3)
"class Solution4(object):
    def minimumScore(self, nums, edges):
        def iter_dfs(nums, adj, u, p):
            result = []
            stk = [(1, (u, p, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    new_rets = []
                    stk.append((2, (u, new_rets, ret)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        new_rets.append([0])
                        stk.append((1, (v, u, new_rets[-1])))
                elif step == 2:
                    u, new_rets, ret = args
                    ret[0] = nums[u]
                    for x in new_rets:
                        ret[0] ^= x[0]
                    result.append(ret[0])
            return result
                
        adj = [[] for _ in range(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        total = reduce(lambda x, y: x^y, nums)
        result = float(""inf"")
        for u, v in edges: 
            for candidates in (iter_dfs(nums, adj, u, v), iter_dfs(nums, adj, v, u)):
                total2 = candidates.pop()
                for x in candidates:
                    a, b, c = total^total2, x, total2^x
                    result = min(result, max(a, b, c)-min(a, b, c))
        return result",O(n ^ 2)
"a = [int(i) for i in input().split()]
n = a[0]
k = a[1]
i = 1
count = 0
cursum = 0
while(count<n):
	if(cursum < k):
		cursum += i
	else:
		break
	count+=1
	i+=1
count += cursum-k
if(n == count):
	print(cursum - k)
else:
	ans = cursum-k
	extra = 0
	while(count<n):
		extra += i
		count+=(i+1)

		i+=1
	print(ans+extra)",O(logn)
"l, r = map(int, input().split())

if l == r:
    print(0)
    exit()
binr, binl = bin(r)[2:], bin(l)[2:]
binl = '0' * (len(binr) - len(binl)) + binl

for i in range(len(binl)):
    if binl[i] != binr[i]:
        binl = '1' * len(binl[i:])
        break

print(int(binl, 2))
",O(logn)
"def solve(N, A):
    cnt = [0] * (N + 1)

    evd = {}
    xs = []
    for a, b in A:
        if a not in evd:
            evd[a] = [0, 0]
            xs.append(a)
        if b not in evd:
            evd[b] = [0, 0]
            xs.append(b)

        evd[a][0] += 1
        evd[b][1] += 1

    xs.sort()

    px = xs[0] - 1
    pop = 0
    for x in xs:
        cnt[pop] += x - px - 1
        cnt[pop + evd[x][0]] += 1
        pop -= evd[x][1]
        pop += evd[x][0]
        px = x

    return cnt[1:]

def main():
    N = int(input())
    A = [tuple([int(e) for e in input().split(' ')]) for _ in range(N)]
    print(*solve(N, A))

if __name__ == '__main__':
    main()
",O(nlogn)
"def stones_after(n, s):
	for i in s:
		if i == '-':
			n -= 1
		else:
			n += 1
		if n < 0:
			return -1
	return n

n = int(input().strip())
s = input().strip()
ans = 99999999
for i in range(n+1):
	stones = stones_after(i, s)
	if stones != -1:
		ans = min(ans, stones)
print(ans)",O(n ^ 2)
"from collections import Counter
a = input()
b = input()
if len(a) < len(b):
    print(''.join(sorted(a)[::-1]))
    exit()
n = len(a)
cnt = Counter(a)
def f(i = 0, check = False):
    if i == n: return []
    for j in sorted(cnt)[::-1]:
        if (check or j <= b[i]) and cnt[j]:
            cnt[j] -= 1
            res = f(i + 1, check or j < b[i])
            if len(res) + i + 1 == n:
                res.append(j)
                return res
            cnt[j] += 1
    return []
print(''.join(f()[::-1]))",O(n ^ 3)
"class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        res = [0] * n

        for i in range(n - 2, -1, -1):
            j = i + 1
            while j < n and temperatures[j] <= temperatures[i]:
                if res[j] == 0:
                    j = n
                    break
                j += res[j]

            if j < n:
                res[i] = j - i
        return res
",O(n)
"class Solution(object):
    def findContentChildren(self, g, s):
        g.sort()
        s.sort()

        result, i = 0, 0
        for j in range(len(s)):
            if i == len(g):
                break
            if s[j] >= g[i]:
                result += 1
                i += 1
        return result",O(nlogn)
"actual = input()
processed = input()

def factorial(num: int):
    res = 1
    while num >= 1:
        res *= num
        num -= 1
    return res

actualPos = actual.count('+')
actualNeg = actual.count('-')
processedPos = processed.count('+')
processedNeg = processed.count('-')

if processedPos > actualPos or processedNeg > actualNeg:
    print(0)
elif processedPos == actualPos and processedNeg == actualNeg:
    print(1)
else:
    remainPos = actualPos - processedPos
    remainNeg = actualNeg - processedNeg

    print((factorial(remainPos + remainNeg) / (factorial(remainPos) * factorial(remainNeg))) / 2 ** (
            remainPos + remainNeg))
",np
"N,M=map(int,input().split())
light=[0]+[int(_) for _ in input().split()]+[M]
sumlist=[]
sumlight,ans=0,-10**30
for i in range(N+1):
    sumlight+=(-1)**(i+1)*light[i]
    sumlist.append(sumlight)
for i in range(1,N+1):
    if light[i]>light[i-1]+1:
        ans=max(ans,2*sumlist[i-1]-sumlight+(-1)**(i+1)*(light[i]-1))
    if light[i]<light[i+1]-1:
        ans=max(ans,2*sumlist[i]-sumlight+(-1)**i*(light[i]+1))
if N%2==0:
    print(max(ans,sumlight+M))
else:
    print(max(ans+M,sumlight))",O(n)
"import collections



class Solution2(object):
    def findMatrix(self, nums):
        result = []
        cnt = collections.Counter(nums)
        while cnt:
            result.append(list(cnt.keys()))
            cnt = {k:v-1 for k, v in cnt.items() if v-1}
        return result",O(n)
"n=int(input())
l=[int(i) for i in input().split()]
s=set(l)
if 0 in s:
    print(len(s)-1)
else:
    print(len(s))",O(n)
"n, v = list(map(int, input().strip().split()))

remaining_dist = n - 1
adding = min(remaining_dist, v)
cost = adding

remaining_dist -= adding

i = 2
while remaining_dist > 0:
    cost += i
    i += 1
    remaining_dist -= 1

print(cost)
",O(n)
"class Solution(object):
    def checkDistances(self, s, distance):
        for i in range(len(s)):
            if i+distance[ord(s[i])-ord('a')]+1 >= len(s) or s[i+distance[ord(s[i])-ord('a')]+1] != s[i]:
                return False
            distance[ord(s[i])-ord('a')] = -1
        return True",O(n)
"import sys
import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

t = int(input())
from collections import Counter
for _ in range(t):
    n = int(input())
    A = list(map(int, input().split()))
    C = Counter(A)
    B = []
    for k, v in C.items():
        if v >= 4:
            B.append(k)
            B.append(k)
        elif v >= 2:
            B.append(k)

    B.sort()
    l = len(B)
    m = 10**18
    ans = [-1, -1, -1, -1]
    for i in range(l-1):
        x, y = B[i], B[i+1]
        temp = (4*(x+y)**2)/(x*y)
        if temp < m:
            m = temp
            ans = [x, x, y, y]
    print(*ans)
",O(nlogn)
"class Solution2(object):
    def minSizeSubarray(self, nums, target):
        INF = float(""inf"")
        q, target = divmod(target, sum(nums))
        if not target:
            return q*len(nums)
        result = INF
        lookup = {0:-1}
        prefix = 0
        for right in range((len(nums)-1)+(len(nums)-1)):
            prefix += nums[right%len(nums)]
            if prefix-target in lookup:
                result = min(result, right-lookup[prefix-target])
            lookup[prefix] = right
        return result+q*len(nums) if result != INF else -1",O(n)
"a,b=map(int,input().split())

b1=bin(b)[2:]
a1=bin(a)[2:]
if len(a1)==len(b1) :
    d=(b^a)
    v=d.bit_length()
    print(int(""0""+""1""*(v),2))
else :
    print(int(""1""*len(b1),2))
",O(logn)
"n,k=map(int, input().split())
a=list(map(int, input().split()))
i=0
d=0
x=-1
y=-1
s=[0]*(10**5+1)
for j in range (len(a)):
    s[a[j]]+=1
    i+=1
    if s[a[j]]==1:
        d+=1
    if i==1:
        x=j+1
    if d==k:
        y=j+1
        break
while k!=1 and s[a[x-1]]-1!=0:
    s[a[x-1]]-=1
    x+=1
if x==-1 or y==-1:
    x=-1
    y=-1
print(x,y)",O(n)
"n = int(input())
ans = []
mult = 1
while n > 3:
    ans += [mult]*(n-n//2)
    n //= 2
    mult *= 2
if n == 3:
    ans += [mult, mult, mult*3]
elif n == 2:
    ans += [mult, mult*2]
else:
    ans += [mult]
print(*ans)",O(logn)
"from sys import stdin, stdout
from math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log
from collections import defaultdict as dd, deque
from heapq import merge, heapify, heappop, heappush, nsmallest
from bisect import bisect_left as bl, bisect_right as br, bisect

mod = pow(10, 9) + 7
mod2 = 998244353

def inp(): return stdin.readline().strip()
def iinp(): return int(inp())
def out(var, end=""\n""): stdout.write(str(var)+""\n"")
def outa(*var, end=""\n""): stdout.write(' '.join(map(str, var)) + end)
def lmp(): return list(mp())
def mp(): return map(int, inp().split())
def smp(): return map(str, inp().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]
def remadd(x, y): return 1 if x%y else 0
def ceil(a,b): return (a+b-1)//b
S1 = 'abcdefghijklmnopqrstuvwxyz'
S2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
def isprime(x):
    if x<=1: return False
    if x in (2, 3): return True
    if x%2 == 0: return False
    for i in range(3, int(sqrt(x))+1, 2):
        if x%i == 0: return False
    return True

n, m, k = mp()
hor = [lmp() for i in range(n)]
ver = [lmp() for i in range(n-1)]
if k%2:
    ml = l2d(n, m, -1)
    for i in ml: print(*i)
    exit()
k//=2
dp = [l2d(n, m) for i in range(k+1)]
for f in range(1, k+1):
    for i in range(n):
        for j in range(m):
            a = inf
            if i!=0:
                a = min(a, 2*ver[i-1][j]+dp[f-1][i-1][j])
            if i!=n-1:
                a = min(a, 2*ver[i][j]+dp[f-1][i+1][j])
            if j!=0:
                a = min(a, 2*hor[i][j-1]+dp[f-1][i][j-1])
            if j!=m-1:
                a = min(a, 2*hor[i][j]+dp[f-1][i][j+1])
            dp[f][i][j] = a
for i in dp[-1]:
    print(*i)",O(n ^ 3)
"class Solution(object):
    def countVisitedNodes(self, edges):
        def find_cycles(adj):
            result = [0]*len(adj)
            lookup = [0]*len(adj)
            stk = [] 
            idx = 0
            for u in range(len(adj)):
                prev = idx
                while not lookup[u]:
                    idx += 1
                    lookup[u] = idx
                    stk.append(u) 
                    u = adj[u]
                if lookup[u] > prev:
                    l = idx-lookup[u]+1
                    for _ in range(l): 
                        result[stk.pop()] = l
                while stk: 
                    result[stk[-1]] = result[adj[stk[-1]]]+1
                    stk.pop()
            return result
        
        return find_cycles(edges)",O(n)
"a = int(input())
s = input()
d = s.count('H')
p = []
for i in range(len(s)):
	if i+d > len(s):
		n = d+i - len(s)
		m = d - n
		h = s[:m] + s[-n:]
		k = h.count(""T"")
		p.append(k)
	else:
		h = s[i:d+i]
		k = h.count(""T"")
		p.append(k)
mi = a
for i in range(len(p)):
	if p[i] < mi:
		mi = p[i]
if s.count(""H"") == 1 or s.count(""T"") == 0:
	print(0)
else:
	print(mi)
",O(n)
"from math import sin
n,r=[int(i) for i in input().split()]
pi=3.14159265359
print(r/((2*sin(pi*(1/2-1/n)))/(sin(2*pi/n))-1))",O(1)
"import re



class Solution3(object):
    def freqAlphabets(self, s):
        def alpha(num):
            return chr(ord('a') + int(num)-1)

        return """".join(alpha(i[:2]) for i in re.findall(r""\d\",O(n)
"class Solution(object):
    def isPowerOfFour(self, num):
        return num > 0 and (num & (num - 1)) == 0 and \
               ((num & 0b01010101010101010101010101010101) == num)",O(1)
"l = input().split(' ')
x = int(l[0])
k = int(l[1])

if x == 0:
    print('0')
else:
    mod = 1000000007

    def pow_mod(a, b):
        if b < 2:
            return int(a ** b) % mod
        elif b % 2 == 0:
            return int(pow_mod(a, b // 2) ** 2) % mod
        else:
            return pow_mod(a, b - 1) * a % mod

    twop = pow_mod(2, k)
    high = x * twop
    leafs = twop
    low = high - leafs + 1
    s = (high + 1) * high // 2 - (low - 1 + 1) * (low - 1) // 2
    answer = s * 2 // leafs
    answer %= mod

    print(answer)",O(logn)
"R, G, B = map(int, input().split())
L = [sorted(map(int, input().split())) for _ in range(3)]
DP = [0] * ((R+1) * (G+1) * (B+1))

def idx(r, g, b):
  return r * (G+1) * (B+1) + g * (B+1) + b

for r in range(R+1):
  for g in range(G+1):
    for b in range(B+1):
      best = 0
      if r:
        if g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]
        if b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])
      if g and b:
        best = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])
      DP[idx(r, g, b)] = best
print(max(DP))
",O(n ^ 3)
"def func(n1,n2,n3):
    global r,g,b
    if((n1<0 and n2<0) or (n3<0 and n2<0) or (n1<0 and n3<0) ):
        return 0
    if(n1<0):
        return g[n2]*b[n3] + func(n1,n2-1,n3-1)
    if(n2<0):
        return r[n1]*b[n3] + func(n1-1,n2,n3-1)
    if(n3<0):
        return g[n2]*r[n1] + func(n1-1,n2-1,n3)
    if(dp[n1][n2][n3]==-1):
        dp[n1][n2][n3]= max(g[n2]*b[n3] + func(n1,n2-1,n3-1),r[n1]*b[n3] + func(n1-1,n2,n3-1),g[n2]*r[n1] + func(n1-1,n2-1,n3))
    return dp[n1][n2][n3]

R,G,B=tuple(map(int,input().split()))
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r=sorted(r)
g=sorted(g)
b=sorted(b)
prefix1=[0]*R
prefix2 = [0]*G
prefix3 = [0]*B
prefix1[0]=r[0]
prefix2[0] = g[0]
prefix3[0]=b[0]
dp=[[[-1 for i in range(B)] for j in range(G)]for k in range(R)]

print(func(R-1,G-1,B-1))",O(n ^ 3)
"import re
import sys
exit=sys.exit
from bisect import bisect_left as bsl,bisect_right as bsr
from collections import Counter,defaultdict as ddict,deque
from functools import lru_cache
cache=lru_cache(None)
from heapq import *
from itertools import *
from math import inf
from pprint import pprint as pp
enum=enumerate
ri=lambda:int(rln())
ris=lambda:list(map(int,rfs()))
rln=sys.stdin.readline
rl=lambda:rln().rstrip('\n')
rfs=lambda:rln().split()
cat=''.join
catn='\n'.join
mod=1000000007
d4=[(0,-1),(1,0),(0,1),(-1,0)]
d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]

n,t=ris()
a=[]
for _ in range(n):
  x,m=ris()
  a.append((x-m/2,m))
a.sort()
ans=2
for i in range(n-1):
  x=a[i][0]+a[i][1]+t
  y=a[i+1][0]
  ans+=(x<=y)+(x<y)
print(ans)
",O(nlogn)
"n=int(input())
if n==1 or n==2 :
    print(n)
elif n%2!=0 :
    m=n*(n-1)*(n-2)
    print(m)
elif n%3!=0 :
    m=n*(n-1)*(n-3)
    print(m)
else :
    m=(n-1)*(n-2)*(n-3)
    print(m)",O(1)
"import itertools


class Solution(object):
    def magicalString(self, n):
        def gen(): 
            for c in 1, 2, 2:
                yield c
            for i, c in enumerate(gen()):
                if i > 1:
                    for _ in range(c):
                        yield i % 2 + 1

        return sum(c & 1 for c in itertools.islice(gen(), n))",O(n)
"import heapq



class Solution(object):
    def makePrefSumNonNegative(self, nums):
        result = prefix = 0
        min_heap = []
        for x in nums:
            heapq.heappush(min_heap, x)
            prefix += x
            if prefix < 0:
                prefix -= heapq.heappop(min_heap)
                result += 1
        return result",O(nlogn)
"class Solution(object):
    def compressedString(self, word):
        result = []
        cnt = 0
        for i in range(len(word)):
            cnt += 1
            if cnt == 9 or (i+1 == len(word) or word[i+1] != word[i]):
                result.append(""%s%s"" % (cnt, word[i]))
                cnt = 0
        return """".join(result)",O(n)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def isSameTree(self, p, q):
        if p is None and q is None:
            return True

        if p is not None and q is not None:
            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

        return False

",O(n)
"def solve():
	c,d = 0,0
	print(""?"",c,d,flush=True)
	ans = int(input())
	if ans==0:

		num = 0
		for i in range(29,-1,-1):
			c = 1<<i
			d = 0
			print(""?"",c,d,flush=True)
			ans =int(input())
			if ans ==-2:
				return
			if ans == -1:
				num+=(1<<i)
		print(""!"",num,num)
	else:
		l = [0,0]
		if ans == 1:
			cur = 0
		else:
			cur = 1

		prev = ans

		for i in range(29,-1,-1):
			tc = c|(1<<i)
			td = d|(1<<i)
			print(""?"",tc,td,flush=True)
			ans = int(input())
			if ans ==-2:
				return
			if ans ==0:
				break
			if ans !=prev:
				l[cur] += (1<<i)
				if cur ==0:
					c = tc
				else:
					d = td
				print(""?"",c,d,flush=True)
				temp = int(input())
				prev = temp
				if temp == 1:
					cur = 0
				else:
					cur = 1
		c = l[0]
		d = l[1]

		for i in range(29,-1,-1):
			if c&(1<<i) != 0 or d&(1<<i) !=0 :
				continue
			tc = c|(1<<i)
			print(""?"",tc,d,flush=True)
			ans = int(input())
			if ans==-2:
				return
			if ans==-1:
				l[0]|=(1<<i)
				l[1]|=(1<<i)
		print(""!"",l[0],l[1])
	return

t = 1

while t>0:
	t-=1
	solve()",O(logn)
"n = int(input())

lst1 = []
for x in range(n):
    lst1.append(input().split())

s = input()

lst2 = []
for x in range(n):
    lst2.append(input().split())

s = input()

lst3 = []
for x in range(n):
    lst3.append(input().split())

s = input()

lst4 = []
for x in range(n):
    lst4.append(input().split())

ans_b1 = 0
ans_w1 = 0
for x in range(n):
    for y in range(n):
        if (x + y) & 1 == 0:
            if lst1[x][0][y] == '0':
                ans_b1 += 1
            else:
                ans_w1 += 1
        else:
            if lst1[x][0][y] == '1':
                ans_b1 += 1
            else:
                ans_w1 += 1

ans_b2 = 0
ans_w2 = 0
for x in range(n):
    for y in range(n):
        if (x + y) & 1 == 0:
            if lst2[x][0][y] == '0':
                ans_b2 += 1
            else:
                ans_w2 += 1
        else:
            if lst2[x][0][y] == '1':
                ans_b2 += 1
            else:
                ans_w2 += 1

ans_b3 = 0
ans_w3 = 0
for x in range(n):
    for y in range(n):
        if (x + y) & 1 == 0:
            if lst3[x][0][y] == '0':
                ans_b3 += 1
            else:
                ans_w3 += 1
        else:
            if lst3[x][0][y] == '1':
                ans_b3 += 1
            else:
                ans_w3 += 1

ans_b4 = 0
ans_w4 = 0
for x in range(n):
    for y in range(n):
        if (x + y) & 1 == 0:
            if lst4[x][0][y] == '0':
                ans_b4 += 1
            else:
                ans_w4 += 1
        else:
            if lst4[x][0][y] == '1':
                ans_b4 += 1
            else:
                ans_w4 += 1

print((2 * n) ** 2 - max(ans_b1 + ans_b2 + ans_w3 + ans_w4, ans_b1 + ans_w2 + ans_b3 + ans_w4, ans_b1 + ans_w2 + ans_w3 + ans_b4, ans_w1 + ans_b2 + ans_b3 + ans_w4, ans_w1 + ans_b2 + ans_w3 + ans_b4, ans_w1 + ans_w2 + ans_b3 + ans_b4))
",O(n ^ 2)
"n = int(input())
a = list(set(map(int, input().split())))
n = len(a)

cnt = 0
for i in range(n):
    f = True
    for j in range(n):
        if i == j:
            continue
        if a[i] % a[j] == 0:
            f = False
    if f:
        cnt += 1

print(cnt)
",O(n ^ 2)
"from sys import stdin
from math import factorial

n, mod = map(int, stdin.readline().split())

def binom(n, m):
    return factorial(n) // factorial(m) // factorial(n-m)

def foo(x, k):
    ans = 0
    for i in range(k, 0, -1):
        sign = 1 if (i-k)%2 == 0 else -1
        ans += sign * binom(k, i) * (i**x)
        ans %= mod
    return ans

def f(x, k):
    return (foo(x, k) * pow(2, x-k, mod)) % mod

ans = 0
for i in range((n+1)//2):
    ans = (ans + f(n-i, i+1))
    ans %= mod
print(ans)
",O(n ^ 2)
"n, s = map(int, input().split())

a, b, c = 0, n + 1, 0

while a < b:
    c = (a + b) // 2
    if c - sum([int(x) for x in str(c)]) < s:
        a = c + 1
    else:
        b = c

print(n - b + 1)",O(logn)
"n=int(input())
print(2*n*n-2*n+1)",O(1)
"n=int(input())
ans=[]
m=int(n**0.5)
x=n
while x-m>0:
  for i in range(1,m+1):
    ans.append(x-m+i)
  x-=m
for i in range(1,x+1):
  ans.append(i)
print(*ans)",O(n)
"n, v = map(int, input().split())

result = v-1 + (n-v)*(n-v+1)//2 if n-1 > v else n-1
print(result)",O(1)
"class Solution(object):
    def numberOfGoodSubarraySplits(self, nums):
        MOD = 10**9+7
        result, prev = 1, -1
        for i in range(len(nums)):
            if nums[i] != 1:
                continue
            if prev != -1:
                result = (result*(i-prev))%MOD
            prev = i
        return result if prev != -1 else 0",O(n)
"import sys
from collections import Counter

input = sys.stdin.readline

n=int(input())
P=list(map(int,input().split()))

LIST=[0]*(n+1)

LEAF=[1]*(n+1)
for p in P:
    LEAF[p]=0

for i in range(1,n+1):
    if LEAF[i]==1:
        LIST[i]=1

for i in range(n,1,-1):
    LIST[P[i-2]]+=LIST[i]

counter=Counter(LIST[1:])

SUM=[0]
SC=sorted(counter.keys())

for j in SC:
    SUM.append(SUM[-1]+counter[j])

i=1
j=0
while j<len(SUM):
    if i<=SUM[j]:
        print(SC[j-1],end="" "")
    else:
        j+=1
        continue

    i+=1
",O(nlogn)
"n, k = map(int, input().split())
s = list(input())
a = ord('A')
cnt = [0] * k
for ch in s:
    cnt[ord(ch) - a] += 1
print(k * min(cnt))",O(n)
"n=int(input())
s=input()
ans=0
for i in s:
    if(i=='+'):
        ans+=1
    else:
        ans-=1
    if(ans<0):
        ans=0
print(ans)",O(n)
"n,k = map(int, input().split())
a = 2*n
b = 5*n
c = 8*n
print((a+k-1)//k + (b+k-1)//k + (c + k -1) // k)",O(1)
"n,m = map(int,input().split())

print(n*""8"")
print((n-1)*""1""+""2"")",O(1)
"from sys import stdin,stdout
input=stdin.readline
for _ in range(int(input())):
    x=10**5
    n,k=map(int,input().split())
    s=input()
    a=10**9
    ans=[[0]*n for i in range(3)]
    curr=['R','G','B']
    for l in range(3):
        z=l
        for j in range(n):
            if s[j]!=curr[z]:
                ans[l][j]=1
            z+=1
            z%=3
    for i in range(3):
        ans[i]=[0]+ans[i]
    for l in range(3):
        z=l
        for j in range(1,n+1):
            ans[l][j]+=ans[l][j-1]
    for l in range(3):
        for j in range(1,n-k+2):
            a=min(a,ans[l][j+k-1]-ans[l][j-1])

    print(a)
",O(n)
"import sys

next(sys.stdin)

q_x, q_y = map(int, next(sys.stdin).rstrip().split())
k_x, k_y = map(int, next(sys.stdin).rstrip().split())
dest_x, dest_y = map(int, next(sys.stdin).rstrip().split())

def sign(x):
    return 1 if x >= 0 else -1

def which_square(x, y):
    return sign(x - q_x), sign(y - q_y)

if which_square(k_x, k_y) == which_square(dest_x, dest_y):
    print(""YES"")
else:
    print(""NO"")
",O(1)
"class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        res = []

        for i in range(len(intervals)):
            if newInterval[1] < intervals[i][0]:
                res.append(newInterval)
                return res + intervals[i:]
            elif newInterval[0] > intervals[i][1]:
                res.append(intervals[i])
            else:
                newInterval = [
                    min(newInterval[0], intervals[i][0]),
                    max(newInterval[1], intervals[i][1]),
                ]
        res.append(newInterval)
        return res
",O(n)
"x = int('00001111', 2)
y = int('00110011', 2)
z = int('01010101', 2)
E = set()
T = set()
F = {('x', x), ('y', y), ('z', z)}
prv = (set(), set(), set())
fam = 2 ** 8
tmpl = '
ans = [tmpl] * fam
def cmpr(E):
    global ans
    ans = [tmpl] * fam
    for e in E:
        if len(ans[e[1]]) > len(e[0]) or len(ans[e[1]]) == len(e[0]) and ans[e[1]] > e[0]:
            ans[e[1]] = e[0]
    return set((j, i) for i, j in enumerate(ans) if j != tmpl)
while prv != (E, T, F):
    prv = E.copy(), T.copy(), F.copy()
    for f in prv[2]:
        F.add(('!' + f[0], ~f[1] & (fam - 1)))
        T.add(f)
        for t in prv[1]:
            T.add((t[0] + '&' + f[0], t[1] & f[1]))
    for t in prv[1]:
        E.add(t)
    for e in prv[0]:
        if e not in F:
            F.add(('(' + e[0] + ')', e[1]))
        for t in prv[1]:
            E.add((e[0] + '|' + t[0], e[1] | t[1]))
    E, T, F = cmpr(E), cmpr(T), cmpr(F)
cmpr(E)
n = int(input())
for i in range(n):
	print(ans[int(input(), 2)])",O(n ^ 2)
"import collections


class Solution(object):

    def __init__(self):
        self.__left, self.__right = collections.deque(), collections.deque()   

    def pushFront(self, val):
        self.__left.appendleft(val)
        self.__balance()        

    def pushMiddle(self, val):
        if len(self.__left) > len(self.__right):
            self.__right.appendleft(self.__left.pop())
        self.__left.append(val)

    def pushBack(self, val):
        self.__right.append(val)
        self.__balance()

    def popFront(self):
        val = (self.__left or collections.deque([-1])).popleft()
        self.__balance()
        return val

    def popMiddle(self):
        val = (self.__left or [-1]).pop()
        self.__balance()
        return val

    def popBack(self):
        val = (self.__right or self.__left or [-1]).pop()
        self.__balance()
        return val

    def __balance(self):
        if len(self.__left) > len(self.__right)+1:
            self.__right.appendleft(self.__left.pop())
        elif len(self.__left) < len(self.__right):
            self.__left.append(self.__right.popleft())",O(1)
"import sys
input = sys.stdin.readline

MAXN = 202

def main():
    R, G, B = list(map(int, input().split()))
    r = list(map(int, input().split()))
    g = list(map(int, input().split()))
    b = list(map(int, input().split()))
    r.sort()
    g.sort()
    b.sort()
    dp = [[[0]*MAXN for _ in range(MAXN)] for _ in range(MAXN)]
    for i in range(1, R+1):
        for j in range(1, G+1):
            dp[i][j][0] = r[i-1]*g[j-1]+dp[i-1][j-1][0]
    for i in range(1, R+1):
        for k in range(1, B+1):
            dp[i][0][k] = r[i-1]*b[k-1]+dp[i-1][0][k-1]
    for j in range(1, G+1):
        for k in range(1, B+1):
            dp[0][j][k] = g[j-1]*b[k-1]+dp[0][j-1][k-1]
    for i in range(1, R+1):
        for j in range(1, G+1):
            for k in range(1, B+1):
                dp[i][j][k] = max(r[i-1]*g[j-1]+dp[i-1][j-1][k], r[i-1]*b[k-1]+dp[i-1][j][k-1], g[j-1]*b[k-1]+dp[i][j-1][k-1])
    print(dp[R][G][B])

main()
",O(n ^ 3)
"n,k=map(int,input().split())
n,k=n-1,k-1
l=0
r=k
g=k*(k+1)//2
ans=-1
while l<=r:
	m=(l+r)//2
	if (g-m*(m+1)//2)>=n:
		ans=k-m
		l=m+1
	else:
		r=m-1
print(ans)",O(logn)
"class Solution2(object):
    def findChampion(self, n, edges):
        lookup = {v for _, v in edges}
        return next(u for u in range(n) if u not in lookup) if len(lookup) == n-1 else -1",O(n)
"
class Solution(object):
    def maximumNumber(self, num, change):
        mutated = False
        result = list(map(int, list(num)))
        for i, d in enumerate(result):
            if change[d] < d:
                if mutated:
                    break
            elif change[d] > d:
                result[i] = str(change[d])
                mutated = True
        return """".join(map(str, result))
",O(n)
"import bisect



class Solution4(object):
    def maximumWhiteTiles(self, tiles, carpetLen):
        tiles.sort()
        prefix = [0]*(len(tiles)+1)
        for i, (l, r) in enumerate(tiles):
            prefix[i+1] = prefix[i]+(r-l+1)
        result = 0
        for right, (_, r) in enumerate(tiles):
            l = r-carpetLen+1
            left = bisect.bisect_right(tiles, [l])
            if left-1 >= 0 and tiles[left-1][1]+1 >= l:
                left -= 1
            extra = max(l-tiles[left][0], 0)
            result = max(result, (prefix[right+1]-prefix[left])-extra)
        return result",O(nlogn)
"z,zz=input,lambda:list(map(int,z().split()))
fast=lambda:stdin.readline().strip()
zzz=lambda:[int(i) for i in fast().split()]
szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())
from string import *
from re import *
from collections import *
from queue import *
from sys import *
from collections import *
from math import *
from heapq import *
from itertools import *
from bisect import *
from collections import Counter as cc
from math import factorial as f
from bisect import bisect as bs
from bisect import bisect_left as bsl
from itertools import accumulate as ac
def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))
def prime(x):
    p=ceil(x**.5)+1
    for i in range(2,p):
        if (x%i==0 and x!=2) or x==0:return 0
    return 1
def dfs(u,visit,graph):
    visit[u]=1
    for i in graph[u]:
        if not visit[i]:
            dfs(i,visit,graph)

n=int(z())

arr=zzz()

new_arr=sorted([ (i,j) for j,i in enumerate(arr) ])

lst=fast()

stack=[]
ans=[]

size=0
left=0
right=n-1

for i,j in enumerate(lst):
    if j=='0':
        ans.append(new_arr[left][1]+1)
        stack.append(new_arr[left][1]+1)
        size+=1
        left+=1

    if j=='1':
        if size==0:
            ans.append(new_arr[right][1]+1)
            stack.append(new_arr[right][1]+1)
            right-=1
        if size>0:
            ans.append(stack[-1])
            stack.pop()
            size-=1

print(*ans)
",O(nlogn)
"pw = [1, 4]
for i in range(2, 32):
    pw.append(pw[i - 1] * 4)
t = int(input())
for cas in range(t):
    n, k = map(int, input().split())
    last = 1
    path = 1
    ans = n
    i = 0
    while True:
        if((pw[i + 1] - 1) // 3 > k):
            ans -= i
            last = k - (pw[i] - 1) // 3
            break
        i = i + 1
        path *= 2
    sp = path * 2 - 1
    if((ans < 0) or ((ans == 0) and (last > 0))):
        print(""No"")
        continue
    sq = path * path - sp
    if (ans == 1) and (last > sq) and (last < sp):
        print(""No"")
        continue
    elif (ans == 1) and (last >= sp):
        ans = ans - 1
    print(""Yes"", ans)
",O(1)
"import sys
from itertools import accumulate

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
INF = 10 ** 18
MOD = 10 ** 9 + 7

def build_grid(H, W, intv, _type, space=True, padding=False):
    if space:
        _input = lambda: input().split()
    else:
        _input = lambda: input()
    _list = lambda: list(map(_type, _input()))
    if padding:
        offset = 1
    else:
        offset = 0
    grid = list2d(H+offset*2, W+offset*2, intv)
    for i in range(offset, H+offset):
        row = _list()
        for j in range(offset, W+offset):
            grid[i][j] = row[j-offset]
    return grid

H, W = MAP()
grid = build_grid(H, W, '

ans = []
imosw = list2d(H+2, W+2, 0)
imosh = list2d(H+2, W+2, 0)
def check(i, j):
    sz = min(L[i][j], R[i][j], U[i][j], D[i][j])
    if sz > 1:
        imosw[i][j-sz+1] += 1
        imosw[i][j+sz] -= 1
        imosh[i-sz+1][j] += 1
        imosh[i+sz][j] -= 1
        ans.append((i, j, sz-1))

def check2():
    for i in range(1, H+1):
        for j in range(1, W+1):
            if grid[i][j] == '*' and not imosw[i][j] and not imosh[i][j]:
                return False
    return True

L = list2d(H+2, W+2, 0)
R = list2d(H+2, W+2, 0)
U = list2d(H+2, W+2, 0)
D = list2d(H+2, W+2, 0)
for i in range(1, H+1):
    for j in range(1, W+1):
        if grid[i][j] == '.':
            L[i][j] = 0
        else:
            L[i][j] = L[i][j-1] + 1
for i in range(1, H+1):
    for j in range(W, 0, -1):
        if grid[i][j] == '.':
            R[i][j] = 0
        else:
            R[i][j] = R[i][j+1] + 1
for j in range(1, W+1):
    for i in range(1, H+1):
        if grid[i][j] == '.':
            U[i][j] = 0
        else:
            U[i][j] = U[i-1][j] + 1
for j in range(1, W+1):
    for i in range(H, 0, -1):
        if grid[i][j] == '.':
            D[i][j] = 0
        else:
            D[i][j] = D[i+1][j] + 1

for i in range(1, H+1):
    for j in range(1, W+1):
        if grid[i][j] == '*':
            check(i, j)
for i in range(1, H+1):
    for j in range(W+1):
        imosw[i][j+1] += imosw[i][j]
for j in range(1, W+1):
    for i in range(H+1):
        imosh[i+1][j] += imosh[i][j]

if check2():
    print(len(ans))
    [print(h, w, sz) for h, w, sz in ans]
else:
    print(-1)
",O(n ^ 2)
"n = int(input())
s = list(input())
d = list(input())
if(sorted(s) != sorted(d)):
    print(-1)
else:
    ans = []
    for i in range(n):
        if(s[i] != d[i]):
            for u in range(i+1,n):
                if(s[u] == d[i]):
                    ind = u
                    break

            cnt = abs(ind - i)
            s.pop(ind)
            s.insert(i,d[i])

            for k in range(cnt):
                if(ind > 0):
                    ans.append(ind)
                else:
                    ans.append(1)
                ind -= 1
    print(len(ans))
    print(*ans)",O(n ^ 2)
"a=[i for i in input()]
b=int(input())
a.sort(reverse=True)
ans = ''
while len(a) > 0:
    for i in range(len(a)):
        tmp = ans + a[i] + ''.join(sorted(a[:i] + a[i + 1:]))
        if int(tmp) <= b:
            ans += a[i]
            a = a[:i] + a[i + 1:]
            break
print(ans)
",O(n ^ 3)
"class Solution2(object):
    def maxBalancedSubsequenceSum(self, nums):
        NEG_INF = float(""-inf"")
        class BIT(object): 
            def __init__(self, n, default=0, fn=lambda x, y: x+y):
                self.__bit = [NEG_INF]*(n+1) 
                self.__default = default
                self.__fn = fn

            def update(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = self.__fn(self.__bit[i], val)
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = self.__default
                while i > 0:
                    ret = self.__fn(ret, self.__bit[i])
                    i -= (i & -i)
                return ret

        val_to_idx = {x:i for i, x in enumerate(sorted({x-i for i, x in enumerate(nums)}))}
        bit = BIT(len(val_to_idx), default=NEG_INF, fn=max)
        for i, x in enumerate(nums):
            v = max(bit.query(val_to_idx[x-i]), 0)+x
            bit.update(val_to_idx[x-i], v)
        return bit.query(len(val_to_idx)-1)",O(nlogn)
"m = int(input())
a = list(map(int, input().split()))

dp = [[505]*m for _ in range(m)]
Max = [[0]*m for _ in range(m)]

for i in range(m):
    dp[i][i] = 1
    Max[i][i] = a[i]

for len in range(1, m+1):
    for i in range(m-len+1):
        j = i + len - 1
        for k in range(i, j):
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
            if dp[i][k] == 1 and dp[k+1][j] == 1 and Max[i][k] == Max[k+1][j]:
                dp[i][j] = 1
                Max[i][j] = Max[i][k] + 1
print(dp[0][m-1])",O(n ^ 3)
"a,b=map(int,input().split())
ans=0
while a and b:
  ans+=a//b
  a,b=b,a%b
print(ans)",O(1)
"class Solution(object):
    def minCost(self, nums, costs):
        stk1, stk2 = [], []
        dp = [float(""inf"")]*len(nums)
        dp[0] = 0
        for i in range(len(nums)):
            while stk1 and nums[stk1[-1]] <= nums[i]:
                dp[i] = min(dp[i], dp[stk1.pop()]+costs[i])
            stk1.append(i)
            while stk2 and nums[stk2[-1]] > nums[i]:
                dp[i] = min(dp[i], dp[stk2.pop()]+costs[i])
            stk2.append(i)
        return dp[-1]",O(n)
"class Solution(object):
    def largest1BorderedSquare(self, grid):
        top, left = [a[:] for a in grid], [a[:] for a in grid]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if not grid[i][j]:
                    continue
                if i:
                    top[i][j] = top[i-1][j] + 1
                if j:
                    left[i][j] = left[i][j-1] + 1
        for l in reversed(range(1, min(len(grid), len(grid[0]))+1)):
            for i in range(len(grid)-l+1):
                for j in range(len(grid[0])-l+1):
                    if min(top[i+l-1][j],
                           top[i+l-1][j+l-1],
                           left[i][j+l-1],
                           left[i+l-1][j+l-1]) >= l:
                        return l*l
        return 0",O(n ^ 3)
"li=[]
for _ in range(int(input())):
    s=input()
    li.append(s)
lst2 = sorted(li, key=len)
c=1
for i in range(len(lst2)-1):
    if(lst2[i] not in lst2[i+1]):
        c=0
if(c==1):
    print(""YES"")
    for j in lst2:
        print(j)
else:
    print(""NO"")
",O(nlogn)
"print(""? 0 0"", flush=True)
res = input()
i = 1
a = 0
b = 0
for i in range(29,-1,-1):
	print(""?"",(a^(1<<i)), b, flush=True)
	res1 = input()
	print(""?"",a, (b^(1<<i)), flush=True)
	res2 = input()
	if res1 == res2:
		if res == '1':
			a ^= (1<<i)
		else:
			b ^= (1<<i)
		res = res1
	elif res1 == '-1':
		a ^= (1<<i)
		b ^= (1<<i)
print(""!"", a, b, flush=True)",O(1)
"n, m = map(int, input().split())
B = list(map(int, input().split()))
G = list(map(int, input().split()))
if min(G) < max(B):
    print(-1)
    exit(0)
cnt = 0
z = max(B)
y = 0
f = 1
f2 = 0
for i in B:
    if i != z or f2:
        y = max(y, i)
    else:
        f2 = 1
for i in G:
    if i == z:
        f = 0
    cnt += i - z
if f:
    cnt += z - y
print(cnt + sum(B) * m)",O(n)
"from sys import stdin

n = int(stdin.readline())

stones = sorted([int(x) for x in stdin.readline().split()])

if n == 1:
    if stones[0]%2 == 0:
        print('cslnb')
    else:
        print('sjfnb')

else:
    chilly = -1
    chill = 2
    prev = stones[0]

    for x in stones[1:]:
        if x == prev:
            chill -= 1
            chilly = x
        else:
            streak = 1
            prev = x

    s = sum(stones)

    if n%4 == 0 or n%4 == 1:
        s += 1

    if chill <= 0 or stones.count(0) > 1:
        print('cslnb')
    elif chill == 1 and chilly-1 in stones:
        print('cslnb')
    elif s%2 == 1:
        print('cslnb')
    else:
        print('sjfnb')
",O(nlogn)
"import math

class Read:
    @staticmethod
    def int():
        return int(input())

    @staticmethod
    def list(sep=' '):
        return input().split(sep)

    @staticmethod
    def list_int(sep=' '):
        return list(map(int, input().split(sep)))

def solve():
    n, k = Read.list_int()
    s = input()

    sf = 'RGB' * (k + 2)

    max_s = 0
    for i in range(n - k + 1):
        for j in range(3):
            count = 0
            for b in range(k):
                if sf[j + b] == s[i + b]:
                    count += 1
            if count > max_s:
                max_s = count

    print(k - max_s)

query_count = Read.int()
for j in range(query_count):
    solve()
",O(n ^ 2)
"def solve():
    n, k = list(map(lambda x: int(x), input().split()))
    upper_bound = n+1
    lower_bound = -1
    while upper_bound > lower_bound + 1:
        m = (upper_bound + lower_bound) // 2
        if (n - m) * (n - m + 1) // 2 - m > k:
            lower_bound = m
        else:
            upper_bound = m
    print(upper_bound)

solve()
",O(logn)
"def interact(c, d): return max(min((a ^ c) - (b ^ d), 1), -1)

def main():
	def ask(c, d):

		print(""?"", c, d, flush = True)
		return int(input())

	relative = ask(0, 0)
	curA = 0
	curB = 0

	for i in range(29, -1, -1):
		q1 = ask(curA ^ 2 ** i, curB)
		q2 = ask(curA, curB ^ 2 ** i)

		if q1 == q2:
			if relative == 1:
				curA ^= 2 ** i
			else:
				curB ^= 2 ** i
			relative = q1
		elif q2 == 1:
			curA ^= 2 ** i
			curB ^= 2 ** i
	return curA, curB
print(""!"", *main())",O(logn)
"class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        for i in range(len(cost) - 3, -1, -1):
            cost[i] += min(cost[i + 1], cost[i + 2])

        return min(cost[0], cost[1])
",O(n)
"for _ in range(int(input())):
    n = int(input())
    li = sorted(list(map(int, input().split())))
    print(min(li[n - 2] - 1, n - 2))
",O(nlogn)
"def permuteDigits(a, b):

    n = len(a)
    if len(a) < len(b):
        return a

    i = 0
    c = 0
    t = a[0]
    flag = 0
    lastind = []
    while i<len(a) and i< len(b) and a[i] >= b[i] :

        if c == n:
            i = i - 1
            t = a[i]
            a = a[:i] + a[i+1:]
            a.insert(lastind.pop(),t)
            flag = 1
            c = i
        elif (flag == 0 and a[c] == b[i]) or a[c] < b[i]:
            lastind.append(c)
            t = a[c]
            a = a[:c] + a[c+1:]

            a.insert(i,t)

        else:
            c = c + 1

        if a[i] < b[i]:
            break
        elif flag == 0 and a[i] == b[i]:
            i = i + 1
            c = i

    return a

aa = input()
bb = input()

a=[]
b=[]
for i in aa:
    a.append(int(i))
for i in bb:
    b.append(int(i))

a.sort(reverse=True)

ans = permuteDigits(a, b)
s = """"
for i in ans:
    s = s + str(i)
print(int(s))",O(n ^ 3)
"import sys
from array import array
from typing import List, Tuple, TypeVar, Generic, Sequence, Union

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

def main():
    n = int(input())
    a = list(map(int, input().split()))

    dp = [array('h', [10000]) * (n + 1) for _ in range(n + 1)]
    num = [array('h', [-1]) * (n + 1) for _ in range(n + 1)]
    for i in range(n):
        dp[i][i + 1] = 1
        num[i][i + 1] = a[i]

    for sublen in range(2, n + 1):
        for l, r in zip(range(n), range(sublen, n + 1)):
            for mid in range(l + 1, r):
                if num[l][mid] == num[mid][r] != -1:
                    dp[l][r] = 1
                    num[l][r] = num[l][mid] + 1
                    break

                dp[l][r] = min(dp[l][r], dp[l][mid] + dp[mid][r])

    print(dp[0][-1])

if __name__ == '__main__':
    main()
",O(n ^ 3)
"import itertools


class Solution(object):
    def numOfWays(self, n):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))]
                       for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b % MOD for a, b in zip(row, col)) % MOD
                     for col in ZB] for row in A]
        
        MOD = 10**9 + 7
        T = [[3, 2],
             [2, 2]]
        return sum(matrix_mult([[6, 6]], matrix_expo(T, n-1))[0]) % MOD",O(logn)
"class Solution(object):
    def longestSemiRepetitiveSubstring(self, s):
        result = left = prev = 0
        for right in range(len(s)):
            if right-1 >= 0 and s[right-1] == s[right]:
                left, prev = prev, right
            result = max(result, right-left+1)
        return result",O(n)
"from collections import defaultdict
import sys
sys.setrecursionlimit(500000)
test = 0

def countleaf(tree, n, leafs):
    leafs[n] = 1 if len(tree[n]) == 0 else 0

    for i in tree[n]:
        leafs[n] += countleaf(tree, i, leafs)

    return leafs[n]

n = int(input())
edges = list(map(int, input().split()))
tree = [[] for i in range(n)]

leafs = [0] * n

for i, e in enumerate(edges):
    tree[e - 1] += [i + 1]

if test: print(tree)

for i in range(n - 1, -1, -1):
    if not tree[i]:
        leafs[i] = 1
    else:
        leafs[i] = sum(leafs[j] for j in tree[i])

print(*sorted(leafs))
",O(nlogn)
"n = int(input())
a = iter(map(int, input().split()))
prev_type = 3
prev_res = 2
curr_a = next(a)
res = []
for _ in range(1):
	for next_a in a:
		if next_a > curr_a:
			if prev_type == 1 or prev_res == 1:
				prev_res += 1
				if prev_res == 5:
					break
			else:
				prev_res = 1
			prev_type = 1
		elif next_a < curr_a:
			if prev_type == 2 or prev_res == 5:
				prev_res -= 1
				if prev_res == 1:
					break
			else:
				prev_res = 5
			prev_type = 2
		else:
			if prev_type == 1:
				prev_res += 1
			elif prev_type == 2:
				prev_res -= 1
			elif prev_res != 2:
				prev_res = 2
			else:
				prev_res = 3
			prev_type = 3
		res.append(prev_res)
		curr_a = next_a
	else:
		if prev_type == 1:
			res.append(prev_res + 1)
		elif prev_type == 2:
			res.append(prev_res - 1)
		elif prev_res != 1:
			res.append(1)
		else:
			res.append(2)
		print(*res)
		break
else:
	print('-1')
",O(n)
"n=int(input())
s=0; pred=0
for i in range(1,20):
    m=9*pow(10,i-1)*i
    s+=m
    if n<=s:
        nd=pow(10,i-1)
        sme=n-pred
        num=sme//i
        ost=sme%i
        if ost==0:
            dig=nd+num-1
        else:
            dig=nd+num
        d=i
        rez=[]
        ddig=dig
        while d>0:
            o=ddig%10
            a=ddig//10
            rez.append(o)
            d-=1
            ddig=a
        break
    pred=s
print(str(rez[-ost]))
",O(logn)
"n = int(input())
a = list(map(int, input().split()))
ans = 0
sum = 0
mp = {}
for i in range(n):
    x = a[i]
    ans += (x * i) - sum;
    ans -= (mp.get(x - 1, 0));
    ans -= (-mp.get(x + 1, 0));
    mp[x] = mp.get(x, 0) + 1;
    sum += x;
print(ans)",O(nlogn)
"class Solution(object):
    def minHeightShelves(self, books, shelf_width):
        dp = [float(""inf"") for _ in range(len(books)+1)]
        dp[0] = 0
        for i in range(1, len(books)+1):
            max_width = shelf_width
            max_height = 0
            for j in reversed(range(i)):
                if max_width-books[j][0] < 0:
                    break
                max_width -= books[j][0]
                max_height = max(max_height, books[j][1])
                dp[i] = min(dp[i], dp[j]+max_height)
        return dp[len(books)]",O(n ^ 2)
"def i_ints():
    return list(map(int, input().split()))

n, a, b = i_ints()
def calc():
    if min(a, b) != 1:
        print(""NO"")
        return
    if a == b == 1 and n in (2, 3):
        print(""NO"")
        return

    print(""YES"")
    ONE, ZERO = ""10"" if a > 1 else ""01""

    edges = n - max(a, b)
    line = ""0"" + (ZERO, ONE)[edges>0]*(n>1) + ZERO * (n-2)
    print(line)

    for y in range(1, n):
        line = ZERO * (y-1) + (ZERO, ONE)[y<=edges] + ""0""
        if y < n-1:
            line += (ZERO, ONE)[y < edges] + ZERO * (n-y-2)
        print(line)

calc()
",O(n ^ 2)
"import os,sys
from io import BytesIO, IOBase

def main():
    inf = -float(""inf"")
    for _ in range(int(input())):
        n,m = map(int,input().split())
        a = [list(map(int,input().split())) for _ in range(n)]
        y = 1<<n
        dp = [[0]+[inf]*(y-1) for _ in range(m+1)]
        for i in range(1,m+1):
            for shift in range(n):
                for mask1 in range(y):
                    for mask2 in range(y):
                        new = mask1^mask2
                        if new&mask1:
                            continue
                        mm,add = 1,0
                        for x in range(n):
                            if mm&new:
                                tt = x+shift
                                if tt >= n:
                                    tt -= n
                                add += a[tt][i-1]
                            mm <<= 1
                        dp[i][mask2] = max(dp[i][mask2],dp[i-1][mask1]+add)
        print(dp[m][y-1])

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",np
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math

alphabets = list('abcdefghijklmnopqrstuvwxyz')

def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))
def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def power_set(L):

    cardinality=len(L)
    n=2 ** cardinality
    powerset = []

    for i in range(n):
        a=bin(i)[2:]
        subset=[]
        for j in range(len(a)):
            if a[-j-1]=='1':
                subset.append(L[j])
        powerset.append(subset)
    powerset_orderred=[]
    for k in range(cardinality+1):
        for w in powerset:
            if len(w)==k:
                powerset_orderred.append(w)

    return powerset_orderred
def fastPlrintNextLines(a):

    print('\n'.join(map(str,a)))

def sortByFirstAndSecond(A):
    A = sorted(A,key = lambda x:x[0])
    A = sorted(A,key = lambda x:x[1])
    return list(A)

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"")

def solve():
    n,k = li()
    l = [['.' for i in range(n)] for j in range(4)]
    print(""YES"")
    if k%2==0:
        for i in range(1,k//2+1):
            l[1][i]='
            l[2][i]='
    else:
        if (k>n-2):

            for i in range(1,n-1):
                l[1][i]='
            k-=(n-2)
        if k>0:
            i = n//2
            if k%2==1:
                l[2][i]='
                k-=1
            i = n//2+1
            for i in range(n//2+1,n//2+1+k//2):
                l[2][i]='
            k = k//2
            for i in range(n//2-1,-1,-1):
                if k==0:
                    break
                k-=1
                l[2][i]='
    for i in l:
        print(''.join(i))

t = 1

for _ in range(t):
    solve()
",O(n)
"l,r=tuple(map(int,input().split("" "")))
x=l^r
pow=1
while(pow<=x) :
    pow*=2

print(pow-1)",O(logn)
"n, = map(int,input().split())

s = input()
if s=='0':
    print(0)
else:
    print(""1""+""0""*s.count('0'))",O(n)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

from collections import Counter

n, s = mi()
d = Counter()
for i in range(n - 1):
    u, v = mi()
    d[u] += 1
    d[v] += 1

l = sum(v == 1 for v in d.values())
ans = s / l * 2
print('%.10f' % (ans,))
",O(n)
"import sys
LI=lambda:list(map(int, sys.stdin.readline().split()))
MI=lambda:map(int, sys.stdin.readline().split())
SI=lambda:sys.stdin.readline().strip('\n')
II=lambda:int(sys.stdin.readline())

n=II()
s=SI()
c=set(s)
ln=[0]*n
for d in c:
	last=-1

	for i, v in enumerate(s):
		if v==d:
			last=i
		if last==-1:
			ln[i]=int(1e9)
		else:
			ln[i]=max(ln[i], i-last+1)

print(min(ln))",O(n)
"n, q = map(int, input().split())
for _ in range(q):
    u = int(input())
    s = input()
    for comm in s:
        k = 1
        while True:
            if k & u:
                break
            k <<= 1
        if comm == 'L':
            if k != 1:
                u -= k
                u += (k>>1)
        elif comm == 'R':
            if k != 1:
                u += (k>>1)
        elif comm == 'U':
            nu = u - k
            nu |= (k<<1)
            if nu <= n:
                u = nu
    print(u)",np
"import sys
input = sys.stdin.readline

n=int(input())
A=list(map(int,input().split()))
A.sort()

from collections import Counter
C=Counter(A)
dou=0

for c in C:
    dou+=C[c]-1

    if C[c]>=2 and C[c-1]!=0:
        print(""cslnb"")
        sys.exit()

if dou>=2:
    print(""cslnb"")
    sys.exit()

ANS=0
for i in range(n):
    if A[i]<i:
        print(""cslnb"")
        sys.exit()
    ANS+=(A[i]-i)%2

if ANS%2==0:
    print(""cslnb"")
    sys.exit()
else:
    print(""sjfnb"")
    sys.exit()
",O(nlogn)
"from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__

class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):

    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):

    self.out.append(str(text))

  def writeLine(self, text):

    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

def bootstrap(f, stack=[]):

  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc

class MDArray(object):

  def __init__(self, dimensions, initial_value=0):

    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):

    return self.arr[self._index(indexes)]

  def set(self, indexes, value):

    self.arr[self._index(indexes)] = value
    return value

def encode(row, col, n, m):
  return row * m + col

def main(inp, out):

  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = [-1] * (n*m*(k/2+1))

  def solve(node, remain):
    if remain == 0:
      return 0

    key = (node + remain * n * m)
    mem = dp[key]
    if mem != -1:
      return mem

    ans = min(map(lambda x: solve(x[0], remain-1) + x[1], adj[node]))
    dp[key] = ans
    return ans

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(solve(node, k/2) * 2)
    out.writeLine(' '.join(map(str, ans)))

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",O(n ^ 3)
"n,m=map(int,input().split())
c=list(map(int,input().split()))
a=list(map(int,input().split()))
j,res=0,0
for i in range(n):
    if j < m:
        if c[i] <= a[j]:
            j+=1
            res+=1
print(res)",O(n)
"class Solution(object):
    def countWays(self, ranges):
        MOD = 10**9+7

        ranges.sort()
        cnt = 0
        curr = float(""-inf"")
        for l, r in ranges:
            if l > curr:
                cnt += 1
            curr = max(curr, r)
        return pow(2, cnt, MOD)",O(nlogn)
"from sortedcontainers import SortedList



class Solution(object):
    def maxBalancedSubsequenceSum(self, nums):
        NEG_INF = float(""-inf"")
        def query(sl, k):
            j = sl.bisect_left((k,))
            return sl[j-1][1] if j-1 >= 0 else NEG_INF
    
        def update(sl, k, v):
            j = sl.bisect_left((k,))
            if j < len(sl) and sl[j][0] == k:
                if not (sl[j][1] < v):
                    return
                del sl[j]
            elif not (j-1 < 0 or sl[j-1][1] < v):
                return
            sl.add((k, v))
            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:
                del sl[j+1]

        sl = SortedList()
        for i, x in enumerate(nums):
            v = max(query(sl, (x-i)+1), 0)+x
            update(sl, x-i, v)
        return sl[-1][1]",O(nlogn)
"class BIT(object): 
    def __init__(self, n):
        self.__bit = [0]*(n+1) 

    def add(self, i, val):
        i += 1 
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def query(self, i):
        i += 1 
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret


class Solution(object):
    def pancakeSort(self, arr):
        bit = BIT(len(arr))
        result = []
        for i in range(len(arr)):
            n = bit.query((arr[i]-1)-1)
            bit.add(arr[i]-1, 1)
            if n == i: 
                continue
            if n == 0:               
                if i > 1:
                    result.append(i) 
                result.append(i+1)   
            else:                    
                if n > 1:
                    result.append(n) 
                result.append(i)     
                result.append(i+1)   
                result.append(n+1)   
        return result",O(nlogn)
"string = input()
size = len(string)

ans_got = 0
for s in range(1,size)[::-1]:
    dic = {}
    for i in range(0,size-s+1):
        if(string[i:i+s] in dic):
            print(s)
            ans_got = 1
            break
        else:
            dic[string[i:i+s]] = 1
    if(ans_got == 1):
        break
if(ans_got == 0):
    print(0)",O(n ^ 3)
"X, K = map(int, input().split())
mod = 1000000007
res = X*pow(2, K+1, mod)-pow(2, K, mod)+1;
while(res < 0):
   res += mod
if(X == 0):
   print(0)
else:
   print(res%mod)",O(logn)
"class Solution2(object):
    def isSymmetric(self, root):
        if root is None:
            return True

        return self.isSymmetricRecu(root.left, root.right)

    def isSymmetricRecu(self, left, right):
        if left is None and right is None:
            return True
        if left is None or right is None or left.val != right.val:
            return False
        return self.isSymmetricRecu(left.left, right.right) and self.isSymmetricRecu(left.right, right.left)",O(n)
"import collections



class Solution(object):
    def distinctSubarraysWithAtMostKOddIntegers(self, A, K):
        def countDistinct(A, left, right, trie): 
            result = 0
            for i in reversed(range(left, right+1)):
                if A[i] not in trie:
                    result += 1
                trie = trie[A[i]]
            return result

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        result, left, count = 0, 0, 0
        for right in range(len(A)):
            count += A[right]%2
            while count > K:
                count -= A[left]%2
                left += 1
            result += countDistinct(A, left, right, trie)
        return result",O(n ^ 2)
"n = int(input())
print(int(3 * n / 2))",O(1)
"MAXN = 200001
n, m = map(int, input().split(' '))
s = list(map(int, input().split(' ')))

f = [0 for i in range(n+1)]
count = [0 for i in range(-MAXN, MAXN+1)]

f[0] = 0

last = 0
res = 0

for i in range(1, n+1):
    if s[i-1] == m:
        for j in range(last, i):
            count[f[j]] += 1
        last = i

    if s[i-1] > m:
        f[i] = f[i-1] - 1
    else:
        f[i] = f[i-1] + 1

    res += count[f[i]] + count[f[i]-1]

print(res)
",O(nlogn)
"class Solution(object):
    def reverseParentheses(self, s):
        stk, lookup = [], {}
        for i, c in enumerate(s):
            if c == '(':
                stk.append(i)
            elif c == ')':
                j = stk.pop()
                lookup[i], lookup[j] = j, i
        result = []
        i, d = 0, 1
        while i < len(s):
            if i in lookup:
                i = lookup[i]
                d *= -1
            else:
                result.append(s[i])
            i += d
        return """".join(result)",O(n)
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math

alphabets = list('abcdefghijklmnopqrstuvwxyz')

def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))
def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def power_set(L):

    cardinality=len(L)
    n=2 ** cardinality
    powerset = []

    for i in range(n):
        a=bin(i)[2:]
        subset=[]
        for j in range(len(a)):
            if a[-j-1]=='1':
                subset.append(L[j])
        powerset.append(subset)

    powerset_orderred=[]
    for k in range(cardinality+1):
        for w in powerset:
            if len(w)==k:
                powerset_orderred.append(w)

    return powerset_orderred
def fastPlrintNextLines(a):

    print('\n'.join(map(str,a)))

def sortByFirstAndSecond(A):
    A = sorted(A,key = lambda x:x[0])
    A = sorted(A,key = lambda x:x[1])
    return list(A)

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"")

t = 1

for _ in range(t):
    n,m = li()
    s = list(si())
    t = list(si())
    if '*' not in s:
        if s==t:
            print(""YES"")
        else:
            print(""NO"")
        continue
    i = s.index('*')
    if s[:i]==t[:i]:
        s = s[i:]
        t = t[i:]
        s=s[::-1]
        t = t[::-1]
        i = s.index('*')

        if len(t)>=i and s[:i]==t[:i]:
            print(""YES"")
        else:
            print(""NO"")
    else:
        print(""NO"")
",O(n)
"from sys import stdin
from math import factorial

n, mod = map(int, stdin.readline().split())

def binom(n, m):
    return factorial(n) // factorial(m) // factorial(n-m)

def foo(x, k):
    ans = 0
    for i in range(k, 0, -1):
        sign = 1 if (i-k)%2 == 0 else -1
        ans += sign * binom(k, i) * (i**x)
        ans %= mod
    return ans

def f(x, k):
    return (foo(x, k) * pow(2, x-k, mod)) % mod

ans = 0
for i in range((n+1)//2):
    ans = (ans + f(n-i, i+1))
    ans %= mod
print(ans)
",O(n ^ 3)
"n,k = map(int,input().split())
arr = list(map(int,input().split()))
bs = [[x,i+1] for i,x in enumerate(arr)]
bs.sort(reverse=True)
cs = [bs[i][1] for i in range(k)]
ans = sum(bs[i][0] for i in range(k))
cs.sort()
print(ans)
if k==1:
    print(n)
else:
    print(cs[0],end="" "")

    for i in range(1,k-1):
        print(cs[i]-cs[i-1],end="" "")
    print(n-cs[k-2])
",O(nlogn)
"c1, c2, c3 = map(int, input().split())
r = sorted(list(map(int, input().split())))
g = sorted(list(map(int, input().split())))
b = sorted(list(map(int, input().split())))
dp = [[[0 for i in range(c3 + 1)] for i in range(c2 + 1)] for i in range(c1 + 1)]
for i in range(c1 + 1):
    for j in range(c2 + 1):
        for k in range(c3 + 1):
            if i>0 and j>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])
            if i>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1])
            if j>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i ][j - 1][k-1] + g[j - 1] * b[k - 1])
print(dp[c1][c2][c3])
",O(n ^ 3)
"class Solution2(object):
    def countOfSubstrings(self, word, k):
        VOWELS = set(""aeiou"")
        def count(k):
            def update(i, d):
                if word[i] not in VOWELS:
                    curr2[0] += d
                    return
                x = ord(word[i])-ord('a')
                if cnt[x] == 0:
                    curr1[0] += 1
                cnt[x] += d
                if cnt[x] == 0:
                    curr1[0] -= 1

            result = 0
            cnt = [0]*26
            curr1, curr2 = [0], [0]
            left = 0
            for right in range(len(word)):
                update(right, +1)
                while curr1[0] == len(VOWELS) and curr2[0] >= k:
                    result += len(word)-right
                    update(left, -1)
                    left += 1
            return result

        return count(k)-count(k+1)",O(n)
"class Solution(object):
    def numberOfAlternatingGroups(self, colors):
        k = 3
        result = curr = left = 0
        for right in range(len(colors)+k-1):  
            if right-left+1 == k:
                result += int(curr == k-1)
                curr -= int(colors[left] != colors[(left+1)%len(colors)])
                left += 1
            curr += int(colors[right%len(colors)] != colors[(right+1)%len(colors)])
        return result",O(n)
"class Solution2(object):
    def isConsecutive(self, nums):
        nums.sort()
        return all(nums[i]+1 == nums[i+1] for i in range(len(nums)-1))",O(nlogn)
"import sys
import math
import collections
import operator as op
from collections import deque
from math import gcd, inf, sqrt, pi, cos, sin, ceil, log2, floor, log
from bisect import bisect_right, bisect_left, bisect

from functools import reduce
from sys import stdin, stdout, setrecursionlimit
setrecursionlimit(2**20)

def ncr(n, r):
    r = min(r, n - r)
    numer = reduce(op.mul, range(n, n - r, -1), 1)
    denom = reduce(op.mul, range(1, r + 1), 1)
    return numer // denom

def prime_factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return (list(factors))

def isPowerOfTwo(x):
    return (x and (not(x & (x - 1))))

MOD = 1000000007
PMOD = 998244353
N = 10**18 + 1
LOGN = 30
alp = 'abcdefghijklmnopqrstuvwxyz'
T = 1

for _ in range(T):
    n, k = list(map(int, stdin.readline().rstrip().split()))

    det = (int(sqrt(9 + 8 * (n + k)) - 3)) // 2
    print(n - det)
",O(logn)
"def factorial(n):
    if n<=1:
        return 1
    return n*factorial(n-1)

original = input()
received = input()

originalNum = original.count('+') - original.count('-')
receivedNum = received.count('+') - received.count('-')

variance = received.count('?')

difference = abs(originalNum - receivedNum)

if variance==0:
    if difference==0:
        print(1.)
    else:
        print(0.)
elif difference > variance or difference%2!=variance%2:
    print(0.)
else:
    difference += variance
    difference//=2

    c = factorial(variance)/(factorial(difference)*factorial(variance-difference))
    print(c/(2**variance))
",np
"class Solution(object):
    def reverseWords(self, s):
        def reverse(s, begin, end):
            for i in range((end - begin) / 2):
                s[begin + i], s[end - 1 - i] = s[end - 1 - i], s[begin + i]

        reverse(s, 0, len(s))
        i = 0
        for j in range(len(s) + 1):
            if j == len(s) or s[j] == ' ':
                reverse(s, i, j)
                i = j + 1",O(n)
"import sys
def main():
    pass
def binary(n):

    return (bin(n).replace(""0b"", """"))
def decimal(s):

    return (int(s, 2))
def pow2(n):

    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)
def isPrime(n):

    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)
def lts(l):

    s = ''.join(map(str, l))
    return s
def stl(s):

    l = list(s)

    return l

def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans

mod = int(1e9) + 7
def ssinp(): return sys.stdin.readline().strip()

def iinp(): return int(input())

def nninp(): return map(int, sys.stdin.readline().strip().split())

def llinp(): return list(map(int, sys.stdin.readline().strip().split()))

def p(xyz): print(xyz)
def p2(a, b): print(a, b)
import math
from collections import OrderedDict
from fractions import Fraction

n,m=nninp()
x=llinp()
y=llinp()
for c in x:
    if(c in y):
        print(c,end="" "")
",O(n ^ 2)
"n = int(input())

t = list(map(int,input().split()))

t.sort()

if t[-1]==1:
    t[-1]=2
else:
    t[-1]=1
t.sort()
print(*t)
",O(nlogn)
"a = int(input())
c = [1] * 30
for i in range (1,20):
	c[i] = 9 * i * pow(10,i-1)
for i in range (1,15):
	if (a > c[i]):
		a -= c[i]
	else:
		d = int((a-1) / i + pow(10,i-1) - 1)
		e = (a-1) % i + 1
		f = str(d+1)
		print(f[e-1])
		exit()",O(logn)
"s = input()
ans = 2
s1 = s[0:2]
s2 = s[3:5]
s3 = s[6:8]
def func(inp):
    ans = 2
    num = int(inp[0])
    c = inp[1]
    ans = min( ans, 2 - int(s.find(str(num + 1)+c) != -1) - int(s.find(str(num + 2)+c) != -1))
    ans = min( ans, 2 - int(s.find(str(num + 1)+c) != -1) - int(s.find(str(num - 1)+c) != -1))
    ans = min( ans, 2 - int(s.find(str(num - 1)+c) != -1) - int(s.find(str(num - 2)+c) != -1))
    ans = min( ans, 3 - s.count(inp))
    return ans
ans = min(ans,func(s1))
ans = min(ans,func(s2))
ans = min(ans,func(s3))
print(ans)
",O(n)
"class Solution(object):
    def getMaximumConsecutive(self, coins):
        coins.sort()
        result = 1
        for c in coins:
            if c > result:
                break
            result += c
        return result",O(nlogn)
"class Solution(object):
    def removeOuterParentheses(self, S):
        deep = 1
        result, cnt = [], 0
        for c in S:
            if c == '(' and cnt >= deep:
                result.append(c)
            if c == ')' and cnt > deep:
                result.append(c)
            cnt += 1 if c == '(' else -1
        return """".join(result)",O(n)
"class Solution(object):
    def countGoodNodes(self, edges):
        def iter_dfs():
            result = 0
            stk = [(1, (0, -1, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    l, valid = [0], [True]
                    stk.append((4, (ret, valid)))
                    stk.append((2, (u, p, 0, ret, l, valid)))
                elif step == 2:
                    u, p, i, ret, l, valid = args
                    if i == len(adj[u]):
                        continue
                    stk.append((2, (u, p, i+1, ret, l, valid)))
                    v = adj[u][i]
                    if v == p:
                        continue
                    new_ret = [0]
                    stk.append((3, (new_ret, ret, l, valid)))
                    stk.append((1, (v, u, new_ret)))
                elif step == 3:
                    new_ret, ret, l, valid = args
                    ret[0] += new_ret[0]
                    l[0] += 1
                    if new_ret[0]*l[0] != ret[0]:
                        valid[0] = False
                elif step == 4:
                    ret, valid = args
                    if valid[0]:
                        result += 1
                    ret[0] += 1
            return result

        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()",O(n)
"class Solution(object):
    def findSmallestInteger(self, nums, value):
        cnt = collections.Counter(x%value for x in nums)
        mn = min((cnt[i], i) for i in range(value))[1]
        return value*cnt[mn]+mn
import collections",O(n)
"class Solution(object):
    def maximumMatchingIndices(self, nums1, nums2):
        return max(sum(nums2[j] == nums1[(i+j)%len(nums1)] for j in range(len(nums2))) for i in range(len(nums1)))",O(n ^ 2)
"from math import factorial

s1 = input()
s2 = input()

cnt_plus_1, cnt_plus_2 = 0, 0
cnt_minus_1, cnt_minus_2 = 0, 0
cnt_question = 0

for i in range(len(s1)):
    if s1[i] == ""+"": cnt_plus_1 += 1
    if s1[i] == ""-"": cnt_minus_1 += 1

    if s2[i] == ""+"": cnt_plus_2 += 1
    if s2[i] == ""-"": cnt_minus_2 += 1

    if s2[i] == ""?"": cnt_question += 1

if cnt_question == 0:
    if cnt_plus_1 == cnt_plus_2:
        print(""{:.9f}"".format(1.0))
    else:
        print(""{:.9f}"".format(0.0))
elif cnt_plus_2 + cnt_question < cnt_plus_1 or cnt_plus_2 > cnt_plus_1:
    print(""{:.9f}"".format(0.0))
else:
    dP = cnt_plus_1 - cnt_plus_2
    dM = cnt_question - dP

    if dM == 0 or dP == 0:
        print(""{:0.9f}"".format(1 / (2**cnt_question)))
    else:
        CP = factorial(cnt_question) / (factorial(dP)*factorial(cnt_question - dP))
        print((CP * (0.5 ** dP) * (1 - 0.5) ** (cnt_question - dP)))
",np
"from math import factorial
s=input()
s1=input()
plus=s.count('+')-s1.count('+')
minus=s.count('-')-s1.count('-')
n=s1.count('?')
if plus<0 or minus<0:
    print(0)
else:
    print((factorial(n)/factorial(n-plus)/factorial(plus))*(0.5**n))",np
"n, m = list(map(int, input().split()))
square = [0] * n
l = list(map(int, input().split()))
for x in l:
    square[x-1] += 1
print(min(square))
",O(n ^ 2)
"def ask(a, b):
    print(""?"", a, b, flush=True)
    return int(input()) <= 0

def solve(M):
    a, b = 0, 0
    less = ask(0, 0)

    for i in range(M - 1, -1, -1):
        bit = 1 << i

        if less:
            if not ask(a | bit, b | bit):
                b |= bit
                less = ask(a, b)
            elif ask(a | bit, b):
                a |= bit
                b |= bit
        else:
            if ask(a | bit, b | bit):
                a |= bit
                less = ask(a, b)
            elif ask(a | bit, b):
                a |= bit
                b |= bit

    print(""!"", a, b, flush=True)

if __name__ == '__main__':
    solve(30)
",O(logn)
"import sys
input = sys.stdin.readline
test = int(input())
for _ in range(test):
  s = input().rstrip()
  t = input().rstrip()
  n = len(s)
  m = len(t)
  ansls = []
  pos = [[1000 for i in range(26)] for j in range(n+2)]
  for i in range(n+1)[::-1]:
    if i < n:
      for j in range(26):
        pos[i][j] = pos[i+1][j]
    if i > 0:
      x = ord(s[i-1])-97
      pos[i][x] = i
  flg = 0
  for i in range(m):
    t1 = t[:i]
    t2 = t[i:]
    m1 = len(t1)
    m2 = len(t2)
    dp = [[1000 for i in range(m2+1)] for j in range(m1+1)]
    dp[0][0] = 0
    for j in range(m1+1):
      for k in range(m2+1):
        if j > 0 and dp[j-1][k] < 1000:
          t1x = ord(t1[j-1])-97
          dp[j][k] = min(dp[j][k],pos[dp[j-1][k]+1][t1x])
        if k > 0 and dp[j][k-1] < 1000:
          t2x = ord(t2[k-1])-97
          dp[j][k] = min(dp[j][k],pos[dp[j][k-1]+1][t2x])
    if dp[-1][-1] < 1000:
      flg = 1
      break
  if flg:
    print(""YES"")
  else:
    print(""NO"")",O(n ^ 3)
"from itertools import permutations, chain

def get_plots(a,b):

  ax,ay = a
  bx,by = b

  for x in range(ax,bx,1 if ax < bx else -1):
    yield (x,ay)
  for y in range(ay,by,1 if ay < by else -1):
    yield (bx,y)

def solve(points):

  for a,b,c in permutations(points):
    ax,ay = a
    bx,by = b
    cx,cy = c
    if min(ax,bx) <= cx <= max(ax,bx) and min(ay,by) <= cy <= max(ay,by):
      return list(chain(get_plots(a,c), get_plots(c,b), [b]))

  def it():
    for a,b,c in permutations(points):
      ax,ay = a
      bx,by = b
      m = (ax,by)
      L = list(chain(get_plots(a,m),get_plots(b,m), get_plots(c,m), [m]))
      yield (len(L),L)

  return min(it())[1]

points = [tuple(map(int,input().split())) for _ in range(3)]

res = solve(points)
print(len(res))
for x,y in res:
  print(x,y)
",O(n)
"from itertools import combinations

p, minn, maxn, dif = map(int, input().split())
(*lst,) = map(int, input().split())
c = 0
for i in range(2, p + 2):
    for j in combinations(lst, i):
        if (maxn >= sum(j) >= minn) and (max(j) - min(j) >= dif):
            c += 1
print(c)",np
"n, S = map(int, input().split())
print((S + n - 1) // n);
",O(1)
"def f(n,s):
    d=[-n,-n];d[s]=0
    for i in range(y//g):d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
    return d[s]
import math;n,x,y=map(int,input().split());g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));y+=x;print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np
"n = int(input())
d = []
for i in range(n):
    xx, ww = [int(i) for i in input().split()]
    d.append([xx-ww, xx+ww])
d.sort(key=lambda x:x[0])
last = -100000000000
ans = 0
for i in range(n):
    if last <= d[i][0]:
        last = d[i][1]
        ans += 1
    elif last > d[i][1]:
        last = d[i][1]
print(ans)
",O(nlogn)
"class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        res = [root.val]

        def dfs(root):
            if not root:
                return 0

            leftMax = dfs(root.left)
            rightMax = dfs(root.right)
            leftMax = max(leftMax, 0)
            rightMax = max(rightMax, 0)

            res[0] = max(res[0], root.val + leftMax + rightMax)
            return root.val + max(leftMax, rightMax)

        dfs(root)
        return res[0]
",O(n)
"def normal_sum(N):
	return (N ** 2 + N) // 2

def sum(i, j):

	return normal_sum(j) - 1 - (normal_sum(i-1) - 1)

def bs_sum(start, end, k, n):

	mid = (start+end) // 2

	if(n - sum(mid, k) >= mid):
		return bs_sum(start, mid - 1, k, n)
	if(n - sum(mid, k) < 0):
		return bs_sum(mid+1, end, k, n)

	return k-mid+2 if (n - sum(mid, k)) != 0 else k-mid+1

n, k = [int(n) for n in input().split()]
if (n == 1):
	print( 0 )
elif n <= k :
	print( 1 )
elif normal_sum(k) - 1 - (k-2) < n:
	print( -1 )
else:
	n-=1
	k-=1

	answer = (bs_sum(1, k, k, n))
	print(answer)
",O(logn)
"n = int(input())
c = [0] + [int(j) for j in input().split()]
a = [0] + [int(j) for j in input().split()]
vis = [0] * (n + 1)
ans = 0
for i in range(1, n + 1):
    x = i
    while vis[x] == 0:
        vis[x] = i
        x = a[x]
    if vis[x] != i:
        continue
    v = x
    mn = c[x]
    while a[x] != v:
        x = a[x]
        mn = min(mn, c[x])
    ans += mn
print(ans)
",O(n)
"class Solution(object):
    def minOperations(self, s1, s2, x):
        parity = curr = prev = 0
        j = -1
        for i in range(len(s1)):
            if s1[i] == s2[i]:
                continue
            curr, prev = min(curr+x, prev+(i-j)*2 if j != -1 else float(""inf"")), curr
            j = i
            parity ^= 1
        return curr//2 if parity == 0 else -1",O(n)
"class Solution2(object):
    def minReverseOperations(self, n, p, banned, k):
        lookup = [False]*n
        for i in banned:
            lookup[i] = True
        d = 0
        result = [-1]*n
        result[p] = d
        sl = [SortedList(i for i in range(0, n, 2)), SortedList(i for i in range(1, n, 2))]
        sl[p%2].remove(p)
        q = [p]
        d += 1
        while q:
            new_q = []
            for p in q:
                left, right = 2*max(p-(k-1), 0)+(k-1)-p, 2*min(p+(k-1), n-1)-(k-1)-p
                for p in list(sl[left%2].irange(left, right)):
                    if not lookup[p]:
                        result[p] = d
                        new_q.append(p)
                    sl[left%2].remove(p)
            q = new_q
            d += 1
        return result",O(nlogn)
"class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        arr = []

        def dfs(node):
            if not node:
                return

            dfs(node.left)
            arr.append(node.val)
            dfs(node.right)

        dfs(root)
        return arr[k - 1]
",O(n)
"s=input()
c=c1=0
for i in range(len(s)//2):
    if s[i]==s[len(s)-i-1]:
        c+=1
for i in range(len(s)):
    if s[i]==s[0]:
        c1+=1
if c1==len(s):
    print(0)
elif c==len(s)//2:
    print(len(s)-1)
else:
    print(len(s))",O(n)
"from bisect import bisect_left
class SegmentTree:
    def __init__(self, N):
        self.n = N
        while (self.n & (self.n - 1)) != 0:
            self.n += 1
        self.tree = [0] * (2 * self.n)

    def update(self, i, val):
        self.tree[self.n + i] = val
        j = (self.n + i) >> 1
        while j >= 1:
            self.tree[j] = max(self.tree[j << 1], self.tree[j << 1 | 1])
            j >>= 1

    def query(self, l, r):
        if l > r:
            return 0
        res = float('-inf')
        l += self.n
        r += self.n + 1
        while l < r:
            if l & 1:
                res = max(res, self.tree[l])
                l += 1
            if r & 1:
                r -= 1
                res = max(res, self.tree[r])
            l >>= 1
            r >>= 1
        return res

class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        def compress(arr):
            sortedArr = sorted(set(arr))
            order = []
            for num in arr:
                order.append(bisect_left(sortedArr, num))
            return order

        nums = compress(nums)
        n = len(nums)
        segTree = SegmentTree(n)

        LIS = 0
        for num in nums:
            curLIS = segTree.query(0, num - 1) + 1
            segTree.update(num, curLIS)
            LIS = max(LIS, curLIS)
        return LIS
",O(nlogn)
"n = int(input())
map1 = [list(input()) for i in range(n)]
map2 = [list(input()) for i in range(n)]

def vFlip (m):
    return([list(reversed(i)) for i in m])

def hFlip(m):
    return(list(reversed(m)))

def rotate(m):
    return(list(zip(*reversed(m))))

def check():
    global map1
    for i in range(4):
        if map1 == map2:
            return(True)
        if vFlip(map1)==map2:
            return(True)
        if hFlip(map1)==map2:
            return(True)
        if vFlip(hFlip(map1))==map2:
            return(True)
        map1 = rotate(map1)
    return(False)

print('YES' if check() else 'NO')",O(n ^ 2)
"def get_ans(x, a, n, m):

    lim = 1<<m
    match = lim-1
    track = [-1 for i in range(lim)]

    for i in range(n):
        mask = 0
        for j in range(m):
            if(a[i][j] >= x):
                mask |= 1 << j
        track[mask] = i

    for i in range(lim):
        for j in range(lim):
            if(i|j == match and track[i] != -1 and track[j] != -1):
                return track[i], track[j]

    return -1, -1

n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]

lo = 0
hi = 1000000000
while(lo < hi-1):
    mid = (lo+hi)/2
    i, j = get_ans(mid,a,n,m)
    if(i == -1):
        hi = mid-1
    else:
        lo = mid

i,j = get_ans(hi,a,n,m)
if(i != -1):
    print(""{} {}"".format(i+1,j+1))
else:
    i,j = get_ans(lo,a,n,m)
    print(""{} {}"".format(i+1,j+1))
",np
"n,U=list(map(int, input().split(' ')))
a=list(map(int, input().split(' ')))

import bisect
def max_eligible(a,x):
    ind=bisect.bisect_right(a,x)
    if ind <= len(a):
        return a[ind-1]
    else:
        return -1

max_val=-1
for i in range(n-2):
    x = a[i]+U
    val1 = max_eligible(a,x)

    if val1!=-1 and val1!=a[i+1] and val1!=a[i]:

        val = (val1-a[i+1]) / (val1-a[i])

        max_val=max(max_val,val)

print(max_val)
",O(nlogn)
"NANS = (False, None)

def is_valid(n, k):
    if n > 31:
        return True
    return k*3 <= (2**(2*n) - 1)

def solve_mini(n, k):
    if not is_valid(n, k):
        return NANS

    if n == 1:
        if k == 1:
            return (True, 0)
        else:
            return (False, None)
    if n == 2:
        if k in [1, 2]:
            return (True, 1)
        if k in [4, 5]:
            return (True, 0)
    return (False, None)

def solve(n, k):
    if n < 3:
        ans, log = solve_mini(n, k)
        return (ans, log)

    if not is_valid(n, k):
        return NANS

    w = 1
    while k >= w and n >= 1:
        k -= w
        n -= 1
        w = w + w + 1
    return(True, n)

t = int(input())
for i in range(t):
    n, k = map(int, input().split())
    ans, log = solve(n, k)
    if ans:
        print(""YES"", log)
    else:
        print(""NO"")
",O(logn)
"class Solution(object):
    def countSubstrings(self, s, c):
        n = s.count(c)
        return (n+1)*n//2",O(n)
"class Solution(object):
    def maxFreeTime(self, eventTime, startTime, endTime):
        def topk(a, k): 
            result = [[float(""-inf"")]*2 for _ in range(k)]
            for x in a:
                for i in range(len(result)):
                    if x > result[i]:
                        result[i], x = x, result[i]
            return result

        result = 0
        startTime.append(eventTime)
        endTime.insert(0, 0)
        diffs = ([startTime[i]-endTime[i], endTime[i]] for i in range(len(startTime)))
        top3 = topk(diffs, 3)
        for i in range(len(startTime)-1):
            for mx, e in top3:
                if e not in (endTime[i], endTime[i+1]) and endTime[i+1]-startTime[i] <= mx:
                    result = max(result, (startTime[i]-endTime[i])+(startTime[i+1]-endTime[i+1])+(endTime[i+1]-startTime[i]))
                    break
            else:
                result = max(result, (startTime[i]-endTime[i])+(startTime[i+1]-endTime[i+1]))
        return result",O(n)
"class Solution(object):
    def findWords(self, words):
        rows = [set(['q', 'w', 'e', 'r', 't', 'y','u', 'i', 'o', 'p']),
                set(['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l']),
                set(['z', 'x', 'c', 'v', 'b' ,'n', 'm'])]

        result = []
        for word in words:
            k = 0
            for i in range(len(rows)):
                if word[0].lower() in rows[i]:
                    k = i
                    break
            for c in word:
                if c.lower() not in rows[k]:
                    break
            else:
                result.append(word)
        return result",O(n)
"n=int(input())
s=input()
l=[]
total=0
p=0
for i in range(0,450):
    sum1=0
    flag=1
    r=0
    for k in range(n):
        sum1=sum1+int(s[k])
        if(sum1>i):
            flag=0
        if(sum1==i):
            sum1=0
            r=r+1
    if(r>=2 and sum1==0 and flag==1):
        print(""YES"")
        p=1
        break
if(p==0):
    print(""NO"")",O(n ^ 2)
"n,m = map(int,input().split())
ans = 0
temp = [0 for i in range(n)]
for i in range(n):
    l,r = map(int,input().split())
    ans += l
    temp[i] = l-r
temp.sort(reverse=True)

if ans<=m:
    print(0)
else:
    for i in range(n):
        ans -= temp[i]
        if ans<=m:
            print(i+1)
            break
    else:
        print(-1)
",O(nlogn)
"import sys
input=sys.stdin.readline

from collections import defaultdict

def toposort(graph):
    res = []
    found = [0] * len(graph)
    stack = list(range(len(graph)))
    while stack:
        node = stack.pop()
        if node < 0:
            res.append(1+(~node))
        elif not found[node]:
            found[node] = 1
            stack.append(~node)
            stack.extend(graph[node])

    for node in res:
        node-=1
        if any(found[nei] for nei in graph[node]):
            print(""NO"")
            return
        found[node] = 0

    print(""YES"")
    print(*res[::-1])

n,m,k=map(int,input().split())
patterns=set()
pos=dict()

for i in range(n):
    p=input().rstrip()
    patterns.add(p)
    pos[p]=i

matches=[[] for _ in range(n)]

chk=True
for i in range(m):
    s,mt=input().rstrip().split()
    mt=int(mt)-1
    if(chk):
        chk=False
        for i in range(1<<k):
            tmp=[]
            for j in range(k):
                if(i&(1<<j)):
                    tmp.append('_')
                else:
                    tmp.append(s[j])
            tmp=''.join(tmp)
            if(tmp in patterns):
                if(mt==pos[tmp]):
                    chk=True
                else:
                    matches[mt].append(pos[tmp])

if(not chk):
    print(""NO"")
else:
    toposort(matches)
",np
"n,m,k = list(map(int,input().split()))

l = list(map(int,input().split()))

out = 0
d = 0

while m > d:
    nex = l[d]
    page = (nex - d - 1)//k
    add = 1
    while d + add < m and (page * k) < l[d + add] - d  <= (page + 1) * k:
        add += 1
    d += add
    out += 1

print(out)
",O(n)
"import collections



class Solution(object):
    def getMaxFunctionValue(self, receiver, k):
        def find_cycles(adj):
            result = []
            lookup = [0]*len(adj)
            idx = 0
            for u in range(len(adj)):
                prev = idx
                while not lookup[u]:
                    idx += 1
                    lookup[u] = idx
                    u = adj[u]
                if lookup[u] > prev:
                    result.append((u, idx-lookup[u]+1))
            return result

        def find_prefixes():
            lookup = [(-1, -1)]*len(receiver)
            prefixes = [[0] for _ in range(len(cycles))]
            for idx, (u, l) in enumerate(cycles):
                for i in range(l):
                    lookup[u] = (idx, i)
                    prefixes[idx].append(prefixes[idx][i]+u)
                    u = receiver[u]
            return lookup, prefixes
        
        def get_sum(prefix, i, cnt):
            l = len(prefix)-1
            q, r = divmod(cnt, l)
            return (q*prefix[-1]+
                    (prefix[min(i+r, l)]-prefix[i])+
                    (prefix[max(((i+r)-l, 0))]-prefix[0]))
        
        def start_inside_cycle():
            result = 0
            for u, l in cycles:
                for _ in range(l):
                    idx, i = lookup[u]
                    result = max(result, get_sum(prefixes[idx], i, k+1))
                    u = receiver[u]
            return result
    
        def start_outside_cycle():
            result = 0
            degree = [0]*len(receiver)
            for x in receiver:
                degree[x] += 1
            for u in range(len(receiver)):
                if degree[u]:
                    continue
                curr = 0
                dq = collections.deque()
                while lookup[u][0] == -1:
                    curr += u
                    dq.append(u)
                    if len(dq) == k+1:
                        result = max(result, curr)
                        curr -= dq.popleft()
                    u = receiver[u]
                idx, i = lookup[u]
                while dq:
                    result = max(result, curr+get_sum(prefixes[idx], i, (k+1)-len(dq)))
                    curr -= dq.popleft()
            return result
            
        cycles = find_cycles(receiver)
        lookup, prefixes = find_prefixes()
        return max(start_inside_cycle(), start_outside_cycle())",O(n)
"class Solution(object):
    def minCost(self, costs):
        if not costs:
            return 0

        min_cost = [costs[0], [0, 0, 0]]

        n = len(costs)
        for i in range(1, n):
            min_cost[i % 2][0] = costs[i][0] + \
                                 min(min_cost[(i - 1) % 2][1], min_cost[(i - 1) % 2][2])
            min_cost[i % 2][1] = costs[i][1] + \
                                 min(min_cost[(i - 1) % 2][0], min_cost[(i - 1) % 2][2])
            min_cost[i % 2][2] = costs[i][2] + \
                                 min(min_cost[(i - 1) % 2][0], min_cost[(i - 1) % 2][1])

        return min(min_cost[(n - 1) % 2])",O(n)
"n,K=map(int,input().split())
b=sorted([int(x)for x in input().split()])
l=cur=0
for i in range(1,n):
    if b[i]==b[i-1]:continue
    if b[i]>b[i-1]+K:l=i
    else:cur+=(i-l);l=i
print(n-cur)
",O(nlogn)
"class Solution(object):
    def arraysIntersection(self, arr1, arr2, arr3):
        result = []
        i, j, k = 0, 0, 0
        while i != len(arr1) and j != len(arr2) and k != len(arr3):
            if arr1[i] == arr2[j] == arr3[k]:
                result.append(arr1[i])
                i += 1
                j += 1
                k += 1
            else:
                curr = max(arr1[i], arr2[j], arr3[k])
                while i != len(arr1) and arr1[i] < curr:
                    i += 1
                while j != len(arr2) and arr2[j] < curr:
                    j += 1
                while k != len(arr3) and arr3[k] < curr:
                    k += 1
        return result",O(n)
"class Solution(object):
    def maximumTime(self, time):
        result = list(time)
        for i, c in enumerate(time): 
            if c != ""?"":
                continue
            if i == 0:
                result[i] = '2' if result[i+1] in ""?0123"" else '1'
            elif i == 1:
                result[i] = '3' if result[0] == '2' else '9'
            elif i == 3:
                result[i] = '5'
            elif i == 4:
                result[i] = '9'
        return """".join(result)",O(1)
"n=int(input())
c=[0]*4
for k in range(4):
 for i in range(n):
  s=input()
  for j in range(n):
   if(i+j)%2!=int(s[j]):c[k]+=1
 if k<3:input()
c.sort()
print(c[0]+c[1]+2*n*n-c[2]-c[3])
",O(n ^ 2)
"class Solution4(object):
    def maxIncreasingGroups(self, usageLimits):
        def check(l):
            return all((i+1)*i//2 <= prefix[len(usageLimits)-(l-i)] for i in range(1, l+1))

        usageLimits.sort()
        prefix = [0]*(len(usageLimits)+1)
        for i in range(len(usageLimits)):
            prefix[i+1] = prefix[i]+usageLimits[i]
        left, right = 1, len(usageLimits)
        while left <= right:
            mid = left + (right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right",O(nlogn)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def correctBinaryTree(self, root):
        q = {root:None}
        while q:
            new_q = {}
            for node, parent in q.items():
                if node.right in q:
                    if parent.left == node:
                        parent.left = None
                    else:
                        parent.right = None
                    return root
                if node.left:
                    new_q[node.left] = node
                if node.right:
                    new_q[node.right] = node
            q = new_q",O(n)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def levelOrder(self, root):
        if root is None:
            return []
        result, current = [], [root]
        while current:
            next_level, vals = [], []
            for node in current:
                vals.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            current = next_level
            result.append(vals)
        return result

",O(n)
"import collections
import itertools



class Solution(object):
    def mostPopularCreator(self, creators, ids, views):
        cnt = collections.Counter()
        lookup = collections.defaultdict(lambda: (float(""inf""), float(""inf"")))
        for c, i, v in zip(creators, ids, views):
            cnt[c] += v
            lookup[c] = min(lookup[c], (-v, i))
        mx = max(cnt.values())
        return [[k, lookup[k][1]] for k, v in cnt.items() if v == mx]",O(n)
"class Solution(object):
    def convertTemperature(self, celsius):
        return [celsius+273.15, celsius*1.80+32.00]",O(1)
"import math

s1 = input()
s2 = input()

plus, minus = s1.count('+'), s1.count('-')

pre_plus = s2.count('+'); pre_minus = s2.count('-')

req_plus, req_minus = plus- pre_plus, minus - pre_minus

if req_minus < 0 or req_plus < 0:
	print('%.12f'%0)
else:
	unknowns = len(s1) - (pre_minus + pre_plus)

	if unknowns == 0:
		print('%.12f'%1)
	else:
		den = pow(2, unknowns)
		num = math.factorial(unknowns)/(math.factorial(req_plus)*math.factorial(req_minus))
		ans = num/den
		print('%.12f'%ans)",np
"class Solution(object):
    def lemonadeChange(self, bills):
        coins = [20, 10, 5]
        counts = collections.defaultdict(int)
        for bill in bills:
            counts[bill] += 1
            change = bill - coins[-1]
            for coin in coins:
                if change == 0:
                    break
                if change >= coin:
                    count = min(counts[coin], change//coin)
                    counts[coin] -= count
                    change -= coin * count
            if change != 0:
                return False
        return True",O(n)
"n=int(input())
i=iter(sorted(zip(map(int,input().split()),range(1,n+1))))
s,o=[],[]
for c in input():
 if c=='0':
  x=next(i)[1];o+=[x];s+=[x]
 else:o.append(s.pop())
print(*o)
",O(nlogn)
"n=int(input())
dict1={}
for i in range(n-1):
    x,y=map(int,input().split())
    try:
        dict1[y].append(x)
    except:
        KeyError
        dict1[y]=[x]
    try:
        dict1[x].append(y)
    except:
        KeyError
        dict1[x]=[y]
arr=list(map(int,input().split()))
if(arr[0]!=1):
    print(""No"")
else:
    j=0
    i=1
    flag=0
    while(i<n and j<n):
        if(arr[j] in dict1[arr[i]]):
            i+=1
        else:
            j+=1
    if(i!=n and j==n):
        print('No')
    else:
        print('Yes')
",O(n)
"cases = int(input())
while cases:
    cases -= 1
    a, b = map(int, input().split())

    ans = 0
    while a > 0 and b > 0:
        if a < b:
            a, b = b, a
        ans += a//b
        a = a % b

    print(ans)
",O(1)
"import sys, string

n, m = map(int, sys.stdin.readline().split())
print('4' * 2229)
print('5' * 2228 + '6')",O(1)
"n,s=map(int,input().split())
degs=[0]*n
for i in range(n-1):
    a,b=map(int,input().split())
    degs[a-1]+=1
    degs[b-1]+=1
print(2*s/degs.count(1))",O(n)
"import heapq
import collections



class Solution(object):
    def minimumAddedInteger(self, nums1, nums2):
        def check(cnt2, cnt1):
            return all(cnt1.get(k, 0)-v >= 0 for k, v in cnt2.items()) 
            
        mx = max(nums2)
        cnt2 = collections.Counter(nums2)
        return next(d for d in [mx-x for x in heapq.nlargest(3, nums1)] if check(cnt2, collections.Counter(x+d for x in nums1)))",O(n)
"from bisect import bisect
n, m = map(int, input().split())
vv = sorted([int(input()) for _ in range(n)])
hh = [0] * n
rr = 0
for _ in range(m):
  one, x, _ = map(int, input().split())
  if one == 1:
    if x == 1000000000:
      rr += 1
    else:
      ind = bisect(vv, x)
      if ind:
        hh[ind-1] += 1
r = n
s = 0

for i, h in reversed(list(enumerate(hh))):
  s += h

  r = min(r, s+i)
print(r+rr)
",O(nlogn)
"import math
n, k = map(int, input().split())
if k % 2 == 1:
  mink = (k + 1) // 2
else:
  mink = k // 2 + 1
print(max(0, min(k - 1, n) - mink + 1))
",O(1)
"import os
import sys
from io import BytesIO, IOBase

def main():
    a=list(map(int,input().rstrip()))
    b=list(map(int,input().rstrip()))
    ans,la,lb=[],len(a),len(b)
    if la!=lb:
        print(*sorted(a,reverse=True),sep="""")
    else:
        for i in range(lb):
            if b[i] in a:
                ans.append(b[i])
                a.remove(b[i])
            else:
                ma=-1
                for j in a:
                    if j<b[i]:
                        ma=max(ma,j)
                if ma!=-1:
                    ans.append(ma)
                    a.remove(ma)
                else:
                    i-=1
                    while ans:
                        a.append(ans.pop())
                        ma=-1
                        for j in a:
                            if j<b[i]:
                                ma=max(ma,j)
                        if ma!=-1:
                            ans.append(ma)
                            a.remove(ma)
                            break
                        i-=1
                a.sort()
                while a:
                    ans.append(a.pop())
                break
        print("""".join(str(i) for i in ans))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(n ^ 3)
"import math

n, r = map(int, input().split())
x = list(map(int, input().split()))
y = [r]

for i in range(1, n):
    _y = r
    for j in range(i):
        if 4 * r * r >= (x[i] - x[j]) * (x[i] - x[j]):
            _y = max(_y, y[j] + math.sqrt(4 * r * r - (x[i] - x[j]) * (x[i] - x[j])))
    y.append(round(_y, 6))

print(' '.join(map(str, y)))
",O(n ^ 2)
"import itertools



class Solution(object):
    def maximumCostSubstring(self, s, chars, vals):
        def kadane(s):
            result = curr = 0
            for c in s:
                curr = max(curr+(lookup[c] if c in lookup else ord(c)-ord('a')+1), 0)
                result = max(result, curr)
            return result

        lookup = {}
        for c, v in zip(chars, vals):
            lookup[c] = v
        return kadane(s)",O(n)
"n = int(input())
res = []
multiplier = 1
while n > 1:
	new_n = n // 2
	res.extend((multiplier,)*(n-new_n))
	if n == 3:
		multiplier *= 3
	else:
		multiplier *= 2
	n = new_n
res.extend((multiplier,)*n)
print(*res)
",O(n)
"class Solution(object):
    def ipToCIDR(self, ip, n):
        def ipToInt(ip):
            result = 0
            for i in ip.split('.'):
                result = 256 * result + int(i)
            return result

        def intToIP(n):
            return ""."".join(str((n >> i) % 256) \
                            for i in (24, 16, 8, 0))

        start = ipToInt(ip)
        result = []
        while n:
            mask = max(33-(start & ~(start-1)).bit_length(), \
                       33-n.bit_length())
            result.append(intToIP(start) + '/' + str(mask))
            start += 1 << (32-mask)
            n -= 1 << (32-mask)
        return result",O(n)
"from collections import defaultdict
import sys
input = sys.stdin.readline

n, k = map(int, input().split())
c = list(map(int, input().split()))
f = list(map(int, input().split()))
h = [0] + list(map(int, input().split()))
cnt1 = defaultdict(lambda : 0)
for i in c:
    cnt1[i] += 1
cnt2 = defaultdict(lambda : 0)
for i in f:
    cnt2[i] += 1
ans = 0
for i in cnt2:
    c1, c2 = cnt1[i], cnt2[i]
    dp0 = [0]
    l = 1
    for _ in range(c2):
        dp = [0] * (l + k)
        for i in range(l):
            dp0i = dp0[i]
            for j in range(k + 1):
                dp[i + j] = max(dp[i + j], dp0i + h[j])
        l += k
        dp0 = dp
    ans += dp[min(c1, k * c2)]
print(ans)",O(n ^ 3)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, self.__next__)

class Solution(object):
    def swapPairs(self, head):
        dummy = ListNode(0)
        dummy.next = head
        current = dummy
        while current.__next__ and current.next.__next__:
            next_one, next_two, next_three = current.__next__, current.next.__next__, current.next.next.__next__
            current.next = next_two
            next_two.next = next_one
            next_one.next = next_three
            current = next_one
        return dummy.__next__",O(n)
"def get_input_list():
	return list(map(int, input().split()))

n = int(input())
l = get_input_list()
r = get_input_list()

a = [0 for _ in range(n)]
m = []
m_ = []
for i in range(n):
	m.append(l[i] + r[i])
	m_.append(l[i] + r[i])
m.sort()
ma = m[-1] + 1

for i in range(n):
	a[i] = ma - m_[i]

l_ = []
r_ = []
for i in range(n):
	c = 0
	d = 0
	for j in range(i+1):
		if a[j] > a[i]:
			c += 1
	for j in range(i,n):
		if a[j] > a[i]:
			d += 1
	l_.append(c)
	r_.append(d)
res = True
for i in range(n):
	if l[i] != l_[i] or r[i] != r_[i]:
		res = False
		break
if res:
	print(""YES"")
	for i in range(n):
		a[i] = str(a[i])
	print("" "".join(a))
else:
	print(""NO"")",O(n ^ 2)
"class UnionFind(object): 
    def __init__(self, n):
        self.set = list(range(n))
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        return True


class Solution5(object):
    def canReachCorner(self, X, Y, circles):
        def check(x1, y1, r1, x2, y2, r2):
            return (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2

        uf = UnionFind(len(circles)+2)
        for u in range(len(circles)):
            x1, y1, r1 = circles[u]
            if x1-r1 <= 0 or y1+r1 >= Y:
                uf.union_set(u, len(circles))
            if x1+r1 >= X or y1-r1 <= 0:
                uf.union_set(u, len(circles)+1)
            for v in range(u):
                x2, y2, r2 = circles[v]
                if not check(x1, y1, r1, x2, y2, r2):
                    continue
                uf.union_set(u, v)
        return uf.find_set(len(circles)) != uf.find_set(len(circles)+1)",O(n ^ 2)
"import sys

k = int(input())
d = [0]
for i in range(1, 12):
    d.append((10 ** i - 10 ** (i - 1)) * i + d[i - 1])

for i in range(1, len(d)):
    if k <= d[i]:
        f = d[i - 1]
        f1 = 10 ** (i - 1)

        print(str(((k - f - 1) // i) + f1)[(k - f - 1) % i])
        sys.exit()
",O(logn)
"class Solution_TLE(object):
    def beautifulSplits(self, nums):
        def z_function(s, left, right): 
            z = [0]*(right-left+1)
            l, r = 0, 0
            for i in range(1, len(z)):
                if i <= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] < len(z) and s[left+z[i]] == s[left+i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 > r:
                    l, r = i, i+z[i]-1
            return z
        
        result = 0
        z0 = z_function(nums, 0, len(nums)-1)
        for i in range(1, len(nums)-1):
            zi = z_function(nums, i, len(nums)-1)
            for j in range(i+1, len(nums)):
                if (z0[i] >= i and j-i >= i) or zi[j-i] >= j-i:
                    result += 1
        return result",O(n ^ 2)
"class Solution2(object):
    def wordPattern(self, pattern, str):
        words = str.split() 
        if len(pattern) != len(words):
            return False

        w2p, p2w = {}, {}
        for p, w in zip(pattern, words):
            if w not in w2p and p not in p2w:
                w2p[w] = p
                p2w[p] = w
            elif w not in w2p or w2p[w] != p:
                return False
        return True",O(n)
"Q = int(input())
for _ in range(Q):
    N, K = map(int, input().split())
    S = input()
    X = [{""R"":0, ""G"":1, ""B"":2}[s] for s in S]
    mi = K
    for i in range(3):
        d = 0
        for j in range(N):
            if X[j] != (i+j) % 3:
                d += 1
            if j >= K and X[j-K] != (i+j-K) % 3:
                d -= 1
            if j >= K-1:
                mi = min(mi, d)
    print(mi)
",O(n)
"n,s=map(int,input().split())
if s>=n:
	print(0)
else:
	ans=0
	def sod(n):
		s=str(n)
		ret=0
		for i in s:
			ret+=int(i)
		return ret
	for nd in range(s,s+1000):
		if nd-sod(nd) >=s:
			ans+=1
		if nd==n:
			break
		if nd==(s+369):
			ans+=(n-nd)
			break
	print(ans)",O(logn)
"n, a, b = map(int, input().split())
if a != 1 and b != 1:
    print(""NO"")
else:

    con_char = '1'
    discon_char = '0'
    if a == 1:
        con_char = '0'
        discon_char = '1'
        t = a
        a = b
        b = t

    if a > 1:
        print(""YES"")
        n_con = n - a + 1
        for i in range(n):
            res = []
            for j in range(n):
                if i == j:
                    res.append('0')
                elif i < n_con and j < n_con:
                    res.append(con_char)
                else:
                    res.append(discon_char)
            print(''.join(res))
    else:
        if n == 1 or n > 3:
            print(""YES"")

            for i in range(n):
                res = []
                for j in range(n):
                    if i == j:
                        res.append('0')
                    elif abs(i-j) == 1:
                        res.append('1')
                    else:
                        res.append('0')
                print(''.join(res))
        else:
            print(""NO"")
",O(n ^ 2)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def rangeSumBST(self, root, L, R):
        result = 0
        s = [root]
        while s:
            node = s.pop()
            if node:
                if L <= node.val <= R:
                    result += node.val
                if L < node.val:
                    s.append(node.left)
                if node.val < R:
                    s.append(node.right)
        return result",O(n)
"import sys
import string
from math import gcd
import getpass
import math
from decimal import Decimal
import pprint

def ria():
    return [int(i) for i in input().split()]

if getpass.getuser() != 'frohenk':
    filename = 'half'

else:
    sys.stdin = open('input.txt')

n, m = ria()
ar = ria()
arc = []
art = []
res = []
for n, i in enumerate(ria()):
    if i == 1:
        art.append(ar[n])
        res.append(0)
    else:
        arc.append(ar[n])
nt = 0
for i in arc:
    while nt != len(art) - 1 and abs(art[nt] - i) > abs(art[nt + 1] - i):
        nt += 1
    res[nt] += 1

for i in res:
    print(i,end= ' ')",O(nlogn)
"class Solution(object):
    def numWays(self, s):
        MOD = 10**9+7

        ones = s.count('1')
        if ones % 3:
            return 0
        ones //= 3
        if ones == 0:
            return (len(s)-1)*(len(s)-2)//2 % MOD
        count = left = right = 0
        for c in s:
            if c == '1':
                count += 1
            if count == ones:
                left += 1
            elif count == 2*ones:
                right += 1
        return left*right % MOD",O(n)
"import sys
import argparse
import json

def main():
    n = int(sys.stdin.readline())
    ticket = sys.stdin.readline().rstrip()
    integers = [int(x) for x in ticket]

    zeros = 0
    while zeros < len(integers) and integers[-1*(zeros+1)] == 0:
        zeros += 1

    if zeros > 0 and zeros >= len(integers):
        integers = []
    elif zeros > 0:
        integers = integers[:-1*zeros]

    if not integers:
        print(""YES"")
        return
    if len(integers) == 1:
        print(""NO"")
        return

    total = 0
    for i, val in enumerate(integers[:-1]):
        total += val
        splice = integers[i+1:]
        if is_golden(total, splice):
            print(""YES"")
            return
    print(""NO"")

def is_golden(total, integers):
    current_total = 0

    for i, val in enumerate(integers):
        current_total += val
        if current_total < total:
            continue
        elif current_total == total:

            splice = integers[i+1:]
            return (not splice) or is_golden(total, splice)
        elif current_total > total:
            return False
    return False

def get_tests():
    tests = [(""5\n73452"", ""YES""),
             (""4\n1248"", ""NO""),
             (""4\n7435"", ""NO""),
             (""8\n0020200"", ""YES""),
             (""99\n999999999999999999999999999999999999999999999918888888888888888888888888888888888888888888888888887"", ""YES""),
             (""84\n123608423980567916563149282633127550576921328162851174479585123236498689270768303090"", ""YES""),
             (""2\n00"", ""YES""),
             (""8\n00020200"", ""YES""),
             (""5\n11980"", ""NO""),
             (""3\n100"", ""NO"")]

    for test in tests:
        print(json.dumps({""input"": test[0], ""output"": test[1]}))

if __name__ == ""__main__"":
    parser = argparse.ArgumentParser()
    parser.add_argument(""--get-tests"", action=""store_true"")
    args = parser.parse_args()

    if args.get_tests:
        get_tests()
    else:
        main()
",O(n ^ 2)
"class Solution2(object):
    def getNoZeroIntegers(self, n):
        return next([a, n-a] for a in range(1, n) if '0' not in '{}{}'.format(a, n-a))",O(nlogn)
"import heapq


class Solution(object):
    def lastStoneWeight(self, stones):
        max_heap = [-x for x in stones]
        heapq.heapify(max_heap)
        for i in range(len(stones)-1):
            x, y = -heapq.heappop(max_heap), -heapq.heappop(max_heap)
            heapq.heappush(max_heap, -abs(x-y))
        return -max_heap[0]",O(nlogn)
"a, b = map(int, input().split())
x, y, z = map(int, input().split())
needa = 2 * x + y
needb = y + 3 * z
print(max(0, needa - a) + max(0, needb - b))",O(1)
"class Solution(object):
    def validWordAbbreviation(self, word, abbr):
        i , digit = 0, 0
        for c in abbr:
            if c.isdigit():
                if digit == 0 and c == '0':
                    return False
                digit *= 10
                digit += int(c)
            else:
                if digit:
                    i += digit
                    digit = 0
                if i >= len(word) or word[i] != c:
                    return False
                i += 1
        if digit:
            i += digit

        return i == len(word)",O(n)
"import threading


class Solution(object):
    def __init__(self):
        self._l = [threading.Lock() for _ in range(5)]

    def wantsToEat(self, philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork):
        left, right = philosopher, (philosopher+4)%5
        first, second = left, right
        if  philosopher%2 == 0:
            first, second = left, right
        else:
            first, second = right, left

        with self._l[first]:
            with self._l[second]:
                pickLeftFork()
                pickRightFork()
                eat()
                putLeftFork()
                putRightFork()",O(1)
"from itertools import combinations
n, l, r, x = map(int, input().split())
a = [int(x) for x in input().split()]
ans = 0
for i in range(2, n+1):
    for p in combinations(a, i):
        if l<=sum(p)<=r and max(p)-min(p)>=x:
            ans += 1
print(ans)
",np
"

class Solution(object):
    def findClosestNumber(self, nums):
        return max(nums, key=lambda x:(-abs(x), x))
",O(n)
"class Solution2(object):
    def equalToDescendants(self, root):
        def dfs(node, result):
            if not node:
                return 0
            total = dfs(node.left, result) + dfs(node.right, result)
            if node.val == total:
                result[0] += 1
            return total+node.val

        result = [0]
        dfs(root, result)
        return result[0]",O(n)
"class Solution(object):
    def findScore(self, nums):
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: (nums[x], x))
        lookup = [False]*len(nums)
        result = 0
        for i in idxs:
            if lookup[i]:
                continue
            lookup[i] = True
            if i-1 >= 0:
                lookup[i-1] = True
            if i+1 < len(lookup):
                lookup[i+1] = True
            result += nums[i]
        return result",O(nlogn)
"class Solution(object):
    def takeCharacters(self, s, k):
        cnt = [0]*3
        for c in s:
            cnt[ord(c)-ord('a')] += 1
        if min(cnt) < k:
            return -1
        result = left = 0
        for right in range(len(s)):
            cnt[ord(s[right])-ord('a')] -= 1
            while cnt[ord(s[right])-ord('a')] < k:
                cnt[ord(s[left])-ord('a')] += 1
                left += 1
            result = max(result, right-left+1)
        return len(s)-result",O(n)
"class Solution2(object):
    def preorderTraversal(self, root):
        result, stack = [], [(root, False)]
        while stack:
            root, is_visited = stack.pop()
            if root is None:
                continue
            if is_visited:
                result.append(root.val)
            else:
                stack.append((root.right, False))
                stack.append((root.left, False))
                stack.append((root, True))
        return result",O(n)
"a, b = map(int, input().split())
c = input()
sorted(c)
summa = 0
count = 0
j = -2
i = 0
abc = ""abcdefghijklmnopqrstuvwxyz""
while i < 26 and count < b:
    if abc[i] in c and i-2 >= j:
        summa += i+1
        count += 1
        j = i
    i += 1
if count < b:
    print(-1)
else:
    print(summa)",O(n)
"import os
import sys
from io import BytesIO, IOBase
from collections import Counter
import math as mt

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)

def lcm(a, b):
    return (a * b) / gcd(a, b)

mod = int(1e9) + 7

def power(k, n):
    if n == 0:
        return 1
    if n % 2:
        return (power(k, n - 1) * k) % mod
    t = power(k, n // 2)
    return (t * t) % mod

def totalPrimeFactors(n):
    count = 0
    if (n % 2) == 0:
        count += 1
        while (n % 2) == 0:
            n //= 2

    i = 3
    while i * i <= n:
        if (n % i) == 0:
            count += 1
            while (n % i) == 0:
                n //= i
        i += 2
    if n > 2:
        count += 1
    return count

def main():
    n = int(input())
    a = list(map(int, input().split()))
    d = {}
    for i in range(n):
        d[a[i]] = i
    found=[-1, -1, -1]
    found2=[-1, -1]
    for i in range(n):
        c=1
        while c<(1<<31):
            if a[i]- c in d.keys() and a[i]+c in d.keys():
                found[0]=a[i]-c
                found[1]=a[i]
                found[2]=a[i]+c
            if a[i]- c in d.keys() :
                found2=[a[i], a[i]-c]
            if a[i]+ c in d.keys() :
                found2=[a[i], a[i]+c]
            c*=2
    if found[0]==found[1]:
        if found2[0]==found2[1]:
            print(1)
            print(a[0])
        else:
            print(2)
            print(*found2)
    else:
        print(3)
        print(*found)

    return

if __name__ == ""__main__"":
    main()
",O(nlogn)
"class Solution2(object):
    def heightOfTree(self, root):
        result = -1
        q = [root]
        while q:
            new_q = []
            for u in q:
                if u.left and u.left.right != u:
                    new_q.append(u.left)
                if u.right and u.right.left != u:
                    new_q.append(u.right)
            q = new_q
            result += 1
        return result",O(n)
"class Solution2(object):
    def reverseParentheses(self, s):
        stk = [[]]
        for c in s:
            if c == '(':
                stk.append([])
            elif c == ')':
                end = stk.pop()
                end.reverse()
                stk[-1].extend(end)
            else:
                stk[-1].append(c)
        return """".join(stk.pop())",O(n ^ 2)
"n,l,r,x = [int(x) for x in input().split("" "")]
arr = [int(x) for x in input().split("" "")]
ans = 0
for i in range(2**n):
	subset = []
	for j in range(n):
		if (i & (1 << j)) != 0:
			subset.append(arr[j])
	if len(subset)>1:
	    mx = max(subset)
	    mn = min(subset)
	    sm = sum(subset)
	    if l<=sm<=r and mx-mn>=x:
	        ans+=1
print(ans)",np
"n=int(input())
s=input()
if ""0"" in s:
    if ""1"" in s:
        print(""1""+""0""*s.count(""0""))
    else:
        print(""0"")
else:
    print(""1"")",O(n)
"n=int(input())
x,y=map(int,input().split())
val1=max(x,y)-1
val2=n-min(x,y)
if(val1<=val2):
    print('White')
else:
    print('Black')",O(1)
"s1, s2 = [str(j) for j in input().split()]
output = s1 + s2
for j in range(len(s1)):
    s = s1[:j + 1]
    for k in range(len(s2)):
        s += s2[k]
        if sorted([s, output])[0] == s:
            output = s
print(output)
",O(n)
"n, k = [int(x) for x in input().split()]
ps = [int(x) for x in input().split()]
mapping = [-1 for _ in range(256)]

res = []
for p in ps:
    if mapping[p] == -1:
        j = p - k + 1
        while j < 0 or (mapping[j] != -1 and mapping[j] + k <= p):
            j += 1
        for i in range(j, p+1):
            mapping[i] = j
    res.append(mapping[p])
print("" "".join(map(str, res)))",O(n ^ 2)
"N=int(input())
L=list(map(int,input().split()))

DP=[[-1]*N for i in range(N)]
for d in range(N):
    for s in range(N-d):
        e=s+d
        if s==e:
            DP[s][e]=L[s]
            continue
        for m in range(s,e):
            l=DP[s][m]
            r=DP[m+1][e]
            if l==r and l!=-1:
                DP[s][e]=max(DP[s][e],l+1)
DP2=[i+1 for i in range(N)]
for i in range(N):
    if DP[0][i]!=-1:
        DP2[i]=1
        continue
    for j in range(i):
        if DP[j+1][i]!=-1:
            DP2[i]=min(DP2[i],DP2[j]+1)
print(DP2[N-1])",O(n ^ 3)
"class Solution(object):
    def makePalindrome(self, s):
        return sum(s[i] != s[~i] for i in range(len(s)//2)) <= 2",O(n)
"n,m=map(int,input().split())
list1=list(map(int,input().split()))
list2=list(map(int,input().split()))
for i in list1:
    if i in list2:
        print(i,end=' ')
",O(n ^ 2)
"class Solution2(object):
    def countQuadruplets(self, nums):
        right = [[0]*(len(nums)+1) for _ in range(len(nums))]
        for j in range(len(nums)):
            for i in reversed(range(j+1, len(nums))):
                right[j][i] = right[j][i+1] + int(nums[i] > nums[j])
        result = 0
        for k in range(len(nums)):
            left = 0
            for j in range(k):
                if nums[k] < nums[j]:
                    result += left*right[j][k+1]
                left += int(nums[k] > nums[j])
        return result",O(n ^ 2)
"a=list(input())
b=int(input())
a.sort()
a=a[::-1]
prefix=""""
while(len(a)>0):
    for i in range(len(a)):
        num=prefix+a[i]+"""".join(sorted(a[:i]+a[i+1:]))
        if(int(num)<=b):
            prefix+=a[i]
            a=a[:i]+a[i+1:]
            break
print(prefix)",O(n ^ 3)
"import sys, math, queue

MOD = 10**9+7
sys.setrecursionlimit(1000000)

def hgt(x):
    if x == 0: return -1
    h = 0
    while x&1 != 1:
        h += 1
        x = x>>1
    return h

def up(x):
    h = hgt(x)
    g = x + (1<<h)
    if g > 0 and g < N and hgt(g) == h+1:
        return g
    g = x - (1<<h)
    if g > 0 and g < N and hgt(g) == h+1:
        return g
    return x

def left(x):
    h = hgt(x)
    if h == 0:
        return x
    g = x - (1<<(h-1))
    if g > 0:
        return g
    return x

def right(x):
    h = hgt(x)
    if h == 0:
        return x
    g = x + (1<<(h-1))
    if g < N:
        return g
    return x

N, q = map(int, input().split())
N += 1
for _ in range(q):
    p = int(input())
    for c in input():
        if c == 'U':
            p = up(p)
        elif c == 'R':
            p = right(p)
        else:
            p = left(p)
    print(p)",np
"n,k=map(int,input().split())
arr=list(map(int,input().split()))
par=[i for i in range(260)]
path=[-1 for i in range(260)]
for i in range(n):
    j=arr[i]
    if path[j] >=0:
        par[j] =par[path[j]]
        continue
    jump=1
    while j>0 and path[j] ==-1 and jump <k:
        path[j] =arr[i]
        j-=1
        jump +=1
    if arr[i] -par[j] +1 <=k:
            par[arr[i]] =par[j]
            path[j] =arr[i]
    else:
        par[arr[i]] =par[j+1]
for i in range(n):
    print(par[arr[i]],end=' ')
print()",O(n ^ 2)
"n, m, k = list(map(int, input().split()));
a = list(map(int, input().split()));

values = list()

for j in range(n):
    result = a[j];
    sum1 = 0;
    for i in range(m):
        if j-i>=0:
            sum1 = sum1 + a[j-i];
            if sum1 > result:
                result = sum1;
        else:
            continue;
    if j-m>=0:
        result = max(result, sum1 + values[j-m]);
    values.append(max(0, result-k));
print(max(values));
",O(n ^ 2)
"def aburrimin(x, y, n, m, costder, costaba, dp):
    dists = []
    vals = []
    if x != 0:
        dis = costder[y][x-1]
        dists.append(dis)
        vals.append(dis+dp[y][x-1])
    if y != 0:
        dis = costaba[y-1][x]
        dists.append(dis)
        vals.append(dis+dp[y-1][x])
    if y < n-1:
        dis = costaba[y][x]
        dists.append(dis)
        vals.append(dis+dp[y+1][x])
    if x < m-1:
        dis = costder[y][x]
        dists.append(dis)
        vals.append(dis+dp[y][x+1])

    mindis = min(dists)
    return min(mindis+dp[y][x],min(vals))

def solvecaso():
    n,m,k = map(int,input().split())
    costder = [[int(x) for x in input().split()] for _ in range(n)]
    costaba = [[int(x) for x in input().split()] for _ in range(n-1)]
    if k%2:
        for i in range(n):
            for j in range(m):
                print(-1, end=' ')
            print()
        return -1
    k //= 2

    for ren in range(len(costder)):
        for col in range(len(costder[ren])):
            costder[ren][col] *= 2
    for ren in range(len(costaba)):
        for col in range(len(costaba[ren])):
            costaba[ren][col] *= 2

    dp = [[0 for _ in range(m)] for _ in range(n)]
    dptemp = [[0 for _ in range(m)] for _ in range(n)]

    for i in range(k):
        for y in range(n):
            for x in range(m):
                dptemp[y][x] = aburrimin(x, y, n, m, costder, costaba, dp)
        dp, dptemp = dptemp, dp

    for ren in dp:
        for num in ren:
            print(num, end=' ')
        print()

    return 0

if __name__ == ""__main__"":

    solvecaso()
",O(n ^ 3)
"import copy
import sys

def find_loop(g, w, k, n):
    visited = [False] * n
    visited_int = [False] * n
    for i in range(n):
        if visited[i]:
            continue
        stack = [g[i][:]]
        path = [i]
        visited[i] = True
        visited_int[i] = True
        while stack:
            if not stack[-1]:
                stack.pop()
                visited_int[path[-1]] = False
                path.pop()
                continue
            nxt = stack[-1][-1]
            stack[-1].pop()
            if w[(path[-1], nxt)] <= k:
                continue
            if visited_int[nxt]:
                return True
            if visited[nxt]:
                continue
            visited[nxt] = True
            visited_int[nxt] = True
            stack.append(g[nxt][:])
            path.append(nxt)
    return False

def top_sort(g, w, k, n):
    visited = [False] * n
    order = [-1] * n
    cnt = 0
    for i in range(n):
        if visited[i]:
            continue
        stack = [g[i][:]]
        path = [i]
        visited[i] = True
        while stack:
            if not stack[-1]:
                order[path[-1]] = cnt
                path.pop()
                stack.pop()
                cnt += 1
                continue
            nxt = stack[-1][-1]
            stack[-1].pop()
            if w[(path[-1], nxt)] <= k:
                continue
            if visited[nxt]:
                continue
            visited[nxt] = True
            stack.append(g[nxt][:])
            path.append(nxt)

    to_reverse = []
    for a, b in w.items():
        if b > k:
            continue
        if order[a[0]] < order[a[1]]:
            to_reverse.append(a)
    return to_reverse

if __name__ == '__main__':
    n, m = map(int, input().split())
    w = {}
    g = [[] for _ in range(n)]
    w_tmp = {}
    c_m = 0
    kk = [0]
    lines = sys.stdin.readlines()
    for i, line in enumerate(lines):
        u, v, c = map(int, line.split())
        g[u - 1].append(v - 1)
        if (u - 1, v - 1) in w.keys():
            w[(u - 1, v - 1)] = max(w[(u - 1, v - 1)], c)
        else:
            w[(u - 1, v - 1)] = c
        if (u - 1, v - 1) in w_tmp.keys():
            w_tmp[(u - 1, v - 1)].append(str(i + 1))
        else:
            w_tmp[(u - 1, v - 1)] = [str(i + 1)]
        kk.append(c)

    kk.sort()
    l, r = 0, len(kk)
    if not find_loop(g, w, kk[l], n):
        print(0, 0)
        exit(0)
    if find_loop(g, w, kk[-1], n):
        kkk = kk[-1]
    else:
        while l + 1 != r:
            m = int((l + r) / 2)
            if find_loop(g, w, kk[m], n):
                l = m
            else:
                r = m
        kkk = kk[l+1]

    to_reverse = top_sort(g, w, kkk, n)
    num = 0
    s = []
    for t in to_reverse:
        num += len(w_tmp[t])
        s.extend(w_tmp[t])

    print(kkk, num)
    print("" "".join(s))",O(nlogn)
"class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def equationsPossible(self, equations):
        union_find = UnionFind(26)
        for eqn in equations:
            x = ord(eqn[0]) - ord('a')
            y = ord(eqn[3]) - ord('a')
            if eqn[1] == '=':
                union_find.union_set(x, y)
        for eqn in equations:
            x = ord(eqn[0]) - ord('a')
            y = ord(eqn[3]) - ord('a')
            if eqn[1] == '!':
                if union_find.find_set(x) == union_find.find_set(y):
                    return False
        return True",O(n)
"n = int(input())
print(""0 0 {}"".format(n))
",O(1)
"def solve(a, b):
    m = max(a, b)
    n = min(a, b)
    if n == 0:
        return 0
    if m == n:
        return 1
    elif m % n == 0:
        return m // n
    k = m // n
    return k + solve(n, m - n * k)

for _ in range(int(input())):
    a, b = map(int, input().split())
    print(solve(a, b))",O(1)
"def main():
    import sys
    input = sys.stdin.readline

    n = int(input())
    arr = list(map(int, input().split()))
    color = [0] * n
    arr.sort()

    ans = 0
    for i in range(n):
        if color[i]:
            continue
        ans += 1
        for j in range(i, n):
            if arr[j] % arr[i] == 0:
                color[j] = ans

    print(ans)

    return 0

main()
",O(n ^ 2)
"import sys
f=sys.stdin
n=int(f.readline())
a=list(map(int,f.readline().split()))
s=0
for i in range(n):
    for j in range(i):
        s^=a[j]>a[i]
q=int(f.readline())
for i in range(q):
    l,r=map(int,f.readline().split())
    s^=(r-l+1)*(r-l)//2%2
    print(['even','odd'][s])",O(n ^ 2)
"import collections


class Solution(object):
    def canPermutePalindrome(self, s):
        return sum(v % 2 for v in list(collections.Counter(s).values())) < 2",O(n)
"def main():
    a, b = map(int, input().split())
    K = 60
    if a == b:
        ans = 0
    else:
        curr = K
        while (b & (1 << curr)) == (a & (1 << curr)):
            curr -= 1
        ans = (1 << curr)
        curr -= 1
        lb = False
        ga = False
        for i in range(curr, -1, -1):
            if (b & (1 << i)) == 0 and (a & (1 << i)) == 0:
                if not lb:
                    ans += (1 << i)
                    ga = True
                else:
                    ans += (1 << i)
            elif (b & (1 << i)) == 0 and (a & (1 << i)) == 1:
                ans += (1 << i)
            elif (b & (1 << i)) == 1 and (a & (1 << i)) == 0:
                if not lb:
                    ans += (1 << i)
                    ga = True
                    lb = True
                else:
                    ans += (1 << i)
            else:
                if not lb:
                    ans += (1 << i)
                    lb = True
                else:
                    ans += (1 << i)
    print(ans)

if __name__ == '__main__':
    main()",O(logn)
"f = lambda m, k: (k*m - m*(m-1)//2 - m + 1)

def ok(m, k, n):
    return f(m, k) >= n

n, k = map(int, input().split())

if not ok(k, k, n): print(-1)
else:
    l, h = 0, k
    while (h > l):
        mid = l + (h - l) // 2
        if ok(mid, k, n): h = mid
        else: l = mid + 1
    print(h)",O(logn)
"import os, sys
from io import BytesIO, IOBase

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class dict(dict):
    def __missing__(self, key):
        return 0

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: list(map(dtype, input().split()))
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
valid = lambda x, y: -1 < x < n and -1 < y < m
dx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1)

n, m, k = inp(int)
if k & 1:
    [print(*([-1] * m)) for _ in range(n)]
    exit()

right, down = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]
mem = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]

for _ in range(n):
    for i, j in enumerate(inp(int)):
        right[_][i] = j

for _ in range(n - 1):
    for i, j in enumerate(inp(int)):
        down[_][i] = j

for i in range(n):
    for j in range(m):
        mem[i][j] = 0

for k1 in range(1, k // 2 + 1):
    mem0 = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]
    for i in range(n):
        for j in range(m):
            mem0[i][j] = min(mem[i - 1][j] + down[i - 1][j], mem[i + 1][j] + down[i][j],
                             mem[i][j - 1] + right[i][j - 1], mem[i][j + 1] + right[i][j])

    mem = mem0

[print(*[mem[i][x] * 2 for x in range(m)]) for i in range(n)]
",O(n ^ 3)
"import random


class SkipNode(object):
    def __init__(self, level=0, num=None):
        self.num = num
        self.nexts = [None]*level


class Solution(object):
    P_NUMERATOR, P_DENOMINATOR = 1, 2 
    MAX_LEVEL = 32 

    def __init__(self):
        self.__head = SkipNode()
        self.__len = 0

    def search(self, target):
        return True if self.__find(target, self.__find_prev_nodes(target)) else False
        
    def add(self, num):
        node = SkipNode(self.__random_level(), num)
        if len(self.__head.nexts) < len(node.nexts): 
            self.__head.nexts.extend([None]*(len(node.nexts)-len(self.__head.nexts)))
        prevs = self.__find_prev_nodes(num)
        for i in range(len(node.nexts)):
            node.nexts[i] = prevs[i].nexts[i]
            prevs[i].nexts[i] = node
        self.__len += 1

    def erase(self, num):
        prevs = self.__find_prev_nodes(num)
        curr = self.__find(num, prevs)
        if not curr:
            return False
        self.__len -= 1   
        for i in reversed(range(len(curr.nexts))):
            prevs[i].nexts[i] = curr.nexts[i]
            if not self.__head.nexts[i]:
                self.__head.nexts.pop()
        return True
    
    def __find(self, num, prevs):
        if prevs:
            candidate = prevs[0].nexts[0]
            if candidate and candidate.num == num:
                return candidate
        return None

    def __find_prev_nodes(self, num):
        prevs = [None]*len(self.__head.nexts)
        curr = self.__head
        for i in reversed(range(len(self.__head.nexts))):
            while curr.nexts[i] and curr.nexts[i].num < num:
                curr = curr.nexts[i]
            prevs[i] = curr
        return prevs

    def __random_level(self):
        level = 1
        while random.randint(1, Solution.P_DENOMINATOR) <= Solution.P_NUMERATOR and \
              level < Solution.MAX_LEVEL:
            level += 1
        return level

    def __len__(self):
        return self.__len
    
    def __str__(self):
        result = []
        for i in reversed(range(len(self.__head.nexts))):
            result.append([])
            curr = self.__head.nexts[i]
            while curr:
                result[-1].append(str(curr.num))
                curr = curr.nexts[i]
        return ""\n"".join([""->"".join(x) for x in result])",O(logn)
"n, p = map(int, input().split())

arr = [int(b) for b in input().split()]

res = []

prefsums = [arr[0]]

for i in range(1, n):
    prefsums.append(prefsums[i - 1] + arr[i])

allsum = sum(arr)

if len(arr) == 2:
    print(arr[0] % p + arr[1] % p)
    exit()

for i in range(1, n - 1):
    res.append((prefsums[i] % p) + ((allsum - prefsums[i]) % p))

print(max(res))
",O(n)
"x1, y1, x2, y2, x3, y3, x4, y4 = [int(s) for s in input().split()]
x11, y11, x22, y22, x33, y33, x44, y44 = [int(s) for s in input().split()]

min_x1 = min(x1, x2, x3, x4)
min_y1 = min(y1, y2, y3, y4)
max_x1 = max(x1, x2, x3, x4)
max_y1 = max(y1, y2, y3, y4)

min_x11 = min(x11, x22, x33, x44)
min_y11 = min(y11, y22, y33, y44)
max_x11 = max(x11, x22, x33, x44)
max_y11 = max(y11, y22, y33, y44)

a = (max_x11 + min_x11) / 2
b = (max_y11 + min_y11) / 2
d2 = (max_x11 - min_x11) / 2

for x in range(min_x1, max_x1 + 1):
    for y in range(min_y1, max_y1 + 1):
        if abs(x - a) + abs(y - b) <= d2:
            print(""yes"")
            exit(0)
print(""no"")
",O(1)
"import math
n = int(input())
m = 0
for i in range(min(100,n)):
	for ii in range(min(100,n)):
		for iii in range(min(100,n)):
			i1 = n-i
			ii1 = n-ii
			iii1 = n-iii
			r1 = (i1*ii1)//math.gcd(i1,ii1)
			r2 = (r1*iii1)//math.gcd(iii1,r1)
			m = max(m,r2)
print(m)",O(1)
"class Solution3(object):
    def distributeCandies(self, n, limit):
        return sum(n-i-j <= limit for i in range(min(limit, n)+1) for j in range(min(limit, n-i)+1))",O(n ^ 2)
"import collections


class Solution(object):
    def deleteTreeNodes(self, nodes, parent, value):
        def dfs(value, children, x):
            total, count = value[x], 1
            for y in children[x]:
                t, c = dfs(value, children, y)
                total += t
                count += c if t else 0
            return total, count if total else 0

        children = collections.defaultdict(list)
        for i, p in enumerate(parent):
            if i:
                children[p].append(i)
        return dfs(value, children, 0)[1]",O(n)
"n, k = map(int,input().split())
s = input()
p = len(s)-1
while s[:p] != s[-p:]:
    p =  p -1
print(s + s[p:]*(k-1))",O(n ^ 2)
"import io,os,bisect;input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline;prime = [2]
for i in range(3,4*10**3,2):
    flag = False
    if i%2==0: continue
    for j in range(3,int(i**0.5)+1,2):
        if i%j==0: flag = True;break
    if not flag:  prime.append(i)
def primefactor(num):
    index = 0;output = []
    while num>=prime[index]**2:
        times = 0
        while num%prime[index]==0:num = num // prime[index];times += 1
        if times&1:  output.append(prime[index])
        index += 1
    if num>1: output.append(num)
    return tuple(output)
for _ in range(int(input())):
    n,k = map(int,input().split());arr = list(map(int,input().split()));seg = 1;fact = {};left = [[0 for j in range(k+1)] for i in range(n)];dp = [[300000 for j in range(k+1)] for i in range(n)];stack = [0]
    for i in range(n):
        factor = primefactor(arr[i])
        if factor in fact:            bisect.insort(stack,fact[factor]+1)
        fact[factor] = i
        for j in range(k+1):
            if j<len(stack):  left[i][j] = stack[-j-1]
    for i in range(n):
        for j in range(k+1):
            for t in range(j+1):l = left[i][t];dp[i][j] = (min(dp[l-1][j-t] + 1, dp[i][j]) if l > 0 else 1)
    print(dp[-1][-1])",O(n ^ 3)
"n, t = map(int, input().split())
l = []
for _ in range(n):
  x, a = map(int, input().split())
  l.append((x-a/2, x+a/2))
l.sort()
res = 2

for i in range(n-1):
  if l[i+1][0] - l[i][1] == t:
    res += 1
  elif l[i+1][0] - l[i][1] > t:
    res += 2

print(res)
",O(nlogn)
"import os
from io import BytesIO, IOBase
import sys
from collections import defaultdict, deque, Counter
from math import sqrt, pi, ceil, log, inf, gcd, floor
from itertools import combinations, permutations
from bisect import *
from fractions import Fraction
from heapq import *
from random import randint

def main():
    n=int(input())
    a=list(map(int,input().split()))
    ans=0
    for i in range(0,2*n,2):
        if a[i]!=a[i+1]:
            for j in range(i+1,2*n):
                if a[j]==a[i]:
                    for k in range(j,i+1,-1):
                        a[k],a[k-1]=a[k-1],a[k]
                        ans+=1
                    break
    print(ans)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(n ^ 2)
"class Solution(object):
    def wiggleSort(self, nums):
        for i in range(1, len(nums)):
            if ((i % 2) and nums[i - 1] > nums[i]) or \
                (not (i % 2) and nums[i - 1] < nums[i]):
                nums[i - 1], nums[i] = nums[i], nums[i - 1]",O(n)
"class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        num_set = set(nums)
        n = len(nums)
        for i in range(n + 1):
            if i not in num_set:
                return i
",O(n)
"class Solution4(object):
    def numberOfWays(self, n):
        MOD = 10**9+7
        dp = [0]*(n+1)
        dp[0] = 1
        for i in (1, 2, 6):
            for j in range(i, n+1):
                dp[j] += dp[j-i]
        return reduce(lambda x, y: (x+dp[n-4*y])%MOD, (i for i in range(min(n//4, 2)+1)), 0)",O(n)
"class Solution(object):
    def stoneGameIII(self, stoneValue):
        dp = [float(""-inf"")]*3
        dp[len(stoneValue)%3] = 0
        for i in reversed(range(len(stoneValue))):
            max_dp, curr = float(""-inf""), 0
            for j in range(min(3, len(stoneValue)-i)):
                curr += stoneValue[i+j]
                max_dp = max(max_dp, curr-dp[(i+j+1)%3])
            dp[i%3] = max_dp
        return [""Tie"", ""Alice"", ""Bob""][cmp(dp[0], 0)]",O(n)
"class Solution2(object):
    def freqAlphabets(self, s):
        def alpha(num):
            return chr(ord('a') + int(num)-1)

        i = len(s)-1
        result = []
        while i >= 0:
            if s[i] == 
                result.append(alpha(s[i-2:i]))
                i -= 3
            else:
                result.append(alpha(s[i]))
                i -= 1
        return """".join(reversed(result))",O(n)
"
class Solution(object):
    def reverseOnlyLetters(self, S):
        def getNext(S):
            for i in reversed(range(len(S))):
                if S[i].isalpha():
                    yield S[i]

        result = []
        letter = getNext(S)
        for i in range(len(S)):
            if S[i].isalpha():
                result.append(next(letter))
            else:
                result.append(S[i])
        return """".join(result)

",O(n)
"def somadig(x):
    soma = 0
    while x>0:
        soma += x%10
        x = x//10
    return soma

def main():
    x,s = map(int,input().split())

    comeco = 9
    fim = x
    if comeco >= fim:
        print(0)
        return
    while fim>=comeco:
        meio = (fim+comeco)//2
        if meio - somadig(meio) >= s:
            if (meio-1) - somadig(meio-1)<s:
                print(x-(meio-1))
                return
            fim = meio-1
        else:
            comeco = meio+1
    print(0)
    return

main()",O(logn)
"k=int(input())
i=0
r=1
while(k>=r):
    r+=9*(i+1)*10**i
    i+=1
r=r-(9*i*10**(i-1))
ans=str(((k-r)//i)+10**(i-1))[(k-r)%i]
print(ans)
",O(logn)
"from collections import deque

def removeUsed(adj, used):
    to_remove = []
    for s in adj:
        if used[s]: to_remove.append(s)
    for s in to_remove:
        adj.remove(s)

def solve(a, s):
    if s[0] != 0: return False
    q = deque()
    q.append(0)
    i, n, cur = 1, len(a), -1
    used = [False]*n
    used[0] = True
    while i < n:
        if cur == -1:
            cur = q.popleft()
            removeUsed(a[cur], used)
        if not a[cur]:
            cur = -1
            continue
        cur_s = s[i]
        i += 1
        if cur_s not in a[cur]:
            return False
        a[cur].remove(cur_s)
        q.append(cur_s)
        used[cur_s] = True
    return True

n = int(input())
a = [set() for i in range(n)]
for i in range(n-1):
    u, v = map(int, input().split())
    a[u-1].add(v-1)
    a[v-1].add(u-1)
s = [(x-1) for x in map(int, input().split())]
print(""Yes"" if solve(a, s) else ""No"")
",O(n)
"import collections


class Solution(object):
    def tupleSameProduct(self, nums):
        result = 0
        count = collections.Counter()
        for i in range(len(nums)):
            for j in range(i+1, len(nums)): 
                result += count[nums[i]*nums[j]]
                count[nums[i]*nums[j]] += 1
        return 8*result",O(n ^ 2)
"def mergeSort(x):
	if len(x) > 1:

		mid = len(x)//2

		L = x[:mid]
		R = x[mid:]

		mergeSort(L)
		mergeSort(R)

		i = j = k = 0

		while i < len(L) and j < len(R):
			if L[i] > R[j]:
				x[k] = L[i]
				i += 1
			else:
				x[k] = R[j]
				j += 1
			k += 1

		while i < len(L):
			x[k] = L[i]
			i += 1
			k += 1

		while j < len(R):
			x[k] = R[j]
			j += 1
			k += 1

n,m = input().split()
n = int(n)
m = int(m)
difference = []
total = 0
for i in range(0,n):
    a,b = input().split()
    a = int(a)
    b = int(b)
    total += a
    difference.append(a - b)

mergeSort(difference)

minimum = 0
idx = 0
if total <= m:
    print(""0"")
else:
    for val in difference:
        minimum += 1
        total = total - val
        if total <= m:
            break

    if total > m:
        print(""-1"")
    else:
        print(minimum)",O(nlogn)
"from sys import stdin, stdout
import math
import heapq
from itertools import accumulate

Q = int(input())

four = []

for i in range(62):
    four.append(4**i)

for i in range(Q):
    N,K = [int(x) for x in stdin.readline().split()]

    tmp_N = N
    if N>=60:
        N = 60

    dk = (4**(N)-1)//3
    if K>dk:
        print('NO')
        continue

    seq = []
    block = []
    s = 0
    for i in range(N):
        s += 2**(i+1) - 1
        block.append(2**(i+1)-1)
        seq.append(s)

    if K>=seq[-1]:
        print('YES',0)
        continue

    for i in range(N-1):
        if K>=seq[i] and K<seq[i+1]:
            d = K-seq[i]
            happy = tmp_N-i-1
            round = i+1
            break

    block = block[::-1]

    res = 0
    for i in range(round):
        A = (4**(i+1)-1)//3
        B = block[i] - 2
        res += A*B

    if d<=res:
        print('YES',happy)
    else:
        print('NO')
",O(logn)
"import itertools


class Solution(object):
    def largestTimeFromDigits(self, A):
        result = """"
        for i in range(len(A)):
            A[i] *= -1
        A.sort()
        for h1, h2, m1, m2 in itertools.permutations(A):
            hours = -(10*h1 + h2)
            mins = -(10*m1 + m2)
            if 0 <= hours < 24 and 0 <= mins < 60:
                result = ""{:02}:{:02}"".format(hours, mins)
                break
        return result",O(1)
"import io
import os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

n = int(input())

endpoints = []

for x in range(n):
    p, w = map(int, input().split())
    endpoints.append([p-w, p+w])

endpoints.sort(key=lambda sublist: sublist[1])

res = 0

bottom = 10**18 * -1

for pt in range(len(endpoints)):
    if endpoints[pt][0] >= bottom:
        res += 1
        bottom = endpoints[pt][1]

print(res)
",O(nlogn)
"n, d = map(int, input().split())
lst = list(map(int, input().split()))
lst.sort()
Ans = 2
for i in range(1, n):
    if lst[i] - lst[i - 1] > 2 * d:
        Ans += 2
    elif lst[i] - lst[i - 1] == 2 * d:
        Ans += 1
print(Ans)
",O(n)
"from math import log
n,k=map(int,input().split())
s=list(map(int,input().split()))
ans=0
for j in range(11):
    d=dict()
    z=10**j
    for i in s:
        y=i*z
        u=y%k
        if u in d:
            d[u]+=1
        else:
            d.update({u:1})
    for i in s:
        y=i
        lg=int(log(i,10))+1
        lg=10**lg
        if lg==z:
            d[(y*z)%k]-=1
            x=(k-y%k)
            if y%k==0:
                x=0
            if x in d:
                ans+=d[x]
            d[(y*z)%k]+=1
print(ans)
",O(nlogn)
"import math
a = input()
b = input()
sa = a.count(""+"")
ta = a.count(""-"")
sb = b.count(""+"")
tb = b.count(""-"")
x = b.count(""?"")
s=abs(sa-sb)
t=abs(ta-tb)
su = math.factorial(s+t)
re = math.factorial(s)
sa = math.factorial(t)
result = su/(re*sa)

if s+t <= x:
    print(float(result)/float((2**x)))
else:
    print(0)",np
"cs = int(input())

for c in range(cs):
    l, r = map(int, input().split())

    if l%2 == 0 and r%2 == 0:
        print((r - l) // 2 + l)
    if l%2 == 1 and r%2 == 0:
        print((r - l + 1) // 2)
    if l%2 == 0 and r%2 == 1:
        print(-(r - l + 1) // 2)
    if l%2 == 1 and r%2 == 1:
        print(-(r - l) // 2 - l)",O(1)
"r,g,b=map(int,input().split())
R=list(map(int,input().split()))
R.sort()
G=list(map(int,input().split()))
G.sort()
B=list(map(int,input().split()))
B.sort()
dp=[[[0]*(b+1) for i in range(g+1)] for j in range(r+1)]
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i<r and j<g:
                dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j])
            if i<r and k<b:
                dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k])
            if j<g and k<b:
                dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+G[j]*B[k])
print(dp[r][g][b])",O(n ^ 3)
"
class Solution(object):
    def trimBST(self, root, L, R):
        if not root:
            return None
        if root.val < L:
            return self.trimBST(root.right, L, R)
        if root.val > R:
            return self.trimBST(root.left, L, R)
        root.left, root.right = self.trimBST(root.left, L, R), self.trimBST(root.right, L, R)
        return root


",O(n)
"x, k = [int(a) for a in input().strip().split()]

def binpow(x, k, mod):
    res = 1
    while k > 0:
        if k & 1:
            res  = ( res * x ) % mod
        x = ( x * x) % mod
        k >>= 1
    return res
if x == 0:
    print(0)
    exit()

mod = int(1e9 + 7)
k2 = binpow(2, k, mod)
res = ( k2 * (2 * x - 1) + 1) % mod

res %= mod

print(int(res))",O(logn)
"class Solution(object):
    def numTrees(self, n):
        if n == 0:
            return 1

        def combination(n, k):
            count = 1
            for i in range(1, k + 1):
                count = count * (n - i + 1) / i
            return count

        return combination(2 * n, n) - combination(2 * n, n - 1)",O(n)
"mod = 10**9+7
x, k = map(int, input().split(' '))
if (x == 0):
    print(0)
else:
    val1 = pow(2,k+1,mod) * x
    val2 = pow(2, k, mod) - 1
    val1 -= val2
    val1 %= mod
    print(val1)
",O(logn)
"n,k = list(map(int, input().split()))
a = list(map(int, input().split()))
t = list(map(int, input().split()))
x = 0
summ = 0
maxx = 0
for i in range(n):
  summ += a[i]*t[i]
for i in range(k):
  if not t[i]:
    x+=a[i]
maxx = max(maxx,x)
for i in range(n-k):
  x+=a[i+k]*(1-t[i+k])
  x-=a[i]*(1-t[i])
  if x>maxx:
    maxx=x

print(summ+maxx)",O(n)
"n, r = map(int, input().split())
x = list(map(int, input().split()))
y = [r] * n
for i in range(n):
    for j in range(i):
        if not (abs(x[i] - x[j]) > 2 * r):
            y[i] = max(y[i], (4 * r ** 2 - (x[i] - x[j]) ** 2) ** 0.5 + y[j])
for i in y:
    print(i, end=' ')
",O(n ^ 2)
"import collections


class Solution(object):
    def getFolderNames(self, names):
        count = collections.Counter()
        result, lookup = [], set()
        for name in names:
            while True:
                name_with_suffix = ""{}({})"".format(name, count[name]) if count[name] else name
                count[name] += 1
                if name_with_suffix not in lookup:
                    break
            result.append(name_with_suffix)
            lookup.add(name_with_suffix)
        return result",O(n)
"def main():
    n = int(input())
    V = []
    for i in range(n):
        x,w = map(int,input().split())
        V.append((x-w,x+w))
    V.sort(key=lambda x: x[1])
    ans = 1
    now = V[0]
    for i in range(1,n):
        if V[i][0] >= now[1]:
            now = V[i]
            ans += 1
    print(ans)

if __name__ == ""__main__"":
    main()",O(nlogn)
"from collections import deque
import sys
input = sys.stdin.readline

def bfs(start,graph,explored):
    queue = deque([start])
    visited = {start}
    ele = 0
    while queue:
        node = queue.popleft()
        explored.add(node)
        neighbours = graph[node]
        cnt = 0
        for neighbour in neighbours:
            if neighbour not in visited and neighbour not in explored:
                cnt += 1

        if e[0] == 0 and cnt != 1:
            ele = node
            break

        else:
            for neighbour in neighbours:
                if neighbour not in visited:
                    queue.append(neighbour)
                    visited.add(neighbour)

    return ele

from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

@bootstrap
def solve(i):
    cnt = 0
    visited.add(i)
    for k in graph[i]:
        if k not in visited:
            cnt += 1

    if cnt >= 1:
        for k in graph[i]:
            if k not in visited:
                yield solve(k)
                break

    else:
        r[0] = i

    yield

n = int(input())
graph = {}
for _ in range(n-1):
    a,b = map(int,input().split())
    if a in graph:
        graph[a].append(b)

    else:
        graph[a] = [b]

    if b in graph:
        graph[b].append(a)

    else:
        graph[b] = [a]

roots = []
visited = set()
ele = 0
e = [ele]
for i in graph:
    if len(graph[i]) == 1:
        roots.append(i)

x = roots[0]
ans = []
ele = bfs(x,graph,visited)
ans.append((str(x),str(ele)))

for i in graph[ele]:
    r = [0]
    if i not in visited:
        y = solve(i)
        ans.append([str(r[0]),str(ele)])

if len(visited) == n:
    sys.stdout.write(""Yes\n"")
    q = str(len(ans))
    sys.stdout.write(q+""\n"")
    for i in ans:
        e = "" "".join(i)
        sys.stdout.write(e + ""\n"")

else:
    sys.stdout.write(""No\n"")",O(n)
"n,k = map(int,input().split(' '))

arr = [n];
k = k+1
z = 1000000007
c = (n*pow(2,k,z)-pow(2,k-1,z)+1)%z
if n==0:
    print(0)
else:
    print(c)
",O(logn)
"from sys import stdin
s=stdin.readline()
for ln in range(len(s),0,-1):
    for L in range(len(s)-ln+1):
        if s[L:L+ln] in s[L+1:]:
            print(ln)
            exit()
print(0)",O(n ^ 3)
"class Solution(object):
    def longestSubarray(self, nums):
        count, left = 0, 0
        for right in range(len(nums)):
            count += (nums[right] == 0)
            if count >= 2:
                count -= (nums[left] == 0)
                left += 1
        return (right-left+1)-1",O(n)
"n = int(input())
a = list(map(int, input().split()))

a = sorted(a)
ans = 0
b = [0] * n
for i in range(n):
    if b[i] == 0:
        ans += 1
        for j in range(i, n):
            if a[j] % a[i] == 0:
                b[j] = 1
print(ans)
",O(n ^ 2)
"n=int(input())
print(n+(n//2))",O(1)
"MOD = 998244353
def power(x, n) :
    ans = 1
    while (n) :
        if ((n & 1) == 1) :
            ans = ans * x % MOD
        x = x * x % MOD
        n = n // 2
    return ans

n = int(input())
a = list(map(int, input().split()))
b = [0 for i in range(n + 1)]

def add(x, v) :
    while (x <= n) :
        b[x] = b[x] + v
        x = x + (x & -x)
def get(x) :
    ans = 0
    while (x) :
        ans = ans + b[x]
        x = x - (x & -x)
    return ans

anss = 0
for i in range(n) :
    if (a[i] != -1) :
        add(a[i], 1)
        anss = anss + get(n) - get(a[i])

anss = anss % MOD
total = 0

sur = [0] + [1 for i in range(n)]
for i in range(n) :
    if (a[i] == -1) :
        total = total + 1
    else :
        sur[a[i]] = 0

if (total == 0) :
    print(anss)
    exit(0)
for i in range(1, n + 1) :
    sur[i] = sur[i] + sur[i - 1]

dead = 0

ansa = 0
for i in range(n) :
    if (a[i] != -1) :
        ansa = ansa + sur[a[i]] * (total - dead) + (sur[n] - sur[a[i]]) * dead
    else :
        dead = dead + 1

ans = (ansa * 4 + anss * 4 * total + total * total * (total - 1)) % MOD
ans = (ans * power(4 * total, MOD - 2)) % MOD
print(ans)
",O(nlogn)
"class Solution(object):
    def hasIncreasingSubarrays(self, nums, k):
        result = 0
        curr, prev = 1, 0
        for i in range(len(nums)-1):
            if nums[i] < nums[i+1]:
                curr += 1
            else:
                prev = curr
                curr = 1
            result = max(result, curr//2, min(prev, curr))
        return result >= k",O(n)
"n = int(input())
bx, by = map(int, input().split())
ax, ay = map(int, input().split())
cx, cy = map(int, input().split())
num1 = ax > bx
num3 = cx > bx
num2 = ay > by
num4 = cy > by
if num1 == num3 and num2 == num4:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"def solve(n, p, s):
    p.append((0, 0))
    p.sort()
    t = 0
    while p:
        x = p.pop()
        s, t = x[0], max(x[1], t + abs(s - x[0]))
    return t

n, s = [int(x) for x in input().split(' ')]
p = [tuple([int(x) for x in input().split(' ')]) for r in range(n)]

print(solve(n, p, s))",O(n)
"class Solution2(object):
    def isCovered(self, ranges, left, right):
        ranges.sort()
        for l, r in ranges:
            if l <= left <= r:
                left = r+1
        return left > right",O(nlogn)
"n, m, k, l = map(int, input().split())
required = k + l
per_friend = (required + m - 1) // m
if (m * per_friend > n):
    print(-1)
else:
    print(per_friend)
",O(1)
"n,m,a,b=[int(x)for x in input().split()]
if n<m:print(min(a*(m-n),b*n))
else:print(min(b*(n%m),a*(m-(n%m)) ))",O(n)
"class Solution(object):
    def findAnagrams(self, s, p):
        result = []

        cnts = [0] * 26
        for c in p:
            cnts[ord(c) - ord('a')] += 1

        left, right = 0, 0
        while right < len(s):
            cnts[ord(s[right]) - ord('a')] -= 1
            while left <= right and cnts[ord(s[right]) - ord('a')] < 0:
                cnts[ord(s[left]) - ord('a')] += 1
                left += 1
            if right - left + 1 == len(p):
                result.append(left)
            right += 1

        return result",O(n)
"import collections


class Solution(object):
    def pathSum(self, nums):
        class Node(object):
            def __init__(self, num):
                self.level = num/100 - 1
                self.i = (num%100)/10 - 1
                self.val = num%10
                self.leaf = True

            def isParent(self, other):
                return self.level == other.level-1 and \
                       self.i == other.i/2

        if not nums:
            return 0
        result = 0
        q = collections.deque()
        dummy = Node(10)
        parent = dummy
        for num in nums:
            child = Node(num)
            while not parent.isParent(child):
                result += parent.val if parent.leaf else 0
                parent = q.popleft()
            parent.leaf = False
            child.val += parent.val
            q.append(child)
        while q:
            result += q.pop().val
        return result",O(n)
"a=input()
b=input()

if len(b)>len(a):

    l=[int(i) for i in a]
    l.sort()
    l=l[::-1]
    temp=[str(i) for i in l]
    s=''.join(temp)
    print(s)

else:
    d={}

    for i in a:

        if i not in d:

            d[i]=1
        else:

            d[i]=d[i]+1

    def find(i):

        global flag
        if i in d and d[i]>0:

            d[i]=d[i]-1

            return(i)

        for j in range(int(i),-1,-1):

            flag=1

            j=str(j)

            if j in d and d[j]>0:

                d[j]=d[j]-1

                return(j)

    def fun(d):

        l=[]
        for i in d:

            if d[i]>0:

                l=l+[int(i)]*d[i]
        l.sort()
        l=l[::-1]
        temp=[str(i) for i in l]

        s=''.join(temp)

        return(s)

    def fun2(x):

        global new
        for i in range(x-1,-1,-1):

            temp=new[i]
            for j in range(int(temp)-1,-1,-1):

                j=str(j)

                if j in d and d[j]>0:

                    new=new[:i]+str(j)
                    d[j]=d[j]-1

                    d[temp]=d[temp]+1

                    return(new)

            d[temp]=d[temp]+1

    flag=0
    new=''
    for i in range(len(b)):

        if flag==0:

            temp=find(b[i])

            if temp==None:

                new=fun2(i)

                new=new+fun(d)

                break

            else:
                new=new+temp

        else:

            new=new+fun(d)
            break

    print(new)
",O(n ^ 3)
"import itertools
from functools import reduce



class Solution(object):
    def getSneakyNumbers(self, nums):
        def f(check):
            return reduce(lambda accu, x: accu^x, (x for x in itertools.chain(nums, range(n)) if check(x)), 0)

        n = len(nums)-2
        x_xor_y = f(lambda _: True)
        bit = x_xor_y&-x_xor_y
        return [f(lambda x: x&bit == 0), f(lambda x: x&bit != 0)]",O(n)
"n,m = int(input()),int(input())
if n < 27:
    print(m%2**n)
else:
    print(m)",O(1)
"
from collections import defaultdict
from operator import getitem


class Solution(object):
    def longestWord(self, words):
        _trie = lambda: defaultdict(_trie)
        trie = _trie()
        for i, word in enumerate(words):
            reduce(getitem, word, trie)[""_end""] = i

        stack = list(trie.values())
        result = """"
        while stack:
            curr = stack.pop()
            if ""_end"" in curr:
                word = words[curr[""_end""]]
                if len(word) > len(result) or (len(word) == len(result) and word < result):
                    result = word
                stack += [curr[letter] for letter in curr if letter != ""_end""]
        return result

",O(n)
"import math
def C1():
    n, r = map(int, input().split())
    x_cord = [int(x) for x in input().split()]

    y_cord = []

    contactedDisk = 0
    for i, x in enumerate(x_cord):
        if len(y_cord) == 0:
            y_cord.append(r)
        else:
            y_cord.append(r)
            for j in range(i):
                diff = abs(x_cord[i] - x_cord[j])
                if diff <= 2 * r:
                    y_cord[i] = max(y_cord[i], math.sqrt(4*r*r - diff ** 2) + y_cord[j])

    for i in y_cord:
        print(i, end= "" "")

if __name__=='__main__':
    C1()
",O(n ^ 2)
"n = int(input())
r = 1
t = sum(map(int, input().split()))
for i in range(n - 1):
    if sum(map(int, input().split())) > t:
        r += 1

print(r)",O(n)
"allcolor=['purple','green','blue','orange','red','yellow']
op=['Power', 'Time', 'Space', 'Soul', 'Reality', 'Mind']
n=int(input())
ipcolor=[]
for i in range(0,n):
    color=input()
    ipcolor.append(color)
diff=list(set(allcolor) - set(ipcolor))
print(len(diff))
for i in range(0,len(diff)):
    print(op[allcolor.index(diff[i])])",O(1)
"l,r=map(int,input().split())
lxr = l^r
msb = 0
while(lxr):
	msb+= 1
	lxr>>= 1
m = 0
t=1
while msb:
	m += t
	t <<= 1
	msb -= 1
print(m)
",O(logn)
"class Solution(object):
    def maximumGain(self, s, x, y):
        def score(s, a, x):
            i = result = 0
            for j in range(len(s)):
                s[i] = s[j]
                i += 1
                if i >= 2 and s[i-2:i] == a:
                    i -= 2
                    result += x
            s[:] = s[:i]
            return result
                
        s, a, b = list(s), list(""ab""), list(""ba"")
        if x < y:
            x, y = y, x
            a, b = b, a
        return score(s, a, x) + score(s, b, y)",O(n)
"class Solution(object):
    def totalSteps(self, nums):
        dp = [0]*len(nums) 
        stk = []
        for i in reversed(range(len(nums))):
            while stk and nums[stk[-1]] < nums[i]:
                dp[i] = max(dp[i]+1, dp[stk.pop()])
            stk.append(i)
        return max(dp)",O(n)
"def bin_ser(arr,curr):
    l=0
    r=len(arr)-1
    ans=-1
    while l<=r:
        mid=(l+r)//2
        if arr[mid]<=curr:
            ans=mid
            l=mid+1
        else:
            r=mid-1
    return ans

def main():
    n,q=map(int,input().split())
    arr=list(map(int,input().split()))
    brr=list(map(int,input().split()))
    su=sum(arr)
    curr=0
    for i in range(1,n):
        arr[i]=arr[i]+arr[i-1]
    for b in brr:
        curr+=b
        pos=n-bin_ser(arr,curr)-1
        if pos==0:
            pos=n
        print(pos)
        if curr>=su:
            curr=0

main()",O(nlogn)
"class Solution(object):
    def maxNonDecreasingLength(self, nums1, nums2):
        result = 1
        dp = [1]*2
        for i in range(len(nums1)-1):
            dp = [max((dp[0]+1 if nums1[i] <= nums1[i+1] else 1), (dp[1]+1 if nums2[i] <= nums1[i+1] else 1)),
                  max((dp[0]+1 if nums1[i] <= nums2[i+1] else 1), (dp[1]+1 if nums2[i] <= nums2[i+1] else 1))]
            result = max(result, max(dp))
        return result",O(n)
"from random import randint


class Solution(object):
    def minMoves2(self, nums):
        def kthElement(nums, k):
            def PartitionAroundPivot(left, right, pivot_idx, nums):
                pivot_value = nums[pivot_idx]
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if nums[i] > pivot_value:
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left <= right:
                pivot_idx = randint(left, right)
                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)
                if new_pivot_idx == k:
                    return nums[new_pivot_idx]
                elif new_pivot_idx > k:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1

        median = kthElement(nums, len(nums)//2)
        return sum(abs(num - median) for num in nums)

    def minMoves22(self, nums):
        median = sorted(nums)[len(nums) / 2]
        return sum(abs(num - median) for num in nums)",O(n)
"import math

n,r = [int(x) for x in input().split()]

x = math.sin(math.pi/n)

y = (x*r)/(1-x)

print(y)",O(1)
"class Solution2(object):
    def maximumImportance(self, n, roads):
        degree = [0]*n
        for a, b in roads:
            degree[a] += 1
            degree[b] += 1
        degree.sort()
        return sum(i*x for i, x in enumerate(degree, 1))",O(nlogn)
"class Solution2(object):
    def maximumWhiteTiles(self, tiles, carpetLen):
        tiles.sort()
        result = left = gap = 0
        for right in range(len(tiles)):
            if right-1 >= 0:
                gap += tiles[right][0]-tiles[right-1][1]-1
            l = tiles[right][1]-carpetLen+1
            while not (tiles[left][1]+1 >= l):
                left += 1
                gap -= tiles[left][0]-tiles[left-1][1]-1
            result = max(result, min(tiles[right][1]-tiles[left][0]+1, carpetLen)-gap)
        return result",O(nlogn)
"from math import log10
from collections import Counter

n,k=[int(x) for x in input().split()]
lst=[int(x) for x in input().split()]
lst2=[]

for i in range(n):
    lst2.append(((lst[i]%k),len(str(lst[i]))))

dp = [[] for i in range(12)]
for j in lst2:
    dp[j[1]].append(j[0])
for i in range(12):
    if len(dp[i]) > 0:
        dp[i] = Counter(dp[i])
ans = 0
for i in lst:
    for j in range(2, 12):
        v1 = ((i%k) * pow(10, j-1))%k
        if (k - v1)%k in  dp[j-1]:
            ans=ans+dp[j-1][(k-v1)%k]
for i in lst:
    if int(str(i)+str(i))%k==0 :
        ans=ans-1
print(ans)
",O(nlogn)
"n,s = map(int,input().split())

if s%n==0:
	print(s//n)
else:
	print(s//n+1)",O(1)
"import os
import sys
from io import BytesIO, IOBase

def main():
    a=list(map(int,input().rstrip()))
    b=list(map(int,input().rstrip()))
    ans,la,lb=[],len(a),len(b)
    if la!=lb:
        print(*sorted(a,reverse=True),sep="""")
    else:
        for i in range(lb):
            if b[i] in a:
                ans.append(b[i])
                a.remove(b[i])
            else:
                while i>-1:
                    ma=-1
                    for j in a:
                        if j<b[i]:
                            ma=max(ma,j)
                    if ma!=-1:
                        ans.append(ma)
                        a.remove(ma)
                        break
                    i-=1
                    a.append(ans.pop())
                a.sort()
                while a:
                    ans.append(a.pop())
                break
        print("""".join(str(i) for i in ans))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(n ^ 3)
"from math import *
from collections import *
from random import *
from decimal import Decimal
from heapq import *
from bisect import *
import sys
input=sys.stdin.readline
sys.setrecursionlimit(10**5)
def lis():
    return list(map(int,input().split()))
def ma():
    return map(int,input().split())
def inp():
    return int(input())
def st1():
    return input().rstrip('\n')
t=1
while(t):
    t-=1
    r,g,b=ma()
    rl=lis()
    gl=lis()
    bl=lis()
    rl.sort()
    bl.sort()
    gl.sort()
    dp= [[[0]*(b+1)for i in range(g+1)] for j in range(r+1)]
    for i in range(r+1):
        for j in range(g+1):
            for k in range(b+1):
                if(i+j+k<2):
                    continue
                if(i and j):
                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+rl[i-1]*gl[j-1])
                if(j and k):
                    dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+gl[j-1]*bl[k-1])
                if(i and k):
                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+rl[i-1]*bl[k-1])
    print(dp[r][g][b])
",O(n ^ 3)
"def digit(a):
    s=0
    while a:
        s+=a%10
        a//=10
    return s

def big(n,s):
    lo=1
    hi=n
    while lo<=hi:
        mid=(lo+hi)//2
        if mid-digit(mid)<s:
            lo=mid+1
        else:
            hi=mid-1
    return n-lo+1

a,b=map(int,input().strip().split())
print(big(a,b))",O(logn)
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

def main():

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc=1
    for _ in range(tc):

        s=2*rs()+""333""
        le=(len(s)-3)//2
        a=[]
        for i in s:
            if i=='b':
                a.append(0)
            if i=='w':
                a.append(1)
            if i=='3':
                a.append(3)
        pehla=[0,1]*len(s)

        doosra=[1,0]*len(s)

        k=[0]*len(s)
        for i in range(len(s)):
            if a[i]==pehla[i]:
                k[i]=1
        ans=0
        t=0
        for i in k:
            if i==1:
                t+=1

            else:
                ans=max(t,ans)
                t=0

        k=[0]*len(s)
        for i in range(len(s)):
            if a[i]==doosra[i]:
                k[i]=1

        t=0
        for i in k:
            if i==1:
                t+=1

            else:
                ans=max(t,ans)
                t=0

        print(min(le,ans))

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(n)
"class Solution(object):
    def sumOfThree(self, num):
        return [num//3-1, num//3, num//3+1] if num%3 == 0 else []",O(1)
"class Solution(object):
    def sumOddLengthSubarrays(self, arr):
        def ceil_divide(a, b):
            return (a+(b-1))//b
        return sum(x * ceil_divide((i-0+1)*((len(arr)-1)-i+1), 2) for i, x in enumerate(arr))",O(n)
"class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

        left = self.height(root.left)
        right = self.height(root.right)
        if abs(left - right) > 1:
            return False
        return self.isBalanced(root.left) and self.isBalanced(root.right)

    def height(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        return 1 + max(self.height(root.left), self.height(root.right))
",O(n ^ 2)
"t = int(input())
for i in range(t):
    n, m = map(int, input().split())
    x1, y1, x2, y2 = map(int, input().split())
    x3, y3, x4, y4 = map(int, input().split())
    count_w = n * m // 2 + n * m % 2
    count_g = n * m // 2
    if (x1 + y1) % 2 == 0:
        count_g -= (x2 - x1 + 1) * (y2 - y1 + 1) // 2
        count_w += (x2 - x1 + 1) * (y2 - y1 + 1) // 2
    else:
        count_g -= (x2 - x1 + 1) * (y2 - y1 + 1) // 2 + (x2 - x1 + 1) * (y2 - y1 + 1) % 2
        count_w += (x2 - x1 + 1) * (y2 - y1 + 1) // 2 + (x2 - x1 + 1) * (y2 - y1 + 1) % 2
    x5 = max(x1, x3)
    x6 = min(x4, x2)
    y5 = max(y1, y3)
    y6 = min(y4, y2)
    if (x3 + y3) % 2 == 1:
        count_g += (x4 - x3 + 1) * (y4 - y3 + 1) // 2
        count_w -= (x4 - x3 + 1) * (y4 - y3 + 1) // 2
    else:
        count_g += (x4 - x3 + 1) * (y4 - y3 + 1) // 2 + (x4 - x3 + 1) * (y4 - y3 + 1) % 2
        count_w -= (x4 - x3 + 1) * (y4 - y3 + 1) // 2 + (x4 - x3 + 1) * (y4 - y3 + 1) % 2
    if (x5 + y5) % 2 == 0 and x5 <= x6 and y5 <= y6:
        count_g += (x6 - x5 + 1) * (y6 - y5 + 1) // 2
        count_w -= (x6 - x5 + 1) * (y6 - y5 + 1) // 2
    elif x5 <= x6 and y5 <= y6:
        count_g += (x6 - x5 + 1) * (y6 - y5 + 1) // 2 + (x6 - x5 + 1) * (y6 - y5 + 1) % 2
        count_w -= (x6 - x5 + 1) * (y6 - y5 + 1) // 2 + (x6 - x5 + 1) * (y6 - y5 + 1) % 2
    print(count_w, count_g)",O(1)
"class Solution(object):
    def copyRandomList(self, head):
        current = head
        while current:
            copied = Node(current.val)
            copied.next = current.__next__
            current.next = copied
            current = copied.__next__

        current = head
        while current:
            if current.random:
                current.next.random = current.random.__next__
            current = current.next.__next__

        dummy = Node(0)
        copied_current, current = dummy, head
        while current:
            copied_current.next = current.__next__
            current.next = current.next.__next__
            copied_current, current = copied_current.__next__, current.__next__
        return dummy.__next__",O(n)
"t = int(input())

while t>0:
    n, k = input().split()
    n, k = int(n), int(k)

    if n >= 32:
        print(""YES"", n-1)
        t -= 1
        continue

    possibleSize = -1
    sz = 1

    while sz <= n:

        req_cuts = 2**(sz+1) - 2 - sz

        tot_cuts = ((4**sz) - 1) // 3 + (((2**sz) -1)**2) * (((4**(n-sz)) - 1) // 3)

        if (req_cuts > k):
            break
        if (tot_cuts >= k):
            possibleSize = sz
            break

        sz+=1

    if (possibleSize != -1):
        print(""YES"", n - possibleSize)
    else:
        print(""NO"")

    t-=1",O(logn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def twoSumBSTs(self, root1, root2, target):
        def inorder_gen(root, asc=True):
            result, stack = [], [(root, False)]
            while stack:
                root, is_visited = stack.pop()
                if root is None:
                    continue
                if is_visited:
                    yield root.val
                else:
                    if asc:
                        stack.append((root.right, False))
                        stack.append((root, True))
                        stack.append((root.left, False))
                    else:
                        stack.append((root.left, False))
                        stack.append((root, True))
                        stack.append((root.right, False))
        
        left_gen, right_gen = inorder_gen(root1, True), inorder_gen(root2, False)
        left, right = next(left_gen), next(right_gen)
        while left is not None and right is not None:
            if left + right < target:
                left = next(left_gen)
            elif left + right > target:
                right = next(right_gen)
            else:
                return True
        return False",O(n)
"class Solution(object):
    def minAddToMakeValid(self, S):
        add, bal, = 0, 0
        for c in S:
            bal += 1 if c == '(' else -1
            if bal == -1:
                add += 1
                bal += 1
        return add + bal",O(n)
"import sys

def pprint(s):
    sys.stdout.write(str(s) + ""\n"")

def solve(n, d, k):
    for i in range(1, d+1):
        pprint(str(i)  + ' ' + str(i+1))
        if i + 1 == n:
            exit()

    q = d+2
    for i in range(2, d+1):
        for j in range(k-2):
            pprint(str(i)  + ' ' + str(q))
            if q == n:
                exit()
            q += 1
            def rec(depth, current, head):
                if depth == 0:
                    return current

                for i in range(k-1):
                    pprint(str(head)  + ' ' + str(current))
                    if current == n:
                        exit()
                    current += 1

                    current = rec(depth-1, current, current-1)

                return current

            if i <= (d+2)/2:
                depth = i-2
            else:
                depth = d-i

            q = rec(depth, q, q-1)

n, d, k = map(int, input().split())

q = k-1
maxi = 0
if k == 2:
    maxi = d+1
else:
    if d % 2:
        maxi = (q * (1-q**(d//2)) // (1-q) + 1) * 2
    else:
        maxi = (q * (1-q**(d//2-1)) // (1-q) + 1) * 3 + 1

if d == 2:
    maxi = k + 1

if n > maxi or n <= d:
    print(""NO"")
else:
    print(""YES"")
    solve(n, d, k)",O(n ^ 2)
"n,l,r,x = map(int,input().split())
a = list(map(int,input().split()))
ans = 0
for i in range(1,(2**n)+1):
    j = bin(i)
    j = j[2:]
    if len(j)<n:
        j = '0'*(n-len(j))+j

    c = 0
    temp = []
    for k in j:
        if k=='1':
            temp.append(a[c])
        c+=1
    s = sum(temp)

    if len(temp)>=2 and s>=l and s<=r and (max(temp)-min(temp))>=x:
        ans+=1

print(ans)",np
"a=9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999990000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
b=9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
print(a)
print(b)
",O(1)
"import collections



class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def verticalTraversal(self, root):
        def dfs(node, lookup, x, y):
            if not node:
                return
            lookup[x][y].append(node)
            dfs(node.left, lookup, x-1, y+1)
            dfs(node.right, lookup, x+1, y+1)
                
        lookup = collections.defaultdict(lambda: collections.defaultdict(list))
        dfs(root, lookup, 0, 0)

        result = []
        for x in sorted(lookup):
            report = []
            for y in sorted(lookup[x]):
                report.extend(sorted(node.val for node in lookup[x][y]))
            result.append(report)
        return result",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n,m = map(int,input().split())

A = [None]*n
lo,hi = 1<<32,-1<<32
for i in range(n):
    A[i] = list(map(int,input().split()))
    lo = min(min(A[i]), lo)
    hi = max(max(A[i]), hi)

best = -1
ans = [-1,-1]

def possible(x):
    global best, ans

    M = [-1]*(1<<m)

    for i in range(n):
        mask = 0
        for j in range(m):
            if A[i][j] >= x:
                mask += (1<<j)
        M[mask] = i

    for m0 in range(1<<m):
        if M[m0] == -1:
            continue

        for m1 in range(1<<m):
            if M[m1] == -1:
                continue

            if m0 | m1 == (1<<m) - 1:
                if best < x:
                    best = x
                    ans = [M[m0]+1, M[m1]+1]

                return True
    return False

possible(hi)
possible(lo)

while lo+1 < hi:
    mid = (lo+hi)//2
    if possible(mid):
        lo = mid
    else:
        hi = mid

print(*ans)
",np
"import collections


class Solution(object):
    def countVowelSubstrings(self, word):
        VOWELS = set(""aeiou"")
        k = 5
        def atLeastK(word, k):
            cnt = collections.Counter()
            result = left = right = 0
            for i, c in enumerate(word):
                if c not in VOWELS:
                    cnt = collections.Counter()
                    left = right = i+1
                    continue
                cnt[c] += 1
                while len(cnt) > k-1:
                    cnt[word[right]] -= 1
                    if not cnt[word[right]]:
                        del cnt[word[right]]
                    right += 1
                result += right-left
            return result

        return atLeastK(word, k)",O(n)
"def Solution(N, Q, wariors_strength, arrows):

    prefix_sum = [0]
    for strength in wariors_strength:
        prefix_sum.append(prefix_sum[-1]+strength)
    prefix_sum.pop(0)
    arrow_so_far = 0
    for arrow in arrows:
        arrow_so_far += arrow
        if arrow_so_far >= prefix_sum[-1]:
            print(N)
            arrow_so_far = 0
        else:
            idx = binarySearch_LowerBound(prefix_sum, arrow_so_far)
            print(N-idx)

def binarySearch_LowerBound(arr, key):
    l = 0
    r = len(arr)-1

    while l <= r:
        mid = (l+r)//2
        if arr[mid] == key:
            return mid+1
        elif arr[mid] > key:
            r = mid-1
        else:
            l = mid+1
    return r+1

N, Q = map(int, input().split())
wariors_strength = list(map(int, input().split()))
arrows = list(map(int, input().split()))

Solution(N, Q, wariors_strength, arrows)
",O(nlogn)
"n = int(input())

lucky = [""1"",""2"",""3"",""5"",""6"",""8"",""9"",""0""]

ye = False
for i in range(1,n+1):
    luck=True
    for char in str(i):
        if char in lucky:
            luck = False
            break

    if luck == True and n % i == 0:
        print(""YES"")
        ye = True
        break
    else:
        continue
if ye != True:
    print(""NO"")",O(1)
"n=int(input())
a=[*map(int,input().split())]
b=[0]*n
s=[0]*n
m=n
while m:
 for i,x in enumerate(a):
  if s[i]==0:
   r=range(i%x,n,x)
   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1
   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1
print(''.join(s))",O(n ^ 2)
"n, m = map(int, input().split())
a = []
b = []
ma = 0
macount = 0
mi = 1000000000000000000000000000
su = 0
for el in map(int, input().split()):
    if el > ma:
        ma = el
        macount = 1
    elif el == ma:
        macount += 1
    a.append(el)
for el in map(int, input().split()):
    mi = min(el, mi)
    b.append(el)
    su += el
if ma > mi:
    print(-1)
elif ma == mi or macount > 1:
    f = True
    for i in range(n):
        if a[i] == ma and f:
            f = False
        else:
            su += a[i] * m
    print(su)
else:
    secmax = 0
    for el in a:
        if el > secmax and el < ma:
            secmax = el
    f = True
    for i in range(n):
        if a[i] == ma and f:
            f = False
        else:
            su += a[i] * m
    print(su + ma - secmax)
",O(n)
"class Solution(object):
    def minChanges(self, n, k):
        def popcount(x):
            return bin(x).count('1')

        return popcount(n^k) if n&k == k else -1",O(logn)
"n = int(input())

if (n == 3):
    print('1 1 3')
else:
    done = 0
    arr = []
    for i in range(30, -1, -1):
        arr.extend([2**i]*(n//(2**i) - done))
        done += n//(2**i) - done
        if (done == 1):
            k = i

    arr[0] = max(arr[0], (n//2**(k-1)) * 2**(k-1))

    arr.reverse()
    print(' '.join(map(str, arr)))
",O(logn)
"max_ = 10**18
arr  = [0, 1]
arr2 = [0, 3]
while arr[-1] < max_:
    arr.append(arr[-1]*4)
    arr2.append(arr2[-1]*2+1)

for i in range(1, len(arr)):
    arr[i] += arr[i-1]

def solve(n, k):
    if n==2 and k==3:
        return 'NO'
    if n==2 and k==4:
        return 'YES 0'
    if n+1<=len(arr) and k > arr[n]:
         return 'NO'

    i=0
    while k >= arr[i+1]:
        i+=1
    if k-arr[i] > arr2[i]:
        i+=1
    return 'YES ' +str(n-i)

for _ in range(int(input())):
    n, k = map(int, input().split())
    print(solve(n, k))",O(logn)
"from heapq import *

MSIZE = 1 << 8
def GetVal(s):
    ans = 0
    for i in range(8):
        if s[i] == '1':
            ans = ans + (1 << i)
    return ans

def GetNot(s):
    return MSIZE - 1 - s;

xVal = GetVal('00001111')
yVal = GetVal('00110011')
zVal = GetVal('01010101')

def Dijkstra():
    depth = [['Z' * 585 for i in range(4)] for i in range(MSIZE)]
    depth[xVal][3] = 'x'
    depth[yVal][3] = 'y'
    depth[zVal][3] = 'z'

    pq = []
    def push(kek):
        heappush(pq, kek)
    def pop():
        return heappop(pq)
    push([1, xVal, 3])
    push([1, yVal, 3])
    push([1, zVal, 3])
    while len(pq) > 0:
        l, i, j = pop();
        if len(depth[i][j]) < l: continue
        for x in range(MSIZE):
            for y in range(4):
                nxt1 = depth[i][j] + '|' + depth[x][y]
                nxt2 = depth[x][y] + '|' + depth[i][j]
                nxt = min(nxt1, nxt2)
                val = (i | x)
                if len(depth[val][0]) == len(nxt) and depth[val][0] > nxt:
                    depth[val][0] = nxt
                    push([len(nxt), val, 0])
                elif len(depth[val][0]) > len(nxt):
                    depth[val][0] = nxt
                    push([len(nxt), val, 0])
        if j > 0:
            for x in range(MSIZE):
                for y in range(1, 4):
                    nxt1 = depth[i][j] + '&' + depth[x][y]
                    nxt2 = depth[x][y] + '&' + depth[i][j]
                    nxt = min(nxt1, nxt2)
                    val = (i & x)
                    if len(depth[val][1]) == len(nxt) and depth[val][1] > nxt:
                        depth[val][1] = nxt
                        push([len(nxt), val, 1])
                    elif len(depth[val][1]) > len(nxt):
                        depth[val][1] = nxt
                        push([len(nxt), val, 1])
        if j > 2:
            val = GetNot(i)
            nxt = '!' + depth[i][j]
            if len(depth[val][2]) == len(nxt) and depth[val][2] > nxt:
                depth[val][2] = nxt
                push([len(nxt), val, 2])
            elif len(depth[val][2]) > len(nxt):
                depth[val][2] = nxt
                push([len(nxt), val, 2])
        nxt = '(' + depth[i][j] + ')'
        val = i
        if len(depth[val][3]) == len(nxt) and depth[val][3] > nxt:
            depth[val][3] = nxt
            push([len(nxt), val, 3])
        elif len(depth[val][3]) > len(nxt):
            depth[val][3] = nxt
            push([len(nxt), val, 3])
    answer = []
    for i in range(MSIZE):
        ans = 'Z' * 585
        for j in range(4):
            if len(ans) > len(depth[i][j]):
                ans = depth[i][j]
            elif len(ans) == len(depth[i][j]) and ans > depth[i][j]:
                ans = depth[i][j]
        answer.append(ans)
    return answer
kek = Dijkstra()

q = int(input())
for i in range(q):
    print(kek[GetVal(input())])",O(n ^ 2)
"class Solution(object):
    def numberOfWays(self, num_people):
        MOD = 10**9+7
        def inv(x, m): 
            return pow(x, m-2, m) 

        def nCr(n, k, m):
            if n-k < k:
                return nCr(n, n-k, m)
            result = 1
            for i in range(1, k+1):
                result = result*(n-k+i)*inv(i, m)%m
            return result

        n = num_people//2
        return nCr(2*n, n, MOD)*inv(n+1, MOD) % MOD",O(n)
"n, m = map(int, input().split())
c = list(map(int, input().split()))
a = list(map(int, input().split()))

x = 0
for i in range(n):
	try:
		if a[0] >= c[i]:
			x += 1
			a.pop(0)
	except IndexError:
		pass

print(x)",O(n)
"def main():
    def update(l, r, i, res):
        j = 0
        while j < i:
            if res[j] is None:
                r[j] -= 1
                if r[j] < 0:
                    return False
            j += 1
        j += 1
        while j < n:
            if res[j] is None:
                l[j] -= 1
                if l[j] < 0:
                    return False
            j += 1
        return True

    ilist = {1}
    n = int(input())
    res = [None] * n
    cur = n
    l = [int(x) for x in input().split()]
    r = [int(x) for x in input().split()]

    while ilist and (sum(l) != 0 or sum(r) != 0):
        ilist = set()
        for i in range(n):
            if l[i] == r[i] == 0 and res[i] is None:
                res[i] = cur
                ilist.add(i)
        for i in ilist:
            check = update(l, r, i, res)
            if not check:
                return False
        cur -= 1
    if not ilist:
        return False
    for i in range(n):
        if res[i] is None:
            res[i] = cur
    return res

if __name__ == '__main__':
    res = main()
    if not res:
        print('NO')
    else:
        print('YES')
        for x in res:
            print(x, end=' ')",O(n ^ 2)
"import sys, os
from io import BytesIO, IOBase
from math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log
from collections import defaultdict as dd, deque
from heapq import merge, heapify, heappop, heappush, nsmallest
from bisect import bisect_left as bl, bisect_right as br, bisect

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

mod = pow(10, 9) + 7
mod2 = 998244353

def inp(): return stdin.readline().strip()
def iinp(): return int(inp())
def out(var, end=""\n""): stdout.write(str(var)+""\n"")
def outa(*var, end=""\n""): stdout.write(' '.join(map(str, var)) + end)
def lmp(): return list(mp())
def mp(): return map(int, inp().split())
def smp(): return map(str, inp().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]
def remadd(x, y): return 1 if x%y else 0
def ceil(a,b): return (a+b-1)//b
S1 = 'abcdefghijklmnopqrstuvwxyz'
S2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
def isprime(x):
    if x<=1: return False
    if x in (2, 3): return True
    if x%2 == 0: return False
    for i in range(3, int(sqrt(x))+1, 2):
        if x%i == 0: return False
    return True

n, m, k = mp()
hor = [lmp() for i in range(n)]
ver = [lmp() for i in range(n-1)]
if k%2:
    ml = l2d(n, m, -1)
    for i in ml: print(*i)
    exit()
k//=2
dp = [l2d(n, m) for i in range(k+1)]
for f in range(1, k+1):
    for i in range(n):
        for j in range(m):
            a = inf
            if i!=0:
                a = min(a, 2*ver[i-1][j]+dp[f-1][i-1][j])
            if i!=n-1:
                a = min(a, 2*ver[i][j]+dp[f-1][i+1][j])
            if j!=0:
                a = min(a, 2*hor[i][j-1]+dp[f-1][i][j-1])
            if j!=m-1:
                a = min(a, 2*hor[i][j]+dp[f-1][i][j+1])
            dp[f][i][j] = a
for i in dp[-1]:
    print(*i)",O(n ^ 3)
"class Solution2(object):
    def sumOfNumberAndReverse(self, num):
        def reverse(n):
            result = 0
            while n:
                result = result*10 + n%10
                n //= 10            
            return result

        return any(x+reverse(x) == num for x in range(num//2, num+1))",O(nlogn)
"m = 10**18

def run():
    n, k = [int(x) for x in input().split()]
    currn, currs = 1, n
    rem = 0

    while True:
        if k == 0:
            print(f'YES {currs}')
            return
        if k < currn or currs == 0:
            print('NO')
            return
        currs -= 1
        k -= currn
        if currs >= 40:
            rem = m
        else:
            rem = min(m, rem + cc[currs]*((currn-1)*2+1))
        currn = (currn - 1) * 2 + 3

        if k <= rem:
            print(f'YES {currs}')
            return

cc = [0, 1]
for i in range(2, 50):
    cc.append(min(m, 1 + 4*cc[-1]))
for i in range(int(input())): run()
",O(logn)
"class Solution(object):
    def singleNonDuplicate(self, nums):
        left, right = 0, len(nums)-1
        while left <= right:
            mid = left + (right - left) / 2
            if not (mid%2 == 0 and mid+1 < len(nums) and \
                    nums[mid] == nums[mid+1]) and \
               not (mid%2 == 1 and nums[mid] == nums[mid-1]):
                right = mid-1
            else:
                left = mid+1
        return nums[left]",O(logn)
"n = int(input())

ax, ay = list(map(int, input().split()))
bx, by = list(map(int, input().split()))
cx, cy = list(map(int, input().split()))

x = [ax, bx, cx]
y = [ay, by, cy]

x.sort()
y.sort()

if (x[1] != ax) and (y[1] != ay):
        print('YES')
else:
        print('NO')
",O(1)
"class Solution(object):
    def chalkReplacer(self, chalk, k):
        k %= sum(chalk)
        for i, x in enumerate(chalk):
            if k < x:
                return i
            k -= x
        return -1",O(n)
"turns = int(input())
s0 = input()
s1 = input()
s2 = input()

d0 = dict()
d1 = dict()
d2 = dict()

alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
for char in alphabet:
	d0[char] = 0
	d1[char] = 0
	d2[char] = 0

for char in s0:
	d0[char] += 1
for char in s1:
	d1[char] += 1
for char in s2:
	d2[char] += 1

m0 = max([d0[char] for char in alphabet])
m1 = max([d1[char] for char in alphabet])
m2 = max([d2[char] for char in alphabet])

l0 = len(s0)
l1 = len(s1)
l2 = len(s2)

if turns == 1 and m0 == l0:
	score0 = m0 - 1
else:
	score0 = min(l0,m0+turns)

if turns == 1 and m1 == l1:
	score1 = m1 - 1
else:
	score1 = min(l1,m1+turns)

if turns == 1 and m2 == l2:
	score2 = m2 - 1
else:
	score2 = min(l2,m2+turns)

scores = [score0,score1,score2]
bestscore = max(scores)

winnerlist = [i for i in range(3) if scores[i] == bestscore]
if len(winnerlist) > 1:
	print('Draw')
else:
	print(['Kuro','Shiro','Katie'][winnerlist[0]])",O(n)
"fac = [1] * 500
finv = [1] * 500
p2 = [1] * 500

n, MOD = map(int, input().split())

for i in range(len(fac) - 1):
    fac[i + 1] = fac[i] * (i + 1) % MOD
    finv[i + 1] = pow(fac[i + 1], MOD - 2, MOD)
    p2[i + 1] = p2[i] * 2 % MOD

ans = 0
dp = [[0] * (n // 2 + 2) for _ in range(n + 2)]
dp[0][0] = 1
for i in range(n):
    for j in range(i + 2, n + 2):
        for k in range(n // 2 + 1):
            dp[j][k + 1] += dp[i][k] % MOD * finv[j - i - 1] * p2[j - i - 2]
ans = 0
for i in range(1, n // 2 + 2):
    ans += dp[n + 1][i] * fac[n - i + 1]
print(ans % MOD)",O(n ^ 3)
"import sys
from collections import defaultdict

reader = (map(int, line.split()) for line in sys.stdin)
input = reader.__next__

n, m = input()

vals = set()
locs = defaultdict(list)
for i in range(n):
    for pos, v in enumerate(input()):
        vals.add(v)
        locs[v].append((pos, i))

masks = [0] * n
full = (1<<m) - 1
met = {0:0}
for v in sorted(vals, reverse=True):
    for pos, i in locs[v]:
        curr_mask = masks[i] = masks[i] | (1<<pos)
        met[curr_mask] = i
        complement = full ^ curr_mask
        if complement in met:
            print(i+1, met[complement]+1)
            sys.exit()",np
"class Solution(object):
    def confusingNumber(self, N):
        lookup = {""0"":""0"", ""1"":""1"", ""6"":""9"", ""8"":""8"", ""9"":""6""}
        
        S = str(N)
        result = []
        for i in range(len(S)):
            if S[i] not in lookup:
                return False
        for i in range((len(S)+1)//2):
            if S[i] != lookup[S[-(i+1)]]:
                return True
        return False",O(logn)
"q=int(input())

Q=[list(map(int,input().split())) for i in range(q)]

for n,m,k in Q:
    if n>k or m>k:
        print(-1)
        continue

    x=max(n,m)-min(n,m)
    y=k-max(n,m)

    if x%2==0 and y%2==0:
        print(k)
    elif x%2==0 and y%2==1:
        print(k-2)
    elif x%2==1 and y%2==0:
        print(k-1)
    elif x%2==1 and y%2==1:
        print(k-1)
",O(1)
"import re


class Solution(object):
    def solveEquation(self, equation):
        a, b, side = 0, 0, 1
        for eq, sign, num, isx in re.findall('(=)|([-+]?)(\d*)(x?)', equation):
            if eq:
                side = -1
            elif isx:
                a += side * int(sign + '1') * int(num or 1)
            elif num:
                b -= side * int(sign + num)
        return 'x=%d' % (b / a) if a else 'No solution' if b else 'Infinite solutions'",O(n)
"n,m,k=map(int,input().split())
p=list(map(int,input().split()))
count=0
delete=0
now=0
while now<m:
    up=((p[now]-delete-1)//k+1)*k+delete
    while now<m and p[now]<=up:
        now+=1
        delete+=1
    count+=1
print(count)",O(n)
"n , k = map(int , input().split())
n , k = n-1 , k-1

l = 0
r = k
g = k*(k+1)//2
ans = -1

while l <= r:
 	m = (l+r)//2
 	if g-m*(m+1)//2>=n:
 		ans = k-m
 		l = m+1
 	else:
 		r = m-1

print(ans)",O(logn)
"x, y, z, t1, t2, t3 = map(int, raw_input().split())
elev = t3*3 + t2*(abs(z-x) + abs(x-y))
stairs = t1*abs(x - y)
if elev <= stairs:
    print('YES')
else:
    print('NO')
",O(1)
"import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

INF = 10**9

n, m = [int(item) for item in input().split()]
s = input().rstrip()

adj_in_subset = [0] * (1 << m)
ord_a = ord(""a"")
for c1, c2 in zip(s, s[1:]):
    c1 = ord(c1) - ord_a
    c2 = ord(c2) - ord_a
    if c1 != c2:
        adj_in_subset[(1 << c1) + (1 << c2)] += 1
for i in range(m):
    for j in range(1 << m):
        if j & (1 << i):
            adj_in_subset[j] += adj_in_subset[j ^ (1 << i)]

total_adj = adj_in_subset[-1]
dp = [INF] * (1 << m)
dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if i & 1 << j:
            continue
        cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]
        dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + cost)
print(dp[-1])",np
"import os, sys
from io import BytesIO, IOBase
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def getInt(): return int(input())
def getStrs(): return input().split()
def getInts(): return list(map(int,input().split()))
def getStr(): return input()
def listStr(): return list(input())
def getMat(n): return [getInts() for _ in range(n)]
def isInt(s): return '0' <= s[0] <= '9'

squares = set([i*i for i in range(1,4000)])

p = [i for i in range(10**7+1)]
for i in range(1,10**7+1):
    if p[i] == i:
        for sq in squares:
            if i*sq > 10**7: break
            p[i*sq] = i

for _ in range(getInt()):
    N, K = getInts()
    A = getInts()
    new = 10**8
    A = [p[A[i]] for i in range(N)]
    dp = [N]*(K+1)
    dp[0] = 0
    used = [set()]*(K+1)
    for i in range(N):
        for j in range(K,-1,-1):
            if dp[j] == N: continue
            if A[i] in used[j]:
                if j < K and dp[j+1] > dp[j]:
                    dp[j+1] = dp[j]
                    used[j+1] = used[j]
                dp[j] += 1
                used[j] = set([A[i]])
            else:
                used[j].add(A[i])
    print(min(dp)+1)
",O(n ^ 3)
"class Solution(object):
    def strongPasswordCheckerII(self, password):
        SPECIAL = set(""!
        return (len(password) >= 8 and
                any(c.islower() for c in password) and
                any(c.isupper() for c in password) and
                any(c.isdigit() for c in password) and
                any(c in SPECIAL for c in password) and
                all(password[i] != password[i+1] for i in range(len(password)-1)))",O(n)
"n, m = map(int, input().split())
a = 0
while m:
    a += n//m
    n, m = m, n % m
print(a)
",O(1)
"n=int(input())
a=[0,0]+[int(x) for x in input().split()]
ans=[0]*(n+1)
for i in range(n,1,-1):
    if ans[i]==0:
        ans[i]=1
    ans[a[i]]+=ans[i]
if n==1:
    ans[1]=1
ans=ans[1:]
ans.sort()
print(*ans)",O(nlogn)
"n = int(input())
s = input()
t = input()
sl = [i for i in s]
tl = [i for i in t]
ans = []
if(''.join(sorted(s))!=''.join(sorted(t))):
    print(-1)

else:
    for i in range(n):
        if(sl[i]!=tl[i]):
            for j in range(i+1,n):
                if(sl[j]==tl[i]):
                    break
            for k in range(j-1,i-1,-1):
                sl[k],sl[k+1] = sl[k+1],sl[k]
                ans.append(k+1)

    print(len(ans))
    for i in ans:
        print(i,end=' ')",O(n ^ 2)
"R,G,B = map(int,input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))
area = 0
r.sort(reverse=True)
b.sort(reverse=True)
g.sort(reverse=True)
L = max(len(r),len(g),len(b))
dp = [[[0]*(B+1) for i in range(G+1)]for j in range(R+1)]

tr = 0
tg = 0
tb = 0
for i in range(R+1):
	for j in range(G+1):
		for k in range(B+1):
			if i>0 and j>0:
				dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])
			if j>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])
			if i>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])
			area = max(area,dp[i][j][k])
print(area)",O(n ^ 3)
"
class Solution(object):
    def toLowerCase(self, str):
        return """".join([chr(ord('a')+ord(c)-ord('A')) 
                        if 'A' <= c <= 'Z' else c for c in str])

",O(n)
"class Solution3(object):
    def singleNumber(self, nums):
        return list((collections.Counter(list(set(nums)) * 3) - collections.Counter(nums)).keys())[0]",O(n)
"n,m,k=map(int,input().split())
arr=list(map(int,input().split()))
arr.sort()
arr=arr+[k]
ans=0
s=0
while ans<n+1:
    s+=arr[-ans-1]
    if s>=m:
        break
    ans+=1
    s-=1
if s>=m:
    print(ans)
else:
    print(""-1"")
",O(nlogn)
"class Solution2(object):
    def categorizeBox(self, length, width, height, mass):
        CATEGORIES = [""Neither"", ""Heavy"", ""Bulky"", ""Both""]
        i = 2*(any(x >= 10**4 for x in (length, width, height)) or length*width*height >= 10**9)+int(mass >= 100)
        return CATEGORIES[i]",O(1)
"a,d=map(int,input().split())
y,g,b=map(int,input().split())
m=y*2+g
n=b*3+g
c=0
if(m>a):
    c+=m-a
if(n>d):
    c+=n-d
print(c)
",O(1)
"t = int(input())

def getcol(x1, y1, x2, y2):
    dx = max((x2-x1+1), 0)
    dy = max((y2-y1+1), 0)
    b = w = dx*dy//2
    if dx % 2 and dy % 2:
        if (x1+y1) % 2:
            b = b + 1
        else:
            w = w + 1
    return w, b

for _ in range(t):
    n, m = map(int, input().split())
    x1, y1, x2, y2 = map(int, input().split())
    x3, y3, x4, y4 = map(int, input().split())
    w, b = getcol(1,1,n,m)
    w1, b1 = getcol(x1,y1,x2,y2)
    w2, b2 = getcol(x3,y3,x4,y4)
    w3, b3 = getcol(max(x1,x3),max(y1,y3),min(x2,x4),min(y2,y4))
    woff = w-w1-w2+w3
    boff = b-b1-b2+b3
    print(woff+w1-w3+b1-b3, boff+w3+b3+b2-b3+w2-w3)
",O(1)
"class Solution3(object):
    def countPairs(self, nums, k):
        idxs = collections.defaultdict(list)
        for i, x in enumerate(nums):
            idxs[x].append(i)
        return sum(idx[i]*idx[j]%k == 0 for idx in idxs.values() for i in range(len(idx)) for j in range(i+1, len(idx)))",O(n ^ 2)
"n, m = map(int, input().split())
a = list(map(int, input().split()))
a.sort()
mx = a[-1]
t = 0
ans = 0;
for i in a:
    if i > 0:
        if i > t:
            t += 1
        ans += i - 1
ans -= mx - t
print(ans)
",O(nlogn)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def partition(self, head, x):
        dummySmaller, dummyGreater = ListNode(-1), ListNode(-1)
        smaller, greater = dummySmaller, dummyGreater

        while head:
            if head.val < x:
                smaller.next = head
                smaller = smaller.__next__
            else:
                greater.next = head
                greater = greater.__next__
            head = head.__next__

        smaller.next = dummyGreater.__next__
        greater.next = None

        return dummySmaller.__next__",O(n)
"import bisect



class Solution3(object):
    def findMaximumLength(self, nums):
        dp = prefix = left = 0
        stk = [(0, 0, 0)]
        for right in range(len(nums)):
            prefix += nums[right]
            left = bisect.bisect_left(stk, (prefix+1, 0, 0))-1
            last, dp = prefix-stk[left][1], stk[left][2]+1
            while stk and stk[-1][0] >= last+prefix:
                stk.pop()
            stk.append((last+prefix, prefix, dp))
        return dp",O(nlogn)
"import itertools

n = int(input())
a = []
for i in range(4):
    a.append([input() for _ in range(n)])
    if i < 3:
        assert input() == ''

best = 4*n*n
for p in itertools.permutations(a):
    for s in range(2):
        count = 0
        for i in range(4):
            for r in range(n):
                for c in range(n):
                    if p[i][r][c] != str((s + (i//2 + r) + (i % 2 + c)) % 2):
                        count += 1
        best = min(best, count)
print(best)
",O(n ^ 2)
"import os,sys;from io import BytesIO, IOBase
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno();self.buffer = BytesIO();self.writable = ""x"" in file.mode or ""r"" not in file.mode;self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:break
            ptr = self.buffer.tell();self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE));self.newlines = b.count(b""\n"") + (not b);ptr = self.buffer.tell();self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:os.write(self._fd, self.buffer.getvalue());self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file);self.flush = self.buffer.flush;self.writable = self.buffer.writable;self.write = lambda s: self.buffer.write(s.encode(""ascii""));self.read = lambda: self.buffer.read().decode(""ascii"");self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
try:sys.stdin,sys.stdout=open('in.txt','r'),open('out.txt','w')
except:pass
ii1=lambda:int(sys.stdin.readline().strip())
is1=lambda:sys.stdin.readline().strip()
iia=lambda:list(map(int,sys.stdin.readline().strip().split()))
isa=lambda:sys.stdin.readline().strip().split()

from functools import lru_cache
from collections import defaultdict
from math import inf

n,m,k = iia()
A = [[0] * (m) for _ in range(n)]
B = [[0] * (m) for _ in range(n)]
for i in range(n):
    tmp = iia()
    for j in range(m - 1):
        A[i][j + 1] = tmp[j]
for i in range(n - 1):
    tmp = iia()
    for j in range(m):
        B[i + 1][j] = tmp[j]

if k%2:
    [print(*[-1]*m) for i in range(n)]
    sys.exit()
ans = [[0] * m for _ in range(n)]
lim = k // 2
dp = [[[inf] * (lim + 1) for _ in range(m)] for _ in range(n)]
for i in range(n):
    for j in range(m):
        dp[i][j][0] = 0

for k in range(1, lim + 1):
    for i in range(n):
        for j in range(m):
            if i: dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1] + B[i][j])
            if j: dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 1] + A[i][j])
            if i < n - 1: dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 1] + B[i + 1][j])
            if j < m - 1: dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 1] + A[i][j + 1])
for i in range(n):
    for j in range(m):
        ans[i][j] = dp[i][j][-1] * 2
[print(*a) for a in ans]",O(n ^ 3)
"import math
import collections
def do():
    n = int(input())
    nums = map(int, input().split("" ""))
    count = collections.defaultdict(int)
    for num in nums:
        for i in range(1, int(math.sqrt(num))+1):
            cp = num // i
            if num % i == 0:
                count[i] += 1
            if cp != i and num % cp == 0:
                count[cp] += 1
    maxk = max(count.keys())
    freq = {k: (1 << count[k]) - 1 for k in count}
    for k in sorted(count.keys(), reverse=True):
        for kk in range(k << 1, maxk+1, k):
            freq[k] -= freq[kk] if kk in freq else 0
    return freq[1] % (10**9 + 7)

print(do())",np
"class Solution(object):
    def minimizeArrayValue(self, nums):
        def ceil_divide(a, b):
            return (a+b-1)//b

        result = curr = 0
        for i, x in enumerate(nums):
            curr += x
            result = max(result, ceil_divide(curr, i+1))
        return result",O(n)
"
class Solution(object):
    def getConcatenation(self, nums):
        nums.extend(nums)
        return nums


",O(n)
"t = int(input())
for i in range(t):
    n = int(input())
    arr = [int(x) for x in input().split()]
    arr.sort(reverse=True)
    print(min(arr[1] - 1, len(arr) - 2))",O(nlogn)
"t=int(input())
k=set()
for i in range(1,10**5):
  k.add(4*i*i)
  k.add(2*i*i)
for _ in range(t):
  n=int(input())
  if n in k:
    print('YES')
  else:
    print('NO')",O(1)
"class Node(object):
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight


class Solution(object):
    def construct(self, grid):
        def dfs(grid, x, y, l):
            if l == 1:
                return Node(grid[x][y] == 1, True, None, None, None, None)
            half = l // 2
            topLeftNode = dfs(grid, x, y, half)
            topRightNode = dfs(grid, x, y+half, half)
            bottomLeftNode = dfs(grid, x+half, y, half)
            bottomRightNode = dfs(grid, x+half, y+half, half)
            if topLeftNode.isLeaf and topRightNode.isLeaf and \
               bottomLeftNode.isLeaf and bottomRightNode.isLeaf and \
               topLeftNode.val == topRightNode.val == bottomLeftNode.val == bottomRightNode.val:
                return Node(topLeftNode.val, True, None, None, None, None)
            return Node(True, False, topLeftNode, topRightNode, bottomLeftNode, bottomRightNode)
        
        if not grid:
            return None
        return dfs(grid, 0, 0, len(grid))",O(n ^ 2)
"class Solution(object):
    def nthUglyNumber(self, n):
        ugly_number = 0

        heap = []
        heapq.heappush(heap, 1)
        for _ in range(n):
            ugly_number = heapq.heappop(heap)
            if ugly_number % 2 == 0:
                heapq.heappush(heap, ugly_number * 2)
            elif ugly_number % 3 == 0:
                heapq.heappush(heap, ugly_number * 2)
                heapq.heappush(heap, ugly_number * 3)
            else:
                heapq.heappush(heap, ugly_number * 2)
                heapq.heappush(heap, ugly_number * 3)
                heapq.heappush(heap, ugly_number * 5)

        return ugly_number

    def nthUglyNumber2(self, n):
        ugly = [1]
        i2 = i3 = i5 = 0
        while len(ugly) < n:
            while ugly[i2] * 2 <= ugly[-1]: i2 += 1
            while ugly[i3] * 3 <= ugly[-1]: i3 += 1
            while ugly[i5] * 5 <= ugly[-1]: i5 += 1
            ugly.append(min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5))
        return ugly[-1]

    def nthUglyNumber3(self, n):
        q2, q3, q5 = [2], [3], [5]
        ugly = 1
        for u in heapq.merge(q2, q3, q5):
            if n == 1:
                return ugly
            if u > ugly:
                ugly = u
                n -= 1
                q2 += 2 * u,
                q3 += 3 * u,
                q5 += 5 * u,",O(n)
"def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]

s = STR()

if len(set(s)) == len(s):
    print('0')
    exit(0)

d = []

for i in range(len(s)):
    for j in range(i+1 , len(s)):
        x = ''
        for k in range(i , j+1):
            x += s[k]

        d.append(x)

v = {}
for i in range(len(s)):
    if s[i] not in v :
        v[s[i]] = 1
    else:
        v[s[i]] +=1

for i in d :
    if i not in v :
        v[i] = 1
    else:
        v[i]+=1

mx = -1
ans = ''

for i in v :
    if v[i] >= 2 :
        if len(i) > mx :
            mx = max(mx , len(i))

print(mx)
",O(n ^ 3)
"class Solution2(object):
    def numberOfPairs(self, points):
        points.sort(key=lambda x: (x[0], -x[1]))
        return sum(all(not points[i][1] >= points[k][1] >= points[j][1] for k in range(i+1, j))
                   for i in range(len(points))
                   for j in range(i+1, len(points)) if points[i][1] >= points[j][1])",O(n ^ 3)
"n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]
ans = []

def check(mid: int) -> bool:
    global ans
    dic = {}
    for i in range(n):
        bit = 0
        for j in range(m):
            if a[i][j] >= mid:
                bit += 1
            bit <<= 1
        dic[bit >> 1] = i
    for x, idx in dic.items():
        for y, idy in dic.items():
            if x | y == 2**m-1:
                ans = idx + 1, idy + 1
                return True
    return False

le = 0
ri = int(1e9)
while le <= ri:
    mid = (le + ri) >> 1
    if check(mid):
        le = mid + 1
    else:
        ri = mid - 1
print(ans[0], ans[1])
",np
"class Solution(object):
    def maximumCoins(self, coins, k):
        def max_amount():
            coins.sort()
            result = curr = left = 0
            for right in range(len(coins)):
                curr += (coins[right][1]-coins[right][0]+1)*coins[right][2]
                while coins[right][1]-coins[left][1]+1 > k:
                    curr -= (coins[left][1]-coins[left][0]+1)*coins[left][2]
                    left += 1
                result = max(result, curr-max((coins[right][1]-coins[left][0]+1)-k, 0)*coins[left][2])
            return result
    
        result = max_amount()
        for i, (l, r, w) in enumerate(coins):
            coins[i][:] = [-r, -l, w]
        result = max(result, max_amount())
        return result",O(nlogn)
"n, m = map(int, input().split())

a = []
b = []

if n <= 8:
    a = [4]
    b = [5]

while n > 8:
    a += [4,5]
    b += [5,4]
    n -= 8

print(*a + [5], sep="""")
print(*b + [5], sep="""")",O(1)
"class Solution(object):
    def maxScore(self, nums):
        return sum(nums)-min(nums) if len(nums)%2 else sum(nums)-min(nums[i]+nums[i+1] for i in range(len(nums)-1))",O(n)
"n = int(input())
a = list(map(int, input().split()))

s = a[0] % 998244353
y = a[0]
for x in a[1:]:

	s = s * 2 + y + x
	y = y * 2 + x

	s %= 998244353
	y %= 998244353

print(s)
",O(n)
"
class Solution(object):
    def containsDuplicate(self, nums):
        return len(nums) > len(set(nums))

",O(n)
"from math import factorial as f
n = input()
s = input()
quest = s.count(""?"")
plusn = n.count(""+"")
plus = s.count(""+"")
try:
	comb = f(quest)/(f(plusn - plus) * f(quest - (plusn - plus)))
	print(""%.12f"" %(comb/2 ** quest))
except:
	print(""%.12f"" %0)
",np
"class Solution(object):
    def checkXMatrix(self, grid):
        return all((i-j == 0 or i+j == len(grid)-1) == (grid[i][j] != 0) for i in range(len(grid)) for j in range(len(grid[0])))",O(n ^ 2)
"def solve():
    n = int(input())
    l = list(map(int,list(input())))
    divisors = []
    total = sum(l)
    for j in range(2,int(sqrt(total))+1):
        if(total%j==0):
            divisors.extend([j,total//j])
    if(total==0):
        print(""YES"")
        return
    if(total!=1):
        divisors.append(1)

    for x in divisors:
        search = x
        index = 0
        summ = 0
        while(index<n):
            summ+=l[index]
            if(summ>search):
                break
            elif(summ==search):
                summ = 0
            index+=1

        if(summ==0 and index==n):
            print(""YES"")
            return
    print(""NO"")
import sys
import math
import bisect
from sys import stdin,stdout
from math import gcd,floor,sqrt,log
from collections import defaultdict as dd
from bisect import bisect_left as bl,bisect_right as br

inp    =lambda: int(input())
strng  =lambda: input().strip()
jn     =lambda x,l: x.join(map(str,l))
strl   =lambda: list(input().strip())
mul    =lambda: map(int,input().strip().split())
mulf   =lambda: map(float,input().strip().split())
seq    =lambda: list(map(int,input().strip().split()))

ceil   =lambda x: int(x) if(x==int(x)) else int(x)+1
ceildiv=lambda x,d: x//d if(x%d==0) else x//d+1

flush  =lambda: stdout.flush()
stdstr =lambda: stdin.readline()
stdint =lambda: int(stdin.readline())
stdpr  =lambda x: stdout.write(str(x))

solve()
",O(n ^ 2)
"from sys import stdin,stdout
import sys

n=int(stdin.readline().strip())
arr=list(map(int,stdin.readline().strip().split(' ')))

dp_arr=[[None for i in range(n)] for i in range(n)]

for i in range(n):
	dp_arr[i][i]=(arr[i],1,arr[i])

def merge_small(c1,c2):
	if c1[1]==1 and c2[1]==1:
		if c1[0]==c2[0]:
			return (c1[0]+1,1,c1[0]+1)
		else:
			return (c1[0],2,c2[0])
	elif c1[1]==2 and c2[1]==1:
		if c1[2]==c2[0]:
			if c1[0]==c1[2]+1:
				return (c1[0]+1,1,c1[0]+1)
			else:
				return (c1[0],2,c2[2]+1)
		else:
			return (c1[0],3,c2[2])

	elif c1[1]==1 and c2[1]==2:
		if c1[2]==c2[0]:
			if c2[2]==c2[0]+1:
				return (c2[2]+1,1,c2[2]+1)
			else:
				return (c2[0]+1,2,c2[2])
		else:
			return(c1[0],3,c2[2])

	elif c1[1]==2 and c2[1]==2:
		if c1[2]==c2[0]:
			c1=(c1[0],2,c1[2]+1)
			c2=(c2[2],1,c2[2])
			if c1[1]==2 and c2[1]==1:
				if c1[2]==c2[0]:
					if c1[0]==c1[2]+1:
						return (c1[0]+1,1,c1[0]+1)
					else:
						return (c1[0],2,c2[2]+1)
				else:
					return (c1[0],3,c2[2])
		else:
			return (c1[0],4,c2[2])

def merge_main(c1,c2):

	if c1[1]>2:
		if c2[1]>2:
			if c1[2]==c2[0]:
				return (c1[0],c1[1]+c2[1]-1,c2[2])
			else:
				return (c1[0],c1[1]+c2[1],c2[2])
		else:
			if c2[1]==1:
				if c1[2]==c2[0]:
					return (c1[0],c1[1],c2[2]+1)
				else:
					return (c1[0],c1[1]+1,c2[2])
			if c2[1]==2:
				if c1[2]==c2[0]:
					if c1[2]+1==c2[2]:
						return (c1[0],c1[1],c2[2]+1)
					else:
						return (c1[0],c1[1]+1,c2[2])
				else:
					return (c1[0],c1[1]+2,c2[2])
	else:
		if c2[1]>2:
			if c1[1]==1:
				if c1[2]==c2[0]:
					return (c1[2]+1,c2[1],c2[2])
				else:
					return (c1[2],c2[1]+1,c2[2])

			if c1[1]==2:
				if c1[2]==c2[0]:
					if c1[0]==c1[2]+1:
						return (c1[0]+1,c2[1],c2[2])
					else:
						return (c1[0],c2[1]+1,c2[2])
				else:
					return (c1[0],c2[1]+2,c2[2])
		else:

			return merge_small(c1,c2)

for i1 in range(1,n):
	for j1 in range(n-i1):
		curr_pos=(j1,j1+i1)

		for k1 in range(j1,j1+i1):

			res=merge_main(dp_arr[j1][k1],dp_arr[k1+1][j1+i1])

			if dp_arr[j1][j1+i1]==None or dp_arr[j1][j1+i1][1]>res[1]:
				dp_arr[j1][j1+i1]=res

stdout.write(str(dp_arr[0][n-1][1])+""\n"")
",O(n ^ 3)
"from sys import stdin, stdout, setrecursionlimit
from collections import deque, defaultdict
from bisect import bisect_left

def check(temp):
	if len(temp) < 2:
		return False
	else:
		s = sum(temp)
		if s >= l and s <= r:
			if temp[-1] - temp[0] >= x:
				return True
			else:
				return False
		else:
			return False

def brute(index, temp):
	global count

	if index == n:
		if check(temp):
			count += 1

	else:
		temp.append(arr[index])
		brute(index + 1, temp)
		temp.pop()
		brute(index + 1, temp)

n, l, r, x = list(map(int, stdin.readline().split()))
arr = list(map(int, stdin.readline().split()))
arr.sort()
count = 0
temp = []
brute(0, temp)
print(count)
",np
"from math import inf

n = int(input())
s_list = list(map(int, input().split()))
c_list = list(map(int, input().split()))

total_min = inf
for j in range(n):
    min_i = inf
    for i in range(0, j):
        if s_list[i] < s_list[j]:
            min_i = min(min_i, c_list[i])

    min_k = inf
    for k in range(j + 1, n):
        if s_list[k] > s_list[j]:
            min_k = min(min_k, c_list[k])

    total_min = min(total_min, min_i + c_list[j] + min_k)
if total_min != inf:
    print(total_min)
else:
    print(-1)",O(n ^ 2)
"import itertools

n, k = [int(i) for i in input().split()]

kas = [[0,0,0,0],[1,0,0,1],[0,1,1,0]]

mmm = 998244353

def count_k(ka, k, t):
    if t == 0:
        return ka[k][0] + ka[k][1] + ka[k][2] + ka[k-1][3]
    if t == 1:
        return ka[k-1][0] + ka[k][1] + ka[k-2][2] + ka[k-1][3]
    if t == 2:
        return ka[k-1][0] + ka[k-2][1] + ka[k][2] + ka[k-1][3]
    if t == 3:
        return ka[k-1][0] + ka[k][1] + ka[k][2] + ka[k][3]

for i in range(1, n):
    if len(kas) < k + 1:
        kas.append([0,0,0,0])
        kas.append([0,0,0,0])
    for kk in range(min(len(kas)-1, k), 1, -1):
        kas[kk] = [count_k(kas, kk, t) % mmm for t in range(4)]

print(sum(kas[k]) % mmm if k < len(kas) else 0)
",np
"import sys
input=sys.stdin.readline
n,m=map(int,input().split())
l=[]
for i in range(n):
    l.append([int(i) for i in input().split()])
left=0
right=10**9+1
while left<right:
    mid=(left+right)//2
    dicta={}
    for i in range(n):
        mask=0
        for j in range(m):
            mask<<=1
            if l[i][j]>=mid:
                mask+=1
        dicta[mask]=i
    ok=False
    for i in dicta:
        for j in dicta:
            if i|j==(2**m-1):
                ok=True
                ans=(dicta[i]+1,dicta[j]+1)
                break
        if ok ==True:
            break
    if ok==True:
        left=mid+1
    else:
        right=mid

print(*ans)
",np
"class Solution(object):
    def numberOfPairs(self, nums):
        cnt = [0]*(max(nums)+1)
        pair_cnt = 0
        for x in nums:
            cnt[x] ^= 1
            if not cnt[x]:
                pair_cnt += 1
        return [pair_cnt, len(nums)-2*pair_cnt]",O(n)
"from collections import Counter

def f(x):
    return max(list(Counter(x).values()))

n=int(input())
z=input()
l=len(z)
a=f(z)
b=f(input())
c=f(input())

def v(x):
    if x==l:
        return x-1
    else:
        return x+1

if n==1:
    a, b, c=v(a), v(b), v(c)
    if a>b and a>c:
        print(""Kuro"")
    elif b>a and b>c:
        print(""Shiro"")
    elif c>a and c>b:
        print(""Katie"")
    else:
        print(""Draw"")
elif (l-a<=n)+(l-b<=n)+(l-c<=n)>=2:
    print(""Draw"")
elif a>b and a>c:
    print(""Kuro"")
elif b>a and b>c:
    print(""Shiro"")
elif c>a and c>b:
    print(""Katie"")
else:
    print(""Draw"")
",O(n)
"from io import BytesIO, IOBase
import sys
import math
import os
from collections import defaultdict
from math import ceil
from bisect import bisect_left, bisect_left

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")
def mint(): return map(int, input().split())
def mfloat(): return map(float, input().split())

def solve():
    n, m, k = mint()
    horizontal = [list(mint()) for i in range(n)]
    vertical = [list(mint()) for i in range(n-1)]
    if k%2 or max(n, m)==1:
        for i in range(n):
            print(*[-1]*m)
        return

    dp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)]
    for length in range(1, k//2+1):
        for i in range(n):
            for j in range(m):

                left_path = math.inf if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]
                right_path = math.inf if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]
                top_path = math.inf if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]
                bottom_path = math.inf if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]
                dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])
    for i in range(n):
        for j in range(m):
            print(dp[i][j][k//2]*2, end=' ')
        print()

def main():

    t = 1
    for _ in range(t):
        solve()

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"sp = 10**9 + 7;

def power(number,n):
    res = 1
    while(n != 0):
        if n % 2 != 0:
            res *= number
            res %= sp
            n-= 1
        number *= number
        number %= sp
        n //= 2
    return res % sp

x,k = map(int,input().split())
if x == 0:
    print(0)
else:
    print(((((x % sp) * (power(2,k)))%sp*2)%sp - ((power(2,k)-1))%sp ) % sp)
",O(logn)
"n = int(input())
lst = [int(i) for i in input().split()]
st = set()
flag = False
count = 0
for i in lst:
    if i not in st:
        st.add(i)
    else:
        flag = True
        count+=1
        lol = i
sum1 = n*(n-1)//2
if count>1:
    print('cslnb')
    quit()
if not flag:
    if (sum(lst)- sum1)% 2 == 0:
        print('cslnb')
    else:
        print('sjfnb')
else:
    if (lol-1) in lst or lol == 0:
        print('cslnb')
    else:
        if (sum(lst)- sum1)% 2 == 0:
            print('cslnb')
        else:
            print('sjfnb')
",O(n)
"def process(X, a, b):
    X1 = set(X)
    Other = set([])
    A = set([])
    B = set([])
    Both = set([])
    for x in X:
        if a-x in X1 and b-x  not in X1:
            A.add(x)
            A.add(a-x)
        elif a-x not in X1 and b-x in X1:
            B.add(x)
            B.add(b-x)
        elif a-x not in X1 and b-x not in X1:
            return 'NO'
        else:
            Both.add(x)
    start = A.copy()
    while len(start) > 0:
        next_s = set([])
        for x in start:
            if b-x in Both:
                Both.remove(b-x)
                next_s.add(b-x)
                if a-b+x in Both:
                    Both.remove(a-b+x)
                    A.add(a-b+x)
                    next_s.add(a-b+x)
                A.add(b-x)
            if a-x in Both:
                Both.remove(a-x)
                next_s.add(a-x)
                A.add(a-x)
            elif a-x in B or a-x not in A:
                return 'NO'
        start = next_s
    start = B.copy()
    while len(start) > 0:
        next_s = set([])
        for x in start:
            if a-x in Both:
                Both.remove(a-x)
                next_s.add(a-x)
                if b-a+x in Both:
                    Both.remove(b-a+x)
                    B.add(b-a+x)
                    next_s.add(b-a+x)
                B.add(a-x)
            if b-x in Both:
                Both.remove(b-x)
                next_s.add(b-x)
                B.add(b-x)
            elif b-x in A or b-x not in B:
                return 'NO'
        start = next_s
    answer = []
    for x in X:
        if x in A:
            answer.append(0)
        else:
            answer.append(1)
    return answer

n, a, b = [int(x) for x in input().split()]
X = [int(x) for x in input().split()]
answer = process(X, a, b)
if answer=='NO':
    print('NO')
else:
    print('YES')
    print(' '.join(map(str, answer)))
",O(n)
"import sys
input=sys.stdin.readline

mod=10**9+7
n,t=map(int,input().split())
a=[]
for i in range(n):
    time,genre=map(int,input().split())
    genre-=1
    a.append((time,genre))
dp=[[0 for j in range(3)] for i in range(1<<n)]
for i in range(n):
    dp[1<<i][a[i][1]]=1
for i in range(1<<n):
    for j in range(3):
        if(dp[i][j]==0):
            continue
        mask=1
        for k in range(n):
            if(i&mask or a[k][1]==j):
                mask<<=1
                continue
            dp[i|mask][a[k][1]]=(dp[i|mask][a[k][1]]+dp[i][j])%mod
            mask<<=1
ans=0
for i in range(1<<n):
    mask=1
    duration=0
    for j in range(n):
        if(i&mask):
            duration+=a[j][0]
        mask<<=1
    if(duration==t):
        ans=(ans+sum(dp[i]))%mod
print(ans)
",np
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')

def main():
    n = N()
    arr = RLL()

    dp = [[n]*n for i in range(n)]
    rec = [[0]*n for i in range(n)]

    for i in range(n):
        rec[i][i] = arr[i]
        dp[i][i] = 1

    for le in range(2, n+1):
        for l in range(n):
            r = l+le-1
            if r>n-1: break
            for m in range(l, r):
                dp[l][r] = min(dp[l][r], dp[l][m] + dp[m+1][r])

                if rec[l][m]==rec[m+1][r] and dp[l][m]==dp[m+1][r]==1:
                    dp[l][r] = 1
                    rec[l][r] = rec[l][m]+1
    print(dp[0][-1])

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"class Solution(object):
    def countDaysTogether(self, arriveAlice, leaveAlice, arriveBob, leaveBob):
        NUMS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        prefix = [0]*(len(NUMS)+1)
        for i in range(len(NUMS)):
            prefix[i+1] += prefix[i]+NUMS[i]
    
        def day(date):
            return prefix[int(date[:2])-1]+int(date[3:])

        return max(day(min(leaveAlice, leaveBob))-day(max(arriveAlice, arriveBob))+1, 0)",O(1)
"data=list(map(int, input().split()))
sum=0
cont=0
res=0
con2=0
con3=0
for i in range(data[0]):
    sum=sum+con2
    con2+=1
    res=data[0]-con2

    if data[1]==0:
        if sum>= res:
            cont+=1

    else:
        if sum>data[1]:
            if res+1 == sum-data[1]:
                cont=res+1
                break
print(cont)
",O(logn)
"if __name__ == '__main__':
		n,m = map(int, input().split())
		l = list(map(int, input().split()))
		d = dict()
		if len(set(l)) < n:
			print(0)
		else:
			for i in range (m):
				d.setdefault(l[i],0)
				d[l[i]]+=1
			min1 = 999999999
			for i in d.values():
				if i < min1 :
					min1 = i
			print(min1)",O(n ^ 2)
"class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        seen = set()
        for num in nums:
            if num in seen:
                seen.remove(num)
            else:
                seen.add(num)
        return list(seen)[0]
",O(n)
"import collections


class Solution(object):
    def countGoodSubstrings(self, s):
        K = 3

        result = 0
        count = collections.Counter()
        for i in range(len(s)):
            if i >= K:
                count[s[i-K]] -= 1
                if not count[s[i-K]]:
                    del count[s[i-K]]
            count[s[i]] += 1
            if len(count) == K:
                result += 1
        return result",O(n)
"class Solution(object):
    def numOfSubarrays(self, arr):
        MOD = 10**9+7
        result, accu = 0, 0
        dp = [1, 0]
        for x in arr:
            accu ^= x&1
            dp[accu] += 1
            result = (result + dp[accu^1]) % MOD
        return result",O(n)
"n,l,r,x = map(int,input().split())
A = list(map(int,input().split()))
count = 0
for i in range(1<<n):
    total = 0
    mn = 1e6
    mx = -1e6
    for k in range(n):
        if (i & (1<<k)):
            total += A[k]
            mn = min(A[k],mn)
            mx = max(A[k],mx)
    if total<=r and total>=l and mx-mn>=x:
        count += 1
print(count)",np
"n,r = map(int,input().split())
x_coord = list(map(int,input().split()))
d = {}
for i in x_coord:
    final = r
    for j in range(i-r,i+r+1):
        check = d.get(j,[-1,-1])
        if check[0] > 0:
            potential = check[1] + ((4*r*r)-((i-check[0])**2))**.5
            final = max(potential,final)
    for j in range(i-r,i+r+1):
        d[j] = (i,final)
    print(final,end = "" "")",O(n ^ 2)
"from collections import deque

def addedge(u, v, value):
	global e
	a = [v, value, None]
	b = [u, 0, a]
	a[2] = b
	e[u].append(a)
	e[v].append(b)

inf = 2 * (10 ** 12)
ans = 0
n, m = map(int, input().split())
e = [[] for i in range(n + m + 2)]
a = tuple(map(int, input().split()))
S, T = 0, m + n + 1
for i in range(1, m + 1):
	u, v, w = map(int, input().split())
	ans += w
	addedge(i, u + m, inf)
	addedge(i, v + m, inf)
	addedge(S, i, w)
for i in range(m + 1, T):
	addedge(i, T, a[i - m - 1])

lvl = None
def bfs():
	global e, lvl
	lvl = [0] * (n + m + 2)
	q = deque([0])
	while q:
		node = q.popleft()

		for edge in e[node]:
			if edge[0] != 0 and lvl[edge[0]] == 0 and edge[1]:
				lvl[edge[0]] = lvl[node] + 1
				q.append(edge[0])

def dfs(node, maxdelta):
	global e, lvl
	if node == T:
		return maxdelta
	delta = 0
	for edge in e[node]:
		if lvl[edge[0]] == lvl[node] + 1 and edge[1]:
			tmp = dfs(edge[0], min(maxdelta, edge[1]))
			if tmp > 0:
				edge[1] -= tmp
				edge[2][1] += tmp
				maxdelta -= tmp
				delta += tmp
			if maxdelta == 0:
				break
	return delta

flow = 0
while 1:
	bfs()
	tmp = dfs(0, inf)
	if tmp == 0:
		break
	flow += tmp
ans -= flow
print(ans)
",O(n ^ 3)
"import math

n, m, k, l = map(int, input().split())

x = (l + k) // m
if x * m < l + k:
    x += 1
assert x * m >= l + k

if m * x > n:
    print(-1)
else:
    print(x)",O(1)
"n = int(input())
left = []
right = []
for i in range(n):
	data = input().split()
	left.append(int(data[0]))
	right.append(int(data[1]))

left.sort()
right.sort()
i = 0
j = 0
count = 1
ans = [0] * (n + 1)
left += [max(right) + 1]
right += [max(right) + 2]
while (i < n) and (j < n):
	while left[i + 1] <= right[j]:
		ans[count] += (left[i + 1] - left[i])
		count += 1
		i += 1
	ans[count] += (right[j] - left[i] + 1)
	i += 1
	count -= 1

	while ((i == n) or (right[j + 1] < left[i])) and (j < n - 1):
		ans[count] += (right[j + 1] - right[j])
		count -= 1
		j += 1
	ans[count] += (left[i] - right[j] - 1)
	j += 1
	count += 1

for i in range(1, n + 1):
	print(ans[i], end = "" "")
print()
",O(nlogn)
"import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return map(int, minp().split())

def main():
	n,m = mints()
	vert = []
	horiz = []
	for i in range(n):
		x = mint()
		vert.append(x)

	vert.sort()

	for i in range(m):
		x1,x2,y = mints()
		horiz.append((y,x1,x2))

	horiz.sort()

	p = -1
	hh = []
	for i in horiz:
		if p != i[0]:
			p = i[0]
			if i[1] == 1:
				hh.append(i[2])

	hh.sort()
	i = 0
	hl = len(hh)
	vl = len(vert)
	r = n + m
	for j in range(vl):
		while i < hl and hh[i] < vert[j]:
			i+=1
		r = min(r, hl-i + j)
	while i < hl and hh[i] < 1000000000:
		i+=1
	r = min(r, hl-i + vl)
	print(r)

main()",O(nlogn)
"def substraction(a,b):
    if a==0 or b==0:
        return 0
    else:
        if a>b:
            count=a//b
            return substraction(a%b,b)+count
        else:
            count = b//a
            return substraction(a,b%a)+count

t=int(input())
lst=[]
res=[]
for i in range(0,t):
    lst=[int(i) for i in input().split()]
    ele=substraction(lst[0],lst[1])
    res.append(ele)

for i in range(0,t):
    print(res[i])",O(1)
"l, r = [int(x) for x in input().split()]

q = l ^ r
a = 1
while q:
    q //=2
    a <<= 1
print(a-1)
",O(logn)
"n = int(input())

l = []
for _ in range(n):
    k,m = map(int, input().strip().split())
    l.append((k,m))

l.sort(key=lambda x:x[0]+x[1])

last = 0
ans = 1

for i in range(1,n):
   if  abs(l[i][0] - l[last][0]) >= l[i][1] + l[last][1] :
       last = i
       ans = ans + 1

print(ans)
",O(nlogn)
"R = lambda: map(int, input().split())
a = sorted(map(int, input()))
b = list(map(int, input()))
bn = int(''.join(map(str, b)))
res = int(''.join(map(str, sorted(a))))
if len(b) != len(a):
    print(''.join(map(str, sorted(a, reverse=True))))
else:
    for i in range(len(a)):
        for j in range(i + 1, len(a)):
            if a[i] < a[j] < b[i]:
                a[i], a[j] = a[j], a[i]
        tmp = int(''.join(map(str, a[:i + 1] + sorted(a[i + 1:], reverse=True))))
        res = max(res, tmp) if tmp <= bn else res
        for j in range(i + 1, len(a)):
            if a[j] == b[i]:
                a[i], a[j] = a[j], a[i]
    print(res)",O(n ^ 3)
"class Solution2(object):
    def maxNumberOfFamilies(self, n, reservedSeats):
        reservedSeats.sort()
        result, i = 2*n, 0
        while i < len(reservedSeats):
            reserved = [False]*3
            curr = reservedSeats[i][0]
            while i < len(reservedSeats) and reservedSeats[i][0] == curr:
                _, c  = reservedSeats[i]
                if 2 <= c <= 5:
                    reserved[0] = True
                if 4 <= c <= 7:
                    reserved[1] = True
                if 6 <= c <= 9:
                    reserved[2] = True
                i += 1
            if not reserved[0] and not reserved[2]:
                continue
            if not all(reserved):
                result -= 1
                continue
            result -= 2
        return result",O(nlogn)
"import random
import math

class Solution(object):

    def __init__(self, radius, x_center, y_center):
        self.__radius = radius
        self.__x_center = x_center
        self.__y_center = y_center
        

    def randPoint(self):
        r = (self.__radius) * math.sqrt(random.uniform(0, 1))
        theta = (2*math.pi) * random.uniform(0, 1)
        return (r*math.cos(theta) + self.__x_center,
                r*math.sin(theta) + self.__y_center)",O(1)
"import sys
input=sys.stdin.readline
n,m=map(int,input().split())
for i in range(n//2+n%2):
    x1=i+1
    x2=n-i
    if(x1==x2):
        for j in range(m//2+m%2):
            if(j+1==m-j):
                sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n""))
            else:
                sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n""))
                sys.stdout.write((str(x2)+"" ""+str(m-j)+""\n""))
    else:
        if(i%2==0):
            for j in range(m):
                sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n""))
                sys.stdout.write((str(x2)+"" ""+str(m-j)+""\n""))
        else:
            for j in range(m):
                sys.stdout.write((str(x1)+"" ""+str(m-j)+""\n""))
                sys.stdout.write((str(x2)+"" ""+str(j+1)+""\n""))",O(n ^ 2)
"def score(l):
    return sum(x*(x%2 == 0) for x in l)

res = 0
ns = list(map(int, input().split()))
for i in range(14):
    l = list(ns)
    for j in range(13):
        l[(i+1+j) % 14] += l[i]//14 + (1 if (j+1) <= l[i]%14 else 0)
    l[i] = l[i]//14
    res = max(res, score(l))

print(res)
",O(1)
"
import pandas as pd



def Solution(student_data: List[List[int]]) -> pd.DataFrame:
    return pd.DataFrame(
        data=student_data,
        columns=[""student_id"", ""age""],
    )


",O(n)
"class Solution2(object):
    def numMovesStones(self, a, b, c):
        stones = [a, b, c]
        stones.sort()
        left, min_moves = 0, float(""inf"")
        max_moves = (stones[-1]-stones[0]) - (len(stones)-1)
        for right in range(len(stones)):
            while stones[right]-stones[left]+1 > len(stones):
                left += 1
            min_moves = min(min_moves, len(stones)-(right-left+1)) 
        return [min_moves, max_moves]",O(1)
"def read():
    return [c == '1' for c in input()]
n = int(input())
a, b = read(), read()

res = 0

i = 0
while i + 1 < n:
    if a[i] != b[i] and a[i] != a[i+1] and b[i] != b[i+1]:
        a[i] = b[i]
        a[i+1] = b[i+1]
        res += 1
        i += 2
    else:
        i += 1

for i in range(n):
    if a[i] != b[i]:
        res += 1

print(res)",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict as dd
for t in range(int(input())):
    n=int(input())
    l=list(map(int,input().split()))
    l1=dd(int)
    a=0
    for j in l:
        l1[j]+=1
        if l1[j]==4:
            a=j
    if a:
        print(a,a,a,a)
    else:
        c=0
        x=0
        l2=[]
        for j in l1:
            if l1[j]>=2:
                l2.append(j)
        l2.sort()
        for j in l2:
                c+=1
                if c==1:
                    a=j
                elif c==2:
                    b=j
                else:
                    if x/j+j/x<a/b+b/a:
                        a,b=x,j
                x=j
        print(a,a,b,b)
",O(nlogn)
"s, ans, = input(), 0
sLen = len(s)

for i in range(sLen):
    for till1 in range(i + 1, sLen + 1):
        till2 = till1 + 1
        for j in range(i + 1, sLen + 1):
            if till2 > sLen:
                break
            sub1 = s[i:till1]
            sub2 = s[j:till2]
            subLen = len(sub1)
            if sub1 == sub2 and ans < subLen:
                ans = subLen
            till2 += 1

print(ans)
",O(n ^ 3)
"import sys
input = sys.stdin.readline

n,m,k=map(int,input().split())
P=[input().strip() for i in range(n)]
S=[input().split() for i in range(m)]

for i in range(m):
    S[i][1]=int(S[i][1])-1

PDICT=dict()
for i in range(n):
    PDICT[P[i]]=i

E=[]

for i in range(m):
    x=S[i][0]
    LIST=[]

    for j in range(1<<k):
        t=""""
        for l in range(k):
            if (1<<l) & j != 0:
                t+=""_""
            else:
                t+=x[l]

        if t in PDICT:
            LIST.append(PDICT[t])

    if not (S[i][1] in LIST):
        print(""NO"")
        exit()

    else:
        s=S[i][1]
        for l in LIST:
            if l==s:
                continue
            else:
                E.append((s,l))

EDGEIN=[0]*n
EDGEOUTLIST=[[] for i in range(n)]
for x,y in E:
    EDGEIN[y]+=1
    EDGEOUTLIST[x].append(y)

from collections import deque
QUE = deque()

for i in range(n):
    if EDGEIN[i]==0:
        QUE.append(i)

TOP_SORT=[]
while QUE:
    x=QUE.pop()
    TOP_SORT.append(x)
    for to in EDGEOUTLIST[x]:
        EDGEIN[to]-=1
        if EDGEIN[to]==0:
            QUE.appendleft(to)

if len(TOP_SORT)==n:
    print(""YES"")
    print(*[i+1 for i in TOP_SORT])
else:
    print(""NO"")
",np
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class union_find:
    def __init__(self, n):
        self.n = n
        self.rank = [0]*n
        self.parent = [int(j) for j in range(n)]

    def union(self,i,j):
        i = self.find(i)
        j = self.find(j)
        if self.rank[i] == self.rank[j]:
            self.parent[i] = j
            self.rank[j] += 1

        elif self.rank[i] > self.rank[j]:
            self.parent[j] = i
        else:
            self.parent[i] = j

    def find(self, i):
        temp = i
        if self.parent[temp] != temp:
            self.parent[temp] = self.find(self.parent[temp])
        return self.parent[temp]
from math import log2, ceil
from collections import deque, Counter as CC, defaultdict as dd
def main():

        p,q,r  = [int(j) for j in input().split()]
        a = [int(j) for j in input().split()]
        b = [int(j) for j in input().split()]
        c = [int(j) for j in input().split()]
        a.sort()
        b.sort()
        c.sort()
        l = [a,b,c]

        dp = [[[0 for i in range(r+1)] for j in range(q+1)] for k in range(p+1)]
        for i in range(p+1):
            for j in range(q+1):
                for k in range(r+1):
                    s = [i-1,j-1,k-1]
                    for u in range(3):

                        s[u]+=1
                        try:
                            tmp = dp[s[0]][s[1]][s[2]]
                        except:
                            s[u]-=1
                            continue
                        tmp2 = 1
                        flag =True
                        for t in range(3):
                            if(u!=t):
                                if(s[t]==-1):
                                    flag = False
                                    break
                                tmp2 *= l[t][s[t]]
                        tmp += tmp2
                        s[u]-=1
                        if(flag):
                            dp[i][j][k] = max(dp[i][j][k], tmp)
        print(dp[p][q][r])

if __name__ == ""__main__"":
    main()",O(n ^ 3)
"q = 1
for t in range(q):
	k = int(input())
	m = 0
	p = 9
	while k > p:
		m = m+1
		l = p
		p = p+ 9*(10**m)*(m+1)
	if m == 0:
		print(k)
		continue
	ans = int(""9""*m)+ (k-l)//(m+1)
	if (k-l)%(m+1) == 0:
		print(str(ans)[-1])
	else:
		ans = ans+1
		print(str(ans)[((k-l)%(m+1))-1])",O(logn)
"def nod(a, b):
    while ((a != 0) and (b != 0)):
        if (a > b):
            a = a % b
        else:
            b = b % a
    return a + b
def point3(x1, y1, x2, y2, x3, y3):
    dy12 = x2 - x1
    dx12 = -(y2 - y1)
    dx13 = x3 - x1
    dy13 = y3 - y1
    if ((dx12 * dx13 + dy12 * dy13) == 0):
        return True
    else:
        return False

lstline = []
mas = list(map(int, input().split()))
n = mas[0]
if (n <= 4):
    for j in range(n):
        mas = list(map(int, input().split()))
    print('YES')
else:
    lst5 = []
    for j in range(5):
        mas = list(map(int, input().split()))
        lst5 = lst5 + [[mas[0], mas[1]]]
    ok = True
    for i in range(3):
        for j in range(i + 1, 4, 1):
            for k in range(j + 1, 5, 1):
                if (ok):
                    if (point3(lst5[i][0], lst5[i][1], lst5[j][0], lst5[j][1], lst5[k][0], lst5[k][1])):
                        l1x1 = lst5[i][0]
                        l1y1 = lst5[i][1]
                        l1x2 = lst5[j][0]
                        l1y2 = lst5[j][1]

                        ok = False
    if (ok == False):
        lstline = []
        for j in range(5):
            if not(point3(l1x1, l1y1, l1x2, l1y2, lst5[j][0], lst5[j][1])):
                lstline = lstline + [[lst5[j][0], lst5[j][1]]]

    if (ok):
        for j in range(n - 5):
            mas = list(map(int, input().split()))
        print('NO')
    else:
        res = 'YES'
        ok1 = True
        for j in range(n - 5):
            mas = list(map(int, input().split()))
            okey1 = point3(l1x1, l1y1, l1x2, l1y2, mas[0], mas[1])

            if (ok1):
                if (len(lstline) == 2):
                    l2x1 = lstline[0][0]
                    l2y1 = lstline[0][1]
                    l2x2 = lstline[1][0]
                    l2y2 = lstline[1][1]
                    ok1 = False
                    okey2 = point3(l2x1, l2y1, l2x2, l2y2, mas[0], mas[1])
                    if (not(okey1) and not(okey2)):
                        res = 'NO'
                elif(not(okey1)):
                    lstline = lstline + [[mas[0], mas[1]]]
            elif(not(okey1)):
                okey2 = point3(l2x1, l2y1, l2x2, l2y2, mas[0], mas[1])

                if (not(okey2)):
                    res = 'NO'
        print(res)",O(nlogn)
"for _ in range(int(input())):
    n,m = sorted(map(int,input().split()))
    count = 0
    while n> 0:
        count+= m//n
        m = m%n
        n,m = sorted([n,m])
    print(count)
",O(1)
"class Solution:
    def rob(self, nums: List[int]) -> int:
        memo = [-1] * len(nums)

        def dfs(i):
            if i >= len(nums):
                return 0
            if memo[i] != -1:
                return memo[i]
            memo[i] = max(dfs(i + 1), nums[i] + dfs(i + 2))
            return memo[i]

        return dfs(0)
",O(n)
"def check(x: int) -> (int, int):
    vis = {}
    for i, array in enumerate(a):
        t = 0
        for j, val in enumerate(array):
            if val >= x:
                t |= 1 << j
        vis[t] = i
    if (1 << m) - 1 in vis:
        return vis[(1 << m) - 1], vis[(1 << m) - 1]
    for i in range(1, (1 << m) - 1):
        for j in range(1, (1 << m) - 1):
            if i in vis and j in vis and i | j == (1 << m) - 1:
                return vis[i], vis[j]
    return -1, -1

if __name__ == '__main__':
    n, m = map(int, input().split())
    a = []
    for i in range(n):
        a.append(list(map(int, input().split())))
    l = 0
    r = int(1e9)
    while l <= r:
        mid = l + r >> 1
        if check(mid) != (-1, -1):
            l = mid + 1
        else:
            r = mid - 1
    ans = check(r)
    print(""%d %d"" % (ans[0] + 1, ans[1] + 1))
",np
"class Solution(object):
    def concatenatedBinary(self, n):
        MOD = 10**9+7
        result = l = 0
        for i in range(1, n+1):
            if i&(i-1) == 0:
                l += 1
            result = ((result<<l)%MOD+i)%MOD
        return result",O(n)
"class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow, fast = head, head

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False
",O(n)
"def main():
    n, m = map(int, input().split())
    w = [c == '*' for i in range(n) for c in input()]
    nm = n * m
    q = [*[range(i, i + m) for i in range(0, nm, m)],
            *[range(i, nm, m) for i in range(m)]]
    e = [1000] * nm
    for f in True, False:
        for r in q:
            v = 0
            for i in r:
                if w[i]:
                    v += 1
                    if e[i] > v:
                        e[i] = v
                else:
                    v = e[i] = 0
        if f:
            w.reverse()
            e.reverse()
    e = [c if c != 1 else 0 for c in e]
    for f in True, False:
        for r in q:
            v = 0
            for i in r:
                if v > e[i]:
                    v -= 1
                else:
                    v = e[i]
                if v:
                    w[i] = False
        if f:
            w.reverse()
            e.reverse()
    if any(w):
        print(-1)
    else:
        r = []
        for i, c in enumerate(e):
            if c:
                r.append(f'{i//m+1} {i%m+1} {c-1}')
        print(len(r), '\n'.join(r), sep='\n')

main()",O(n ^ 2)
"class Solution2(object):
    def isPrefixString(self, s, words):
        i = 0
        for word in words:
            for c in word:
                if i == len(s) or s[i] != c:
                    return False
                i += 1
            if i == len(s):
                return True
        return False",O(n)
"class Solution(object):
    def twoSumLessThanK(self, A, K):
        A.sort()
        result = -1
        left, right = 0, len(A)-1
        while left < right:
            if A[left]+A[right] >= K:
                right -= 1
            else:
                result = max(result, A[left]+A[right])
                left += 1
        return result",O(nlogn)
"from math import factorial as fact

a = input()
b = input()

aplus = a.count('+')
aminus = len(a) - aplus

bplus = b.count('+')
bminus = b.count('-')
bjolly = len(b) - bplus - bminus

if bplus > aplus or bminus > aminus:
    print(0)
else:
    c = aplus-bplus
    res = fact(bjolly) / fact(bjolly-c) / fact(c) / 2**bjolly
    print(res)
",np
"class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        if not nums:
            return 0
        res = 0
        nums.sort()

        curr, streak = nums[0], 0
        i = 0
        while i < len(nums):
            if curr != nums[i]:
                curr = nums[i]
                streak = 0
            while i < len(nums) and nums[i] == curr:
                i += 1
            streak += 1
            curr += 1
            res = max(res, streak)
        return res
",O(nlogn)
"k,n,s,p = map(int, input().split())
q = (n+s-1)//s
ans = (q*k+p-1)//p
print(ans)
",O(1)
"from sys import stdin

rstr = lambda: stdin.readline().strip()
rints = lambda: [int(x) for x in stdin.readline().split()]

n, m, k = rints()
a = [rstr() for _ in range(n)]
mem = [[float('inf') if i else 0 for _ in range(k + 1)] for i in range(n + 1)]

for i in range(n):
    ixs = []
    for j in range(m):
        if a[i][j] == '1':
            ixs.append(j)

    for j in range(k + 1):
        tem = 0
        if j < len(ixs):
            tem, c = float('inf'), 0
            for j1 in range(len(ixs) - j - 1, len(ixs)):
                tem = min(tem, ixs[j1] - ixs[c] + 1)
                c += 1

        for j1 in range(k + 1 - j):
            mem[i + 1][j1 + j] = min(mem[i + 1][j1 + j], mem[i][j1] + tem)

print(mem[n][k])
",O(n ^ 3)
"def occurrences(string, sub):
    count = start = 0
    while True:
        start = string.find(sub, start) + 1
        if start > 0:
            count += 1
        else:
            return count

class CodeforcesTask23ASolution:
    def __init__(self):
        self.result = ''
        self.string = ''

    def read_input(self):
        self.string = input()

    def process_task(self):
        o_max = 0
        for x in range(len(self.string)):
            for y in range(x):
                m = occurrences(self.string, self.string[y:x])
                if m >= 2:
                    o_max = max(x - y, o_max)
        self.result = str(o_max)

    def get_result(self):
        return self.result

if __name__ == ""__main__"":
    Solution = CodeforcesTask23ASolution()
    Solution.read_input()
    Solution.process_task()
    print(Solution.get_result())
",O(n ^ 3)
"import sys

def input():
    return sys.stdin.readline().rstrip()

def slv():
    n, m, k = map(int, input().split())
    if k % 2 != 0:
        for i in range(n):
            print(*[-1]*m)
        return

    k //= 2

    DP = [[[0]*m for i in range(n)] for _ in range(k + 1)]
    G = [[[] for i in range(m)] for j in range(n)]
    for i in range(n):
        C = list(map(int,input().split()))
        for j in range(m - 1):
            cost = C[j]
            G[i][j].append((cost,i,j + 1))
            G[i][j + 1] .append((cost,i,j))

    for i in range(n - 1):
        C = list(map(int,input().split()))
        for j in range(m):
            cost = C[j]
            G[i][j].append((cost,i + 1,j))
            G[i+1][j].append((cost,i,j))

    for p in range(1,k + 1):
        for u in range(n):
            for v in range(m):
                DP[p][u][v] = min(DP[p - 1][x][y] + cost for (cost,x,y) in G[u][v])
    for i in range(n):
        ans = [DP[k][i][j]*2 for j in range(m)]
        print(*ans)
    return
def main():
    t = 1
    for i in range(t):
        slv()
    return

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"def read():
    return [int(v) for v in input().split()]

def main():
    mod = 10 ** 9 + 7
    x, k = read()
    if x == 0:
        print(0)
    else:
        print((pow(2, k, mod) * (2 * x - 1) + 1) % mod)

if __name__ == '__main__':
    main()
",O(logn)
"class Solution(object):
    def convertToTitle(self, n):
        result = []
        while n:
            result += chr((n-1)%26 + ord('A'))
            n = (n-1)//26
        result.reverse()
        return """".join(result)",O(logn)
"lis = list(map(int,input().split()))
if lis[2] <= lis[0] and lis[2] <= lis[1]:
	if ((lis[0]+lis[1]) - lis[2]) < lis[3]:
		print(lis[3] - ((lis[0]+lis[1]) - lis[2]))
	elif sum(lis) == 0:
		print(-1)
	elif lis[0] == 0 and lis[1] == 0 and lis[2] == 0 :
		print(lis[3])
	else:
		print(-1)
else:
	print(-1)
",O(1)
"class Solution(object):
    def stoneGame(self, piles):
        if len(piles) % 2 == 0 or len(piles) == 1:
            return True

        dp = [0] * len(piles)
        for i in reversed(range(len(piles))):
            dp[i] = piles[i]
            for j in range(i+1, len(piles)):
                dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1])
        return dp[-1] >= 0",O(n ^ 2)
"import sys

pl=1

if pl:
	input=sys.stdin.readline
else:
	sys.stdin=open('input.txt', 'r')
	sys.stdout=open('outpt.txt','w')

def li():
	return [int(xxx) for xxx in input().split()]
def fi():
	return int(input())
def si():
	return list(input().rstrip())
def mi():
	return 	map(int,input().split())

t=1
while t>0:
	t-=1
	n=fi()
	a=li()
	dp=[[0]*(n+1) for i in range(n+1)]
	for i in range(n-1,-1,-1):
		for j in range(i,n):
			if i==j:
				dp[i][j]=a[i]
			elif i==j-1:
				if a[i]==a[j]:
					dp[i][j]=a[i]+1
			else:
				for k in range(i,j):
					if dp[i][k]	and dp[k+1][j] and dp[i][k]==dp[k+1][j]:
						dp[i][j]=dp[i][k]+1
						break
	ans=[10**18]*(n+1)
	ans[-1]=0

	for i in range(n-1,-1,-1):
		for j in range(i,n):
			if dp[i][j]:
				ans[i]=min(ans[i],1+ans[j+1])
			else:
				ans[i]=min(ans[i],j-i+1+ans[j+1])
	print(ans[0])
",O(n ^ 3)
"import sys
import os

def solve(slimes):
    if len(slimes) == 1:
        return slimes[0]

    havePos = False
    haveNeg = False

    for s in slimes:
        if s > 0:
            havePos = True
        elif s < 0:
            haveNeg = True

    if havePos and haveNeg:
        return sum(map(abs, slimes))
    elif not havePos:
        m = max(slimes)
        return sum(list(map(abs, slimes))) + 2 * m
    elif not haveNeg:
        m = min(slimes)
        return sum(list(map(abs, slimes))) - 2 * m
    else:
        return 0

def main():
    n = int(input())
    slimes = list(map(int, input().split()))
    print(solve(slimes))

if __name__ == '__main__':
    main()",O(n)
"import collections


class Solution(object):
    def closeStrings(self, word1, word2):
        if len(word1) != len(word2):
            return False 
        
        cnt1, cnt2 = collections.Counter(word1), collections.Counter(word2)  
        return set(cnt1.keys()) == set(cnt2.keys()) and \
               collections.Counter(iter(cnt1.values())) == collections.Counter(iter(cnt2.values()))",O(n)
"n = int(input())
a = list(input())
smm = 0
for i in range(n):
    a[i] = int(a[i])
    smm += a[i]
ans = ""NO""
sm = smm
for div in range(2, n + 1):
    sm = smm
    if not sm % div:
        sm //= div
        f = 0
        s = 0
        for i in range(n):
            s += a[i]
            if s == sm:
                s = 0
                f += 1
        if f == div:
            ans = ""YES""
            break
print(ans)
",O(n ^ 2)
"import sys
import random

from itertools import permutations, combinations
from math import sqrt, fabs, ceil
from collections import namedtuple

in_file_path = ""input.txt""
output_file_path = ""output.txt""

SUBMIT = True

def read_num(fin, num_type=int):
    tmp_list = [num_type(x) for x in fin.readline().strip().split()]
    if len(tmp_list) == 1:
        return tmp_list[0]
    else:
        return tuple(tmp_list)

def solve(fin):
    T = read_num(fin)
    for _ in range(0, T):
        n, k = read_num(fin)
        if n > 34 or k == 1:
            print('YES', n - 1)
        else:
            f = [0]
            for _ in range(0, n):
                f.append(f[-1] * 4 + 1)
            min_step = 1
            max_step = 1 + f[n - 1]

            out_range = 3
            flag = True
            for i in range(0, n):

                if min_step <= k <= max_step:
                    print('YES', n - i - 1)
                    flag = False
                    break
                max_step += out_range
                min_step += out_range
                out_range = out_range * 2 + 1
                if n - 2 - i >= 0:

                    max_step += (out_range - 2) * f[n - 2 - i]

            if flag:
                print('NO')

if __name__ == '__main__':
    if SUBMIT:
        solve(sys.stdin)
    else:
        solve(open(in_file_path, 'r'))
",O(logn)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def reorderList(self, head):
        if head == None or head.__next__ == None:
            return head

        fast, slow, prev = head, head, None
        while fast != None and fast.__next__ != None:
            fast, slow, prev = fast.next.__next__, slow.__next__, slow
        current, prev.next, prev = slow, None, None

        while current != None:
            current.next, prev, current = prev, current, current.next

        l1, l2 = head, prev
        dummy = ListNode(0)
        current = dummy

        while l1 != None and l2 != None:
            current.next, current, l1 = l1, l1, l1.__next__
            current.next, current, l2 = l2, l2, l2.__next__

        return dummy.__next__",O(n)
"from bisect import bisect_left as bl
from bisect import bisect_right as br
from heapq import heappush,heappop
import math
from collections import *
from functools import reduce,cmp_to_key,lru_cache
import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
import sys

M = mod = 10 ** 9 + 7
def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
def inv_mod(n):return pow(n, mod - 2, mod)

def li():return [int(i) for i in input().rstrip().split()]
def st():return str(input().rstrip())[2:-1]
def val():return int(input().rstrip())
def li2():return [str(i)[2:-1] for i in input().rstrip().split()]
def li3():return [int(i) for i in st()]

n = val()
l = li()
c = li()

element = l[0]
for i in range(1, n):element = math.gcd(element, l[i])

if element != 1:
    print(-1)
    exit()

myset = {}

for ind, i in enumerate(l):
    for j in list(myset):
        temp = math.gcd(j, i)
        if(temp not in myset):myset[temp] = myset[j] + c[ind]
        else:myset[temp] = min(myset[temp], c[ind] + myset[j])

    if i not in myset:myset[i] = c[ind]
    else:myset[i] = min(myset[i], c[ind])

print(myset[1])",np
"n,k = map(int,input().split())

t  = list(map(int,input().split()))

t.sort()

f={}

for j in t:
    if j not in f:
        f[j]=1
    else:
        f[j]+=1

p=0
for j in range(n):
    if j<n-1:
        if t[j+1]>t[j] and t[j]+k >= t[j+1]:
            p+=f[t[j]]

print(n-p)
",O(nlogn)
"n, t = map(int, input().split())

a, v = sorted(list(map(int, input().split())) for i in range(n)), 2

for i in range(n - 1):

    d = 2 * a[i + 1][0] - a[i + 1][1] - 2 * a[i][0] - a[i][1]

    if d > 2 * t:

        v += 2

    elif d == 2 * t:

        v += 1

print(v)",O(nlogn)
"a, b = input().split()
a = int(a)
b = int(b)
s = a ^ b
cnt = 0
while s != 0:
    s = int(s / 2)
    cnt = cnt + 1
print((2 ** cnt) - 1)",O(logn)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def goodNodes(self, root):
        result = 0
        stk = [(root, root.val)]
        while stk:
            node, curr_max = stk.pop()
            if not node:
                continue
            curr_max = max(curr_max, node.val)
            result += int(curr_max <= node.val)
            stk.append((node.right, curr_max))
            stk.append((node.left, curr_max))
        return result",O(n)
"import sys, math
import io, os

from bisect import bisect_left as bl, bisect_right as br, insort
from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var) : sys.stdout.write('\n'.join(map(str, var))+'\n')
def out(var) : sys.stdout.write(str(var)+'\n')
from decimal import Decimal
from fractions import Fraction

INF = float('inf')
mod = int(1e9)+7

from types import GeneratorType

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

@bootstrap
def recur(r,g,b):
    if (r+b+g)==r or (r+b+g)==g or (r+b+g)==b:
        yield 0
        return
    if dp[r][g][b]:
        yield dp[r][g][b]
        return
    if r>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*G[g-1]+(yield recur(r-1,g-1,b)))
    if r>0 and b>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*B[b-1]+(yield recur(r-1,g,b-1)))
    if b>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],B[b-1]*G[g-1]+(yield recur(r,g-1,b-1)))
    yield dp[r][g][b]

r,g,b=mdata()
R=sorted(mdata())
G=sorted(mdata())
B=sorted(mdata())
dp=[[[0]*(b+1) for i in range(g+1)] for i in range(r+1)]
out(recur(r,g,b))
",O(n ^ 3)
"class Solution(object):
    def arrayStringsAreEqual(self, word1, word2):
        idx1 = idx2 = arr_idx1 = arr_idx2 = 0
        while arr_idx1 < len(word1) and arr_idx2 < len(word2):
            if word1[arr_idx1][idx1] != word2[arr_idx2][idx2]:
                break
            idx1 += 1
            if idx1 == len(word1[arr_idx1]):
                idx1 = 0
                arr_idx1 += 1
            idx2 += 1
            if idx2 == len(word2[arr_idx2]):
                idx2 = 0
                arr_idx2 += 1
        return arr_idx1 == len(word1) and arr_idx2 == len(word2)",O(n)
"class Solution(object):
    def maxLevelSum(self, root):
        def dfs(node, i, level_sums):
            if not node:
                return
            if i == len(level_sums):
                level_sums.append(0)
            level_sums[i] += node.val
            dfs(node.left, i+1, level_sums)
            dfs(node.right, i+1, level_sums)

        level_sums = []
        dfs(root, 0, level_sums)
        return level_sums.index(max(level_sums))+1",O(n)
"list_int_input = lambda inp: list(map(int, inp.split()))
int_input = lambda inp: int(inp)
string_to_list_input = lambda inp: list(inp)

n,v=map(int,input().split())
val=v-1+int(((n-v)*(n-v+1))/2)
if n>v:
    print(val)
else:
    print(n-1)",O(1)
"s = input().split(' ')
s1 = s[0]
s2 = s[1]
res = s1[0]
flag = 0
for i in range(1, len(s1)):
    if(s1[i]>=s2[0]):
        res+=s2[0]
        flag = 1
        break
    else:
        res+=s1[i]
if(flag == 0):
    res+=s2[0]
print(res)
",O(n)
"class Solution(object):
    def numDistinct(self, S, T):
        ways = [0 for _ in range(len(T) + 1)]
        ways[0] = 1
        for S_char in S:
            for j, T_char in reversed(list(enumerate(T))):
                if S_char == T_char:
                    ways[j + 1] += ways[j]
        return ways[len(T)]",O(n ^ 2)
"class Solution(object):
    def largeGroupPositions(self, S):
        result = []
        i = 0
        for j in range(len(S)):
            if j == len(S)-1 or S[j] != S[j+1]:
                if j-i+1 >= 3:
                    result.append([i, j])
                i = j+1
        return result",O(n)
"import sys

n, k = [int(i) for i in sys.stdin.readline().split()]

left = 0
right = n - 1

while left <=  right:
    mid = left + (right - left)//2
    fmid = (mid+1)*(mid +2)/2  - (n  - (mid + 1))
    if fmid == k:

        print(n - 1 - mid )
    if fmid > k:
        right = mid - 1
    else:
        left = mid + 1
",O(logn)
"R = lambda: map(int, input().split())

n = int(input())
arr1 = tuple(R())
arr2 = tuple(R())

d = dict()
ans = [0]*n

for i in range(n):
    d[i] = [arr1[i], arr2[i]]

def run():
    for nn in range(n, 0, -1):
        s = list()
        for i in d:
            if d[i][0] == d[i][1] == 0:
                s.append(i)
                ans[i] = nn

        if s:
            for i in s: del d[i]
            for i in d:
                l = r = 0
                for j in s:
                    if j < i:
                        l += 1
                    else:
                        r += 1
                if d[i][0] >= l:
                    d[i][0] -= l
                else:
                    return
                if d[i][1] >= r:
                    d[i][1] -= r
                else:
                    return

        else:
            return

run()

if 0 in ans:
    print('NO')

else:
    print('YES')
    print(*ans, sep=' ')",O(n ^ 2)
"import os, sys, heapq as h, time
from io import BytesIO, IOBase
from types import GeneratorType
from bisect import bisect_left, bisect_right
from collections import defaultdict as dd, deque as dq, Counter as dc
import math, string
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def getInt(): return int(input())
def getStrs(): return input().split()
def getInts(): return list(map(int,input().split()))
def getStr(): return input()
def listStr(): return list(input())
def getMat(n): return [getInts() for _ in range(n)]
def isInt(s): return '0' <= s[0] <= '9'

MOD = 10**9 + 7

squares = set([i*i for i in range(1,4000)])

p = [i for i in range(10**7+1)]
for i in range(1,10**7+1):
    if p[i] == i:
        for sq in squares:
            if i*sq > 10**7: break
            p[i*sq] = i

def solve():
    N, K = getInts()
    A = getInts()
    new = 10**8
    A = [p[A[i]] for i in range(N)]
    dp = [N]*(K+1)
    dp[0] = 0
    used = [set()]*(K+1)
    for i in range(N):
        for j in range(K,-1,-1):
            if dp[j] == N: continue
            if A[i] in used[j]:
                if j < K and dp[j+1] > dp[j]:
                    dp[j+1] = dp[j]
                    used[j+1] = used[j]
                dp[j] += 1
                used[j] = set([A[i]])
            else:
                used[j].add(A[i])
    return min(dp)+1

for _ in range(getInt()):
    print(solve())
",O(n ^ 3)
"class Solution(object):
    def maximumUnits(self, boxTypes, truckSize):
        boxTypes.sort(key=lambda x: x[1], reverse=True)
        result = 0
        for box, units in boxTypes:
            if truckSize > box:
                truckSize -= box
                result += box*units
            else:
                result += truckSize*units
                break
        return result",O(nlogn)
"class Solution(object):
    def isPrefixString(self, s, words):
        i = j = 0
        for c in s:
            if i == len(words) or words[i][j] != c:
                return False 
            j += 1
            if j == len(words[i]):
                i += 1
                j = 0
        return j == 0",O(n)
"def possible(arr):

    a,b,c,d,e,f = arr
    if(a == c == e and b + d + f == a):
        one = ""A"" * b + ""B"" * d + ""C"" * f
        print(a)
        for i in range(a):
            print(one)
        return True
    if(b == d == f and a + c + e == d):
        print(b)
        for i in range(a):
            print(""A"" * b)
        for i in range(c):
            print(""B"" * b)
        for i in range(e):
            print(""C"" * b)
        return True
    ns = [(a,b,""A""),(c,d,""B""),(e,f,""C"")]
    fs = [(b, a,""A""),(d, c,""B""),(f, e,""C"")]
    ns.sort(reverse = True)
    x,y,z = ns
    a,b,t1 = x
    c,d,t2 = y
    e,f,t3 = z
    if(c + e == a and d == f and d + b == a):
        print(a)
        mat = [[""."" for i in range(a)] for j in range(a)]
        for i in range(a):
            for j in range(b):
                mat[i][j] = t1
        for i in range(c):
            for j in range(b, a):
                mat[i][j] = t2
        for  i in range(c, a):
            for j in range(b, a):
                mat[i][j] = t3
        for i in range(a):
            print("""".join(mat[i]))
        return True

    fs.sort(reverse = True)
    x,y,z = fs
    b,a,t1 = x
    d,c,t2 = y
    f,e,t3 = z
    if(d + f == b and c == e and c + a == b):
        print(b)
        mat = [[""."" for i in range(b)] for j in range(b)]
        for i in range(a):
            for j in range(b):
                mat[i][j] =t1
        for i in range(a, b):
            for j in range(d):
                mat[i][j] = t2
        for i in range(a, b):
            for j in range(d, b):
                mat[i][j] = t3
        for i in range(b):
            print("""".join(mat[i]))
        return True
    return False

arr = [int(x) for x in input().split()]
cnt = 0
ok = False
for i in range(8):
    send = [x for x in arr]
    if(i&1):
        send[0], send[1] = send[1], send[0]
    if(i&2):
        send[2], send[3] = send[3], send[2]
    if(i&4):
        send[4], send[5] = send[5], send[4]
    if(possible(send)):
        ok = True
        break
if(not ok):
    print(-1)
",np
"class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        cols = defaultdict(set)
        rows = defaultdict(set)
        squares = defaultdict(set)

        for r in range(9):
            for c in range(9):
                if board[r][c] == ""."":
                    continue
                if ( board[r][c] in rows[r]
                    or board[r][c] in cols[c]
                    or board[r][c] in squares[(r // 3, c // 3)]):
                    return False

                cols[c].add(board[r][c])
                rows[r].add(board[r][c])
                squares[(r // 3, c // 3)].add(board[r][c])

        return True
",O(n ^ 2)
"class Solution(object):
    def distanceTraveled(self, mainTank, additionalTank):
        USE, REFILL, DIST = 5, 1, 10
        cnt = min((mainTank-REFILL)//(USE-REFILL), additionalTank)
        return (mainTank+cnt*REFILL)*DIST",O(1)
"ints=[int(x) for x in input().split()]

n=ints[0]
k=ints[1]
print(int(n-((8*(n+k)+9)**(1/2)-3)/2))",O(logn)
"from itertools import accumulate
from sys import stdin, stdout

def main():
    k = int(stdin.readline())
    a = [
        tuple(map(int, stdin.readline().split()[1:]))
        for _ in range(k)
    ]
    a2ij = {
        aij: (i, j)
        for i, ai in enumerate(a)
        for j, aij in enumerate(ai)
    }

    plena = [0, ] + list(accumulate(map(len, a)))
    suma = tuple(map(sum, a))
    totala = sum(suma)

    if totala % k != 0:
        stdout.write(""No\n"")
    else:
        needle = totala // k
        mask2i2cp = compute_mask2i2cp(a, a2ij, needle, plena, suma)
        dp = compute_previous_mask(mask2i2cp)
        output(dp, mask2i2cp)

def compute_mask2i2cp(a, a2ij, needle, plena, suma):
    used = [False, ] * plena[-1]
    number_of_masks = 1 << len(a)
    mask2i2cp = [-1, ] * number_of_masks

    for i, ai in enumerate(a):
        for j, aij in enumerate(ai):
            if not used[plena[i] + j]:
                mask, i2cp = compute_mask_i2cp(a2ij, aij, i, j, needle, suma)

                if i2cp != -1:
                    mask2i2cp[mask] = i2cp

                    for cp in i2cp:
                        if cp != -1:
                            c, p = cp
                            ii, jj = a2ij[c]
                            used[plena[ii] + jj] = True

    return mask2i2cp

def output(dp, mask2i2cp):
    mask = len(mask2i2cp) - 1

    if dp[mask] == -1:
        stdout.write(""No\n"")
    else:
        answer = [-1, ] * len(mask2i2cp[dp[mask]])

        while mask > 0:
            current_mask = dp[mask]

            for i, cp in enumerate(mask2i2cp[current_mask]):
                if 1 == ((current_mask >> i) & 1):
                    c, p = cp
                    answer[i] = (c, p)

            mask ^= current_mask

        stdout.write('Yes\n' + '\n'.join('{} {}'.format(c, 1 + p) for c, p in answer))

def compute_mask_i2cp(a2ij, aij, i, j, needle, suma):
    i2cp = [-1, ] * len(suma)
    mask = 0
    current_a = aij
    current_i = i

    try:
        while True:
            next_a = needle - (suma[current_i] - current_a)

            next_i, next_j = a2ij[next_a]

            if ((mask >> next_i) & 1) == 1:
                return mask, -1

            mask |= 1 << next_i
            i2cp[next_i] = (next_a, current_i)

            if next_i == i:
                if next_j == j:
                    return mask, i2cp

                return mask, -1

            if next_i == current_i:
                return mask, -1

            current_a = next_a
            current_i = next_i
    except KeyError:
        return mask, -1

def compute_previous_mask(mask2cp):
    number_of_masks = len(mask2cp)
    dp = [-1, ] * number_of_masks
    dp[0] = 0

    for mask, cp in enumerate(mask2cp):
        if cp != -1:
            complement_mask = (number_of_masks - 1) & (~mask)
            previous_mask = complement_mask

            while previous_mask > 0:
                if dp[previous_mask] != -1 and dp[previous_mask | mask] == -1:
                    dp[previous_mask | mask] = mask

                previous_mask = (previous_mask - 1) & complement_mask

            if dp[mask] == -1:
                dp[mask] = mask
    return dp

if __name__ == '__main__':
    main()
",np
"import os
import sys
import time
from io import BytesIO, IOBase

def main():
    max_int = 10 ** 9
    d = ((1, 0), (-1, 0), (0, 1), (0, -1))
    n, m, k = li_input()
    H = []
    for i in range(n):
        H.append(li_input() + [max_int])

    V = []
    for i in range(n - 1):
        V.append(li_input())

    V.append([max_int] * m)

    if k % 2:
        for i in range(n):
            print(' '.join(['-1'] * m))
        return

    k //= 2

    DP0 = [[0] * (m + 1) for _ in range(n + 1)]
    DP1 = [[0] * (m + 1) for _ in range(n + 1)]

    for kk in range(k):
        for i in range(n):
            for j in range(m):
                l = DP0[i][j - 1] + H[i][j - 1]
                r = DP0[i][j + 1] + H[i][j]
                u = DP0[i - 1][j] + V[i - 1][j]
                d = DP0[i + 1][j] + V[i][j]
                DP1[i][j] = min(l, r, u, d)

        DP0, DP1 = DP1, DP0

    O = []
    for row in DP0[:-1]:
        O.append(' '.join((str(n * 2) for n in row[:-1])))

    print('\n'.join(O))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

def print(*args, **kwargs):

    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input():
    return sys.stdin.readline().rstrip(""\r\n"")

def i_input():
    return int(input())

def l_input():
    return input().split()

def li_input():
    return list(map(int, l_input()))

def il_input():
    return list(map(int, l_input()))

if __name__ == ""__main__"":
    TT = time.time()
    main()
",O(n ^ 3)
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

INF=999999999999999999999999
alphabets=""abcdefghijklmnopqrstuvwxyz""
class SortedList:
    def __init__(self, iterable=[], _load=200):

        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):

        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):

        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):

        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):

        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):

        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):

        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):

        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):

        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):

        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):

        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):

        return self._len

    def __getitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):

        return (value for _list in self._lists for value in _list)

    def __reversed__(self):

        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):

        return 'SortedList({0})'.format(list(self))

class SegTree:

    def __init__(self, n):
        self.N = 1 << n.bit_length()
        self.tree = [0] * (self.N<<1)

    def update(self, i, j, v):
        i += self.N
        j += self.N
        while i <= j:
            if i%2==1: self.tree[i] += v
            if j%2==0: self.tree[j] += v
            i, j = (i+1) >> 1, (j-1) >> 1

    def query(self, i):
        v = 0
        i += self.N
        while i > 0:
            v += self.tree[i]
            i >>= 1
        return v

def SieveOfEratosthenes(limit):

    isPrime = [True]*(limit+1)
    isPrime[0] = isPrime[1] = False
    primes = []
    for i in range(2, limit+1):
        if not isPrime[i]:continue
        primes += [i]
        for j in range(i*i, limit+1, i):
            isPrime[j] = False
    return primes

def main():

    mod=1000000007

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc = 1
    for _ in range(tc):
        a,b=ria()
        op=0
        while True:
            if b:
                op+=a//b
                a%=b
                a,b=b,a
            else:
                break
        wi(op)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(1)
"from math import sqrt
n, k = map(int, input().split())
print(int(n - 0.5 * (sqrt(8 * (k + n) + 9) - 3)))
",O(1)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a+b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

prime = [True for i in range(10)]
pp=[0]*10
def SieveOfEratosthenes(n=10):
    p = 2
    c=0
    while (p * p <= n):

        if (prime[p] == True):
            c+=1
            for i in range(p, n+1, p):
                pp[i]+=1
                prime[i] = False
        p += 1

def binarySearch(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=0
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid][0] > key):
            right = mid-1
        else:
            res=mid
            left = mid + 1
    return res

n,m,k=map(int,input().split())
r=[]
for i in range (n):
    a=list(map(int,input().split()))
    r.append(a)
c=[]
for i in range (n-1):
    a=list(map(int,input().split()))
    c.append(a)
if k%2:
    a=[-1]*m
    for i in range (n):
        print(*a)
    sys.exit(0)
dp=[[[0 for i in range ((k//2)+1)]for j in range (m)]for p in range (n)]
for x in range (1,(k//2)+1):
    for i in range (n):
        for j in range (m):
            mn=10**8
            if i>0:
                mn=min(mn,c[i-1][j]+dp[i-1][j][x-1])
            if j>0:
                mn=min(mn,r[i][j-1]+dp[i][j-1][x-1])
            if i<n-1:
                mn=min(mn,c[i][j]+dp[i+1][j][x-1])
            if j<m-1:
                mn=min(mn,r[i][j]+dp[i][j+1][x-1])
            dp[i][j][x]=mn
for i in range (n):
    for j in range (m):
        print(2*dp[i][j][k//2],end=' ')
    print()",O(n ^ 3)
"class Solution(object):
    def xorQueries(self, arr, queries):
        for i in range(1, len(arr)):
            arr[i] ^= arr[i-1]
        return [arr[right] ^ arr[left-1] if left else arr[right] for left, right in queries]",O(n)
"n=int(input())

l=list(map(int,input().split()))
r=list(map(int,input().split()))

a=[[l[i]+r[i],i] for i in range(n)]
a.sort()

candies=[0 for i in range(n)]

if(a[0][0] != 0):

    print('NO')
    exit()
else:
    candies[a[0][1]] = n - a[0][0]

for i in range(1,n):
    if(a[i][0] != a[i-1][0] and a[i][0]!=i):
        print('NO')

        exit()

    candies[a[i][1]] = n - a[i][0]

for i in range(n):
    l1=0
    r1=0
    for j in range(i):
        if(candies[j]>candies[i]):
            l1+=1
    for j in range(i+1,n):
        if(candies[j]>candies[i]):
            r1+=1

    if(l1 != l[i] or r1 != r[i]):
        print('NO')
        exit()
print('YES')
print(*candies)
",O(n ^ 2)
"class Solution2(object):
    def clearDigits(self, s):
        result = []
        for x in s:
            if x.isdigit():
                result.pop()
                continue
            result.append(x)
        return """".join(result)",O(n)
"class Point:

    def __init__(self, x, y):
        self.x = x
        self.y = y

class Vector:

    def __init__(self, start, end):
        self.x = end.x - start.x
        self.y = end.y - start.y

    def mult(self, a):
        return self.y * a.x - self.x * a.y

n = int(input())
points = []
for i in range(n):
    x, y = map(int, input().split())
    points.append(Point(x, y))

if n <= 3:
    print('YES')
    exit()

def onLine(points):
    n = len(points)
    if n < 3:
        return True
    a = Vector(points[0], points[1])
    for i in range(2, n):
        b = Vector(points[0], points[i])
        if a.mult(b) != 0:
            return False
    return True

tmp = [points[0], points[1]]
oth = []
for i in range(2, n):
    tmp.append(points[i])
    if not onLine(tmp):
        oth.append(points[i])
    tmp.pop()
if onLine(oth):
    print('YES')
    exit()

tmp = [points[0], points[2]]
oth = []
for i in range(1, n):
    if i == 2:
        continue
    tmp.append(points[i])
    if not onLine(tmp):
        oth.append(points[i])
    tmp.pop()
if onLine(oth):
    print('YES')
    exit()

tmp = [points[1], points[2]]
oth = []
for i in range(0, n):
    if i == 2 or i == 1:
        continue
    tmp.append(points[i])
    if not onLine(tmp):
        oth.append(points[i])
    tmp.pop()
if onLine(oth):
    print('YES')
    exit()

print('NO')
",O(nlogn)
"class Solution2(object):
    def minimumSubarrayLength(self, nums, k):
        result = float(""inf"")
        for left in range(len(nums)):
            curr = 0
            for right in range(left, len(nums)):
                curr |= nums[right]
                if curr < k:
                    continue
                result = min(result, right-left+1)
                break
        return result if result != float(""inf"") else -1",O(n ^ 2)
"import os
import sys
from math import *
from collections import *

from bisect import *
from io import BytesIO, IOBase

def vsInput():
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA = ""abcdefghijklmnopqrstuvwxyz/""
M = 1000000007
EPS = 1e-6

def Ceil(a, b):
    return a // b + int(a % b > 0)

def value():
    return tuple(map(int, input().split()))

def array():
    return [int(i) for i in input().split()]

def Int():
    return int(input())

def Str():
    return input()

def arrayS():
    return [i for i in input().split()]

n=int(input())
a=list(map(int,input().split("" "")))
dic=defaultdict(lambda:0)
cursum=0
ans=0
for i in range(n):
    ele=a[i]
    if ele-1 in dic.keys() and ele+1 in dic.keys():
        ans+=ele*(i-dic[ele-1]-dic[ele+1])-(cursum-(dic[ele-1]*(ele-1)+dic[ele+1]*(ele+1)))
    elif ele-1 in dic.keys():
        ans+=ele*(i-dic[ele-1])-(cursum-(dic[ele-1]*(ele-1)))
    elif ele+1 in dic.keys():
        ans+=ele*(i-dic[ele+1])-(cursum-(dic[ele+1]*(ele+1)))
    else:
        ans+=(ele*i-cursum)
    dic[ele]+=1
    cursum+=ele
print(ans)
",O(nlogn)
"import math
import heapq, bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
mod = 10 ** 9 + 7
mod1 = 998244353

import os
import sys
from io import BytesIO, IOBase
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a + b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m

def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z

def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por

def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        if (arr[mid] < key):
            count = mid + 1
            left = mid + 1

        else:
            right = mid - 1

    return count

def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    leftGreater = n

    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        else:
            l = m + 1

    return (n - leftGreater)

n,m=map(int,input().split())
l=[]
tot=[]
done=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    l.append(input())
colsum=[[0 for i in range(m)]for j in range(n)]
rowsum=[[0 for i in range(m)]for j in range(n)]
col=[[0 for i in range(m)]for j in range(n)]
row=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            rowsum[i][j]=1
            colsum[i][j]=1
            row[i][j]=1
            col[i][j]=1
for i in range(n):
    for j in range(1,m):
        if l[i][j]=='.':
            continue
        rowsum[i][j]+=rowsum[i][j-1]
for i in range(n):
    for j in range(m-2,-1,-1):
        if l[i][j]=='.':
            continue
        row[i][j]+=row[i][j+1]
for i in range(m):
    for j in range(n-2,-1,-1):
        if l[j][i]=='.':
            continue
        col[j][i]+=col[j+1][i]
for i in range(m):
    for j in range(1,n):
        if l[j][i]=='.':
            continue
        colsum[j][i]+=colsum[j-1][i]
def check(x,y):
    i=x
    j=y
    ans=min(row[i][j],rowsum[i][j],colsum[i][j],col[i][j])-1
    if ans==0:
        return []
    return [ans]
h=[[0 for i in range(m+1)]for j in range(n)]
v=[[0 for i in range(m)]for j in range(n+1)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            ans=check(i,j)
            for j1 in ans:
                tot.append([i+1,j+1,j1])
                h[i][j-j1]+=1
                h[i][j+j1+1]-=1
                v[i-j1][j]+=1
                v[i+j1+1][j]-=1
for i in range(n):
    for j in range(1,m):
        h[i][j]+=h[i][j-1]
for i in range(m):
    for j in range(1,n):
        v[j][i]+=v[j-1][i]

for i in range(n):
    for j in range(m):
        if l[i][j]=='*' and h[i][j]==0 and v[i][j]==0:
            print(-1)
            sys.exit(0)
print(len(tot))
for i in tot:
    print(*i)
",O(n ^ 2)
"class Solution(object):
    def getPermutationIndex(self, perm):
        MOD = 10**9+7
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = (self.__bit[i]+val) % MOD
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret = (ret+self.__bit[i]) % MOD
                    i -= (i & -i)
                return ret

        fact = [0]*len(perm)
        fact[0] = 1
        for i in range(len(fact)-1):
            fact[i+1] = ((i+1)*fact[i])%MOD
        result = 0
        bit = BIT(len(perm))
        for i, x in enumerate(perm):
            result = (result+(((((x-1)-bit.query((x-1)-1))%MOD)*fact[(len(perm)-1)-i])%MOD))%MOD
            bit.add(x-1, +1)
        return result",O(nlogn)
"a,b,c,n=list(map(int,input().split()))
p=(a+b-c)
f=n-p
if p>=n or c>a or c>b:
	print(""-1"")
else:
	print(f)",O(1)
"class Solution(object):
    def minimumSteps(self, s):
        result = left = 0
        for right in range(len(s)):
            if s[right] != '0':
                continue
            result += right-left
            left += 1
        return result",O(n)
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key=lambda x: x[1])
        n = len(intervals)
        dp = [0] * n
        dp[0] = 1

        def bs(r, target):
            l = 0
            while l < r:
                m = (l + r) >> 1
                if intervals[m][1] <= target:
                    l = m + 1
                else:
                    r = m
            return l

        for i in range(1, n):
            idx = bs(i, intervals[i][0])
            if idx == 0:
                dp[i] = dp[i - 1]
            else:
                dp[i] = max(dp[i - 1], 1 + dp[idx - 1])
        return n - dp[n - 1]
",O(nlogn)
"class Solution(object):
    def checkPowersOfThree(self, n):
        while n > 0:
            if n%3 == 2:
                return False
            n //= 3
        return True",O(logn)
"n,k = map(int,input().split())

for puts in range(10**9):
    candy = puts*(puts+1)//2
    if candy - (n-puts) == k:
        print(n-puts)
        exit(0)
",O(n)
"from sys import *
n = int(stdin.readline())
ans = 0
for i in range(2,n+1):
    for j in range(i*2,n+1,i):
        ans += 4 * (j // i)
print(ans)
",O(nlogn)
"import collections
import functools



class Node(object):
    def __init__(self, val="" "", left=None, right=None):
        pass



class Solution(object):
    def checkEquivalence(self, root1, root2):
        def add_counter(counter, prev, d, val):
            if val.isalpha():
                counter[ord(val)-ord('a')] += d if prev[0] == '+' else -d
            prev[0] = val
    
        def morris_inorder_traversal(root, cb):
            curr = root
            while curr:
                if curr.left is None:
                    cb(curr.val)
                    curr = curr.right
                else:
                    node = curr.left
                    while node.right and node.right != curr:
                        node = node.right
                    if node.right is None:
                        node.right = curr
                        curr = curr.left
                    else:
                        cb(curr.val)
                        node.right = None
                        curr = curr.right

        counter = collections.defaultdict(int)
        morris_inorder_traversal(root1, functools.partial(add_counter, counter, ['+'], 1))
        morris_inorder_traversal(root2, functools.partial(add_counter, counter, ['+'], -1))
        return all(v == 0 for v in counter.values())",O(n)
"from collections import defaultdict
import sys
input = sys.stdin.readline

n, k = map(int, input().split())
a = list(map(int, input().rstrip().split()))
cnt = [defaultdict(lambda : 0) for _ in range(11)]
for i in a:
    cnt[len(str(i))][i % k] += 1
ans = 0
d = 10
for i in range(1, 11):
    cnti = cnt[i]
    for j in a:
        ans += cnti[(k - d * j) % k]
    d *= 10
for i in a:
    if not int(str(i) * 2) % k:
        ans -= 1
print(ans)",O(nlogn)
"class Solution(object):
    def findIndices(self, nums, indexDifference, valueDifference):
        mx_i = mn_i = 0
        for i in range(len(nums)-indexDifference):
            if nums[i] > nums[mx_i]:
                mx_i = i
            elif nums[i] < nums[mn_i]:
                mn_i = i
            if nums[mx_i]-nums[i+indexDifference] >= valueDifference:
                return [mx_i, i+indexDifference]
            if nums[i+indexDifference]-nums[mn_i] >= valueDifference:
                return [mn_i, i+indexDifference]
        return [-1]*2",O(n)
"import collections


class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def minMalwareSpread(self, graph, initial):
        initial_set = set(initial)
        clean = [i for i in range(len(graph)) if i not in initial_set]
        union_find = UnionFind(len(graph))
        for i in range(len(clean)):
            for j in range(i+1, len(clean)):
                if graph[clean[i]][clean[j]] == 1:
                    union_find.union_set(clean[i], clean[j])
        union_size = collections.Counter(union_find.find_set(i) for i in range(len(graph)))
        
        shared_union = collections.defaultdict(set)
        for i in initial:
            for j in clean:                  
                if graph[i][j] == 1:
                    x = union_find.find_set(j)
                    shared_union[x].add(i)

        result, total = float(""inf""), float(""-inf"")
        for i in initial:
            lookup = set()
            curr = 0
            for j in clean:                  
                if graph[i][j] == 1:
                    x = union_find.find_set(j)
                    if len(shared_union[x]) == 1 and \
                       x not in lookup:
                        curr += union_size[x]
                        lookup.add(x)
            if curr > total or \
               (curr == total and i < result):
                total = curr
                result = i
        return result",O(n ^ 2)
"import random



class Solution2(object):
    def kthLargestPerfectSubtree(self, root, k):
        def nth_element(nums, left, n, right, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target):
                i = left
                while i <= right:
                    if compare(nums[i], target):
                        nums[i], nums[left] = nums[left], nums[i]
                        left += 1
                        i += 1
                    elif compare(target, nums[i]):
                        nums[i], nums[right] = nums[right], nums[i]
                        right -= 1
                    else:
                        i += 1
                return left, right

            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx])
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def dfs(curr):
            if not curr:
                result.append(0)
                return
            dfs(curr.left)
            left = result[-1]
            dfs(curr.right)
            right = result[-1]
            result.append(left+right+1 if left == right != -1 else -1)

        result = []
        dfs(root)
        nth_element(result, 0, k-1, len(result)-1, lambda a, b: a > b)
        return result[k-1] if k-1 < len(result) and result[k-1] > 0 else -1",O(n)
"import collections


class Solution(object):
    def frequencySort(self, s):
        freq = collections.defaultdict(int)
        for c in s:
            freq[c] += 1

        counts = [""""] * (len(s)+1)
        for c in freq:
            counts[freq[c]] += c

        result = """"
        for count in reversed(range(len(counts)-1)):
            for c in counts[count]:
                result += c * count

        return result",O(n)
"N, MOD = map(int, input().split())
dp = [[0]*(N+2) for i in range(N+2)]
dp[0][0] = 1
limit = 1000
frac = [1]*limit
for i in range(2,limit):
    frac[i] = i * frac[i-1]%MOD
fraci = [None]*limit
fraci[-1] = pow(frac[-1], MOD -2, MOD)
for i in range(-2, -limit-1, -1):
    fraci[i] = fraci[i+1] * (limit + i + 1) % MOD
bb = [1, 2]
for i in range(1000):
    bb.append(bb[-1] *2 %MOD)
for ln in range(N+1):
    for cnt in range(ln//2, ln+1):
        for k in range(1, N-ln+1):
            cmb = frac[cnt+k] * (fraci[cnt]*fraci[k]%MOD)%MOD
            dp[ln+k+1][cnt+k] += dp[ln][cnt] * (bb[k-1] * cmb % MOD) %MOD
            dp[ln+k+1][cnt+k] %= MOD
R = 0
for x in dp[N+1][:N+1]:
    R = (R+x)%MOD
print(R)
",O(n ^ 3)
"import collections



class Solution2(object):
    def maximumRobots(self, chargeTimes, runningCosts, budget):
        result = left = curr = 0
        dq = collections.deque()
        for right in range(len(chargeTimes)):
            while dq and chargeTimes[dq[-1]] <= chargeTimes[right]:
                dq.pop()
            dq.append(right)
            curr += runningCosts[right]
            while dq and chargeTimes[dq[0]]+(right-left+1)*curr > budget:
                if dq[0] == left:
                    dq.popleft()
                curr -= runningCosts[left]
                left += 1
            result = max(result, right-left+1)            
        return result",O(n)
"class Solution(object):
    def subtractProductAndSum(self, n):
        product, total = 1, 0
        while n:
            n, r = divmod(n, 10)
            product *= r
            total += r
        return product-total",O(logn)
"import sys
from collections import defaultdict as dd

mod=10**9+7

def ri(flag=0):
	if flag==0:
		return [int(i) for i in sys.stdin.readline().split()]
	else:
		return int(sys.stdin.readline())

for _ in range(int(input())):
	n,k = ri()
	a = input()
	rgb= [0 for i in range(n)]
	gbr= [0 for i in range(n)]
	brg= [0 for i in range(n)]

	for i in range(n):
		if i%3==0:
			if a[i]!=""R"":
				rgb[i]+=1
		if i%3==1:
			if a[i]!=""G"":
				rgb[i]+=1
		if i%3==2:
			if a[i]!=""B"":
				rgb[i]+=1

	for i in range(n):
		if i%3==0:
			if a[i]!=""G"":
				gbr[i]+=1
		if i%3==1:
			if a[i]!=""B"":
				gbr[i]+=1
		if i%3==2:
			if a[i]!=""R"":
				gbr[i]+=1

	for i in range(n):
		if i%3==0:
			if a[i]!=""B"":
				brg[i]+=1
		if i%3==1:
			if a[i]!=""R"":
				brg[i]+=1
		if i%3==2:
			if a[i]!=""G"":
				brg[i]+=1

	for i in range(1,n):
		rgb[i]+=rgb[i-1]
		brg[i]+=brg[i-1]
		gbr[i]+=gbr[i-1]

	ans = 999999999

	for i in range(k-1,n):

		if i-k ==-1:
			ans = min(ans,rgb[i],gbr[i],brg[i])
		else:
			ans = min(ans, rgb[i]- rgb[i-k] , gbr[i]- gbr[i-k], brg[i]- brg[i-k] )

	print(ans)
",O(n)
"import os,sys
from io import BytesIO,IOBase

def main():
    mod = 10**9+7
    n,T = map(int,input().split())
    y = 1<<n
    dp = [[0]*3 for _ in range(y)]

    peo = [list(map(int,input().split())) for _ in range(n)]

    for ind,i in enumerate(peo):
        peo[ind][1] -= 1
        dp[1<<ind][i[1]] = 1
    for i in range(y):
        for j in range(3):
            if not dp[i][j]:
                continue
            mask = 1
            for k in range(n):
                if i&mask or peo[k][1] == j:
                    mask <<= 1
                    continue
                dp[i|mask][peo[k][1]] = (dp[i|mask][peo[k][1]]+dp[i][j])%mod
                mask <<= 1
    ans = 0
    for i in range(y):
        ans1,mask = 0,1
        for j in range(n):
            if i&mask:
                ans1 += peo[j][0]
            mask <<= 1
        if ans1 == T:
            ans = (ans+sum(dp[i]))%mod
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",np
"n=int(input());print('4 '+str(n-4) if n%2==0 else '9 '+str(n-9))
",O(1)
"class Solution(object):
    def minIncrementForUnique(self, A):
        A.sort()
        A.append(float(""inf""))
        result, duplicate = 0, 0
        for i in range(1, len(A)):
            if A[i-1] == A[i]:
                duplicate += 1
                result -= A[i]
            else:
                move = min(duplicate, A[i]-A[i-1]-1)
                duplicate -= move
                result += move*A[i-1] + move*(move+1)//2
        return result",O(nlogn)
"import sys
n,a,b = list(map(int, input().split()))

if a>1 and b>1:
	print('NO')
	sys.exit(0)

if n==3 and a==1 and b==1:
	print('NO')
	sys.exit(0)

if n==2 and a==1 and b==1:
	print('NO')
	sys.exit(0)

t = [[0 for i in range(n)] for j in range(n)]

comp = max(a,b)

for i in range(comp-1, n-1):
	t[i][i+1] = 1
	t[i+1][i] = 1

if b>1:
	for i in range(n):
		for j in range(n):
			if i!=j:
				t[i][j] = 1-t[i][j]
print('YES')
for i in range(n):
	print("""".join(map(str, t[i])))
",O(n ^ 2)
"n,m,k=map(int,input().split())
list1=list(map(int,input().split()))
list1.sort(reverse=True)
c=0
i=0

while(k<m and i<n):
    k+=list1[i]-1
    i+=1
    c+=1
if(k>=m):
    print(c)
else:
    print(-1)",O(nlogn)
"class Solution2(object):
    def largestValues(self, root):
        result = []
        curr = [root]
        while any(curr):
            result.append(max(node.val for node in curr))
            curr = [child for node in curr for child in (node.left, node.right) if child]
        return result",O(n)
"n, s = map(int, input().split())
def really_big(ni, s):
    dig_sum = sum(list(map(int, list(str(ni)))))
    return (ni-dig_sum)>=s
cont = 0
for i in range(s, n+1):
    if really_big(i, s):
        cont = n-i+1
        break
print(cont)",O(logn)
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        res = 0
        for i in range(len(prices)):
            buy = prices[i]
            for j in range(i + 1, len(prices)):
                sell  = prices[j]
                res = max(res, sell - buy)
        return res
",O(n ^ 2)
"class Solution(object):
    def reverseVowels(self, s):
        vowels = ""aeiou""
        string = list(s)
        i, j = 0, len(s) - 1
        while i < j:
            if string[i].lower() not in vowels:
                i += 1
            elif string[j].lower() not in vowels:
                j -= 1
            else:
                string[i], string[j] = string[j], string[i]
                i += 1
                j -= 1
        return """".join(string)",O(n)
"from sys import stdin, stdout
n,m,k = [int(x) for x in stdin.readline().rstrip().split()]
L = [int(x) for x in stdin.readline().rstrip().split()]
off=1
page=-1
c=0
ans=0
for l in L:
    p=(l-off)//k
    if p==page:
        c+=1
    else:
        off+=c
        c=1
        ans+=1
        page=(l-off)//k

stdout.write( str(ans) + ""\n"" )",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import factorial
from collections import Counter, defaultdict
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
def ctd(chr): return ord(chr)-ord(""a"")
mod = 998244353
INF = float('inf')

from math import gcd

def main():
    n = N()
    larr = RLL()
    carr = RLL()

    dic = {}
    dic[0] = 0

    for i in range(n):
        l, c = larr[i], carr[i]
        ndic = dic.copy()
        for j in dic:
            now = gcd(j, l)
            if now not in ndic:
                ndic[now] = c+dic[j]
            else:
                ndic[now] = min(ndic[now], dic[j]+c)
        dic = ndic

    print(dic.get(1, -1))

if __name__ == ""__main__"":
    main()
",np
"class Solution(object):
    def twoSum(self, nums, target):
        lookup = {}
        for i, num in enumerate(nums):
            if target - num in lookup:
                return [lookup[target - num], i]
            lookup[num] = i

    def twoSum2(self, nums, target):
        for i in nums:
            j = target - i
            tmp_nums_start_index = nums.index(i) + 1
            tmp_nums = nums[tmp_nums_start_index:]
            if j in tmp_nums:
                return [nums.index(i), tmp_nums_start_index + tmp_nums.index(j)]",O(n)
"def read_int():
    return int(raw_input().strip())

def read_ints():
    return list(map(int, raw_input().strip().split(' ')))

def solve():

    R, G, B = read_ints()
    dp = [[[0 for _ in range(B+1)] for _ in range(G+1)] for _ in range(R+1)]

    Rs = read_ints()
    Gs = read_ints()
    Bs = read_ints()
    Rs.sort(reverse=True)
    Gs.sort(reverse=True)
    Bs.sort(reverse=True)
    answer = 0
    for r in range(R+1):
        for g in range(G+1):
            for b in range(B+1):
                if r > 0 and g > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g-1][b]+Rs[r-1]*Gs[g-1])
                if g > 0 and b > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r][g-1][b-1]+Gs[g-1]*Bs[b-1])
                if r > 0 and b > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g][b-1]+Rs[r-1]*Bs[b-1])
                answer = max(answer, dp[r][g][b])
    return answer

if __name__ == '__main__':
    print(solve())
",O(n ^ 3)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

for _ in range(ii()):
    l, r = mi()
    l -= 1
    sr = r // 2 + (r % 2) * -r
    sl = l // 2 + (l % 2) * -l
    print(sr - sl)",O(1)
"class Solution:
    def hammingWeight(self, n: int) -> int:
        res = 0
        while n:
            res += 1 if n & 1 else 0
            n >>= 1
        return res
",O(1)
"class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        nodes = []
        for lst in lists:
            while lst:
                nodes.append(lst.val)
                lst = lst.next
        nodes.sort()

        res = ListNode(0)
        cur = res
        for node in nodes:
            cur.next = ListNode(node)
            cur = cur.next
        return res.next
",O(nlogn)
"arr1=str(input())
arr2=str(input())
arr1=arr1.encode()
arr2=arr2.encode()
arr1=bytearray(arr1)
arr2=bytearray(arr2)
n, tot=len(arr1), 0
for i in range(n-1):
	if arr1[i]==48 and arr1[i+1]==48 and arr2[i]==48:
		tot+=1
		arr1[i]=49
		arr1[i+1]=49
		arr2[i]=49
	elif arr1[i]==48 and arr2[i]==48 and arr2[i+1]==48:
		tot+=1
		arr1[i]=49
		arr2[i]=49
		arr2[i+1]=49
	elif arr2[i]==48 and arr2[i+1]==48 and arr1[i+1]==48:
		tot+=1
		arr2[i]=49
		arr2[i+1]=49
		arr1[i+1]=49
	elif arr1[i]==48 and arr1[i+1]==48 and arr2[i+1]==48:
		tot+=1
		arr1[i]=49
		arr1[i+1]=49
		arr2[i+1]=49
print(tot)",O(1)
"n, m, a, b = map(int, input().split())
print(min(n%m*b, (m-n%m)*a))
",O(n)
"p = [int(x) + 100 for x in input().strip().split()]
d = [int(x) + 100 for x in input().strip().split()]

minx = min(p[::2])
maxx = max(p[::2])
miny = min(p[1::2])
maxy = max(p[1::2])

grid = [[False] * 201 for _ in range(201)]
for x in range(minx, maxx+1):
    for y in range(miny, maxy+1):
        grid[x][y] = True

minx = min(d[::2])
maxx = max(d[::2])
avgx = sum(d[::2]) // 4
avgy = sum(d[1::2]) // 4
span = (maxx - minx) // 2

for x in range(minx, maxx+1):
    height = span - abs(x - avgx)
    for y in range(avgy - height, avgy + height + 1):
        if grid[x][y]:
            print('YES')
            exit()

print('NO')
",O(1)
"class Solution(object):
    def sumOfGoodNumbers(self, nums, k):
        return sum(nums[i] for i in range(len(nums)) if (i-k < 0 or nums[i-k] < nums[i]) and (i+k >= len(nums) or nums[i+k] < nums[i]))",O(n)
"class Solution(object):
    def triangleNumber(self, nums):
        result = 0
        nums.sort()
        for i in reversed(range(2, len(nums))):
            left, right = 0, i-1
            while left < right:
                if nums[left]+nums[right] > nums[i]:
                    result += right-left
                    right -= 1
                else:
                    left += 1
        return result",O(n ^ 2)
"import sys
input = sys.stdin.readline

RI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]
rw = lambda : input().strip().split()
from collections import defaultdict as df

import random

infinite = float('inf')

t=int(input())

for _ in range(t):
    n,k=RI()
    s=input()

    mini=n

    test=""RGB""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    test=""GBR""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    test=""BRG""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    print(mini)
",O(n ^ 2)
"import sys
input=sys.stdin.buffer.readline

nr,ng,nb=[int(x) for x in input().split()]
r=[int(x) for x in input().split()]
g=[int(x) for x in input().split()]
b=[int(x) for x in input().split()]

r.sort()
g.sort()
b.sort()

memo=[[[-1 for _ in range(nb+1)] for __ in range(ng+1)] for ___ in range(nr+1)]
memo[0][0][0]=0
for i in range(nr):
    memo[i+1][0][0]=0
for j in range(ng):
    memo[0][j+1][0]=0
for k in range(nb):
    memo[0][0][k+1]=0
def dp(i,j,k):
    if i<-1 or j<-1 or k<-1:
        return -float('inf')
    if memo[i+1][j+1][k+1]==-1:
        memo[i+1][j+1][k+1]=max(dp(i,j-1,k-1)+g[j]*b[k],
                   dp(i-1,j-1,k)+r[i]*g[j],
                   dp(i-1,j,k-1)+r[i]*b[k]
                )
    return memo[i+1][j+1][k+1]

print(dp(nr-1,ng-1,nb-1))",O(n ^ 3)
"import sys
from math import floor

if __name__ == '__main__':

    entrada = input()
    entrada_str = list(entrada.split("" ""))
    entrada_int = list(map(int, entrada_str))

    a = entrada_int[0]
    b = entrada_int[1]

    if a == b:
        print(0)
        sys.exit()

    string_1 = """"
    string_2 = """"
    while a:
        if a%2 == 0:
            string_1 = string_1 + ""0""
        else:
            string_1 = string_1 + ""1""
        a = floor(a/2)

    while b:
        if b%2 == 0:
            string_2 = string_2 + ""0""
        else:
            string_2 = string_2 + ""1""
        b = floor(b/2)

    lista_1 = list(string_1)
    lista_1.reverse()
    contrario_1 = """".join(lista_1)

    lista_2 = list(string_2)
    lista_2.reverse()
    contrario_2 = """".join(lista_2)

    if len(string_1) != len(string_2):
        resposta = pow(2, len(string_2)) - 1
    else:
        potencia = 0
        for i in range(len(string_1)):
            if contrario_1[i] != contrario_2[i]:
                break
            potencia += 1

        potencia = len(string_1) - potencia
        resposta = pow(2, potencia)-1

    print(resposta)
",O(logn)
"import collections


class Solution(object):
    def countKDifference(self, nums, k):
        lookup = collections.defaultdict(int)
        result = 0
        for x in nums:
            if x-k in lookup:
                result += lookup[x-k]
            if x+k in lookup:
                result += lookup[x+k]
            lookup[x] += 1            
        return result",O(n)
"import sys

def ask(c, d):
    print(""? {} {}"".format(c, d))
    return int(input())

c = d = 0

def solve(mi, base):
    def solve_same():
        global c, d
        print(""
        for i in range(mi, -1, -1):
            print(f"">> {i=} {c=} {d=}"", file=sys.stderr)
            bit = 1 << i
            res1 = ask(c ^ bit, d)
            res2 = ask(c, d ^ bit)
            if res1 == -1 and res2 == 1:
                c |= bit
                d |= bit

    def solve1():
        global c, d
        print(""
        for i in range(mi, -1, -1):
            print(f"">> {i=} {c=} {d=}"", file=sys.stderr)
            bit = 1 << i
            res1 = ask(c ^ bit, d ^ bit)
            if res1 == -1:

                c |= bit
                return solve(i - 1, ask(c, d))
            else:

                res2 = ask(c ^ bit, d)
                if res2 == -1:

                    c |= bit
                    d |= bit

    def solve2():
        global c, d
        print(""
        for i in range(mi, -1, -1):
            print(f"">> {i=} {c=} {d=}"", file=sys.stderr)
            bit = 1 << i
            res1 = ask(c ^ bit, d ^ bit)
            if res1 == 1:

                d |= bit
                return solve(i - 1, ask(c, d))
            else:

                res2 = ask(c, d ^ bit)
                if res2 == 1:

                    c |= bit
                    d |= bit

    if base == 0:
        solve_same()
    elif base == 1:
        solve1()
    else:
        solve2()

solve(29, ask(0, 0))
print(""! {} {}"".format(c, d))
",O(1)
"n=int(input())
a=sorted([int(x) for x in input().split()])
counter=0
test=[False]*n
for j in range(n):
    if not test[j]:
        for i in range(n):
            if not test[i] and a[i]%a[j]==0:
                test[i]=True
        counter+=1
print(counter)
",O(n ^ 2)
"from math import *
from cmath import *
from itertools import *
from decimal import *
from fractions import *
from sys import *
from types import CodeType, new_class

n, m = map(int, (input().split()))
a = [int(x) for x in input().split()]
b = [int(x) for x in input().split()]
for x in a:
    if x in b:
        print(x, end = ' ')",O(n ^ 2)
"from sys import stdin, stdout

def check(k, b, T):
	c = [e for e in b if e[0] >= k]

	if len(c) < k:
		return False, None

	first_k_probs = c[:k]
	s = sum([e[1] for e in first_k_probs])

	if s > T:
		return False, None

	return True, first_k_probs

def solve(n, T, a, t):
	b = []

	for i in range(n):
		b.append((a[i], t[i], i + 1))

	b.sort(key=lambda x: x[1])

	low, high = 0, n
	result = 0
	final_probs = []

	while low <= high:
		mid = (low + high) // 2

		(possible, probs) = check(mid, b, T)
		if possible:
			result, final_probs = mid, probs
			low = mid + 1
		else:
			high = mid - 1

	return (result, [e[2] for e in final_probs])

n, T = (int(x) for x in stdin.readline().split())

a = [0] * n
t = [0] * n

for i in range(n):
	a[i], t[i] = (int(x) for x in stdin.readline().split())

point, probs = solve(n, T, a, t)
stdout.write(""%s\n"" % point)
stdout.write(""%s\n"" % len(probs))
if len(probs) > 0:
	stdout.write(""%s\n"" % "" "".join([str(x) for x in probs]))",O(nlogn)
"n,m = map(int,input().split())
print(n*""8"")
print((n-1)*""1""+""2"")",O(1)
"class Solution(object):
    def maximumPopulation(self, logs):
        MIN_YEAR, MAX_YEAR = 1950, 2050
        years = [0]*(MAX_YEAR-MIN_YEAR+1)
        for s, e in logs:
            years[s-MIN_YEAR] += 1
            years[e-MIN_YEAR] -= 1
        result = 0
        for i in range(len(years)):
            if i:
                years[i] += years[i-1]
            if years[i] > years[result]:
                result = i
        return result+MIN_YEAR",O(n)
"class Solution(object):
    def getRow(self, rowIndex):
        result = [0] * (rowIndex + 1)
        for i in range(rowIndex + 1):
            old = result[0] = 1
            for j in range(1, i + 1):
                old, result[j] = result[j], old + result[j]
        return result

    def getRow2(self, rowIndex):
        row = [1]
        for _ in range(rowIndex):
            row = [x + y for x, y in zip([0] + row, row + [0])]
        return row

    def getRow3(self, rowIndex):
        if rowIndex == 0: return [1]
        res = [1, 1]

        def add(nums):
            res = nums[:1]
            for i, j in enumerate(nums):
                if i < len(nums) - 1:
                    res += [nums[i] + nums[i + 1]]
            res += nums[:1]
            return res

        while res[1] < rowIndex:
            res = add(res)
        return res",O(n ^ 2)
"class Solution3(object):
    def maximalSquare(self, matrix):
        if not matrix:
            return 0

        H, W = 0, 1
        table = [[[0, 0] for j in range(len(matrix[0]))] \
                         for i in range(len(matrix))]
        for i in reversed(range(len(matrix))):
            for j in reversed(range(len(matrix[i]))):
                if matrix[i][j] == '1':
                    h, w = 1, 1
                    if i + 1 < len(matrix):
                        h = table[i + 1][j][H] + 1
                    if j + 1 < len(matrix[i]):
                        w = table[i][j + 1][W] + 1
                    table[i][j] = [h, w]

        s = [[0 for j in range(len(matrix[0]))] \
                for i in range(len(matrix))]
        max_square_area = 0
        for i in reversed(range(len(matrix))):
            for j in reversed(range(len(matrix[i]))):
                side = min(table[i][j][H], table[i][j][W])
                if matrix[i][j] == '1':
                    if i + 1 < len(matrix) and j + 1 < len(matrix[i + 1]):
                        side = min(s[i + 1][j + 1] + 1, side)
                    s[i][j] = side
                    max_square_area = max(max_square_area, side * side)

        return max_square_area",O(n ^ 2)
"k, n, s, p = map(int, input().split())
print(((n + s - 1) // s * k + p - 1) // p)",O(1)
"n=int(input())
if n>-1:
    print(n)
else:
    n=str(n)
    x=int(n[:len(n)-1])
    y=int(n[:len(n)-2]+n[-1])
    print(max(x,y))",O(1)
"def iscomposite(value):
    for i in range(2,value):
        if(value%i==0):
            return '1'
    else:
        return '0'

n=int(input())
for i in range(4,n):
    a=i
    b=n-i
    if(iscomposite(a)=='1' and iscomposite(b)=='1'):
        print(a,b)
        break
    else:
        continue
",O(1)
"def matches(pos, c, case):
    if case==0:
        return pos%3==""RGB"".index(c)
    elif case==1:
        return pos%3==""GBR"".index(c)
    else:
        return pos%3==""BRG"".index(c)

q = int(input())
for _ in range(q):
    n, k = map(int, input().split())

    s = input()

    mglobal = k

    r=g=b=0

    for i, c in enumerate(s[:k]):

        r += not matches(i, c, 0)
        g += not matches(i, c, 1)
        b += not matches(i, c, 2)

    mglobal = min([mglobal, r, g, b])
    for i, c in enumerate(s[k:]):
        i+=k
        r += -(not matches(i-k, s[i-k], 0)) + (not matches(i, c, 0))
        g += -(not matches(i-k, s[i-k], 1)) + (not matches(i, c, 1))
        b += -(not matches(i-k, s[i-k], 2)) + (not matches(i, c, 2))

        mglobal = min([mglobal, r, g, b])

    print(mglobal)
",O(n)
"R = lambda: map(int, input().split())
for _ in range(int(input())):
    n,k = R()
    s = input()
    p = (k+2)//2
    l = ""RGB""*p
    res = n
    for i in range(n-k+1):
        c = 0

        for j in range(0,k):
            c += (s[i+j] != l[j])
        res = min(res,c)

        c = 0

        for j in range(1,k+1):
            c += (s[i+j-1] != l[j])
        res = min(res,c)

        c = 0

        for j in range(2,k+2):
            c += (s[i+j-2] != l[j])
        res = min(res,c)

    print(res)",O(n ^ 2)
"class Solution2(object):
    def isReflected(self, points):
        if not points:
            return True
        points.sort()
        points[len(points)/2:] = sorted(points[len(points)/2:], \
                                        lambda x, y: y[1] - x[1] if x[0] == y[0] else \
                                                     x[0] - y[0])
        mid = points[0][0] + points[-1][0]
        left, right = 0, len(points) - 1
        while left <= right:
            if (mid != points[left][0] + points[right][0]) or \
               (points[left][0] != points[right][0] and \
                points[left][1] != points[right][1]):
                return False
            left += 1
            right -= 1
        return True",O(nlogn)
"class Solution(object):
    def numberOfSubarrays(self, nums):
        result = 0
        stk = []
        for x in nums:
            while stk and stk[-1][0] < x:
                stk.pop()
            if not stk or stk[-1][0] != x:
                stk.append([x, 0])
            stk[-1][1] += 1
            result += stk[-1][1]
        return result",O(n)
"from sys import stdin, stdout
mod=(10**9)+7
mod1=mod-1
def modinv(n,p):
    return pow(n,p-2,p)
def ncr(n,r,p):
    t=((fact[n])*(modinv(fact[r],p)%p)*(modinv(fact[n-r],p)%p))%p
    return t
def GCD(x, y):
   while(y):
       x, y = y, x % y
   return x

from bisect import bisect_left as bl
from bisect import bisect_right as br
import itertools
import math
import heapq
from random import randint as rn
from Queue import Queue as Q
def comp(x,y):
    if(x[0]<y[0]):
        return -1
    elif(x[0]==y[0]):
        if(x[1]<y[1]):
            return -1
        else:
            return 1
    else:
        return 1
import heapq
k=[(0,0),(0,1),(0,2),(1,0),(1,2),(2,0),(2,1),(2,2)]
def gg(i,j):
    if(i<n-2 and j<m-2):
        f=0
        for g in range(8):
            if(w[i+k[g][0]][j+k[g][1]]=="".""):
                f=1
        if(f!=1):
            for g in range(8):
                p[i+k[g][0]][j+k[g][1]]=1

n=input()
w=n
d=1
p=[]
while(n!=1):
    t=(n+1)/2
    for i in range(t):
        p.append(str(d))
    n-=t
    if(n==1):
        break
    d*=2
if(w%d==0):
    p.append(str(w))
else:
    g=w/d
    r=d*g
    p.append(str(r))
stdout.write("" "".join(p))
",O(logn)
"import os
import sys
from io import BytesIO, IOBase
import math

def main():
    l, r = map(int, input().split())
    for i in range(62, -1, -1):
        if ((1 << i) & l) ^ ((1 << i) & r):
            print((1 << (i+1)) - 1)
            break
    else:
        print(0)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(logn)
"import itertools




class Solution2(object):
    def beautifulPair(self, nums1, nums2):
        INF = float(""inf"")
        MAX_NEIGHBOR_COUNT = (8+2)//2
        def dist(a, b):
            if a > b:
                a, b = b, a
            return [abs(points[a][0]-points[b][0])+abs(points[a][1]-points[b][1]), a, b]

        def merge_sort(left, right):
            def update(arr, i): 
                for j in reversed(range(len(arr))):
                    if points[i][1]-points[arr[j]][1] > result[0]:
                        break
                    result[:] = min(result, dist(i, arr[j]))
                else:
                    j = -1
                assert((len(arr)-1)-j <= MAX_NEIGHBOR_COUNT)

            if left == right:
                return
            mid = left+(right-left)//2
            x = points[order[mid]][0] 
            merge_sort(left, mid)
            merge_sort(mid+1, right)
            tmp, tmp_l, tmp_r = [], [], []
            l, r = left, mid+1
            while l <= mid or r <= right:
                if r == right+1 or (l <= mid and points[order[l]][1] <= points[order[r]][1]): 
                    update(tmp_r, order[l])
                    if x-points[order[l]][0] <= result[0]: 
                        tmp_l.append(order[l])
                    tmp.append(order[l])
                    l += 1
                else:
                    update(tmp_l, order[r])
                    if points[order[r]][0]-x <= result[0]: 
                        tmp_r.append(order[r])
                    tmp.append(order[r])
                    r += 1
            order[left:right+1] = tmp

        points = [(i, j) for i, j in zip(nums1, nums2)]
        result = [INF]*3
        lookup = {}
        for i in reversed(range(len(points))):
            if points[i] in lookup:
                result = [0, (i, lookup[points[i]])]
            lookup[points[i]] = i
        if result[0] == 0:
            return result[1]
        order = list(range(len(points)))
        order.sort(key=lambda x: points[x][0])
        merge_sort(0, len(points)-1)
        return result[1:]",O(nlogn)
"n = int(input())

l = list(map(int,input().split()))

s = list(set(l))

s.sort()

if len(s)>1:
    ans = s[1]
else:
    ans='NO'

print(ans)",O(nlogn)
"class Solution(object):
    def minNumberOfFrogs(self, croakOfFrogs):
        S = ""croak""
        lookup = [0]*len(S)
        result = 0
        for c in croakOfFrogs:
            i = S.find(c)
            lookup[i] += 1
            if lookup[i-1]:
                lookup[i-1] -= 1
            elif i == 0:
                result += 1
            else:
                return -1
        return result if result == lookup[-1] else -1",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):

    def __init__(self, root):
        def dfs(node, v, lookup):
            if not node:
                return
            node.val = v    
            lookup.add(v)
            dfs(node.left, 2*v+1, lookup)
            dfs(node.right, 2*v+2, lookup)

        self.__lookup = set()
        dfs(root, 0, self.__lookup)

    def find(self, target):
        return target in self.__lookup",O(n)
"import sys

def prepare():
    stack = [i for i in range(n) if deg[i] == 0]
    cnt = 0
    while stack:
        v = stack.pop()
        cnt += 1
        for dest in adj[v]:
            deg[dest] -= 1
            if deg[dest] == 0:
                stack.append(dest)
        adj[v].clear()

    return cnt == n

def solve(st):
    stack = [st]
    visited = [0]*n
    cnt = 0
    while stack:
        v = stack.pop()
        cnt += 1
        for dest in adj[v]:
            if dest == st:
                continue
            visited[dest] += 1
            if deg[dest] == visited[dest]:
                stack.append(dest)

    return cnt == m

n, m = map(int, sys.stdin.buffer.readline().decode('utf-8').split())
adj = [[] for _ in range(n)]
rev = [[] for _ in range(n)]
deg = [0]*n
for u, v in (map(int, line.decode('utf-8').split()) for line in sys.stdin.buffer):
    adj[u-1].append(v-1)
    rev[v-1].append(u-1)
    deg[v-1] += 1

ok = prepare()
if ok:
    print('YES')
    exit()

m = len([1 for i in range(n) if deg[i] > 0])
for i in range(n):
    if deg[i] == 1 and solve(i):
        print('YES')
        exit()

print('NO')
",O(n ^ 2)
"import pandas as pd



def Solution(students: pd.DataFrame) -> pd.DataFrame:
    return students[students[""student_id""] == 101][[""name"", ""age""]]",O(n)
"class Solution2(object):
    def maxRepOpt1(self, text):
        A = [[c, len(list(group))] for c, group in itertools.groupby(text)]
        total_count = collections.Counter(text)
        result = max(min(l+1, total_count[c]) for c, l in A)
        for i in range(1, len(A)-1):
            if A[i-1][0] == A[i+1][0] and A[i][1] == 1:
                result = max(result, min(A[i-1][1] + 1 + A[i+1][1], total_count[A[i+1][0]]))
        return result",O(n)
"def solve(n, a):
    a = sorted(a)
    col = [False for i in range(n)]
    count = 0
    for i in range(n):
        if not col[i]:
            count += 1
            col[i] = True
            for j in range(n):
                if a[j] % a[i] == 0:
                    col[j] = True
    return count

n = int(input())
a = list(map(int, input().split()))
print(solve(n, a))",O(n ^ 2)
"import itertools


class Solution(object):
    def distanceBetweenBusStops(self, distance, start, destination):
        if start > destination:
            start, destination = destination, start
        s_to_d = sum(itertools.islice(distance, start, destination))
        d_to_s = sum(itertools.islice(distance, 0, start)) + \
                 sum(itertools.islice(distance, destination, len(distance)))
        return min(s_to_d, d_to_s)",O(n)
"class Solution(object):
    def sumScores(self, s):
        def z_function(s): 
            z = [0]*len(s)
            l, r = 0, 0
            for i in range(1, len(z)):
                if i <= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 > r:
                    l, r = i, i+z[i]-1
            return z

        z = z_function(s)
        z[0] = len(s)
        return sum(z)",O(n)
"class Solution(object):
    def maxTotalFruits(self, fruits, startPos, k):
        max_pos = max(startPos, fruits[-1][0])
        cnt = [0]*(1+max_pos)
        for p, a in fruits:
            cnt[p] = a
        prefix = [0]
        for x in cnt:
            prefix.append(prefix[-1]+x)
        result = 0
        for left_dist in range(min(startPos, k)+1):
            right_dist = max(k-2*left_dist, 0)            
            left, right = startPos-left_dist, min(startPos+right_dist, max_pos)
            result = max(result, prefix[right+1]-prefix[left])
        for right_dist in range(min(max_pos-startPos, k)+1):
            left_dist = max(k-2*right_dist, 0) 
            left, right = max(startPos-left_dist, 0), startPos+right_dist
            result = max(result, prefix[right+1]-prefix[left])
        return result",O(n)
"t = int(input())

def sol(n, k):
    p = 1
    q = 1
    acc = 0
    while n > 0 and k >= p:
        k -= p
        n -= 1
        if n >= 40:
            return n
        acc += q*(4**n-1)//3
        if k <= acc:
            return n
        p = 2*p+1
        q = 2*q+3
    return -1

for _ in range(t):
    n, k = (int(v) for v in input().split())
    ans = sol(n, k)
    if ans == -1:
        print(""NO"")
    else:
        print(""YES"", ans)",O(logn)
"class Solution(object):
    def isValid(self, S):
        stack = []
        for i in S:
            if i == 'c':
                if stack[-2:] == ['a', 'b']:
                    stack.pop()
                    stack.pop()
                else:
                    return False
            else:
                stack.append(i)
        return not stack",O(n)
"def check_combos(diff,n,size,start,picked,total,l,r,x,combination = []):
    if picked == size:
        if max(combination) - min(combination) >= x and l <= sum(combination) <= r:
            total += 1
    else:
        for i in range(start,n-(size-picked-1)):
            combination.append(diff[i])
            picked += 1
            total = check_combos(diff,n,size,i+1,picked,total,l,r,x,combination)
            picked -= 1
            combination.pop()
    return total

def prog():
    n,l,r,x = map(int,input().split())
    diff = list(map(int,input().split()))
    suitable_problemsets = 0
    for size in range(1,n+1):
        suitable_problemsets += check_combos(diff,n,size,0,0,0,l,r,x)
    print(suitable_problemsets)
prog()
",np
"def f(n,s):
 d=[-n,-n];d[s]=0
 for i in range(y//g):d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
 return d[s]
import math;n,x,y=map(int,input().split());g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));y+=x;print(n%g*h(n//g+1)+(g-n%g)*h(n//g))
",np
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    def middleNode(self, head):
        slow, fast = head, head
        while fast and fast.__next__:
            slow, fast = slow.__next__, fast.next.__next__
        return slow

",O(n)
"
class Solution(object):
    def maxSubArray(self, nums):
        result, curr = float(""-inf""), float(""-inf"")
        for x in nums:
            curr = max(curr+x, x)
            result = max(result, curr)
        return result
",O(n)
"import sys
input = sys.stdin.readline
n, m, k = map(int, input().split())
ej = [list(map(int, input().split())) for _ in range(n)]
ei = [list(map(int, input().split())) for _ in range(n - 1)]

if k % 2:
  for _ in range(n): print(*[-1] * m)
  exit(0)
inf = -1
dp = [[inf] * (n * m) for _ in range(k // 2 + 1)]
for t in range(n * m): dp[0][t] = 0
for c in range(k // 2):
  for i in range(n):
    for j in range(m):
      t = i * m + j

      tt = (i + 1) * m + j
      if i + 1 < n and (dp[c + 1][tt] == -1 or dp[c + 1][tt] > dp[c][t] + ei[i][j]): dp[c + 1][tt] = dp[c][t] + ei[i][j]

      tt = i * m + j + 1
      if j + 1 < m and (dp[c + 1][tt] == -1 or dp[c + 1][tt] > dp[c][t] + ej[i][j]): dp[c + 1][tt] = dp[c][t] + ej[i][j]

      tt = (i - 1) * m + j
      if i - 1 >= 0 and (dp[c + 1][tt] == -1 or dp[c + 1][tt] > dp[c][t] + ei[i - 1][j]): dp[c + 1][tt] = dp[c][t] + ei[i - 1][j]

      tt = i * m + j - 1
      if j - 1 >= 0 and (dp[c + 1][tt] == -1 or dp[c + 1][tt] > dp[c][t] + ej[i][j - 1]): dp[c + 1][tt] = dp[c][t] + ej[i][j - 1]

res = [[0] * m for _ in range(n)]
for i in range(n):
  for j in range(m): res[i][j] = dp[-1][i * m + j] * 2
  print(*res[i])
",O(n ^ 3)
"class Solution(object):
    def minCapability(self, nums, k):
        def check(x):
            cnt = i = 0
            while i < len(nums):
                if nums[i] <= x:
                    cnt += 1
                    i += 2
                else:
                    i += 1
            return cnt >= k

        sorted_nums = sorted(set(nums))
        left, right = 0, len(sorted_nums)-1
        while left <= right:
            mid = left + (right-left)//2
            if check(sorted_nums[mid]):
                right = mid-1
            else:
                left = mid+1
        return sorted_nums[left]",O(nlogn)
"l,r = map(int, input().split())
ans = 0
a,b,c = [],[],[]
if l==r:
    print(0)
    exit()

for i in range(63, -1, -1):
    if (r^l) & (1<<i):
        for j in range(i,-1,-1):
            ans|= 1<<j
        break
print(ans)",O(logn)
"import collections
from functools import reduce


class Solution(object):
    def longestRepeatingSubstring(self, S):
        M = 10**9+7
        D = 26

        def check(S, L):
            p = pow(D, L, M)
            curr = reduce(lambda x, y: (D*x+ord(y)-ord('a')) % M, S[:L], 0)
            lookup = collections.defaultdict(list)
            lookup[curr].append(L-1)
            result = 0
            for i in range(L, len(S)):
                curr = ((D*curr) % M + ord(S[i])-ord('a') -
                        ((ord(S[i-L])-ord('a'))*p) % M) % M
                if curr in lookup:
                    for j in lookup[curr]:
                        if S[j-L+1:j+1] == S[i-L+1:i+1]:
                            if result == 0:
                                result = i
                            return result-L+1
                lookup[curr].append(i)
            return result

        left, right = 0, len(S)-1
        while left <= right:
            mid = left + (right-left)//2
            if not check(S, mid):
                right = mid-1
            else:
                left = mid+1
        return right",O(nlogn)
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque

n, k = map(int,input().split())
s = input()

def judge(needed):

    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0

    effect = [[inf]*(n+1) for j in range(k)]

    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

            if accu>=needed:
                index = i + needed
            effect[j][i] = index

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index])

        minstate[state] = minimum

    if minstate[-1]<=n:  return True
    return False

front = 0
rear = n//k+1

while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)

    if flag:
        front = mid + 1
    else:
        rear = mid

print(front-1)
",np
"import sys as _sys

_sys.setrecursionlimit(2**14)

_cache = dict()

class _SortedSeqs:

    def __init__(self, seqs):
        self.seqs = tuple(tuple(sorted(seq)) for seq in seqs)

    def __hash__(self):
        return id(self)

def compute_max_area(r_seq, g_seq, b_seq):
    sorted_seqs_obj = _SortedSeqs((r_seq, g_seq, b_seq))
    seqs_sizes = tuple(map(len, sorted_seqs_obj.seqs))
    return _compute_max_area(sorted_seqs_obj, seqs_sizes)

def _compute_max_area(sorted_seqs_obj, seqs_sizes):
    cache_key = (sorted_seqs_obj, seqs_sizes)
    if cache_key in _cache.keys():
        return _cache[cache_key]

    seqs = sorted_seqs_obj.seqs
    nonempty_seqs_n = _how_many_nonempty(seqs_sizes)

    if nonempty_seqs_n < 2:
        ab_seqs_indices_list = []

    elif nonempty_seqs_n == 2:
        ab_seqs_indices = [i for i, seq_size in enumerate(seqs_sizes) if seq_size > 0]
        ab_seqs_indices_list = [ab_seqs_indices]

    else:
        assert nonempty_seqs_n == 3
        seqs_indices_sorted_by_size = [
            i for i, seq in sorted(
                enumerate(seqs),
                key=lambda pair: (pair[1][seqs_sizes[pair[0]]-1], seqs_sizes[pair[0]])
            )
        ]
        ab_seqs_indices_1 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[0]
        ab_seqs_indices_2 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[1]
        ab_seqs_indices_list = [ab_seqs_indices_1, ab_seqs_indices_2]

    max_areas_variants = []
    for a_seq_index, b_seq_index in ab_seqs_indices_list:
        a_seq_last = seqs[a_seq_index][seqs_sizes[a_seq_index]-1]
        b_seq_last = seqs[b_seq_index][seqs_sizes[b_seq_index]-1]
        new_seqs_sizes = list(seqs_sizes)
        new_seqs_sizes[a_seq_index] -= 1
        new_seqs_sizes[b_seq_index] -= 1
        max_area = _compute_max_area(sorted_seqs_obj, tuple(new_seqs_sizes))
        max_area += a_seq_last * b_seq_last
        max_areas_variants.append(max_area)

    max_area = max(max_areas_variants, default=0)

    _cache[cache_key] = max_area
    return max_area

def _how_many_nonempty(seqs_sizes):
    return len([size for size in seqs_sizes if size > 0])

def main():
    r_n, g_n, b_n = map(int, input().split())
    r_seq = tuple(map(int, input().split()))
    g_seq = tuple(map(int, input().split()))
    b_seq = tuple(map(int, input().split()))
    result = compute_max_area(r_seq, g_seq, b_seq)
    print(result)

if __name__ == '__main__':
    main()
",O(n ^ 3)
"n, m = map(int, input().split())
V = []
for i in range(n):
    V.append(int(input()))
V.sort()
V.append(10 ** 9)
n += 1
X2 = []
for i in range(m):
    x1, x2, y = map(int, input().split())
    if x1 == 1:
        X2.append(x2)
X2.sort()
k = len(X2)
i = 0
j = 0
ans = 10 ** 9 + 7
c = 0

while i < n:
    while j < k:
        if X2[j] < V[i]:
            c += 1
            j += 1
        else:
            break
    ans = min(ans,  k - c + i)
    i += 1
print(ans)",O(nlogn)
"class Solution2(object):
    def numTilings(self, N):
        M = int(1e9+7)
        dp = [1, 1, 2]
        for i in range(3, N+1):
            dp[i%3] = (2*dp[(i-1)%3]%M + dp[(i-3)%3])%M
        return dp[N%3]",O(n)
"a, b= list(map(int, input().split()))
c = 1
result = a^b
while c <= result:
    c *= 2
c -= 1

print(c)
",O(logn)
"class Solution:
    def reverse(self, x: int) -> int:
        org = x
        x = abs(x)
        res = int(str(x)[::-1])
        if org < 0:
            res *= -1
        if res < -(1 << 31) or res > (1 << 31) - 1:
            return 0
        return res
",O(1)
"class Solution(object):
    def minOperations(self, k):
        def isqrt(n):
            a, b = n, (n+1)//2
            while b < a:
                a, b = b, (b+n//b)//2
            return a

        def ceil_divide(a, b):
            return (a+b-1)//b
    
        x = isqrt(k)
        return (x-1)+(ceil_divide(k, x)-1)",O(logn)
"def qtd(u):
    ans = 0
    while(u > 0):
        u//=10
        ans += 1
    return ans

def digitos(u):
    ans = 0
    while(u > 0):
        ans += u%10
        u//=10
    return ans

n, m = input().split()
m = int(m)
number = int(n)
ans = 0
size_n = qtd(m)
i = m

while(i < m+(size_n*9) + 1):
    if(i > number):
        break
    if(i - digitos(i) >= m):
        ans += 1
    i += 1

if(i > number):
    print(ans)
else:
    print(number-i+1+ans)
",O(logn)
"class Solution(object):
    def alienOrder(self, words):
        result, in_degree, out_degree = [], {}, {}
        zero_in_degree_queue = collections.deque()
        nodes = set()
        for word in words:
            for c in word:
                nodes.add(c)

        for i in range(1, len(words)):
            if (len(words[i-1]) > len(words[i]) and
                    words[i-1][:len(words[i])] == words[i]):
                return """"
            self.findEdges(words[i - 1], words[i], in_degree, out_degree)

        for node in nodes:
            if node not in in_degree:
                zero_in_degree_queue.append(node)

        while zero_in_degree_queue:
            precedence = zero_in_degree_queue.popleft()
            result.append(precedence)

            if precedence in out_degree:
                for c in out_degree[precedence]:
                    in_degree[c].discard(precedence)
                    if not in_degree[c]:
                        zero_in_degree_queue.append(c)

                del out_degree[precedence]

        if out_degree:
            return """"

        return """".join(result)

    def findEdges(self, word1, word2, in_degree, out_degree):
        str_len = min(len(word1), len(word2))
        for i in range(str_len):
            if word1[i] != word2[i]:
                if word2[i] not in in_degree:
                    in_degree[word2[i]] = set()
                if word1[i] not in out_degree:
                    out_degree[word1[i]] = set()
                in_degree[word2[i]].add(word1[i])
                out_degree[word1[i]].add(word2[i])
                break",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def main():
    n,m=map(int,input().split())
    ans=[];moves=n*m;
    c1=[1,1];c2=[n,m];p=0
    while moves>0:
        if p%2==0:
            ans.append(tuple(c1))
            c1[1]+=1
            if c1[1]>m:
                c1[0]+=1;c1[1]=1
        else:
            ans.append(tuple(c2))
            c2[1]-=1
            if c2[1]<1:
                c2[0]-=1;c2[1]=m
        moves-=1;p+=1
    for i in ans:
        print(*i)
main()",O(n ^ 2)
"from sys import stdin
n,m=map(int,stdin.readline().strip().split())
s=list(map(int,stdin.readline().strip().split()))
s1=list(map(int,stdin.readline().strip().split()))
if min(s1)<max(s):
    print(-1)
    exit(0)
s.sort()
s1.sort()

ans=0
if s1[0]!=s[-1]:
    ans+=s1[0]
    ans+=s[-2]*(m-1)
    ans+=sum(s1[1::])
    ans+=s[-1]
    for i in range(n-2):
        ans+=s[i]*m
else:
    ans+=sum(s1)
    for i in range(n-1):
        ans+=s[i]*m
print(ans)
",O(nlogn)
"import sys
n = int(input())
a = [int(i) for i in input().split()]
a.sort()
t = 0
for i in range(1,n):
	t += a[i]==a[i-1]
if t >= 2:
	print(""cslnb"")
	sys.exit(0)
if t:
	for i in range(n):
		if a[i]==a[i+1]:
			if a[i] and a[i]!=a[i-1]+1:
				a[i] -= 1
				break
			else:
				print(""cslnb"")
				sys.exit(0)
print([""cslnb"",""sjfnb""][(sum(a)-t-n*(n-1)//2)&1])
",O(nlogn)
"class Solution(object):
    def maxRotateFunction(self, A):
        s = sum(A)
        fi = 0
        for i in range(len(A)):
            fi += i * A[i]

        result = fi
        for i in range(1, len(A)+1):
            fi += s - len(A) * A[-i]
            result = max(result, fi)
        return result",O(n)
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n):
        self.BIT=[0]*(n+1)
        self.num=n

    def query(self,idx):
        res_sum = 0
        while idx > 0:
            res_sum += self.BIT[idx]
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        while idx <= self.num:
            self.BIT[idx] += x
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n = int(input())
P = permutations([i for i in range(4)])
plus = [(0,0),(0,n),(n,0),(n,n)]

A = []
for i in range(4):
    tmp = [input() for i in range(n)]
    if i!=3:
        _ = input()
    A.append(tmp)

tmp = [[0 for i in range(2*n)] for j in range(2*n)]
res = 10**17
for p in P:
    for k in range(4):
        x,y = plus[p[k]]
        for i in range(n):
            for j in range(n):
                tmp[i+x][j+y] = int(A[k][i][j])

    ans_1 = 0
    ans_2 = 0
    for i in range(2*n):
        for j in range(2*n):
            if tmp[i][j]==(i+j)%2:
                ans_1 += 1
            else:
                ans_2 += 1

    res = min(res,ans_1,ans_2)

print(res)
",O(n ^ 2)
"from itertools import combinations
n,l,r,x = map(int,input().split())
a = list(map(int,input().split()))
ans = 0
for i in range(2,n+1):
    for j in combinations(a,i):
        if max(j)-min(j)>=x and l<=sum(j)<=r:
            ans+=1
print(ans)
",np
"l,r=map(int,input().split())
j=r-l+1

if j==3:
	if l%2==0:
		print(l,l+1,l+2)
	else:
		print(-1)
elif j>3:
	if l%2==0:print(l,l+1,l+2)
	else:print(l+1,l+2,l+3)
else:print(-1)",O(1)
"from collections import Counter

def solve():
    n, k = tuple( map( lambda x: int(x), input().split()) )

    low, high = 0, n

    while low <= high:
        eaten = (low+high)//2
        added = (n-eaten)* (n-eaten+1)/2

        if added - eaten >= k:
            low = eaten + 1
        else:
            high = eaten - 1

    print(high)

if __name__ == ""__main__"":
    solve()",O(logn)
"class Solution(object):
    def numSubarraysWithSum(self, A, S):
        result = 0
        left, right, sum_left, sum_right = 0, 0, 0, 0
        for i, a in enumerate(A):
            sum_left += a
            while left < i and sum_left > S:
                sum_left -= A[left]
                left += 1
            sum_right += a
            while right < i and \
                  (sum_right > S or (sum_right == S and not A[right])):
                sum_right -= A[right]
                right += 1
            if sum_left == S:
                result += right-left+1
        return result",O(n)
"class Solution2(object):
    def largestSquareArea(self, bottomLeft, topRight):
        return max(max(min(min(topRight[i][0], topRight[j][0])-max(bottomLeft[i][0], bottomLeft[j][0]), min(topRight[i][1], topRight[j][1])-max(bottomLeft[i][1], bottomLeft[j][1])) for i in range(len(bottomLeft)) for j in range(i+1, len(bottomLeft))), 0)**2",O(n ^ 2)
"class Solution2(object):
    def numOfSubarrays(self, arr, k, threshold):
        accu = [0]
        for x in arr:
            accu.append(accu[-1]+x)
        result = 0
        for i in range(len(accu)-k):
            if accu[i+k]-accu[i] >= threshold*k:
                result += 1
        return result",O(n)
"import random



class Solution(object):
    def minimumCost(self, nums):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        nth_element(nums, 1+(2-1), 1)
        return nums[0]+nums[1]+nums[2]",O(n)
"class Solution(object):
    def getSmallestString(self, s, k):
        result = [ord(x)-ord('a') for x in s]
        for i in range(len(result)):
            d = min(result[i]-0, 26-result[i])
            result[i] = 0 if d <= k else result[i]-k
            k -= min(d, k)
            if k == 0:
                break
        return """".join([chr(x+ord('a')) for x in result])",O(n)
"class Solution(object):
    def isSameAfterReversals(self, num):
        return num == 0 or num%10",O(1)
"n = int(input())
lst = list(map(int, input().split()))
cur = 1
if n == 1:
    print(1)
    exit()
if lst[cur] > lst[cur - 1]:
    a = [1]
elif lst[cur] < lst[cur - 1]:
    a = [5]
else:
    a = [3]
pr = False
while cur != n:
    cnt = 0

    if lst[cur] > lst[cur - 1]:
        while cur != n and lst[cur] > lst[cur - 1]:
            cnt += 1
            cur += 1
        for i in range(cnt - 1):
            a.append(a[-1] + 1)
            if a[-1] >= 5:
                print(-1)
                exit()
        if n != cur and lst[cur] == lst[cur - 1]:
            a.append(a[-1] + 1)
        else:
            a.append(5)

    elif lst[cur] < lst[cur - 1]:
        while cur != n and lst[cur] < lst[cur - 1]:
            cnt += 1
            cur += 1
        for i in range(cnt - 1):
            a.append(a[-1] - 1)
            if a[-1] <= 1:
                print(-1)
                exit()
        if n != cur and lst[cur] == lst[cur - 1]:
            a.append(a[-1] - 1)
        else:
            a.append(1)
    else:
        while cur != n and lst[cur] == lst[cur - 1]:
            cnt += 1
            cur += 1

        for i in range(cnt - 1):
            if a[-1] < 3:
                a.append(a[-1] + 1)
            else:
                a.append(a[-1] - 1)

        if cur != n and lst[cur] > lst[cur - 1]:
            if a[-1] == 1:
                a.append(2)
            else:
                a.append(1)
        else:
            if a[-1] == 5:
                a.append(4)
            else:
                a.append(5)
print(*a)
",O(n ^ 2)
"import sys

input = sys.stdin.buffer.readline

def find_pair(candidate,data,m):
    ans = (-1,-1)
    binary_bit = [False for i in range(1 << m)]
    for i in data:
        bit_tmp = 0
        for j in range(len(i)):
            if i[j] >= candidate: bit_tmp |= 1 << j
        binary_bit[bit_tmp] = True

    for i in range(1 << m):
        for j in range(1 << m):
            if i | j == (( 1 << m ) - 1) and binary_bit[i] and binary_bit[j]:
                ans = i , j
                break
    return ans

def backtracking(candidate,ans,data):
    idx_i = -1 ; idx_j = -1
    for i in range(len(data)):
        bit_tmp = 0
        for j in range(len(data[i])):
            if data[i][j] >= candidate: bit_tmp |= 1 << j
        if bit_tmp == ans[0]: idx_i = i
        if bit_tmp == ans[1]: idx_j = i

    print(str(idx_i + 1) + "" "" + str(idx_j + 1))

def main():
    n , m = [int(i) for i in input().split()]
    data = [[int(i) for i in input().split()] for i in range(n)]
    a = 0 ; b = 10**9 + 7
    ans = (-1,-1)
    candidate = -1
    while a <= b:
        mid = (a + b)//2
        bin_ans = find_pair(mid,data,m)
        if bin_ans[0] != -1 and bin_ans[1] != -1:
            ans = bin_ans
            candidate = mid
            a = mid + 1
        else:
            b = mid - 1
    backtracking(candidate,ans,data)

main()
",np
"n = int(input())
f0= 0
f1 = 1
li = [0,1]
for i in range(45):
	t = f1
	f1 += f0
	f0 = t
	li.append(f1)
x = []
for i in range(3):
	for i in range(len(li)-1, -1, -1):
		if li[i] <= n:
			n -= li[i]
			x.append(li[i])
			break
if n == 0:
	print(*x, sep = "" "")
else:
	print(""I'm too stupid to solve this problem"")
",O(1)
"n, k = map(int, input().split())
p = (k - 1) // n + 1
print(p)
",O(1)
"n = int(input())
a = [ int(x) for x in input().split() ]

dp = [ [-1] * (n+1) for _ in range(n+1) ]
for i in range(n):
    dp[i][i+1] = a[i]

for leng in range(2, n+1):
    for l in range(n+1):
        if l + leng > n: continue
        r = l + leng
        for mid in range(l+1, n+1):
            if dp[l][mid] != -1 and dp[l][mid] == dp[mid][r]:
                dp[l][r] = dp[l][mid] + 1

dp2 = [ float(""inf"") for _ in range(n+1) ]
for i in range(n+1):
    dp2[i] = i
    for j in range(i):
        if dp[j][i] != -1:
            dp2[i] = min(dp2[i], dp2[j] + 1)

print(dp2[n])
",O(n ^ 3)
"import sys

input = sys.stdin.readline

n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

ans = float('inf')
for i in range(1, n-1):
    bef = aft = float('inf')
    for j in range(i):
        if a[j] < a[i]:
            bef = min(bef, b[j])
    for j in range(i, n):
        if a[i] < a[j]:
            aft = min(aft, b[j])
    ans = min(ans, b[i]+bef+aft)
print(-1 if ans > 10**9 else ans)
",O(n ^ 2)
"from collections import *
from itertools import *
from random import  *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from sys import *
from re import *
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]

z, zz = input, lambda: list(map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())

def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer): stdout.write(str(answer))

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]

n,l,r,x = zzz()
arr = zzz()
cnt=0
for i in range(2,2**n):
    b = bin(i)[2:]
    b='0'*(n-len(b))+b
    s,mx,mi =0, float('-inf'),float('inf')
    for j in range(n):
        if b[j]=='1':
            mx=max(mx,arr[j])
            mi=min(mi,arr[j])
            s+=arr[j]
    if s>=l and s<=r and mx-mi>=x:
        cnt+=1
print(cnt)
",np
"n=int(input())
list1=list(map(int,input().split(' ')))
sum2=0
sum1=0
count=0
list1.sort(reverse=True)
for i in range(len(list1)):
    sum1=sum1+list1[i]

for i in range(len(list1)):
    if(int(sum1/2)>=sum2):
        sum2=sum2+list1[i]
        count=count+1
print(count)",O(nlogn)
"from itertools import*
def out1(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==1 and b==0 and c==0:
        return 1
    return a*(out2(a-1,b,c)+out3(a-1,b,c))
def out2(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==0 and b==1 and c==0:
        return 1
    return b*(out1(a,b-1,c)+out3(a,b-1,c))
def out3(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==0 and b==0 and c==1:
        return 1
    return c*(out2(a,b,c-1)+out1(a,b,c-1))
def column(matrix, i):
    return [row[i] for row in matrix]
N, T = [int(x) for x in raw_input().split()]
A = []
s = 0
for i in range(N):
    A.append([int(x) for x in raw_input().split()])
for i in range(1,N+1):
    comb = list(combinations(A, i))
    for x in comb:
        if sum(column(x,0))==T:
            a = column(x,1).count(1)
            b = column(x,1).count(2)
            c = column(x,1).count(3)
            s+=(out1(a,b,c)+out2(a,b,c)+out3(a,b,c))
print(s%1000000007)",np
"import sys
from collections import defaultdict

exist_num,new_width = map(int,sys.stdin.readline().strip().split())
buildings = []
for _ in range(exist_num):
    center, width = map(int,sys.stdin.readline().strip().split())
    buildings.append((center-width/2,center+width/2))
buildings.sort()
possible_loc = 2
for left,right in zip(buildings,buildings[1:]):
    gap=right[0] - left[1]
    if gap == new_width:
        possible_loc += 1
    elif gap > new_width:
        possible_loc += 2

print(possible_loc)
",O(nlogn)
"n,k=map(int,input().split())
a=list(map(int,input().split()))
a.sort()
slow,fast=0,0
while fast<n:
    if a[slow]==a[fast]:
        fast+=1
    elif abs(a[slow]-a[fast])<=k:
        a[slow]=0
        slow+=1
    else:
        slow+=1
ans=0
for i in a:
    if i!=0:
        ans+=1
print(ans)",O(nlogn)
"import sys

mod=(10**9)+7

from sys import stdin, stdout
import bisect
from bisect import bisect_left as bl
from bisect import bisect_right as br
import itertools
import collections
import math
import heapq
from random import randint as rn
from Queue import Queue as Q
def modinv(n,p):
    return pow(n,p-2,p)
def ncr(n,r,p):
    t=((fact[n])*((ifact[r]*ifact[n-r])%p))%p
    return t
def ain():
    return map(int,sin().split())
def sin():
    return stdin.readline().strip()
def GCD(x,y):
    while(y):
        x, y = y, x % y
    return x
def isprime(x):
    if(x==1):
        return False
    elif(x<4):
        return True
    for i in range(2,int(math.sqrt(x))+1):
        if(x%i==0):
            return False
    return True

n,q=ain()
a=ain()
g=max(a)
d=collections.deque(a)
f=0
an1=[]
while(d[0]!=g):
    f+=1
    x=d.popleft()
    y=d.popleft()
    an1.append(str(x)+"" ""+str(y))
    if(y==g):
        d.appendleft(y)
        d.append(x)
        break
    if(x<y):
        d.appendleft(y)
        d.append(x)
    else:
        d.appendleft(x)
        d.append(y)
r=[]
ans=[]
for i in range(n):
    r.append(str(d.popleft()))
for i in range(q):
    b=int(sin())
    if(b<=f):
        ans.append(an1[b-1])
    else:
        b-=f
        b-=1
        b%=(n-1)
        ans.append(r[0]+"" ""+r[b+1])
stdout.write(""\n"".join(ans))
",O(n)
"class Solution(object):
    def minFlips(self, target):
        result, curr = 0, '0'
        for c in target:
            if c == curr:
                continue
            curr = c
            result += 1
        return result",O(n)
"import bisect
xzy=[10,190,2890,38890,488890,5888890,68888890,788888890,8888888890,98888888890,1088888888890,11888888888890]
k=int(input())
digits=bisect.bisect_left(xzy,k)
if k==10:
    print(1)
elif k>10:
    apu=k-xzy[digits-1]
    modulo=apu%(digits+1)
    dlj=apu//(digits+1)
    output=10**(digits)+dlj
    list1=[i for i in str(output)]
    print(list1[modulo])
else:
    print(k)
",O(logn)
"class Solution:
    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:
        x = y = z = False
        for t in triplets:
            x |= (t[0] == target[0] and t[1] <= target[1] and t[2] <= target[2])
            y |= (t[0] <= target[0] and t[1] == target[1] and t[2] <= target[2])
            z |= (t[0] <= target[0] and t[1] <= target[1] and t[2] == target[2])
            if x and y and z:
                return True
        return False
",O(n)
"def my_cmp(x):
    if x[0] == 0:
        return float('inf')
    return x[1]/x[0]

def dis(a, b):
    return a*a + b*b

n = int(input())
v = []
for i in range(n):
    x, y = map(int, input().split())
    v.append((x, y, i))
v.sort(key = my_cmp)
x, y = 0, 0
ans = [0]*n
for i in range(n):
    if dis(x+v[i][0], y+v[i][1]) < dis(x-v[i][0], y-v[i][1]):
        ans[v[i][2]] = 1
    else:
        ans[v[i][2]] = -1
    x += v[i][0]*ans[v[i][2]]
    y += v[i][1]*ans[v[i][2]]
for x in ans:
    print(x, end = ' ')",O(nlogn)
"x,y,z,t1,t2,t3=map(int,input().split())
if abs(x-y)*t1>=abs(x-z)*t2+t3*3+abs(x-y)*t2:
    print('YES')
else:
    print('NO')",O(1)
"n = int(input())
A = list(map(int, input().split()))
k = 10 ** 10
for i in range(1, n - 1):
    k = min(k, min(A[0], A[i]) // i)
    k = min(k, min(A[-1], A[i]) // (n - i - 1))
k = min(k, min(A[0], A[-1]) // (n - 1))
print(k)",O(n)
"n, m = map(int, input().split())
buf = []
for i in range(n//2):
    for j in range(m):
        buf.append(f'{i + 1} {j + 1}\n')
        buf.append(f'{n - i} {m - j}\n')

if n % 2 == 1:
    for j in range(m // 2):
        buf.append(f'{n // 2 + 1} {j + 1}\n')
        buf.append(f'{n // 2 + 1} {m - j}\n')
    if m % 2 == 1:
        buf.append(f'{n//2 + 1} {m//2 + 1}\n')
print(*buf, sep='')",O(n ^ 2)
"class Solution(object):
    def carFleet(self, target, position, speed):
        times = [float(target-p)/s for p, s in sorted(zip(position, speed))]
        result, curr = 0, 0
        for t in reversed(times):
            if t > curr:
                result += 1
                curr = t
        return result",O(nlogn)
"class Solution(object):
    def longestString(self, x, y, z):
        return ((min(x, y)*2+int(x != y))+z)*2",O(1)
"class Solution2(object):
    def totalStrength(self, strength):
        MOD = 10**9+7
        prefix, prefix2 = [0]*(len(strength)+1), [0]*(len(strength)+1)
        for i in range(len(strength)):
            prefix[i+1] = (prefix[i]+strength[i])%MOD
            prefix2[i+1] = (prefix2[i]+strength[i]*(i+1))%MOD
        suffix, suffix2 = [0]*(len(strength)+1), [0]*(len(strength)+1)
        for i in reversed(range(len(strength))):
            suffix[i] = (suffix[i+1]+strength[i])%MOD
            suffix2[i] = (suffix2[i+1]+strength[i]*(len(strength)-i))%MOD
        stk, result = [-1], 0
        for i in range(len(strength)+1):
            while stk[-1] != -1 and (i == len(strength) or strength[stk[-1]] >= strength[i]):
                x, y, z = stk[-2]+1, stk.pop(), i-1
                result = (result+(strength[y]*((z-y+1)*((prefix2[y+1]-prefix2[x])-x*(prefix[y+1]-prefix[x]))+
                                               (y-x+1)*((suffix2[y+1]-suffix2[z+1])-(len(strength)-(z+1))*(suffix[y+1]-suffix[z+1])))))%MOD
            stk.append(i)
        return result",O(n)
"class Solution2(object):
    def distMoney(self, money, children):
        if money < children*1:
            return -1
        money -= children*1
        q, r = divmod(money, 7)
        if q > children:
            return children-1
        if q == children:
            return q-int(r != 0)
        if q == children-1:
            return q-int(r == 3)
        return q",O(1)
"n,m = map(int, input().split())
b = [int(s) for s in input().split()]
g = [int(s) for s in input().split()]
ans = 0
maxb2, maxb = sorted(b)[-2:]
ming = min(g)
if maxb > ming:
    ans = -1
else:
    ans += sum(b)*m
    ans += (sum(g)-ming)-(maxb*(m-1))
    if ming > maxb:
        ans += ming-maxb2
print(ans)",O(nlogn)
"k=int(input())
i=0
r=1
while(k>=r):
    r+=9*(i+1)*10**i
    i+=1
r=r-(9*i*10**(i-1))
ans=str(((k-r)//i)+10**(i-1))[(k-r)%i]
print(ans)",O(1)
"
import collections


class Solution(object):
    def canBeEqual(self, target, arr):
        return collections.Counter(target) == collections.Counter(arr)


",O(n)
"import sys, heapq

n, m = map(int, sys.stdin.readline().split())
for _ in range(m):
    a, b = map(int, sys.stdin.readline().split())
ans = [0] * n
for i in range(1, n, 2):
    ans[i] = 1
print(''.join(map(str, ans)))
",O(n)
"s=input()
n=len(s)
if(s[0]=='-'):
    if(s[n-1]<s[n-2]):
        s=s[::-1]
        s=s.replace(s[1],"""",1)
        s=s[::-1]
    else:
        s=s[::-1]
        s=s.replace(s[0],"""",1)
        s=s[::-1]
    if(s==""-0""):
        print(""0"")
    else:
        print(s)
else:
    print(s)",O(1)
"import math

n=int(input())

for _ in range(n):
    a,b=map(int,input().split())
    ans=0
    while a>0 and b>0:
        if a>=b:
            ans+=a//b
            a=a%b
        else:
            ans+=b//a
            b=b%a
    print(ans)
",O(1)
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

n,k=map(int, input().split())
kk=list(map(str, input()))
s=sorted(list(set(kk)))
if k > 13:
    print(-1)
else:
    dic={}
    for index, value in enumerate(""abcdefghijklmnopqrstuvwxyz""):
        dic[value]= index+1

    ans=0
    ans+=dic[s[0]]
    k-=1
    curr=s[0]
    for i in range(1,len(s)):
        if k:
            if dic[s[i]]>dic[curr]+1:
                ans+=dic[s[i]]
                curr=s[i]
                k-=1
            if k==0:
                break
    if k==0:
        print(ans)
    else:
        print(-1)
",O(n)
"class Solution(object):
    def largestBSTSubtree(self, root):
        if root is None:
            return 0

        max_size = [1]
        def largestBSTSubtreeHelper(root):
            if root.left is None and root.right is None:
                return 1, root.val, root.val

            left_size, left_min, left_max = 0, root.val, root.val
            if root.left is not None:
                left_size, left_min, left_max = largestBSTSubtreeHelper(root.left)

            right_size, right_min, right_max = 0, root.val, root.val
            if root.right is not None:
                right_size, right_min, right_max = largestBSTSubtreeHelper(root.right)

            size = 0
            if (root.left is None or left_size > 0) and \
               (root.right is None or right_size > 0) and \
               left_max <= root.val <= right_min:
                size = 1 + left_size + right_size
                max_size[0] = max(max_size[0], size)

            return size, left_min, right_max

        largestBSTSubtreeHelper(root)
        return max_size[0]",O(n)
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums)

        while l < r:
            m = l + ((r - l) // 2)
            if nums[m] > target:
                r = m
            elif nums[m] <= target:
                l = m + 1
        return l - 1 if (l and nums[l - 1] == target) else -1
",O(logn)
"import collections



class Solution(object):
    def countPalindromePaths(self, parent, s):
        def iter_dfs():
            result = 0
            cnt = collections.defaultdict(int)
            cnt[0] = 1
            stk = [(0, 0)]
            while stk:
                u, mask = stk.pop()
                if u:
                    mask ^= 1<<(ord(s[u])-ord('a'))
                    result += cnt[mask]+sum(cnt[mask^(1<<i)] if mask^(1<<i) in cnt else 0 for i in range(26))
                    cnt[mask] += 1
                for v in reversed(adj[u]):
                    stk.append((v, mask))
            return result

        adj = [[] for _ in range(len(parent))]
        for u, p in enumerate(parent):
            if p != -1:
                adj[p].append(u)
        return iter_dfs()",O(n)
"from sys import stdin, stdout
import heapq
from collections import defaultdict
import math
import bisect

def main():
    n,m,k = list(map(int, stdin.readline().split()))
    right = []
    for _ in range(n):
        right.append(list(map(int, stdin.readline().split())))
    down = []
    for _ in range(n-1):
        down.append(list(map(int, stdin.readline().split())))
    if k % 2 == 1:
        for _ in range(n):
            stdout.write("" "".join([""-1"" for _ in range(m)])+""\n"")
        return
    dp = [[0 for _ in range(m)] for _ in range(n)]
    for x in range(1, (k//2) + 1):
        tmp = [[math.inf for _ in range(m)] for _ in range(n)]
        for i in range(n):
            for j in range(m):
                if i:
                    tmp[i][j] = min(tmp[i][j], dp[i-1][j] + 2 * down[i-1][j])
                if i < n-1:
                    tmp[i][j] = min(tmp[i][j], dp[i + 1][j] + 2 * down[i][j])
                if j:
                    tmp[i][j] = min(tmp[i][j], dp[i][j - 1] + 2 * right[i][j - 1])
                if j < m-1:
                    tmp[i][j] = min(tmp[i][j], dp[i][j + 1] + 2 * right[i][j])
        dp = tmp

    for i in range(n):
        stdout.write("" "".join([str(x) for x in dp[i]]) + ""\n"")

main()",O(n ^ 3)
"n = int(input())
a = list(map(int, input().split()))
b = []
c = []
e = []
for i in range(n):
	if a[i] == 1:
		b += [i]
for i in range(n):
	if a[i] != 1:
		c += [[a[i], i]]
if not c:
	print(""NO"")
	exit(0)
ans = len(c)
for i in range(len(c) - 1):
	e += [(c[i][1], c[i + 1][1])]
	c[i][0] -= 1
	c[i + 1][0] -= 1
if b:
	e += [(b[-1], c[-1][1])]
	c[-1][0] -= 1
	b.pop()
	ans += 1
if b:
	e += [(b[-1], c[0][1])]
	c[0][0] -= 1
	b.pop()
	ans += 1
i = 0
while b:
	while i < len(c) and c[i][0] == 0:
		i += 1
	if i == len(c):
		print(""NO"")
		exit(0)
	e += [(b[-1], c[i][1])]
	c[i][0] -= 1
	b.pop()

print(""YES"", ans - 1)
print(len(e))
for (x, y) in e:
	print(x + 1, y + 1)
",O(n)
"class Solution(object):
    def minimizeSum(self, nums):
        nums.sort()
        return min(nums[-3+i]-nums[i] for i in range(3))",O(nlogn)
"class Solution(object):
    def isRobotBounded(self, instructions):
        directions = [[ 1, 0], [0, -1], [-1, 0], [0, 1]]
        x, y, i = 0, 0, 0
        for instruction in instructions:
            if instruction == 'R':
                i = (i+1) % 4
            elif instruction == 'L':
                i = (i-1) % 4
            else:
                x += directions[i][0]
                y += directions[i][1]
        return (x == 0 and y == 0) or i > 0",O(n)
"class Solution(object):
    def longestPalindromeSubseq(self, s):
        dp = [[[0]*26 for _ in range(len(s))] for _ in range(2)]
        for i in reversed(range(len(s))):
            for j in range(i+1, len(s)):
                if i == j-1:
                    if s[j] == s[i]:
                        dp[i%2][j][ord(s[i])-ord('a')] = 2
                else:
                    for k in range(26):
                        if s[j] == s[i] and ord(s[j])-ord('a') != k:
                            dp[i%2][j][ord(s[j])-ord('a')] = max(dp[i%2][j][ord(s[j])-ord('a')], dp[(i+1)%2][j-1][k]+2)
                        dp[i%2][j][k] = max(dp[i%2][j][k], dp[i%2][j-1][k], dp[(i+1)%2][j][k], dp[(i+1)%2][j-1][k])
        return max(dp[0][-1])",O(n ^ 2)
"import sys
a,b,c=sys.stdin.readline().strip().split()
if a==b and b==c:
    print(0)
elif a==b or b==c or a==c:
    print(1)
else:
    na = int(a[0])
    nb = int(b[0])
    nc = int(c[0])
    if (a[1]==b[1] and a[1]==c[1]):
        cp=[na,nb,nc]
        cp.sort()
        cp[0]+=2
        cp[1]+=1
        if (cp[0]==cp[1] and cp[1]==cp[2]):
            print(""0"")
        elif (cp[0]==cp[1] or cp[1]==cp[2] or cp[0]==cp[1] or (cp[0]+1)==cp[1] or (cp[1]+1)==cp[2]):
            print(""1"")
        else:
            print(""2"")
    elif(a[1]==b[1]):
        mi=min(na,nb)
        ma=max(na,nb)
        if (mi==(ma-1) or mi==(ma-2)):
            print(""1"")
        else: print(""2"")
    elif(a[1]==c[1]):
        mi=min(na,nc)
        ma=max(na,nc)
        if (mi==(ma-1) or mi==(ma-2)):
            print(""1"")
        else: print(""2"")
    elif(b[1]==c[1]):
        mi = min(nb,nc)
        ma = max(nb,nc)
        if (mi==(ma-1) or mi==(ma-2)):
            print(""1"")
        else: print(""2"")
    else:
        print(""2"")
",O(nlogn)
"import math
def getx(n):
    return math.floor(math.sqrt(n))
def getans(n,x):
    l1=[i for i in range(n,0,-1)]
    l2=[]
    i=0
    while(i<n):
        l2=l2+sorted(l1[i:i+x])
        i+=x
    return l2
n=int(input())
a=getx(n)
ans=getans(n,a)
ans1=[str(i) for i in ans]
print(' '.join(ans1))",O(n)
"class Solution:
    def jump(self, nums: List[int]) -> int:
        res = 0
        l = r = 0

        while r < len(nums) - 1:
            farthest = 0
            for i in range(l, r + 1):
                farthest = max(farthest, i + nums[i])
            l = r + 1
            r = farthest
            res += 1
        return res
",O(n)
"k=int(input())

s=0
i=1
while  (s +  i * ( 9 * pow ( 10,i-1)) ) < k :
    s +=  i * (9 * pow(10, i - 1))
    i+=1
else:
    i-=1

k=k-s-1
x= k // (i+1)
y= k %(i+1)
x= pow(10,i)+x
ss=str(x)
print(ss[y])
",O(logn)
"from sys import stdin, stdout
n=int(input())
s=list(map(int,stdin.readline().strip().split()))
dp=[[-1 for i in range(n+1)]for j in range(n+1)]
for i in range(n):
    dp[0][i]=s[i]
for i in range(1,n):
    for j in range(n-i):
        dp[i][j]=dp[i-1][j]^dp[i-1][j+1]
for i in range(1,n):
    for j in range(n-i):
        dp[i][j]=max(dp[i-1][j],dp[i-1][j+1],dp[i][j])
q=int(input())
ans=""""
for i in range(q):
    l,r=map(int,stdin.readline().strip().split())
    print(dp[r-l][l-1])
",O(n ^ 2)
"n=int(input())
ar=list(map(int,input().split()))
d={};ans=0
for i in ar:d[i]=d.get(i,0)+1
for i in ar:
  flag=False
  for j in range(31):
    k=2**j;
    if k>=i:
     k1=k-i
     if i!=k1 and d.get(k1,0)>0:flag=True;break
     if i==k1 and d.get(i,0)>1:flag=True;break
  if not flag:ans+=1

print(ans)
",O(nlogn)
"test=int(input())
first=[]
for i in range(test):
    list_=list(map(int,input().split()))
    sum_=sum(list_)
    first.append(sum_)
first_sum=first[0]
count=0
for i in first:
    if first_sum<i:
        count=count+1
    else:
        continue
print(count+1)",O(n)
"n, m = map( int, input().split() )
a = list( map( int, input().split() ) )

ans = sum( a )
a.sort()
lastlevel = 0
level = 0
got = 0

for i in a:
    got = max( got, i )
    level = min( level + 1, got )
    if i > 0:
        ans -= 1
        lastlevel = level

ans -= ( got - level )
print( ans )
",O(nlogn)
"n=int(input())
a=list(map(int, input().rstrip().split()))
a.sort()
sum1=0
rem=sum(a)
i=len(a)-1
c=0
while(sum1<=rem):
    sum1+=a[i]
    rem=sum(a)-sum1
    i-=1
    c+=1
print(c)",O(nlogn)
"n, k = list(map(int,input().split()))
chuj_twojej_starej = (n - k) // 2 + 1
i = 1
while True:
	if i % chuj_twojej_starej == 0:
		print(0, end = """")
	else:
		print(1, end = """")
	if i == n:
		break
	i += 1",O(n)
"S = input()

ans = 0
met = set()

for i in range(len(S)):
    for j in range(i, -1, -1):
        if S[j:i+1] in met:
            ans = max(ans, i - j + 1)
        else:
            met.add(S[j:i+1])

print(ans)",O(n ^ 3)
"n,k=map(int,input().split())
same=[0]*(k+1)
diff=[0]*(k+1)
same[1]=2
if k>1:
    diff[2]=2
for i in range(n-1):
    newsame=[0]*(k+1)
    newdiff=[0]*(k+1)
    for i in range(1,k+1):
        newsame[i]=(same[i]+same[i-1]+2*diff[i])%998244353
    for i in range(2,k+1):
        newdiff[i]=(2*same[i-1]+diff[i]+diff[i-2])%998244353
    same=newsame
    diff=newdiff
print((same[-1]+diff[-1])%998244353)",np
"class DisjointSet:
    def __init__(self, n):
        self._fa = list(range(n))

    def union(self, x, y):
        x = self.get_father(x)
        y = self.get_father(y)
        self._fa[x] = y
        return y

    def get_father(self, x):
        y = self._fa[x]
        if self._fa[y] == y:
            return y
        else:
            z = self._fa[y] = self.get_father(y)
            return z

    def __repr__(self):
        return repr([self.get_father(i) for i in range(len(self._fa))])

def solve(n, a, b, xs):
    h = {x: i for i, x in enumerate(xs)}
    if a == b:
        if all(a - x in h for x in xs):
            return [0] * n
        return False
    g1 = n
    g2 = n + 1
    ds = DisjointSet(n + 2)

    for i, x in enumerate(xs):
        for t in (a, b):
            if t - x in h:
                ds.union(i, h[t - x])

    for i, x in enumerate(xs):
        b1 = (a - x) in h
        b2 = (b - x) in h
        if b1 + b2 == 0:
            return False
        if b1 + b2 == 1:
            if b1:
                ds.union(i, g1)
            else:
                ds.union(i, g2)
            if ds.get_father(g1) == ds.get_father(g2):
                return False
    group = [None] * n
    for i, x in enumerate(xs):
        f = ds.get_father(i)
        if f < n:
            return False
        group[i] = f - n
    return group

n, a, b = map(int, input().split())
xs = list(map(int, input().split()))
group = solve(n, a, b, xs)
if isinstance(group, list):
    print('YES')
    print(' '.join(map(str, group)))
else:
    print('NO')",O(n)
"import sys
def read():
    return int(input())
def reads():
    return [int(x) for x in input().split()]
N,M=reads()
table=[reads() for i in range(N)]
A=[[0]*N for i in range(N)]
B=[[0]*N for i in range(N)]
for i in range(N):
    for j in range(N):
        res=10**9+7
        for k in range(M):
            res=min(res,abs(table[i][k]-table[j][k]))
        A[i][j]=res
        A[j][i]=res
        res=10**9+7
        for k in range(M-1):
            res=min(res,abs(table[i][k]-table[j][k+1]))
        B[i][j]=res

dp=[[-1]*N for i in range((1<<N) )]
def calc(mask,v):
    if dp[mask][v]!=-1:
        return dp[mask][v]
    res =0
    for u in range(N):
        if (mask & 1<<u) and u!=v:
            res =max(res,min(calc(mask^(1<<v),u),A[u][v]))
    dp[mask][v]=res
    return dp[mask][v]
ans=0
for i in range(N):
    dp = [[-1] * N for i in range((1 << N))]
    for k in range(N):
        if k==i:
            dp[1<<k][k]=10**9+7
        else:
            dp[1<<k][k]=0
    for j in range(N):
        ans=max(ans,min(B[j][i],calc((1<<N)-1,j)))

print(ans)",np
"for _ in range(int(input())):
    N, M = map(int, input().split())
    X = [[int(a) for a in input().split()] for _ in range(N)]
    Y = [[X[i][j] for i in range(N)] for j in range(M)]
    ma = 0
    dp = [[0] * (1<<N) for _ in range(M+1)]
    for j in range(M):
        for mask in range(1<<N):
            maskpre = mask
            while maskpre >= 0:
                maskpre &= mask
                ma = 0
                for k in range(N):
                    s = 0
                    for i in range(N):
                        if (maskpre >> i) & 1 == 0 and (mask >> i) & 1:
                            s += X[i-k][j]
                    ma = max(ma, s)
                dp[j+1][mask] = max(dp[j+1][mask], dp[j][maskpre] + ma)

                maskpre -= 1
    print(dp[-1][-1])",np
"n=int(input())
a=list(map(int,input().split()))
if sum(a[i]==i+1 for i in range(n))>=n//1000:print(""Petr"")
else:print(""Um_nik"")
",O(nlogn)
"print('?', 0, 0, flush=True)
t = int(input())
s = [0]*31
if t == 1:
    s[30] = 1
else:
    s[30] = -1

a = 0
b = 0
for i in range(30, 0, -1):
    c = (1 << (i-1)) + a
    d = b
    print('?', c, d, flush=True)
    ans1 = int(input())
    c = a
    d = (1 << (i-1)) + b
    print('?', c, d, flush=True)
    ans2 = int(input())
    if ans1 == -1 and ans2 == 1:
        a += 1 << (i-1)
        b += 1 << (i-1)
        s[i-1] = s[i]
    elif ans1 == 1 and ans2 == -1:
        a += 0 << (i-1)
        b += 0 << (i-1)
        s[i-1] = s[i]
    else:
        s[i-1] = ans1
        if s[i] == 1:
            a += 1 << (i-1)
            b += 0 << (i-1)
        else:
            a += 0 << (i-1)
            b += 1 << (i-1)
print('!', a, b)
",O(1)
"import sys, os

if os.environ['USERNAME']=='kissz':
    inp=open('in.txt','r').readline
    def debug(*args):
        print(*args,file=sys.stderr)
else:
    inp=sys.stdin.readline
    def debug(*args):
        pass

n,m,k=map(int,inp().split())
A=[[*map(int,inp().split())] for _ in range(n)]
B=[[*map(int,inp().split())] for _ in range(n-1)]
if k%2==0:
    O=[[[1e12]*m for _ in range(n)] for _ in range(k//2)]
    for i in range(n):
        for j in range(m):
            if i>0:
                O[0][i][j]=min(O[0][i][j],B[i-1][j])
            if i<n-1:
                O[0][i][j]=min(O[0][i][j],B[i][j])
            if j>0:
                O[0][i][j]=min(O[0][i][j],A[i][j-1])
            if j<m-1:
                O[0][i][j]=min(O[0][i][j],A[i][j])

    for l in range(1,k//2):
        for i in range(n):
            for j in range(m):
                if i>0:
                    O[l][i][j]=min(O[l][i][j],B[i-1][j]+O[l-1][i-1][j])
                if i<n-1:
                    O[l][i][j]=min(O[l][i][j],B[i][j]+O[l-1][i+1][j])
                if j>0:
                    O[l][i][j]=min(O[l][i][j],A[i][j-1]+O[l-1][i][j-1])
                if j<m-1:
                    O[l][i][j]=min(O[l][i][j],A[i][j]+O[l-1][i][j+1])

    for i in range(n):
        print(*[O[-1][i][j]*2 for j in range(m)])
else:
    for i in range(n):
        print(*[-1]*m)
",O(n ^ 3)
"n , s = map(int,input().split())
a = [0] * (n+1)
for _ in range(n-1) :
    u , v=map(int, input().split())
    a[u] += 1
    a[v] += 1
print(2.0*s/a.count(1))",O(n)
"from math import factorial,pow
send = input()
received = input()

pos = 0
for p in send:
	pos = pos +1 if p=='+' else pos-1
qcount = 0
curr_pos = 0
for p in received:
	if p=='+':
		curr_pos = curr_pos +1
	elif(p=='-'):
		curr_pos = curr_pos-1
	if p=='?':
		qcount +=1

if qcount == 0:
	print(""{:.12f}"".format(1.0 if pos==curr_pos else 0.0))
else:
	exp_val_q = abs(pos -curr_pos)
	if exp_val_q%2!=qcount%2 or qcount<exp_val_q:
		print(""{:.12f}"".format(0.0))
	else:
		neg = (qcount - exp_val_q)/2
		posi = qcount - neg
		val = factorial(qcount)/(factorial(neg)*factorial(posi)*pow(2,qcount))
		print(""{:.12f}"".format(val))
",np
"class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        res = 0
        store = set(nums)

        for num in nums:
            streak, curr = 0, num
            while curr in store:
                streak += 1
                curr += 1
            res = max(res, streak)
        return res
",O(n ^ 2)
"class Solution(object):
    def countTriples(self, n):
        lookup = set()
        for i in range(1, n+1):
            lookup.add(i**2)
        result = 0
        for i in range(1, n+1):
            for j in range(1, n+1):
                result += int(i**2+j**2 in lookup)
        return result",O(n ^ 2)
"from __future__ import division
from sys import stdin, stdout

def write(x):
    stdout.write(str(x) + ""\n"")

n, s = map(int, stdin.readline().split())

if s % n == 0:
    write(s // n)
else:
    write(s // n + 1)
",O(1)
"class Solution(object):
    def search(self, nums, target):
        left, right = 0, len(nums) - 1

        while left <= right:
            mid = left + (right - left) / 2

            if nums[mid] == target:
                return mid
            elif (nums[mid] >= nums[left] and nums[left] <= target < nums[mid]) or \
                 (nums[mid] < nums[left] and not (nums[mid] < target <= nums[right])):
                right = mid - 1
            else:
                left = mid + 1

        return -1",O(logn)
"import sys
input = sys.stdin.readline

Q=int(input())
LR=[list(map(int,input().split())) for i in range(Q)]

def SUM(i):
    plus=i//2
    minus=(i+1)//2

    P=(2+2*plus)*plus//2
    M=(1+2*minus-1)*minus//2
    return P-M

for l,r in LR:
    print(SUM(r)-SUM(l-1))
",O(1)
"n, k = map(int, input().split())
s = input()
fail = [-1] * (len(s) + 1)
for i in range(1, len(s) + 1):
    j = fail[i - 1]
    while j != -1 and s[i - 1] != s[j]:
        j = fail[j]
    fail[i] = j + 1

f1 = fail[-1]
print(s + s[f1:] * (k - 1))",O(n ^ 2)
"import sys
input = sys.stdin.readline

n, m = map(int, input().split())
s = [list(input().rstrip()) for _ in range(n)]
t = [[1000] * m for _ in range(n)]
ok1 = [[0] * m for _ in range(n)]
ok2 = [[0] * m for _ in range(n)]
for i in range(n):
    si = s[i]
    c = 0
    for j in range(m):
        if si[j] == ""*"":
            c += 1
        else:
            c = 0
        t[i][j] = min(t[i][j], c)
    c = 0
    for j in range(m - 1, -1, -1):
        if si[j] == ""*"":
            c += 1
        else:
            c = 0
        t[i][j] = min(t[i][j], c)
for j in range(m):
    c = 0
    for i in range(n):
        if s[i][j] == ""*"":
            c += 1
        else:
            c = 0
        t[i][j] = min(t[i][j], c)
    c = 0
    for i in range(n - 1, -1, -1):
        if s[i][j] == ""*"":
            c += 1
        else:
            c = 0
        t[i][j] = min(t[i][j], c)
ans = []
for i in range(n):
    for j in range(m):
        tij = t[i][j] - 1
        if tij >= 1:
            ans.append((i + 1, j + 1, tij))
            ok1[max(0, i - tij)][j] += 1
            if i + tij + 1 < n:
                ok1[i + tij + 1][j] -= 1
            ok2[i][max(0, j - tij)] += 1
            if j + tij + 1 < m:
                ok2[i][j + tij + 1] -= 1
for i in range(1, n):
    for j in range(1, m):
        ok1[i][j] += ok1[i - 1][j]
        ok2[i][j] += ok2[i][j - 1]
for i in range(n):
    for j in range(m):
        if s[i][j] == ""*"":
            if not (ok1[i][j] or ok2[i][j]):
                ans = -1
                print(ans)
                exit()
k = len(ans)
print(k)
for ans0 in ans:
    print(*ans0)",O(n ^ 2)
"class Solution2(object):
    def compareVersion(self, version1, version2):
        v1, v2 = version1.split("".""), version2.split(""."")

        if len(v1) > len(v2):
            v2 += ['0' for _ in range(len(v1) - len(v2))]
        elif len(v1) < len(v2):
            v1 += ['0' for _ in range(len(v2) - len(v1))]

        i = 0
        while i < len(v1):
            if int(v1[i]) > int(v2[i]):
                return 1
            elif int(v1[i]) < int(v2[i]):
                return -1
            else:
                i += 1

        return 0

    def compareVersion2(self, version1, version2):
        v1 = [int(x) for x in version1.split('.')]
        v2 = [int(x) for x in version2.split('.')]
        while len(v1) != len(v2):
            if len(v1) > len(v2):
                v2.append(0)
            else:
                v1.append(0)
        return cmp(v1, v2)

    def compareVersion3(self, version1, version2):
        splits = (list(map(int, v.split('.'))) for v in (version1, version2))
        return cmp(*list(zip(*itertools.zip_longest(*splits, fillvalue=0))))

    def compareVersion4(self, version1, version2):
        main1, _, rest1 = ('0' + version1).partition('.')
        main2, _, rest2 = ('0' + version2).partition('.')
        return cmp(int(main1), int(main2)) or len(rest1 + rest2) and self.compareVersion4(rest1, rest2)",O(n)
"class Solution3(object):
    def countPairsOfConnectableServers(self, edges, signalSpeed):
        def bfs(u, p, dist):
            result = 0
            q = [(u, p, dist)]
            while q:
                new_q = []
                for u, p, dist in q:
                    if dist%signalSpeed == 0:
                        result += 1
                    for v, w in adj[u]:
                        if v == p:
                            continue
                        new_q.append((v, u, dist+w))
                q = new_q
            return result
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        result = [0]*(len(edges)+1)
        for u in range(len(result)):
            curr = 0
            for v, w in adj[u]:
                cnt = bfs(v, u, w)
                result[u] += curr*cnt
                curr += cnt
        return result",O(n ^ 2)
"class Solution(object):
    def peakIndexInMountainArray(self, arr):
        left, right = 0, len(arr)-1
        while left <= right:
            mid = left + (right-left)//2
            if arr[mid] > arr[mid+1]:
                right = mid-1
            else:
                left = mid+1
        return left",O(logn)
"n = int(input())
print(n // 2 + 1)",O(1)
"import sys

n,a,b = map(int, sys.stdin.readline().strip().split(' '))

ans = []
g = {i:set({}) for i in range(n)}

if a > 1 and b > 1:
	print(""NO"")
elif a == 1 and b == 1:
	if n == 1:
		print(""YES"")
		print(""0"")
	elif n < 4:
		print(""NO"")
	else:
		for i in range(n-1):
			g[i].add(i+1)
			g[i+1].add(i)
		for i in range(n):
			tmp = []
			for j in range(n):
				if i in g[j]:
					tmp.append('1')
				else:
					tmp.append('0')
			ans.append(''.join(tmp))
		print(""YES"")
		print('\n'.join(ans))
else:
	swap = False
	if a == 1:
		a, b = b, a
		swap = True
	for i in range(a-1,n-1):
		g[i].add(i+1)
		g[i+1].add(i)
	if swap:
		for i in range(n):
			tmp = []
			for j in range(n):
				if i == j:
					tmp.append('0')
				elif i not in g[j]:
					tmp.append('1')
				else:
					tmp.append('0')
			ans.append(''.join(tmp))
	else:
		for i in range(n):
			tmp = []
			for j in range(n):
				if i in g[j]:
					tmp.append('1')
				else:
					tmp.append('0')
			ans.append(''.join(tmp))
	print(""YES"")
	print('\n'.join(ans))",O(n ^ 2)
"n,m = map(int,input().split())
a = [int(x) for x in input().split()]

def gC(m,a):
    s = [0 for x in range(2*n + 1)]
    sum = n
    res = 0
    s[sum] = 1
    ad = 0
    for i in range(n):
        if a[i] < m:
            sum -=1
            ad -=s[sum]
        else:
            ad +=s[sum]
            sum +=1
        res +=ad
        s[sum] +=1
    return res

print(gC(m,a) - gC(m + 1,a))",O(nlogn)
"import math


class Solution(object):
    def reachNumber(self, target):
        target = abs(target)
        k = int(math.ceil((-1+math.sqrt(1+8*target))/2))
        target -= k*(k+1)/2
        return k if target%2 == 0 else k+1+k%2",O(1)
"a,b,c=list(map(int,input().split()))
R=list(map(int,input().split()))
G=list(map(int,input().split()))
B=list(map(int,input().split()))
dp=[[[0 for i in range(201)] for j in range(201)] for k in range(201)]

R.sort()
G.sort()
B.sort()
for i in range(len(R)+1):
    for j in range(len(G)+1):
        for k in range(len(B)+1):
            if(i and j):
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1])
            if(j and k):
                dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1])
            if(i and k):
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1])
print(dp[len(R)][len(G)][len(B)])",O(n ^ 3)
"dict={""Power"":""purple"",
      ""Time"":""green"",
      ""Space"":""blue"",
      ""Soul"":""orange"",
      ""Reality"":""red"",
      ""Mind"":""yellow""}
dict1={}
n=(int(input()))
while n:
    str=input()
    if str==""purple"":
        dict1[""Power""]=str
    elif str==""green"":
        dict1[""Time""]=str
    elif str==""blue"":
        dict1[""Space""]=str
    elif str==""orange"":
        dict1[""Soul""]=str
    elif str==""red"":
        dict1[""Reality""]=str
    elif str==""yellow"":
        dict1[""Mind""]=str
    n-=1

val=list(dict.keys())
val_list=list(dict1.keys())
l=[key for key in val if key not in val_list]
print(len(l))
for i in range(len(l)):
    print(l[i])",O(1)
"t=int(input())
for l in range(t):
	n=int(input())
	arr=list(map(int,input().split()))
	arr.sort()
	a=arr[-2]
	print(min(a-1,n-2))
",O(nlogn)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n = int(input())
*a, = map(int, input().split())
dp = [[0 for i in range(n + 1)] for j in range(n + 1)]
for i in range(n):
    dp[0][i] = a[i]
for i in range(1, n):
    for j in range(n - i + 1):
        dp[i][j] = dp[i - 1][j] ^ dp[i - 1][j + 1]
for i in range(1, n):
    for j in range(n - i):
        dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i - 1][j + 1])
for i in range(int(input())):
    l, r = map(int, input().split())
    print(dp[r - l][l - 1])",O(n ^ 2)
"import collections


class Solution2(object):
    def countSubTrees(self, n, edges, labels):
        def dfs(labels, adj, node, parent, result):
            count = [0]*26
            for child in adj[node]:
                if child == parent:
                    continue
                new_count = dfs(labels, adj, child, node, result)
                for k in range(len(new_count)):
                    count[k] += new_count[k]
            count[ord(labels[node]) - ord('a')] += 1
            result[node] = count[ord(labels[node]) - ord('a')]
            return count
        
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]*n
        dfs(labels, adj, 0, -1, result)
        return result",O(n)
"n = int(input())
k = n // 3
ans = []
for i in range(k):
    ans += [(0, 2 * i)]
    ans += [(1, 2 * i + 1)]
    ans += [(2, 2 * i)]
for i in range(n % 3):
    ans += [(-1000, -1000 + i)]
res = """"
for i in ans:
    res += "" "".join(map(str, i)) + ""\n""
print(res)",O(n)
"class Solution(object):
    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):
        max_run = -1
        i = max_prof = prof = waiting = 0
        run = 1
        while i < len(customers) or waiting > 0:
            if i < len(customers):
                waiting += customers[i] 
                i += 1
            boarding = min(waiting, 4) 
            waiting -= boarding
            prof += boarding * boardingCost - runningCost 
            if prof > max_prof:
                max_prof = prof
                max_run = run
            run += 1
        return max_run",O(n)
"def main():
    n, k = [int(x) for x in input().split(' ')]
    if k==1:
        print(n)
        return
    a = []
    b = {}
    a = [int(x) for x in input().split(' ')]
    a.sort()

    a=dict(zip(a,range(n)))
    count = {}

    for x in a:
        if x % k == 0 and int(x / k) in a:
            b[x] = b[int(x / k)]
            count[b[int(x / k)]] += 1
        else:
            b[x] = x
            count[x] = 1

    for x,y in count.items():
        n -= int(y / 2)

    print(n)

main()
",O(nlogn)
"import os, sys
from io import BytesIO, IOBase

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class dict(dict):
    def __missing__(self, key):
        return 0

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [tuple(inp(dtype)) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [tuple([i + 1] + inp(dtype)) for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

n, T = inp(int)
a = sorted(inp_enus(int, n), key=lambda x: x[-1])
be, en, ans = 0, n, []

while be < en:
    md, time, c = (be + en + 1) >> 1, 0, 0

    for _, i, j in a:
        if time + j <= T and i >= md:
            time += j
            c += 1

    if c >= md:
        be = md
    else:
        en = md - 1

l = be
for _, i, j in a:
    if be and i >= l:
        ans.append(_)
        be -= 1

print(f""{l}\n{l}"")
print(*ans)
",O(nlogn)
"class Solution(object):
    def decodeAtIndex(self, S, K):
        i = 0
        for c in S:
            if c.isdigit():
                i *= int(c)
            else:
                i += 1

        for c in reversed(S):
            K %= i
            if K == 0 and c.isalpha():
                return c

            if c.isdigit():
                i /= int(c)
            else:
                i -= 1",O(n)
"def somaDigitos(x):
    resp = 0
    while x > 0:
        resp += x%10
        x = x//10
    return resp

def isReallyBigNumber(x):
    return x - somaDigitos(x) >= s

n, s = input().split("" "")
n = int(n)
s = int(s)

count = 0

ini = 1
fim = n
i = 0
ans = False
while ini <= fim:
    meio = (ini + fim)//2
    if isReallyBigNumber(meio):
        ans = meio
        fim = meio - 1
    else:
        ini = meio + 1

if ans:
    print(n - ans + 1)
else:
    print(0)
",O(logn)
"class Node(object):
    def __init__(self, val, children):
        self.val = val
        self.children = children



class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):

    def encode(self, root):
        def encodeHelper(root, parent, index):
            if not root:
                return None
            node = TreeNode(root.val)
            if index+1 < len(parent.children):
                node.left = encodeHelper(parent.children[index+1], parent, index+1)
            if root.children:
                node.right = encodeHelper(root.children[0], root, 0)
            return node

        if not root:
            return None
        node = TreeNode(root.val)
        if root.children:
            node.right = encodeHelper(root.children[0], root, 0)
        return node

    def decode(self, data):
        def decodeHelper(root, parent):
            if not root:
                return
            children = []
            node = Node(root.val, children)
            decodeHelper(root.right, node)
            parent.children.append(node)
            decodeHelper(root.left, parent)

        if not data:
            return None
        children = []
        node = Node(data.val, children)
        decodeHelper(data.right, node)
        return node",O(n)
"n = int(input())
b = []
bb =[]
for i in range(n):
    x=int(input())
    idx = 0
    for j in range(len(b)):
        nxt = b[j] ^ x
        if nxt < x :
            x = nxt
            idx ^= bb[j]
    if x == 0:
        cnt = 0
        v = []
        for k in range(2000):
            if idx & (1 << k) :
                v.append(k)
        print(len(v),end=' ')
        for e in v:
            print(e,end=' ')
        print()
    else :
        print(0)
        idx ^= 1 << i
        b.append(x)
        bb.append(idx)
",np
"n, a, b = map(int, input().split())
z, o = ('01', '10')[a < b]
n *= not (a > 1 < b or 1 < n * a * b < 4)
l = [[z] * n for _ in range(n)]
for i in range(n):
    l[i][i] = '0'
for i in range(n - a * b):
    l[i][i + 1] = l[i + 1][i] = o
print(('YES', 'NO')[not n])
print('\n'.join(map(''.join, l)))
",O(n ^ 2)
"import heapq


class Solution(object):
    def minBuildTime(self, blocks, split):
        heapq.heapify(blocks)
        while len(blocks) != 1:
            x, y = heapq.heappop(blocks), heapq.heappop(blocks)
            heapq.heappush(blocks, y+split)
        return heapq.heappop(blocks)",O(nlogn)
"

class Solution(object):
    def minOperations(self, nums, k):
        return sum(nums)%k
",O(n)
"class Solution3(object):
    def isPowerOfFour(self, num):
        num = bin(num)
        return True if num[2:].startswith('1') and len(num[2:]) == num.count('0') and num.count('0') % 2 and '-' not in num else False",O(1)
"class Solution(object):
    def findChampion(self, grid):
        return next(u for u in range(len(grid)) if sum(grid[u]) == len(grid)-1)",O(n ^ 2)
"class Solution:
    left_check = staticmethod(lambda val, limit: val < limit)
    right_check = staticmethod(lambda val, limit: val > limit)

    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

        if (not self.isValid(root.left, root.val, self.left_check) or
            not self.isValid(root.right, root.val, self.right_check)):
            return False

        return self.isValidBST(root.left) and self.isValidBST(root.right)

    def isValid(self, root: Optional[TreeNode], limit: int, check) -> bool:
        if not root:
            return True
        if not check(root.val, limit):
            return False
        return (self.isValid(root.left, limit, check) and
                self.isValid(root.right, limit, check))
",O(n ^ 2)
"base=998244353;
def power(x, y):
    if(y==0):
        return 1
    t=power(x, y//2)
    t=(t*t)%base
    if(y%2):
        t=(t*x)%base
    return t;
def inverse(x):
    return power(x, base-2)
f=[1]
iv=[1]
for i in range(1, 5555):
    f.append((f[i-1]*i)%base)
    iv.append(inverse(f[i]))
def C(n, k):
    return (f[n]*iv[k]*iv[n-k])%base
def candy(n, k):

    return C(n+k-1, k-1)
def count_game(k, n, x):
    if(k==0):
        if(n==0):
            return 1
        else:
            return 0
    ans=0
    for i in range(0, k+1):
        t=n-x*i

        if(t<0):
            break
        if(i%2):
            ans=(ans-C(k, i)*candy(t, k))%base
        else:
            ans=(ans+C(k, i)*candy(t, k))%base
    return ans
p, s, r= list(map(int, input().split()))
gamesize=count_game(p, s-r, int(1e18))
gamesize=inverse(gamesize)
ans=0;
for q in range(r, s+1):
    for i in range(0, p):
        t=s-(i+1)*q
        if(t<0):
            break

        ans=(ans+C(p-1, i)*count_game(p-i-1, t, q)*gamesize*inverse(i+1))%base
print(ans)
",O(n ^ 3)
"a=int(input())
if a>0:
    print(a)
else:
    a=a-2*a
    k=a//10
    b=a%10
    c=(a//100)*10+b
    if k<c:
        if k!=0:
            print('-%d' %k)
        else:
            print(k)
    else:
        if c!=0:
            print('-%d' %c)
        else:
            print(c)",O(1)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except ModuleNotFoundError:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, = getIntList()

s1 = input() +'0'
s2 = input() +'0'

res = 0

i = 0
while i<N:
    if s1[i] != s2[i]:
        if s1[i+1] == s2[i] and s2[i+1] == s1[i]:
            res+=1
            i+=2
            continue
        res+=1
    i+=1
print(res)
",O(n)
"class Solution(object):
    def checkPalindromeFormation(self, a, b):
        def is_palindrome(s, i, j):
            while i < j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True

        def check(a, b):
            i, j = 0, len(b)-1
            while i < j:
                if a[i] != b[j]:
                    return is_palindrome(a, i, j) or is_palindrome(b, i, j)
                i += 1
                j -= 1
            return True

        return check(a, b) or check(b, a)",O(n)
"class Solution2(object):
    def copyRandomList(self, head):
        dummy = Node(0)
        current, prev, copies = head, dummy, {}

        while current:
            copied = Node(current.val)
            copies[current] = copied
            prev.next = copied
            prev, current = prev.__next__, current.__next__

        current = head
        while current:
            if current.random:
                copies[current].random = copies[current.random]
            current = current.__next__

        return dummy.__next__",O(n)
"import bisect
from collections import defaultdict,Counter
import math

def solve(a):
    count=0
    mp=Counter(a)
    for i in range(len(a)):
        flag=0
        for j in range(31):
            x=int(1<<j)-a[i]
            if (x in mp) and (x==a[i] and mp[x]>1):

                flag=1
                break
            elif (x in mp) and (x!=a[i] and mp[x]>0):
                flag=1
                break
        if flag==0:
            count+=1

    return count

n=int(input(''))
a=list(map(int,input('').split()))
print(solve(a))
",O(nlogn)
"class Solution2(object):
    def deleteTreeNodes(self, nodes, parent, value):
        result = [1]*nodes
        for i in reversed(range(1, nodes)):
            value[parent[i]] += value[i]
            result[parent[i]] += result[i] if value[i] else 0
        return result[0]",O(n)
"class Solution2(object):
    def minLength(self, s, numOps):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def check(x):
            if x == 1:
                cnt = sum(int(x) != i%2 for i, x in enumerate(s))
                return min(cnt, len(s)-cnt) <= numOps
            return sum(l//(x+1) for l in arr) <= numOps
    
        arr = []
        cnt = 0
        for i in range(len(s)):
            cnt += 1
            if i+1 == len(s) or s[i+1] != s[i]:
                arr.append(cnt)
                cnt = 0
        return binary_search(1, len(s), check)",O(nlogn)
"def formula(n, x):
    return x*(x + 1)//2 - (n-x)

def solve():
    n, k = map(int, input().split())
    l = 1
    r = n
    x = 0
    while l <= r:
        x = (l+r)//2
        res = formula(n, x)
        if res == k:
            break
        elif res < k:
            l = x + 1
        else:
            r = x - 1
    print(n-x)
    return

solve()",O(logn)
"class Solution2(object):
    def maxChunksToSorted(self, arr):
        def compare(i1, i2):
            return arr[i1]-arr[i2] if arr[i1] != arr[i2] else i1-i2

        idxs = [i for i in range(len(arr))]
        result, max_i = 0, 0
        for i, v in enumerate(sorted(idxs, cmp=compare)):
            max_i = max(max_i, v)
            if max_i == i:
                result += 1
        return result",O(nlogn)
"def ask(a, b):
    print(""?"", a, b, flush=True)
    return int(input()) <= 0

def solve(M):
    a, b = 0, 0
    less = ask(0, 0)

    for i in range(M - 1, -1, -1):
        bit = 1 << i

        if less:
            if not ask(a | bit, b | bit):
                b |= bit
                less = ask(a, b)
            elif ask(a | bit, b):
                a |= bit
                b |= bit
        else:
            if ask(a | bit, b | bit):
                a |= bit
                less = ask(a, b)
            elif ask(a | bit, b):
                a |= bit
                b |= bit

    print(""!"", a, b, flush=True)

if __name__ == '__main__':
    solve(30)
",O(1)
"class Solution(object):
    def minEnd(self, n, x):
        n -= 1
        base_n = base_x = 1
        while base_n <= n:
            if (x&base_x) == 0:
                if n&base_n:
                    x |= base_x
                base_n <<= 1
            base_x <<= 1
        return x",O(logn)
"x1, y1, x2, y2, x3, y3 = map(int, input().split())
rect1 = [x1, y1]
rect2 = [x2, y2]
rect3 = [x3, y3]
def func():
    rect11 = [x1, y1]
    rect22 = [x2, y2]
    rect33 = [x3, y3]
    rect1 = [x1, y1]
    rect2 = [x2, y2]
    rect3 = [x3, y3]

    recta = [x1, y1]
    rectb = [x2, y2]
    rectc = [x3, y3]
    for i in rect11:
        for ii in rect22:
            for iii in rect33:
                if i==ii:
                    rect1.remove(i)
                    rect2.remove(ii)
                    if rect1[0]+rect2[0]==iii:
                        rect3.remove(iii)
                        if i+rect3[0]==iii:
                            print(iii)
                            for j in range(iii):
                                if j<rect1[0]:
                                    print(""C""*rect3[0]+""A""*i)
                                else:
                                    print(""C""*rect3[0]+""B""*ii)
                            exit()
                rect1=recta.copy()
                rect2=rectb.copy()
                rect3=rectc.copy()

                if i==iii:
                    rect1.remove(i)
                    rect3.remove(iii)
                    if rect1[0]+rect3[0]==ii:
                        rect2.remove(ii)
                        if i+rect2[0]==ii:
                            print(ii)

                            for j in range(ii):
                                if j<rect1[0]:
                                    print(""B""*rect2[0]+""A""*i)
                                else:
                                    print(""B""*rect2[0]+""C""*iii)
                            exit()
                rect1 = recta.copy()
                rect2 = rectb.copy()
                rect3 = rectc.copy()
                if ii==iii:
                    rect2.remove(ii)
                    rect3.remove(iii)
                    if rect2[0]+rect3[0]==i:
                        rect1.remove(i)
                        if i==rect1[0]+ii:
                            print(i)
                            for j in range(i):
                                if j<rect2[0]:
                                    print(""A""*rect1[0]+""B""*ii)
                                else:print(""A""*rect1[0]+""C""*iii)
                            exit()
                rect1=recta.copy()
                rect2=rectb.copy()
                rect3=rectc.copy()
    return print(-1)
for i in rect1:
    for ii in rect2:
        for iii in rect3:
            recta = [x1, y1]
            rectb = [x2, y2]
            rectc = [x3, y3]

            if i==ii==iii:
                rect1.remove(i)
                rect2.remove(i)
                rect3.remove(i)

            if rect1[0]+rect2[0]+rect3[0]==i:
                print(i)
                for j in range(i):
                    print(""A""*rect1[0]+""B""*rect2[0]+""C""*rect3[0])
                exit()
            rect1=recta
            rect2=rectb
            rect3=rectc

func()
",np
"class Solution(object):
    def maximumScoreAfterOperations(self, edges, values):
        def iter_dfs():
            dp = [0]*len(values)
            stk = [(1, 0, -1)]
            while stk:
                step, u, p = stk.pop() 
                if step == 1:
                    if len(adj[u]) == (1 if u else 0):
                        dp[u] = values[u]
                        continue
                    stk.append((2, u, p))
                    for v in reversed(adj[u]):
                        if v != p:
                            stk.append((1, v, u))
                elif step == 2:
                    dp[u] = min(sum(dp[v] for v in adj[u] if v != p), values[u]) 
            return dp[0]

        adj = [[] for _ in range(len(values))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return sum(values)-iter_dfs()",O(n)
"import os, sys, atexit
from io import BytesIO, StringIO

input = BytesIO(os.read(0, os.fstat(0).st_size)).readline
_OUTPUT_BUFFER = StringIO()
sys.stdout = _OUTPUT_BUFFER

@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())

n, m = map(int, input().split())
arr = [0] * n
for i in range(n):
    temp = list(map(int, input().split()))
    arr[i] = temp
x = 1
N = 2 ** m - 1
lo = 1
hi = 1000000009
ind = [0, 0]
while 1:
    l = {}
    freq = [0] * (2 ** m)
    for i in range(n):
        an = 0
        for j in range(m):
            if arr[i][j] >= x: an += 2 ** (m - j - 1)
        if freq[an] == 0:
            l[i] = an
        freq[an] = 1

    ch = 0
    for k1, v1 in l.items():
        for k2, v2 in l.items():

            if v1 | v2 == N:
                ch = 1
                ind[0] = k1 + 1
                ind[1] = k2 + 1

                break
        if ch: break
    if ch:
        lo = x
        x = x * 2
    else:
        hi = x
        break
ans = lo
while hi - lo > 1:
    x = (lo + hi) // 2
    l = {}
    freq = [0] * (2 ** m)
    for i in range(n):
        an = 0
        for j in range(m):
            if arr[i][j] >= x: an += 2 ** (m - j - 1)
        if freq[an] == 0:
            l[i] = an
        freq[an] = 1

    ch = 0
    for k1, v1 in l.items():
        for k2, v2 in l.items():

            if v1 | v2 == N:
                ch = 1
                ind[0] = k1 + 1
                ind[1] = k2 + 1

                break
        if ch: break
    if ch:
        lo = x
    else:
        hi = x
ans = lo

if ind[0] == 0: print(""1 1"")
else: print(*ind)",np
"import collections


class Solution(object):
    def kthDistinct(self, arr, k):
        count = collections.Counter(arr)
        arr = [x for x in arr if count[x] == 1]
        return arr[k-1] if k-1 < len(arr) else """"",O(n)
"n = int(input())
a = sorted(list(map(int,input().split())))
bal = 0
if a.count(0)>1:
    print('cslnb')
    exit()
if n-len(set(a))>1:
    print('cslnb')
    exit()
if n-len(set(a))==1:
    for i in range(1,n):
        if a[i]==a[i-1]:
            if a[i]-1 in a:
                print('cslnb')
                exit()
            break
if n==1:
    print('cslnb' if not a[0] % 2 else 'sjfnb')
    exit()

for i in range(n):
    bal+=a[i]-i
print('sjfnb'if bal%2 else 'cslnb')",O(n)
"class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [0] * n

        for i in range(n):
            prod = 1
            for j in range(n):
                if i == j:
                    continue
                prod *= nums[j]

            res[i] = prod
        return res
",O(n ^ 2)
"from math import gcd

def t_prime(n):
    if n == 1:
        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:
            return False
    return True

primes = [i for i in range(2,10**5) if t_prime(i)]
pset = set(primes)

n, k = map(int, input().split())
l = list(map(int, input().split()))

if k == 1:
    print(0)
    exit()

for i in range(n):
    for j in range(i):
        u, v = l[i], l[j]
        poss = gcd(u,v)
        poss2 = max(u,v)//poss
        smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:
            primes.append(smol)
            pset.add(smol)

powers = set()

count = 0
outLs = []
pgood = []
for p in primes:
    curr = []
    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:
            v2 //= p
        if v2 == 1:
            curr.append(v)
            powers.add(v)
    if len(curr) > 1:
        count += len(curr)
        outLs.append(curr)
        pgood.append(p)

order = [(len(lis), lis) for lis in outLs]
order.sort(key = lambda x: x[0])

if len(order) == 0:
    print(0)
    exit()

if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1
    need = -1
    last = []

    for v in l:
        if v in powers:
            continue

        v2 = v
        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:
                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):
            extra = v
            last = primesn
            need = len(last)
            assert need >= 2

    if need == -1 or 2 * need + 1 > k:
        print(0)
        exit()

    other = []
    out = [extra]

    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:
                works = True
                break
        if works:
            out.append(a)
            out.append(b)
        else:
            other.append(a)
            other.append(b)

    assert len(out) == 2 * need + 1
    assert (k - 2 * need - 1) % 2 == 0

    ret = out + other[:(k - 2*need - 1)]
    assert len(ret) == k

    print(' '.join(map(str,ret)))
    exit()

out = []
need = k
for i in range(len(order)):
    assert need != 1

    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0

assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:
        break

    if v in powers:
        continue

    v2 = v
    for p in pgood:
        while v2 % p == 0:
            v2 //= p
    if v2 == 1:
        out.append(v)
        need -= 1

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)
",np
"class Solution2(object):
    def maxIntersectionCount(self, y):
        events = []
        for i in range(len(y)-1):
            left, right = 2*y[i], 2*y[i+1]+(-1 if y[i] < y[i+1] else +1)
            events.append((min(left, right), +1))
            events.append((max(left, right)+1, -1))
        events.append((2*y[-1], +1))
        events.append((2*y[-1]+1, -1))
        events.sort()
        result = cnt = 0
        for _, c in events:
            cnt += c
            result = max(result, cnt)
        return result",O(nlogn)
"import os, sys
from io import BytesIO, IOBase
from copy import deepcopy

def main():
    n = rint()
    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []
    for i in range(4):
        ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()])
    print(['No', 'Yes'][a2.mat in ans])

class Matrix:
    def __init__(self, r, c, mat=None, id=None):
        self.r, self.c = r, c

        if mat != None:
            self.mat = deepcopy(mat)
        else:
            self.mat = [[0 for i in range(c)] for j in range(r)]

    def __add__(self, other):
        mat0 = Matrix(self.r, self.c)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][j] = self.mat[i][j] + other.mat[i][j]

        return mat0

    def __mul__(self, other):
        mat0 = Matrix(self.r, other.c)

        for i in range(self.r):
            for j in range(other.c):
                for k in range(self.c):
                    mat0.mat[i][j] += self.mat[i][k] * other.mat[k][j]

        return mat0

    def dot_mul(self, other):
        res = 0
        for i in range(self.r):
            for j in range(self.c):
                res += self.mat[i][j] * other.mat[j][i]

        return res

    def trace(self):
        res = 0
        for i in range(self.r):
            res += self.mat[i][i]

        return res

    def rotate(self):
        mat0 = Matrix(self.c, self.r)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]

        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r
        return self.mat

    def flipv(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def fliph(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def mat_pow(self, mat, p, mod=None):
        sq = Matrix(mat.r, mat.r, id=1)

        while p:
            if p & 1:
                p -= 1
                sq = sq * mat

            p //= 2
            mat = mat * mat

        return sq.mat

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [list(rstr()) for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",O(n ^ 2)
"class Solution:
    def hammingWeight(self, n: int) -> int:
        res = 0
        for i in range(32):
            if (1 << i) & n:
                res += 1
        return res
",O(1)
"n,m=map(int,input().split())
arr=[]
for i in range(m):
  arr.append(list(map(int,input().split())))
k=0;ans=str()
for i in range(n):
  ans+=str(k^1)
  k=k^1
print(ans)
",O(n)
"import os,sys
from io import BytesIO,IOBase

def main():
    n,c = map(int,input().split())
    a = list(map(int,input().split()))
    nums = [[0] for _ in range(500001)]
    freq,minus = [0]*500001,0
    for i in a:
        if i == c:
            minus += 1
        else:
            freq[i] += 1
            nums[i].append(freq[i]-minus)
    tot = minus
    suff = [i[:] for i in nums]
    for i in range(500001):
        for j in range(len(nums[i])-2,0,-1):
            suff[i][j] = max(suff[i][j],suff[i][j+1])
    freq,ans = [0]*500001,tot
    for i in a:
        if i == c:
            continue
        freq[i] += 1
        ans = max(ans,suff[i][freq[i]]-nums[i][freq[i]]+1+tot)
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")
sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",O(n)
"class Solution(object):
    def maxRectangleArea(self, xCoord, yCoord):
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] += val
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret += self.__bit[i]
                    i -= (i & -i)
                return ret
    
        points = sorted((xCoord[i], yCoord[i]) for i in range(len(xCoord)))
        y_to_idx = {y:idx for idx, y in enumerate(sorted(set(yCoord)))}
        bit = BIT(len(y_to_idx))
        lookup = {}
        result = -1
        for i, (x, y) in enumerate(points):
            y_idx = y_to_idx[y]
            bit.add(y_idx, +1)
            if not (i-1 >= 0 and points[i-1][0] == x):
                continue
            prev_y_idx = y_to_idx[points[i-1][1]]
            curr = bit.query(y_idx)-bit.query(prev_y_idx-1)
            if (prev_y_idx, y_idx) in lookup and lookup[prev_y_idx, y_idx][0] == curr-2:
                result = max(result, (x-lookup[prev_y_idx, y_idx][1])*(y-points[i-1][1]))
            lookup[prev_y_idx, y_idx] = (curr, x)
        return result",O(nlogn)
"class Solution5(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=lambda _: None,
                         query_fn=lambda x, y: max(x, y),
                         update_fn=lambda x, y: max(x, y)):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(self.tree[x], h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def query(self, L, R):
                if L > R:
                    return None
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L //= 2
                    R //= 2
                return self.query_fn(left, right)

        price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))}
        right = [NEG_INF]*len(prices)
        st = SegmentTree(len(price_to_idx))
        for i in reversed(range(len(prices))):
            right[i] = st.query(price_to_idx[prices[i]]+1, len(price_to_idx)-1)
            st.update(price_to_idx[prices[i]], profits[i])
        result = NEG_INF
        st = SegmentTree(len(price_to_idx))
        for i in range(len(prices)):
            left = st.query(0, price_to_idx[prices[i]]-1)
            if left is not None and right[i] is not None:
                result = max(result, left+profits[i]+right[i])
            st.update(price_to_idx[prices[i]], profits[i])
        return result if result != NEG_INF else -1",O(nlogn)
"R = lambda: map(int, input().split())

n, r = R()
xs = list(R())
ys = []
for i in range(n):
    ys.append(max([((2 * r) ** 2 - abs(xs[i] - xs[j]) ** 2) ** 0.5 + ys[j] for j in range(i) if abs(xs[i] - xs[j]) <= 2 * r], default=r))
print(*ys)",O(n ^ 2)
"a = [0 for i in range(0, 256)]
n,k = input().split(' ')
k = int(k)
for c in input().split(' '):
        c = int(c)
        if a[c] != 0:
            print(a[c]-1, end=' ')
        else:
            for x in range(c, c-k, -1):
                if a[x] == 0:
                    i = x
                else:
                    if c-a[x]+1<k:
                        i = a[x]-1
                    break
                if x == 0:
                    break
            for x in range(int(i), c+1):
                a[x] = i + 1
            print(i, end=' ')
",O(n ^ 2)
"n=int(input())
if(n<3):
    print(n)
else:

    if(n%2!=0):
        print(n*(n-1)*(n-2))
    elif(n%3==0):
        print((n-1)*(n-2)*(n-3))
    else:
        print(n*(n-1)*(n-3))",O(1)
"class Solution(object):
    def numSubarrayBoundedMax(self, A, L, R):
        def count(A, bound):
            result, curr = 0, 0
            for i in A :
                curr = curr + 1 if i <= bound else 0
                result += curr
            return result

        return count(A, R) - count(A, L-1)",O(n)
"n,ll,r,x=map(int,input().split("" ""))
l=list(map(int,input().split("" "")))
subset = []
for i in range(1,(2**n)):
  sub=[]
  for j in range(n):
    if (1<<j)&i>0:
      sub.append(l[j])
  subset.append(sub)
c=0

for i in subset:
  if len(i)>1:
    su=sum(i)
    if (su>=ll and su<=r) and ((max(i)-min(i))>=x):
      c+=1
print(c)",np
"n = int(input())

L = list(map(int, input().split("" "")))
R = list(map(int, input().split("" "")))

LR = list(zip(L,R))

index_to_candies = {}
candy = n

for nn in range(n,0,-1):
    if(len(index_to_candies) == n):
        break

    zero_index = []
    for idx, (l,r) in enumerate(LR):
        if (l,r) == (0,0) and not idx in index_to_candies:
            index_to_candies[idx] = nn
            zero_index.append(idx)

    if len(zero_index) == 0:
        print(""NO"")
        exit()

    dec_left = 0
    dec_right = len(zero_index)
    zero_index_idx = 0

    for idx, (l,r) in enumerate(LR):
        if zero_index_idx < len(zero_index) and zero_index[zero_index_idx] == idx:

            zero_index_idx += 1
            dec_left += 1
            dec_right -= 1

        if (l,r) != (0,0):
            LR[idx] = (l-dec_left,r-dec_right)
            if LR[idx][0] < 0 or LR[idx][1] < 0:
                print(""NO"")
                exit()
print(""YES"")
j = []
for i in range(n):
    j.append(str(index_to_candies[i]))
print("" "".join(j))
",O(n ^ 2)
"L1=list(map(int, input().split()))
numList=list(map(int, input().split()))
length=L1[0]
targetnumber=L1[1]
pos=numList.index(targetnumber)
pos_r=pos+1
rem=0
right={0:1}
left={0:1}
while pos_r<=length-1:
    if numList[pos_r]>targetnumber:
        rem+=1
    else:
        rem-=1
    if rem not in right:
        right[rem]=1
    else:
        right[rem]+=1
    pos_r+=1
pos_l=pos-1
rem=0
while pos_l>=0:
    if numList[pos_l]>targetnumber:
        rem+=1
    else:
        rem-=1
    if rem not in left:
        left[rem]=1
    else:
        left[rem]+=1
    pos_l-=1
sum=0
for number_l in left:
    if number_l*(-1) in right:
        sum += (left[number_l] * right[(-1) * number_l])
    if 1-number_l in right:
        sum += (left[number_l] * right[1-number_l])
print(sum)",O(nlogn)
"x, k = map(int, input().split())
if x == 0:
    print(0)
else:
    mod = 10 ** 9 + 7
    p = pow(2, k, mod)
    ans = (x * (p * 2) - (p - 1)) % mod
    print(ans)",O(logn)
"class Solution(object):
    def minimumTimeToInitialState(self, word, k):
        def ceil_divide(a, b):
            return (a+b-1)//b
    
        def z_function(s): 
            z = [0]*len(s)
            l, r = 0, 0
            for i in range(1, len(z)):
                if i <= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 > r:
                    l, r = i, i+z[i]-1
            return z

        z = z_function(word)
        for i in range(k, len(word), k):
            if z[i] == len(word)-i:
                return i//k
        return ceil_divide(len(word), k)",O(n)
"import sys
from array import array
import typing as Tp

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

T = Tp.TypeVar('T')

class FenwickSum(Tp.Generic[T]):
    __slots__ = ['nodes', 'size', 'unit']

    def __init__(self, size: int, default: T, unit: T):
        self.nodes = [default] * (size + 1)
        self.size = size + 1
        self.unit = unit

    def add(self, index: int, value: T):
        while index < self.size:
            self.nodes[index] += value
            index += index & -index

    def sum(self, right: int) -> T:
        result = self.unit

        while right:
            result += self.nodes[right]
            right -= right & -right

        return result

def main():
    n = int(input())
    a = list(map(int, input().split()))
    b = [x for x in a if x != -1]
    mod = 998244353
    minus = n - len(b)
    m_inv = pow(minus, mod - 2, mod)
    ans = 0

    bit = FenwickSum[int](n, 0, 0)
    for x in reversed(b):
        ans += bit.sum(x)
        bit.add(x, 1)

    ans += minus * (minus - 1) * pow(4, mod - 2, mod) % mod

    acc_u, m = [0] * (n + 1), minus
    for x in a:
        if x == -1:
            m -= 1
        else:
            acc_u[x] = m

    for i in range(n - 1, 0, -1):
        acc_u[i] += acc_u[i + 1]
        if acc_u[i] >= mod:
            acc_u[i] -= mod

    acc_d, m = [0] * (n + 1), minus
    for x in reversed(a):
        if x == -1:
            m -= 1
        else:
            acc_d[x] = m

    for i in range(1, n + 1):
        acc_d[i] += acc_d[i - 1]
        if acc_d[i] >= mod:
            acc_d[i] -= mod

    for x in set(range(1, n + 1)) - set(b):
        ans = (ans + (acc_u[x] + acc_d[x]) * m_inv) % mod

    print(ans % mod)

if __name__ == '__main__':
    main()
",O(nlogn)
"n=int(input())
arr=list(map(int,input().split()));ans=0
while len(arr)!=0:
 e=arr.pop(0)
 ans+=arr.index(e)
 arr.remove(e)
print(ans)
",O(n ^ 2)
"a = [str(i) for i in input().split()]
a.sort()
first = a[0]
second = a[1]
third = a[2]
firstnum = int(first[0])
secondnum = int(second[0])
thirdnum = int(third[0])
if(first == second):
	if(second == third):
		print(0)
	else:
		print(1)
elif(second == third):
	print(1)
elif(first[1] == second[1] and second[1] == third[1]):
	if(firstnum +1 == secondnum and secondnum + 1 == thirdnum):
		print(0)
	elif(firstnum + 1 == secondnum or firstnum + 2 == secondnum):
		print(1)
	elif(secondnum + 1 == thirdnum or secondnum + 2 == thirdnum):
		print(1)
	else:
		print(2)
elif(first[1] == second[1] and (firstnum + 1 == secondnum or firstnum+2 == secondnum)):
	print(1)
elif(second[1] == third[1] and (secondnum + 1 == thirdnum or secondnum+2 == thirdnum)):
	print(1)
elif(first[1] == third[1] and (firstnum + 1 == thirdnum or firstnum + 2 == thirdnum)):
	print(1)
else:
	print(2)",O(nlogn)
"def main():
    n, k = map(int, input().split())
    p = list(map(int, input().split()))
    solve(n, k, p)

def solve(n, k, p):
    group = 256 * [None]
    r = p[:]
    for i, pi in enumerate(p):

        if group[pi] is not None:
            r[i] = group[pi][0]
        else:
            lo = pi
            while lo >= 0 and pi - lo < k and group[lo] is None:
                lo -= 1
            if lo < 0 or pi - lo == k:
                lo += 1
                hi = pi + 1
            else:
                if pi - group[lo][0] < k:
                    lo = group[lo][0]
                    hi = pi + 1
                else:
                    lo += 1
                    hi = pi + 1
            lohi = (lo, hi)
            for j in range(lo, hi):
                group[j] = lohi
            r[i] = group[pi][0]
    print("" "".join(map(str, r)))

main()
",O(n ^ 2)
"class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        LIS = [1] * len(nums)

        for i in range(len(nums) - 1, -1, -1):
            for j in range(i + 1, len(nums)):
                if nums[i] < nums[j]:
                    LIS[i] = max(LIS[i], 1 + LIS[j])
        return max(LIS)
",O(n ^ 2)
"class Solution(object):
    def countSegments(self, s):
        result = int(len(s) and s[-1] != ' ')
        for i in range(1, len(s)):
            if s[i] == ' ' and s[i-1] != ' ':
                result += 1
        return result

    def countSegments2(self, s):
        return len([i for i in s.strip().split(' ') if i])",O(n)
"from itertools import combinations
num,min_dif,max_dif,easy_hard_dif=map(int, input().split("" ""))
arr=[int(m) for m in input().split("" "")]
all_combinations=[]
for x in range(2, num+1):
    combs=combinations(arr, x)
    for abc in combs:
        all_combinations.append(list(abc))
possible_answers=0
for a in all_combinations:
    if sum(a)>=min_dif and sum(a)<=max_dif and max(a)-min(a)>=easy_hard_dif:
        possible_answers+=1
print(possible_answers)",np
"n = int(input())
x, y = 1, 9
n -= 1
while n > x * y:
    n -= x * y
    x += 1
    y *= 10
a = 10 ** (x - 1) + n // x
print(str(a)[n % x])",O(logn)
"input = raw_input

def f(n):
    t = (n + 1) // 2
    return t if n % 2 == 0 else -t

for i in range(int(input())):
    le, rg = map(int, input().split())

    print(f(rg) - f(le - 1))
",O(1)
"n, m = map(int,input().split())

max_dist = (n - 1)* n//2
min_dist = max_dist
curr_value = max_dist
for i in range(n):
    curr_value = i * (i + 1) // 2 + (n - 1 - i)*(n - i)//2
    min_dist = min(min_dist, curr_value)

answer = 0
add_value = 0

for i in range(m):
    x, d = map(int, input().split())
    answer+=x
    if d >= 0:
        add_value += d*max_dist
    else:
        add_value += d * min_dist

print(answer + (add_value / n))
",O(n)
"def factorial(n) :
    ans = 1
    if (n == 0) :
        return 1
    for i in range(1, n + 1) :
        ans *= i
    return ans
def ncr(n , r) :
    n = abs(n)
    if r > n :
        return 0
    ans = factorial(n)
    ans = ans//(factorial(n-r))
    ans = ans//(factorial(r))
    return ans

if __name__ == ""__main__"" :
    A = input()
    B = input()
    QMarks = B.count('?')
    TotalA = A.count('+') - A.count('-')
    TotalB = B.count('+') - B.count('-')
    denominator = 2**QMarks
    if QMarks < abs(TotalA - TotalB) :
        print(0)
    else :
        x = (QMarks - abs(TotalA - TotalB))//2
        x += abs(TotalA - TotalB)
        num = ncr(QMarks,x)
        print(num/denominator)",np
"n,m=map(int,input().split())
o=0
c=0
diff=[]
while n:
    n-=1
    a,b=map(int,input().split())
    diff.append(a-b)
    o+=a
    c+=b

if m >=o:
    print(0)
elif m <c:
    print(-1)
else:
    diff.sort(reverse=True)
    nd=o-m

    for i in range(len(diff)):

        nd-=diff[i]
        if nd<=0:
            print(i+1)
            break
",O(nlogn)
"if input()=='1':
 print(input())
else:
 x,*a,y=sorted(map(int,input().split()))
 print(y-x+sum(map(abs,a)))",O(nlogn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def maxSumBST(self, root):
        result = 0
        stk = [[root, None, []]]
        while stk:
            node, tmp, ret = stk.pop()
            if tmp:
                lvalid, lsum, lmin, lmax = tmp[0]
                rvalid, rsum, rmin, rmax = tmp[1]
                if lvalid and rvalid and lmax < node.val < rmin:
                    total = lsum + node.val + rsum
                    result = max(result, total)
                    ret[:] = [True, total, min(lmin, node.val), max(node.val, rmax)]
                    continue
                ret[:] = [False, 0, 0, 0]
                continue
            if not node:
                ret[:] = [True, 0, float(""inf""), float(""-inf"")]
                continue
            new_tmp = [[], []]
            stk.append([node, new_tmp, ret])
            stk.append([node.right, None, new_tmp[1]])
            stk.append([node.left, None, new_tmp[0]])
        return result",O(n)
"line1 = str(input());
line2 = str(input());

truePosition = 0;
fakePosition = 0;
questionMarks = 0;
for i in range(len(line1)):
	if line1[i] == ""+"":
		truePosition += 1;
	if line1[i] == ""-"":
		truePosition -= 1;
	if line2[i] == ""+"":
		fakePosition += 1;
	if line2[i] == ""-"":
		fakePosition -= 1;
	if line2[i] == ""?"":
		questionMarks += 1;

distanceToMove = abs(truePosition - fakePosition);

def factorial(x):
	if x == 0:
		return 1;
	else:
		return x * factorial(x-1);

def probToMove(dist, questionMarks):
	if(dist > questionMarks):
		return float(0);
	reducedDist = questionMarks - dist;
	if(reducedDist % 2 != 0):
		return float(0);
	dist = reducedDist//2 + dist;
	headsFlips = 1;
	headsOrders = factorial(questionMarks) / ((factorial(dist) *factorial(questionMarks-dist)));

	totalPossibilities = 2**questionMarks;

	return headsFlips * headsOrders / totalPossibilities;

print(probToMove(distanceToMove, questionMarks));",np
"import collections


class Solution(object):
    def balancedString(self, s):
        count = collections.Counter(s)
        result = len(s) 
        left = 0
        for right in range(len(s)):
            count[s[right]] -= 1
            while left < len(s) and \
                  all(v <= len(s)//4 for v in count.values()):
                result = min(result, right-left+1)
                count[s[left]] += 1
                left += 1
        return result",O(n)
"class Solution2(object):
    def maxJumps(self, arr, d):
        left, decreasing_stk = [[] for _ in range(len(arr))], []
        for i in range(len(arr)):
            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
                if i - decreasing_stk[-1] <= d:
                    if left[i] and arr[left[i][-1]] != arr[decreasing_stk[-1]]:
                        left[i] = []
                    left[i].append(decreasing_stk[-1])
                decreasing_stk.pop()
            decreasing_stk.append(i)
        right, decreasing_stk = [[] for _ in range(len(arr))], []
        for i in reversed(range(len(arr))):
            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
                if decreasing_stk[-1] - i <= d:
                    if right[i] and arr[right[i][-1]] != arr[decreasing_stk[-1]]:
                        right[i] = []
                    right[i].append(decreasing_stk[-1])
                decreasing_stk.pop()
            decreasing_stk.append(i)

        dp = [0]*len(arr)
        for a, i in sorted([a, i] for i, a in enumerate(arr)):
            dp[i] = 1
            for j in itertools.chain(left[i], right[i]):
                dp[i] = max(dp[i], dp[j]+1)
        return max(dp)




class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=max,
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h): 
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])
        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1: 
                self.__apply(L, h)
                L += 1
            if R & 1 == 0: 
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R): 
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = self.default_val
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1: 
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0: 
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return "","".join(map(str, showList))",O(nlogn)
"import sys
input = sys.stdin.readline

n = int(input())
mod = pow(10, 9) + 7
a = list(map(int, input().split()))
l = 100000
cnt = [0] * (l + 1)
for i in a:
    cnt[i] += 1
pow2 = [1]
for _ in range(l):
    pow2.append(2 * pow2[-1] % mod)
ans = pow2[n] - 1
x = [-1] * (l + 1)
for i in range(2, l + 1):
    c = cnt[i]
    xi = x[i]
    for j in range(2 * i, l + 1, i):
        c += cnt[j]
        x[j] -= xi
    ans += xi * (pow2[c] - 1) % mod
    ans %= mod
print(ans)",np
"s = input()
n = len(s)
m = n - 1;
while m > 0:
    find = False
    for i in range(0, n - m):
        for j in range(i + 1, n - m + 1):
            match = True
            for k in range(0, m):
                if s[i+k] != s[j+k]:
                    match = False
                    break
            if match:
                find = True
                break
        if find:
            break
    if find:
        break
    m -= 1
print(m)",O(n ^ 3)
"def win1():
    if n==k or r[k+1]==n or l[n-k]==1:
        return True
    for i in range(2,n-k+1):
        if l[i-1]==1 and r[i+k]==n and a[i-1]==a[i+k]:
            return True
    return False

def win2():
    if 2*k<n:
        return False
    for i in range(2,n-k+1):
        if l[i-1]!=1 or r[i+k]!=n:
            return False
    return True

if __name__ == ""__main__"":
    s=input().split()
    n,k=int(s[0]),int(s[1])
    s=input().split()
    a=[0]
    l=[0 for i in range(n+1)]
    r=[0 for i in range(n+1)]
    for c in s[0]:
        a.append(int(c))
    l[1],r[n]=1,n
    for i in range(2,n+1):
        if a[i-1]==a[i]:
            l[i]=l[i-1]
        else:
            l[i]=i
        if a[n-i+1]==a[n-i+2]:
            r[n-i+1]=r[n-i+2]
        else:
            r[n-i+1]=n-i+1

    if win1():
        print(""tokitsukaze"")
    elif win2():
        print(""quailty"")
    else:
        print(""once again"")
",O(n)
"import sys,math

def read_int():
	return int(sys.stdin.readline().strip())

def read_int_list():
	return list(map(int,sys.stdin.readline().strip().split()))

def read_string():
	return sys.stdin.readline().strip()

def read_string_list(delim="" ""):
	return sys.stdin.readline().strip().split(delim)

k = read_int()

base_digit_number = 1; expo = 0

while k >= base_digit_number:
	base_digit_number += 9*(expo+1)*(10**expo)
	expo += 1

base_digit_number -= 9*(expo)*(10**(expo-1))

ans_number = (k - base_digit_number)//expo + 10**(expo-1)

ans_digit = str(ans_number)[(k - base_digit_number)%expo]

print(ans_digit)
",O(logn)
"class Solution3(object):
    def minimumAddedInteger(self, nums1, nums2):
        nums1.sort()
        nums2.sort()
        for i in range(3):
            d = nums2[-1]-nums1[~i]
            cnt = 0
            for j in range(len(nums2)):
                while j+cnt < len(nums1) and nums1[j+cnt]+d != nums2[j]:
                    cnt += 1
            if cnt <= 2:
                return d
        return -1",O(nlogn)
"class Solution(object):
    def minimumDifference(self, nums, k):
        nums.sort()
        return min(nums[i]-nums[i-k+1] for i in range(k-1, len(nums)))",O(nlogn)
"n = int(input())
lst = list(map(int,input().split()))
lst.sort()
lst.reverse()
m = 0
for i in range(n):
  if sum(lst[:i]) > sum(lst[i:]):
    break
  else:
    m+=1
print(m)",O(nlogn)
"class Solution(object):
    def findMissingRanges(self, nums, lower, upper):
        def getRange(lower, upper):
            if lower == upper:
                return ""{}"".format(lower)
            else:
                return ""{}->{}"".format(lower, upper)
        ranges = []
        pre = lower - 1

        for i in range(len(nums) + 1):
            if i == len(nums):
                cur = upper + 1
            else:
                cur = nums[i]
            if cur - pre >= 2:
                ranges.append(getRange(pre + 1, cur - 1))

            pre = cur

        return ranges",O(n)
"n=int(input())
a=list(map(int,input().split()))
a.sort()
if a[n-1]==1:
    a[n-1]+=1
else:
    a[n-1]=1
a.sort()
print(*a)
",O(nlogn)
"import sys

input=lambda : sys.stdin.readline().strip()
char = [chr(i) for i in range(97,123)]
CHAR = [chr(i) for i in range(65,91)]
mp = lambda:list(map(int,input().split()))
INT = lambda:int(input())
rn = lambda:range(INT())

from math import ceil,sqrt,factorial,gcd

r,g,b = mp()
rl = sorted(mp(),reverse=True)
gl = sorted(mp(),reverse=True)
bl = sorted(mp(),reverse=True)

def solve(i,j,k):
	if dp_table[i][j][k] != -1:
		return dp_table[i][j][k]

	ans = 0

	if i < r and j < g:
		ans = max(solve(i+1,j+1,k) + rl[i]*gl[j],ans)

	if i < r and k < b:
		ans = max(solve(i+1,j,k+1) + rl[i]*bl[k],ans)

	if j < g and k < b:
		ans = max(solve(i,j+1,k+1) + gl[j]*bl[k],ans)

	dp_table[i][j][k] = ans
	return dp_table[i][j][k]

dp_table = [[[-1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
res = solve(0,0,0)
print(res)
",O(n ^ 3)
"import os
import sys
from io import BytesIO, IOBase
from collections import *
from itertools import *
from functools import *
from math import *

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

A = [int(n) for n in input().split()]
N = len(A)
dp = [0] * N
for i in range(N):
    B = A.copy()
    each = B[i] // N
    curr = B[i]
    B[i] = 0
    for j in range(N):
        B[j] += each
    for j in range(1, (curr - each * N) + 1):
        B[(i + j) % N] += 1
    for M in B:
        if M % 2 == 0:
            dp[i] += M
print(max(dp))",O(1)
"import math
import sys

n = int(input())
r = 0
t = 1
for i in range(n-1):
    r += t*2
    t += 2
print(r + t)
",O(n)
"n,s=map(int,input().split())
h=list()
m=list()
l=list()
l.append(0)
for _ in range(n):
    x,y=map(int,input().split())
    h.append(x)
    m.append(y)
    l.append((x*60)+y)
if(l[1]!=0 and (l[1]-l[0])>=s+1):
    print(0,0)
else:
    k=2*s+2
    r=0
    for i in range(n):
        if(l[i+1]-l[i]>=k):
            r=l[i]+s+1
            break
        else:
            continue
    if(r==0):
        r=l[n]+s+1
    print(r//60,r%60)
",O(n)
"import os,sys
from io import BytesIO, IOBase

def main():
    n = int(input())
    p = [list(map(float,input().split())) for _ in range(n)]
    y = 1<<n
    dp = [[0]*y for _ in range(n)]

    dp[0][y-1] = 1
    for i in range(y-2,-1,-1):
        mask = 1
        for j in range(n):
            if not mask&i:
                mask <<= 1
                continue
            mask1 = 1
            for k in range(n):
                if i&mask1:
                    mask1 <<= 1
                    continue
                dp[j][i] = max(dp[j][i],
                    dp[j][i|mask1]*p[j][k]+dp[k][i|mask1]*p[k][j])
                mask1 <<= 1
            mask <<= 1
    print(max(dp[i][1<<i] for i in range(n)))

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",np
"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**10
mod = 10**9+7
dd = [(0,-1),(1,0),(0,1),(-1,0)]
ddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)

def main():
    x,k = LI()
    if x == 0:
        return 0
    t = pow(2,k+1,mod) * x % mod
    d = pow(2,k,mod) - 1

    return (t + mod - d) % mod

print(main())
",O(logn)
"import math

a=input()
b=input()
x1=a.count('+')
y1=a.count('-')
x2=b.count('+')
y2=b.count('-')
l=b.count('?')
if l==0 and(x1==x2 and y1==y2):
	print(float(1))
elif x1>(x2+l) or y1>(y2+l):
	print(float(0))
else:
	w=math.factorial(l)
	m=math.factorial(x1-x2)
	n=math.factorial(l-(x1-x2))
	print((w/(m*n)) /2**(x1+y1-x2-y2))
",np
"class Solution(object):
    def countSubarrays(self, nums):
        result = l = 1
        for i in range(1, len(nums)):
            if nums[i-1] >= nums[i]:
                l = 0
            l += 1
            result += l
        return result",O(n)
"class Solution(object):
    def subsetXORSum(self, nums):
        result = 0
        for x in nums:
            result |= x
        return result * 2**(len(nums)-1)",O(n)
"import sys, os
from collections import defaultdict

if os.environ['USERNAME']=='kissz':
    inp=open('in.txt','r').readline
    def debug(*args):
        print(*args,file=sys.stderr)
else:
    inp=input
    def debug(*args):
        pass

def get_hash(s):
    r=0
    for c in s:
        r*=30
        if c!='_':
            r+=ord(c)-96
    return r

def matches(s):
    R=[]
    for i in range(2**k):
        r=0
        for j in range(k):
            if i&(1<<j):
                r+=(ord(s[j])-96)*(30**(k-j-1))
        if pattern_pos[r]>=0:

            R.append(pattern_pos[r])
    return R

n,m,k=map(int,inp().split())

pattern_pos=[-1]*(30**k)

for i in range(n):
    p=get_hash(inp().strip())
    pattern_pos[p]=i+1

parents=[0]*(n+1)
edges=defaultdict(list)
failed=False
for i in range(m):
    s,l=inp().split()
    l=int(l)
    M=matches(s)
    if l in M:
        for m in M:
            if l==m: continue
            edges[l].append(m)
            parents[m]+=1
    else:
        failed=True
        break

if failed:
    print('NO')
else:
    Q=[]
    for i in range(1,n+1):
        if parents[i]==0:
            Q.append(i)

    ans=[]
    while Q:
        i=Q.pop()
        ans.append(i)
        for child in edges[i]:
            parents[child]-=1
            if parents[child]==0:
                Q.append(child)
    if len(ans)==n:
        print('YES')
        print(*ans)
    else:
        print('NO')
",np
"import collections



class Solution(object):
    def findHighAccessEmployees(self, access_times):
        LIMIT_COUNT = 2
        LIMIT_MINUTE = 60
        def to_minute(x):
            return int(x[:2])*60+int(x[2:])
    
        lookup = collections.defaultdict(list)
        for x, t in access_times:
            lookup[x].append(to_minute(t))
        result = []
        for x, ts in lookup.items():
            ts.sort()
            if not all(ts[i]+LIMIT_MINUTE <= ts[i+LIMIT_COUNT] for i in range(len(ts)-LIMIT_COUNT)):
                result.append(x)
        return result",O(nlogn)
"def subsets(L, i):
    if i == len(L):
        yield []
    else:
        for s in subsets(L, i+1):
            yield s
            yield [L[i]] + s

def computeValidProblemsets(problems, l, r, x):
    isValid = lambda ps: (len(ps) > 1) and (l <= sum(ps) <= r) and (ps[-1]-ps[0] >= x)
    print(sum(isValid(problemset) for problemset in subsets(sorted(problems), 0)))

if __name__ == '__main__':
    n, l, r, x = map(int, input().split())
    problems = list(map(int, input().split()))
    computeValidProblemsets(problems, l, r, x)
",np
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def replaceValueInTree(self, root):
        q = [(root, root.val)]
        while q:
            new_q = []
            total = sum(node.val for node, _ in q)
            for node, x in q:
                node.val = total-x
                x = (node.left.val if node.left else 0) + (node.right.val if node.right else 0)
                if node.left:
                    new_q.append((node.left, x))
                if node.right:
                    new_q.append((node.right, x))
            q = new_q
        return root",O(n)
"import heapq

def read_int():
    return int(input().strip())

def read_ints():
    return list(map(int, input().strip().split(' ')))

def solve():

    R, G, B = read_ints()
    dp = [[[0 for _ in range(B+1)] for _ in range(G+1)] for _ in range(R+1)]

    Rs = read_ints()
    Gs = read_ints()
    Bs = read_ints()
    Rs.sort(reverse=True)
    Gs.sort(reverse=True)
    Bs.sort(reverse=True)
    answer = 0
    for r in range(R+1):
        for g in range(G+1):
            for b in range(B+1):
                if r > 0 and g > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g-1][b]+Rs[r-1]*Gs[g-1])
                if g > 0 and b > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r][g-1][b-1]+Gs[g-1]*Bs[b-1])
                if r > 0 and b > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g][b-1]+Rs[r-1]*Bs[b-1])
                answer = max(answer, dp[r][g][b])
    return answer

if __name__ == '__main__':
    print(solve())
",O(n ^ 3)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n = int(input())-1
x, y = 1, 9
while n > x * y: n,x,y = n-x*y,x+1,y*10
a = str(10 ** (x - 1) + n // x)[n%x]
print(a)",O(logn)
"import sys
input=sys.stdin.readline
n,k=map(int,input().split())
theorems=list(map(int,input().split()))
sleep=list(map(int,input().split()))
tsum=[]
ts=0
sleepsum=[]
slsum=0
for i in range(n):
    ts+=theorems[i]
    tsum.append(ts)
    if(sleep[i]==1):
        slsum+=theorems[i]
    sleepsum.append(slsum)

maxdiff=0

maxdiff=tsum[k-1]-sleepsum[k-1]
for i in range(1,n-k+1):
    diff=(tsum[i+k-1]-tsum[i-1])-(sleepsum[i+k-1]-sleepsum[i-1])

    maxdiff=max(maxdiff,diff)

print(slsum+maxdiff)",O(n)
"n = int(input())
a = list(map(int, input().split()))[::-1]
b = list(map(int, input().split()))
ans = [0] * n
marked = [True] * (n + 1)
for i in range(n):
    if marked[b[i]]:
        while True:
            marked[a[-1]] = False
            ans[i] += 1
            if a[-1] == b[i]:
                a.pop()
                break
            a.pop()
    else:
        continue
print(*ans)",O(n ^ 2)
"class Solution2(object):
    def visibleMountains(self, peaks):
        def is_covered(a, b):
            x1, y1 = a
            x2, y2 = b
            return x2-y2 <= x1-y1 and x1+y1 <= x2+y2

        peaks.sort()
        stk = []
        for i in range(len(peaks)):
            while stk and is_covered(peaks[stk[-1]], peaks[i]):
                stk.pop()
            if (i-1 == -1 or peaks[i-1] != peaks[i]) and (not stk or not is_covered(peaks[i], peaks[stk[-1]])): 
                stk.append(i)
        return len(stk)",O(nlogn)
"m = int(input())
values = []
idx = []
for i in range(m):
    x = int(input())
    ans = 0
    for xx,ii in zip(values,idx):
        if (xx^x) < x:
            x^=xx
            ans^=ii
    if x == 0:
        anss = []
        for j in range(i):
            if (ans&1)==1:
                anss.append(j)
            ans>>=1
        print(len(anss),*anss)
    else:
        print(0)
        values.append(x)
        idx.append(ans^(2**i))
",np
"import sys
input = sys.stdin.readline

n = int(input())
li = []

for i in range(n):
    x,w = map(int,input().split())
    li.append((x-w,x+w))

li.sort(key = lambda x: x[1])

a = -10 ** 9
ans = 0

for i in range(n):
     if a <= li[i][0]:
         ans += 1
         a = li[i][1]

print(ans)",O(nlogn)
"import collections



class Solution2(object):
    def maxFrequencyScore(self, nums, k):
        MOD = 10**9+7
        result = curr = 0
        cnt = collections.Counter()
        for i in range(len(nums)):
            if i >= k:
                curr = (curr-pow(nums[i-k], cnt[nums[i-k]], MOD))%MOD
                cnt[nums[i-k]] -= 1
                if cnt[nums[i-k]]:
                    curr = (curr+pow(nums[i-k], cnt[nums[i-k]], MOD))%MOD
            if cnt[nums[i]]:
               curr = (curr-pow(nums[i], cnt[nums[i]], MOD))%MOD
            cnt[nums[i]] += 1
            curr = (curr+pow(nums[i], cnt[nums[i]], MOD))%MOD
            if i >= k-1:
                result = max(result, curr)
        return result",O(n)
"def get_smallest(m, l):
    res = ''
    for i in ""0123456789"":
        if m.get(i, 0):
            if i == l:
                res += i * (m[i] - 1)
            else:
                res += i * m[i]
    return res

a = input()
b = input()

if len(a) < len(b):
    a = sorted(a)
    a.reverse()
    print(''.join(a))
elif a == b:
    print(a)
else:
    cmap = dict()
    for i in a:
        cmap[i] = cmap.get(i, 0) + 1

    cur = 0
    res = ''
    gm = False

    while cur < len(a):
        for i in ""9876543210"":
            if cmap.get(i, 0):
                if cur == len(a) - 1 or i < b[cur] or gm:
                    res += i
                    cmap[i] -= 1
                    gm = True
                    break
                elif i == b[cur]:
                    if get_smallest(cmap, i) <= b[cur + 1:]:
                        res += i
                        cmap[i] -= 1
                        break
        cur += 1

    print(res)",O(n ^ 3)
"from sys import stdin
from collections import Counter

class Node:
    def __init__(self,val):
        self.val=val
        self.forw=set()
        self.cou=0

    def __str__(self):
        return f'{self.val} {self.forw} {self.cou}'

n=int(stdin.readline())
arr=[Node(i) for i in range(1,n+1)]
c=2
for x in map(int,stdin.readline().split()):
    arr[x-1].forw.add(c)
    c+=1

dct=Counter()
lst = [1]
while len(lst):
    fl = 0
    for i in arr[lst[-1]-1].forw:
        lst.append(i)
        fl = 1
        break
    if fl:
        arr[lst[-2]-1].forw.remove(i)
    if not fl:
        if arr[lst[-1]-1].cou ==0:
            arr[lst[-1]-1].cou=1
        dct[arr[lst[-1]-1].cou]+=1
        k=arr[lst.pop()-1].cou
        if len(lst):arr[lst[-1]-1].cou+=k

y=1
for _ in range(n):
    while not dct[y]:
        y+=1
    dct[y]-=1
    print(y,end=' ')",O(n)
"n=int(input())
s=0
i=1
c=1
while(s<n):
    s+=9*i*c
    c+=1
    i*=10
n=n-s+9*i*(c-1)//10
c=c-1
r=n%c
d=n//c
k=10**(c-1)+d
if(r==0):
    print(int(str(k-1)[-1]))
else:
    print(int(str(k)[r-1]))
",O(logn)
"n = int(input())

pairs = [int(i) for i in input().split("" "")]

N=len(pairs)
N//=2
visited = [False] * (N + 1)

minimumSwaps = 0

for i in range(2 * N) :
    if (visited[pairs[i]] == False) :
        visited[pairs[i]] = True
        count = 0
        for j in range( i + 1, 2 * N) :
            if (visited[pairs[j]] == False) :
                count += 1
            elif (pairs[i] == pairs[j]) :
                minimumSwaps += count
print(minimumSwaps)
",O(n ^ 2)
"L = [(i+1)*9*10**i for i in range(12)]
number = int(input())

exponent=0
while number >= 0:
    number-=L[exponent]
    exponent+=1
exponent-=1
number%=L[exponent]
start = 10**exponent
numDigits = exponent+1
final = start+(number//numDigits-1)
remainder = number%numDigits
if remainder == 0:
    final = str(final)
    print(final[-1])
else:
    final = str(final+1)
    print(final[remainder-1])
",O(logn)
"import collections



class Solution(object):
    def divisibleTripletCount(self, nums, d):
        result = 0
        cnt = collections.Counter()
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
                if (nums[i]+nums[j])%d in cnt:
                    result += cnt[(nums[i]+nums[j])%d]
            cnt[-nums[i]%d] += 1
        return result",O(n ^ 2)
"class SegTree:
    def __init__(self, init_val, ide_ele, segfunc):
        self.n = len(init_val)
        self.num = 2**(self.n-1).bit_length()
        self.ide_ele = ide_ele
        self.segfunc = segfunc
        self.seg = [ide_ele]*2*self.num

        for i in range(self.n):
            self.seg[i+self.num] = init_val[i]

        for i in range(self.num-1, 0, -1):
            self.seg[i] = self.segfunc(self.seg[2*i], self.seg[2*i+1])

    def update(self, k, x):
        k += self.num
        self.seg[k] = x
        while k:
            k = k >> 1
            self.seg[k] = self.segfunc(self.seg[2*k], self.seg[2*k+1])

    def query(self, l, r):
        if r <= l:
            return self.ide_ele
        l += self.num
        r += self.num
        lres = self.ide_ele
        rres = self.ide_ele
        while l < r:
            if r & 1:
                r -= 1
                rres = self.segfunc(self.seg[r], rres)
            if l & 1:
                lres = self.segfunc(lres, self.seg[l])
                l += 1
            l = l >> 1
            r = r >> 1
        res = self.segfunc(lres, rres)
        return res

    def __str__(self):
        arr = [self.query(i,i+1) for i in range(self.n)]
        return str(arr)

n = int(input())
S = list(map(int, input().split()))
C = list(map(int, input().split()))
SA = list(set(S))
SA = sorted(SA)
d = {}
for i, s in enumerate(SA):
    d[s] = i
S = [d[s] for s in S]
L = [0]*n
R = [0]*n
INF = 10**18
N = len(d)
seg = SegTree([INF]*(N+1), INF, min)
seg.update(S[0], C[0])
for i in range(1, n-1):
    s = S[i]
    L[i] = seg.query(0, s)
    seg.update(s, C[i])

seg = SegTree([INF]*(N+1), INF, min)
seg.update(S[-1], C[-1])
for i in reversed(range(1, n-1)):
    s = S[i]
    R[i] = seg.query(s+1, seg.n)
    seg.update(s, C[i])

ans = INF
for i in range(1, n-1):
    ans = min(ans, L[i]+C[i]+R[i])
if ans >= INF:
    print(-1)
else:
    print(ans)
",O(n ^ 2)
"class Solution(object):
    def isTransformable(self, s, t):
        idxs = [[] for _ in range(10)]
        for i in reversed(range(len(s))):
            idxs[int(s[i])].append(i)
        for c in t:
            d = int(c)
            if not idxs[d]:
                return False
            for k in range(d): 
                if idxs[k] and idxs[k][-1] < idxs[d][-1]:
                    return False
            idxs[d].pop()
        return True",O(n)
"n,q = map(int, raw_input().split())
nums = list(map(int, raw_input().split()))

m = max(nums)

ab = []
while nums[0] < m:
    ab.append([nums[0], nums[1]])
    nums.append(nums.pop(1)) if nums[0]>nums[1] else nums.append(nums.pop(0))

for i in range(q):
    mj = int(input())
    a, b = map(str, ab[mj-1] if mj <= len(ab) else (m, nums[(mj-len(ab)-1)%(len(nums)-1) +1]))
    print(a + "" "" + b)
",O(n)
"n,x=list(map(int,input().split()))
b=list(map(int,input().split()))
d={}
flag=0
for i in b:
    if d.get(i):
        flag=1
        break
    else:
        d[i]=1
if flag:
    print(0)
else:
    flag=0
    c=set()
    for i in b:
        a=i&x
        c.add(a)
        if d.get(a) and a!=i:
            flag=1
            break
    if flag:
        print(1)
    elif len(c)<n and flag==0:
        print(2)
    else:
        print(-1)
",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')
from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

def cord(c):
    return ord(c)-ord('a')

def main():
    n, m = RL()
    s = input()
    ct = [0]*(1<<m)

    for i in range(n-1):
        now, nex = cord(s[i]), cord(s[i+1])
        if now==nex: continue
        ct[1<<now | 1<<nex]+=1

    for i in range(m):
        for j in range(1<<m):
            if (1<<i) & j:
                ct[j]+=ct[(1<<i) ^ j]

    dp = [INF]*(1<<m)
    dp[0] = 0
    for i in range(1<<m):

        for j in range(m):

            if i & 1<<j == 0:
                sm = ct[-1]-ct[i]-ct[~i]
                dp[i|(1<<j)] = min(dp[i|(1<<j)], dp[i] + sm)

    print(dp[-1])

if __name__ == ""__main__"":
    main()
",np
"from sys import stdin
from collections import deque
c=int(stdin.readline().strip())
for cas in range(c):
    n,m=map(int,stdin.readline().strip().split())
    s=deque(stdin.readline().strip())
    arr=[""R"",""G"",""B""]
    ans=n+3
    for k in range(1):

        for  i in range(3):
            x=i

            dp=[0 for i in range(n+1)]
            for j in range(n):

                if s[j]!=arr[x]:
                    dp[j+1]+=1
                dp[j+1]+=dp[j]
                if j+1>=m:

                    ans=min(ans,dp[j+1]-dp[j+1-m])
                x+=1
                x=x%3

    print(ans)

1
",O(n)
"t = int(input())
for i in range(t):
    n = int(input())

    lens = sorted(map(int, input().split()))
    cnt = len(list(filter(lambda x: x> 0, lens[:-2])))

    print(min(cnt, lens[-2]-1))",O(nlogn)
"n,s=map(int,input().split())
a=[0]*(n+1)

if n==2:
  print(s)
  exit(0)

for _ in range(n-1):
  u,v=map(int,input().split())
  a[u]+=1
  a[v]+=1

print(2.0*s/a.count(1))",O(n)
"import bisect



class Solution4(object):
    def maximumBeauty(self, flowers, newFlowers, target, full, partial):
        def check(prefix, total, x):
            return (prefix[x]-prefix[x-1])*x-prefix[x] <= total

        def binary_search_right(prefix, total, left, right):
            while left <= right:
                mid = left+(right-left)//2
                if not check(prefix, total, mid):
                    right = mid-1
                else:
                    left = mid+1
            return right
    
        flowers.sort()
        n = bisect.bisect_left(flowers, target)
        prefix = [0]*(n+1)
        for i in range(n):
            prefix[i+1] = prefix[i]+flowers[i]
        result = suffix = 0
        left = n
        for right in reversed(range(n+1)):
            if right != n:
                suffix += flowers[right]
            total = newFlowers-((n-right)*target-suffix)
            if total < 0:
                break
            left = binary_search_right(prefix, total, 1, right)
            mn = min((total+prefix[left])//left if left else 0, target-1)
            result = max(result, mn*partial+(len(flowers)-right)*full)
        return result",O(nlogn)
"from math import *
from cmath import *
from itertools import *
from decimal import *
from fractions import *
from sys import *
from types import CodeType, new_class

n = int(input())
print(n//2+1)",O(1)
"n = int(input())
b = list(map(int, input().split(' ')))

a = [0] * n

minV = 0
maxV = b[0]

m = n //2

a[n - 1] = b[0]

i = 1
j = n - 2

while(i < m):
  if(b[i] - minV > 0 and b[i] - minV <= maxV):
    a[i] = minV
    a[j] = b[i] - minV
    maxV = min(maxV, b[i] - minV)
  else:
    a[i] = b[i] - maxV
    a[j] = maxV
    minV = max(minV, b[i] - maxV)

  i += 1
  j -= 1

print(' '.join(map(str, a)))
",O(n)
"n = int(input())
ax, ay = map(int, input().split())
bx, by = map(int, input().split())
cx, cy = map(int, input().split())

if (bx > ax, by > ay) != (cx > ax, cy > ay):
    print(""NO"")
    exit(0)

print(""YES"")
",O(1)
"class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        mp = defaultdict(int)
        for i in range(len(numbers)):
            tmp = target - numbers[i]
            if mp[tmp]:
                return [mp[tmp], i + 1]
            mp[numbers[i]] = i + 1
        return []
",O(n)
"class Solution2(object):
    def amountOfTime(self, root, start):
        def dfs(curr, start, result):
            if curr is None:
                return [-1, -1]
            left = dfs(curr.left, start, result)
            right = dfs(curr.right, start, result)
            d = -1
            if curr.val == start:
                d = 0
                result[0] = max(left[0], right[0])+1
            elif left[1] >= 0:
                d = left[1]+1
                result[0] = max(result[0], right[0]+1+d)
            elif right[1] >= 0:
                d = right[1]+1
                result[0] = max(result[0], left[0]+1+d)
            return [max(left[0], right[0])+1, d] 

        result = [-1]
        dfs(root, start, result)
        return result[0]",O(n)
"class Solution(object):
    def captureForts(self, forts):
        result = left = 0
        for right in range(len(forts)):
            if not forts[right]:
                continue
            if forts[right] == -forts[left]:
                result = max(result, right-left-1)
            left = right
        return result",O(n)
"class Solution(object):
    def maxHeightOfTriangle(self, red, blue):
        def f(x, y):
            a, b = int(2*x**0.5)-1, int((4*y+1)**0.5)-1
            return min(a, b)+int(a != b)
        
        return max(f(red, blue), f(blue, red))",O(1)
"n,k = map(int,input().split())
mod = 998244353
dp = [[[0,0]for j in range(2*n+1)] for i in range(n)]
dp[0][0][0] = dp[0][1][1] = 1
for i in range(1,n):
  for j in range(2*n-1):
    dp[i][j][0] +=  (dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][1]) %mod
    dp[i][j+1][0] += dp[i-1][j][0] % mod
    dp[i][j+1][1] += (dp[i-1][j][0] + dp[i-1][j][0])%mod
    dp[i][j][1] += dp[i-1][j][1] %mod
    dp[i][j+2][1] += dp[i-1][j][1] %mod
print(sum(dp[n-1][k-1])*2%mod)",np
"n = int(input())
a = [list(map(int,input().split())) for i in range(n)]
for t in range(n):
    a[t].append(t+1)
a.sort()
for i in range(n-1):
    if a[i][1] >= a[i+1][1]:
        print(a[i+1][2],a[i][2])
        exit()
    if a[i][0] == a[i+1][0] and a[i][1] <= a[i+1][1]:
        print(a[i][2],a[i+1][2])
        exit()
print(-1,-1)",O(nlogn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def constructMaximumBinaryTree(self, nums):
        nodeStack = []
        for num in nums:
            node = TreeNode(num)
            while nodeStack and num > nodeStack[-1].val:
                node.left = nodeStack.pop()
            if nodeStack:
                nodeStack[-1].right = node
            nodeStack.append(node)
        return nodeStack[0]",O(n)
"class Solution(object):
    def findDerangement(self, n):
        M = 1000000007
        mul, total = 1, 0
        for i in reversed(range(n+1)):
            total = (total + M + (1 if i % 2 == 0 else -1) * mul) % M
            mul = (mul * i) % M
        return total",O(n)
"a = list(map(int, input().split()))
n = len(a)
k = [i for i in a]
lst = []
for i in range(n):
    p = k[i]%n
    ans = 0
    a = k[i+1:] + k[:i+1]
    a[-1] = 0
    for j in range(n):
        if (a[j] + 1 + int(k[i]//n))%2 == 0 and j < p:
            ans += a[j] + 1 + int(k[i]//n)
        elif (a[j] + int(k[i]//n))%2 == 0 and j >= p:
            ans += a[j] + int(k[i]//n)
    lst.append(ans)

print(max(lst))
",O(1)
"from sys import stdin, stdout
from math import sin, tan, cos

x, y, z, t1, t2, t3 = map(int, stdin.readline().split())

if abs(x - z) * t2 + abs(x - y) * t2 + 3 * t3 <= abs(x - y) * t1:
    stdout.write('YES')
else:
    stdout.write('NO')",O(1)
"import math
from sys import stdin

I=stdin.readline

s=I()
t=I()

p=0
for c in s:
	if(c=='+'): p+=1

pt,qt=0,0

for c in t:
	if(c=='+'):pt+=1
	elif(c=='?'): qt+=1

req=p-pt
if(req>qt or req<0): ans=0

else:
	ans=(math.factorial(qt)/math.factorial(req))
	ans/=math.factorial(qt-req)
	ans/=pow(2,qt)

print(ans)",np
"import math
t=1
while t:
        t-=1
        n=int(input())
        m=int(input())
        if(n>=27):
                print(m)
        else:
                print(m%(pow(2,n)))
",O(1)
"def fn(n):
	return (n * (n + 1)) / 2

def search(x, n):
	left, right = 0, n
	while left <= right:
		middle = left + (right - left) // 2
		if fn(middle) - (n - middle) == x: return (n - middle)
		elif fn(middle) - (n - middle) > x: right = middle - 1
		else: left = middle + 1
	return -1

if __name__ == '__main__':
	n, k = [int(i) for i in input().split()]
	print(search(k, n))",O(logn)
"from math import ceil

def solve(n, k):
	if k == 1:
		return n - 1
	if k == 2:
		if n > 1:
			return n - 1
		else:
			return -1
	if k == 3:
		if n > 2:
			return n - 1
		else:
			return -1
	if k in {4, 5}:
		if n > 1:
			return n - 2
		else:
			return -1

	if 2 * n + 1 <= len(bin(3 * k)[2:]):
		return -1
	else:
		return n - ceil((len(bin(3 * k)[2:]) - 1) / 2)

for i in range(int(input())):
	n, k = map(int, input().split())
	a = solve(n, k)
	if a == -1:
		print('NO')
	else:
		print('YES', a)
",O(logn)
"a = list(map(int,input().split()))
if a.count(1)>=1 or a.count(2)>=2 or a.count(3)==3 or (a.count(2)==1 and a.count(4)==2):
    print(""YES"")
else:
    print(""NO"")",O(1)
"n, s = int(input()), input() * 2

h = s.count('H') // 2

print(h - max(s[i:i + h].count('H') for i in range(n)))
",O(n)
"n, c = map(int, input().split())
cnt = [0] * 500005
ans = 0
for v in map(int, input().split()):
    if v == c:
        cnt[c] = cnt[c] + 1
    else:
        if cnt[v] < cnt[c]:
            cnt[v] = cnt[c]
        cnt[v] += 1
    ans = max(ans, cnt[v] - cnt[c])
print(ans + cnt[c])
",O(n)
"t = int(input())
for i in range(t):
    n, m = [int(item) for item in input().split()]
    mat = []
    col = [[] for _ in range(m)]
    for j in range(n):
        line = [int(item) for item in input().split()]
        for k, item in enumerate(line):
            col[k].append(item)
        mat.append(line)
    colmax = []
    for line in col:
        colmax.append([max(line), line])
    colmax.sort(reverse=True)
    colmax = colmax[:n]
    ans = 0
    for j in range(n ** (n-1)):
        index = j
        rot = [0]
        for k in range(n-1):
            rot.append(index % n)
            index //= n
        ret = 0
        for l in range(n):
            val = 0
            for k in range(len(colmax)):
                val = max(val, colmax[k][1][(l + rot[k]) % n])
            ret += val
        ans = max(ans, ret)
    print(ans)",np
"class Solution2(object):
    def rotatedDigits(self, N):
        INVALID, SAME, DIFF = 0, 1, 2
        same, diff = [0, 1, 8], [2, 5, 6, 9]
        dp = [0] * (N+1)
        dp[0] = SAME
        for i in range(N//10+1):
            if dp[i] != INVALID:
                for j in same:
                    if i*10+j <= N:
                        dp[i*10+j] = max(SAME, dp[i])
                for j in diff:
                    if i*10+j <= N:
                        dp[i*10+j] = DIFF
        return dp.count(DIFF)",O(n)
"class Solution(object):
    def canSeePersonsCount(self, heights):
        result = [0]*len(heights)
        stk = []
        for i, h in enumerate(heights):
            while stk and heights[stk[-1]] < h:
                result[stk.pop()] += 1
            if stk:
                result[stk[-1]] += 1
            if stk and heights[stk[-1]] == h:
                stk.pop()
            stk.append(i)
        return result",O(n)
"num=int(input())

vals=list(map(int,input().split()))

vals.sort()

flag=0

for i in vals:
    if i>vals[0]:
        print(i)
        flag=1
        break

if flag==0:
    print('NO')
",O(nlogn)
"n, K = map(int, input().split())
A = list(map(int, input().split()))
A.sort()
s = []
for a in A:
    if not s:
        s.append(a)
        continue
    while s:
        if a-K <= s[-1] < a:
            s.pop()
        else:
            break
    s.append(a)
print(len(s))
",O(nlogn)
"class Solution2(object):
    def eraseOverlapIntervals(self, intervals):
        intervals.sort(key=lambda interval: interval[0])
        result, prev = 0, 0
        for i in range(1, len(intervals)):
            if intervals[i][0] < intervals[prev][1]:
                if intervals[i][1] < intervals[prev][1]:
                    prev = i
                result += 1
            else:
                prev = i
        return result",O(nlogn)
"from collections import defaultdict, deque
from heapq import heappush, heappop
from math import inf

ri = lambda : map(int, input().split())

def solve():
    n,m = ri()
    A = [[0 for _ in range(m)] for __ in range(n)]
    left = [[0 for _ in range(m)] for __ in range(n)]
    right = [[0 for _ in range(m)] for __ in range(n)]
    up = [[0 for _ in range(m)] for __ in range(n)]
    down = [[0 for _ in range(m)] for __ in range(n)]
    for r in range(n):
        lst = input()
        for c in range(m):
            if lst[c] == '*':
                A[r][c] = left[r][c] = right[r][c] = up[r][c] = down[r][c] = 1

    for r in range(n):
        for c in range(1, m):
            if A[r][c]:
                left[r][c] += left[r][c-1]
        for c in range(m-2, -1, -1):
            if A[r][c]:
                right[r][c] += right[r][c+1]

    for c in range(m):
        for r in range(1, n):
            if A[r][c]:
                up[r][c] += up[r-1][c]

        for r in range(n-2, -1, -1):
            if A[r][c]:
                down[r][c] += down[r+1][c]
    res = []
    stars = 0

    ROWS = [[0 for _ in range(m)] for __ in range(n)]
    COLS = [[0 for _ in range(m)] for __ in range(n)]

    for r in range(n):
        for c in range(m):
            if A[r][c]:
                can = min(left[r][c], right[r][c], up[r][c], down[r][c])
                can -= 1
                if can > 0:
                    stars += 1
                    res.append((r+1, c+1, can))
                ROWS[r-can][c] += can
                if r+can+1 < n:
                    ROWS[r+can+1][c] -= can
                COLS[r][c-can] += can
                if c+can+1 < m:
                    COLS[r][c+can+1] -= can

    valid = [[False for _ in range(m)] for __ in range(n)]
    for r in range(n):
        curr = 0
        for c in range(m):
            curr += COLS[r][c]
            if curr > 0:
                valid[r][c] = True

    for c in range(m):
        curr = 0
        for r in range(n):
            curr += ROWS[r][c]
            if curr > 0:
                valid[r][c] = True

    for r in range(n):
        for c in range(m):
            if A[r][c] and not valid[r][c]:
                print(-1)
                return
    print(stars)
    for x,y,z in res:
        print(x,y,z)
t = 1

while t:
    t -= 1
    solve()
",O(n ^ 2)
"n=int(input())
arr=[int(x) for x in input().split()]
li=arr[:]
li.sort()
c=0
for i in range(n):
    if(arr[i]!=li[i]):
        c+=1
    if(c>2):
        print(""NO"")
        break
else:
    print(""YES"")",O(nlogn)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def __init__(self, root):
        self.__stk = []
        self.__traversalLeft(root)

    def hasNext(self):
        return self.__stk

    def __next__(self):
        node = self.__stk.pop()
        self.__traversalLeft(node.right)
        return node.val
    
    def __traversalLeft(self, node):
        while node is not None:
            self.__stk.append(node)
            node = node.left

",O(1)
"class Solution(object):
    def findValidPair(self, s):
        cnt = [0]*9
        for x in s:
            cnt[ord(x)-ord('1')] += 1
        for i in range(len(s)-1):
            if s[i] != s[i+1] and cnt[ord(s[i])-ord('1')] == ord(s[i])-ord('0') and cnt[ord(s[i+1])-ord('1')] == ord(s[i+1])-ord('0'):
                return s[i:i+2]
        return """"",O(n)
"class Solution(object):
    def minCostConnectPoints(self, points):
        result, u = 0, 0 
        dist = [float(""inf"")]*len(points)
        lookup = set()
        for _ in range(len(points)-1):
            x0, y0 = points[u]
            lookup.add(u)
            for v, (x, y) in enumerate(points):
                if v in lookup:
                    continue
                dist[v] = min(dist[v], abs(x-x0) + abs(y-y0))
            val, u = min((val, v) for v, val in enumerate(dist)) 
            dist[u] = float(""inf"") 
            result += val
        return result",O(n ^ 2)
"class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        mp = {}
        l = 0
        res = 0

        for r in range(len(s)):
            if s[r] in mp:
                l = max(mp[s[r]] + 1, l)
            mp[s[r]] = r
            res = max(res, r - l + 1)
        return res
",O(n)
"import collections


class Solution(object):
    def shortestBridge(self, A):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        def get_islands(A):
            islands = []
            done = set()
            for r, row in enumerate(A):
                for c, val in enumerate(row):
                    if val == 0 or (r, c) in done:
                        continue
                    s = [(r, c)]
                    lookup = set(s)
                    while s:
                        node = s.pop()
                        for d in directions:
                            nei = node[0]+d[0], node[1]+d[1]
                            if not (0 <= nei[0] < len(A) and 0 <= nei[1] < len(A[0])) or \
                               nei in lookup or A[nei[0]][nei[1]] == 0:
                                continue
                            s.append(nei)
                            lookup.add(nei)
                    done |= lookup
                    islands.append(lookup)
                    if len(islands) == 2:
                        break
            return islands

        lookup, target = get_islands(A)
        q = collections.deque([(node, 0) for node in lookup])
        while q:
            node, dis = q.popleft()
            if node in target:
                return dis-1
            for d in directions:
                nei = node[0]+d[0], node[1]+d[1]
                if not (0 <= nei[0] < len(A) and 0 <= nei[1] < len(A[0])) or \
                   nei in lookup:
                    continue
                q.append((nei, dis+1))
                lookup.add(nei)",O(n ^ 2)
"n=input()
l = list(map(int,input().split()))
l = sorted(l)
s = 0
c = 0
cnt =0
for i in l:
	s+=i
for i in l[::-1]:
	c+=i
	cnt+=1
	if c >(s/2):
		break
print(cnt)",O(nlogn)
"R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
dp=[[[-1]*(B+1) for i in range(G+1)] for j in range(R+1)]
def calc(nr,ng,nb):
  if dp[nr][ng][nb]!=-1:
    return dp[nr][ng][nb]
  res=0
  if nr<R and ng<G:
    res=max(res,calc(nr+1,ng+1,nb)+r[nr]*g[ng])
  if nr<R and nb<B:
    res=max(res,calc(nr+1,ng,nb+1)+r[nr]*b[nb])
  if ng<G and nb<B:
    res=max(res,calc(nr,ng+1,nb+1)+g[ng]*b[nb])
  dp[nr][ng][nb]=res
  return res
print(calc(0,0,0))",O(n ^ 3)
"ma = {0:1}
n, m = [int(x) for x in input().split()]
arr  = [int(x) for x in input().split()]
s, fla, ans=0,False,0
for v in arr:
    if v == m: fla = True
    elif v < m: s-= 1
    elif v > m: s+= 1
    if fla:
        ans += ma.get(s, 0) + ma.get(s-1, 0)
    else:
            ma[s] = ma.get(s, 0) + 1
print(ans)",O(nlogn)
"test=int(input())
while test:
	test=test-1
	n,k = input().split()
	n=int(n)
	k=int(k)
	s=0
	curr=1
	ct=0
	while s<k:
		s=s+curr
		curr=4*curr
		ct=ct+1
	if n>=35:
		print(""YES"",n-1)
		continue
	val=[]
	val.append(0)
	for i in range(1,n):
		val.append(1+4*val[i-1])
	s=0
	t=2
	rem=0
	while n>0:
		s=s+t-1
		t*=2
		p=3
		rem=rem+(t-3)*(val[n-1])
		rem=int(rem)
		if rem+s>=k and s<=k:
			print(""YES"",n-1)
			n=-2
			break
		n=n-1
	if n != -2:
		print(""NO"")",O(logn)
"import sys
input=sys.stdin.readline
def read():return list(map(int,input().split()))
n,k=read()
s=input()[:-1]
ans=""""
for i in range(len(s)+1, 0, -1):
    res=s
    end=s[-i:]
    for j in range(k-1):
        res += end
    cnt=0
    for j in range(len(res)-len(s)+1):
        if res[j:j+len(s)] == s:
            cnt += 1
    if cnt == k:
        ans = res
print(ans)
",O(n ^ 2)
"class Solution3(object):
    def minimumCoins(self, prices):
        dp = [float(""inf"")]*(len(prices)+1)
        dp[0] = 0
        for i in range(len(prices)):
            for j in range(i//2, i+1):
                dp[i+1] = min(dp[i+1], dp[j]+prices[j])
        return dp[-1]",O(n ^ 2)
"import sys
from array import array
import typing as Tp

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

def output(*args):
    sys.stdout.buffer.write(
        ('\n'.join(map(str, args)) + '\n').encode('utf-8')
    )

def main():
    R, G, B = map(int, input().split())
    r_sticks = sorted(map(float, input().split()), reverse=True) + [0.0]
    g_sticks = sorted(map(float, input().split()), reverse=True) + [0.0]
    b_sticks = sorted(map(float, input().split()), reverse=True) + [0.0]

    dp = [[[0.0] * (B + 2) for _ in range(G + 2)] for _ in range(R + 2)]

    for ri in range(R + 1):
        for gi in range(G + 1):
            for bi in range(B + 1):
                dp[ri + 1][gi + 1][bi] = max(dp[ri + 1][gi + 1][bi], dp[ri][gi][bi] + r_sticks[ri] * g_sticks[gi])
                dp[ri + 1][gi][bi + 1] = max(dp[ri + 1][gi][bi + 1], dp[ri][gi][bi] + r_sticks[ri] * b_sticks[bi])
                dp[ri][gi + 1][bi + 1] = max(dp[ri][gi + 1][bi + 1], dp[ri][gi][bi] + g_sticks[gi] * b_sticks[bi])

    ans = max(max(max(dp[r][g][b] for b in range(B + 1)) for g in range(G + 1)) for r in range(R + 1))
    print(int(ans + 1e-6))

if __name__ == '__main__':
    main()
",O(n ^ 3)
"a='4'*(300)+'5'
b='5'*(301)
print(a);print(b)
",O(1)
"from collections import Counter as C
n, m = map(int, input().split())
l = [*map(int, input().split())]
c = sorted(C(l).items())

res = 0
j = 0
for hi, ni in c:

    h = min(hi - j, ni) + j
    res += (hi - 1) * ni
    if h > j:
        j = h
m = max(l)
if j < m:
    res -= m - j
print(res)",O(nlogn)
"from sys import stdin
import math

rgb = 'RGB'

for query in range(int(stdin.readline())):
    n, k = map(int, stdin.readline().split())
    s = stdin.readline()

    ans = math.inf
    for start in range(3):
        dp = [0 for i in range(n + 1)]
        for i in range(n):
            cur = rgb[(start + i) % len(rgb)]
            dp[i + 1] = dp[i] + int(s[i] != cur)
        for i in range(n - k + 1):
            ans = min(ans, dp[i + k] - dp[i])
    print(ans)
",O(n)
"class Solution(object):
    def canConstruct(self, ransomNote, magazine):
        counts = [0] * 26
        letters = 0

        for c in ransomNote:
            if counts[ord(c) - ord('a')] == 0:
                letters += 1
            counts[ord(c) - ord('a')] += 1

        for c in magazine:
            counts[ord(c) - ord('a')] -= 1
            if counts[ord(c) - ord('a')] == 0:
                letters -= 1
                if letters == 0:
                    break

        return letters == 0",O(n)
"import sys
input_file = sys.stdin
C = (10**9+7)
[n, q] = list(int(i) for i in input_file.readline().split())
temp = input_file.readline()
lst = []
for char in temp[:-1]:
    lst.append(int(char))

new_lst = [(0, 0)]
for i in lst:
    if i == 0:
        new_lst.append((new_lst[-1][0]+1, new_lst[-1][1]))
    else:
        new_lst.append((new_lst[-1][0], new_lst[-1][1]+1))

ls = [1]
for i in range(n):
    ls.append(ls[-1]*2 % C)

for line in input_file:
    [l, r] = list(int(i) for i in line[:-1].split())
    q = (new_lst[r][0] - new_lst[l-1][0], new_lst[r][1] - new_lst[l-1][1])
    print((ls[sum(q)] - ls[q[0]]) % C)
",O(n)
"def main():
    q = int(input())
    ans = []
    for i in range(q):
        n, k = map(int, input().split())
        s = input()
        min_ans = 10 ** 9
        pr1 = [0]
        pr2 = [0]
        pr3 = [0]
        for i in range(n):
            count1 = 0
            count2 = 0
            count3 = 0
            if i % 3 == 0:
                if s[i] != ""R"":
                    count1 += 1
                if s[i] != ""G"":
                    count2 += 1
                if s[i] != ""B"":
                    count3 += 1
            if i % 3 == 1:
                if s[i] != ""G"":
                    count1 += 1
                if s[i] != ""B"":
                    count2 += 1
                if s[i] != ""R"":
                    count3 += 1
            if i % 3 == 2:
                if s[i] != ""B"":
                    count1 += 1
                if s[i] != ""R"":
                    count2 += 1
                if s[i] != ""G"":
                    count3 += 1
            pr1.append(pr1[-1] + count1)
            pr2.append(pr2[-1] + count2)
            pr3.append(pr3[-1] + count3)
            j = i + 1
            if j >= k:
                count1 = pr1[j] - pr1[j - k]
                count2 = pr2[j] - pr2[j - k]
                count3 = pr3[j] - pr3[j - k]
                min_ans = min(min_ans, count1, count2, count3)
        ans.append(min_ans)
    print(*ans, sep=""\n"")

main()",O(n)
"n = int(input())
x,y = map(int,input().split())
num = x - 1 + y - 1
num2 = n - x + n - y
ans = num <= num2
if ans:
    print(""White"")
else:
    print(""Black"")
",O(1)
"import math
def f(n,s):
    d=[-n,-n];d[s]=0
    for i in range(y//g):
        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
    return d[s]

n,x,y=map(int,input().split())
g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1))
y+=x
print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np
"from collections import defaultdict, Counter,deque
from math import sqrt, log10, log, floor, factorial,gcd
from bisect import bisect_left, bisect_right
from itertools import permutations,combinations
import sys, io, os
input = sys.stdin.readline
input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

inf = float('inf')
mod = 10 ** 9 + 7
def yn(a): print(""YES"" if a else ""NO"")
ceil = lambda a, b: (a + b - 1) // b
lim=22
po=[1<<j for j in range(lim+1)]
maxbits=lim
masks=po[lim]
dp=[-1]*masks
t=1
for i in range(1):
    n=int(input())
    l=[int(i) for i in input().split()]
    for i in l:
        dp[i]=i
    for i in range(masks):
        for j in range(maxbits):
            if dp[i]==-1 and i&po[j]:
                dp[i]=dp[i-po[j]]
    ans=[dp[i^(masks-1)] for i in l]
    print(*ans)
",np
"def search(arr,power):
    lo=0
    hi=len(arr)-1
    ans=-1
    while lo<=hi:
        mid=(lo+hi)//2
        if arr[mid]<=power:
            ans=mid
            lo=mid+1
        else:
            hi=mid-1
    return ans

n,q = list(map(int, input().split()))
a = list(map(int, input().split()))
k = list(map(int, input().split()))
for i in range(1,n):
    a[i]+=a[i-1]
power = 0
for i in range(q):
    power+=k[i]
    pos = search(a,power)
    if pos==n-1:
        print(n)
        power=0
    elif pos==-1:
        print(n)
    else:
        print(n-pos-1)",O(nlogn)
"DV = 10**9 +7

x , k = list(map(int , input().split()))

mult = pow (2, k, DV)
if x == 0:
    print(0)
else:
    print((2*mult*x - mult +1) % DV)
",O(logn)
"
import collections



class Solution(object):
    def digitCount(self, num):
        cnt = collections.Counter(num)
        return all(cnt[str(i)] == int(x) for i, x in enumerate(num))
",O(n)
"class Solution(object):
    def maxNumber(self, n):
        return (1<<(n.bit_length()-1))-1",O(1)
"n = int(input())

xs = [int(x) for x in input().split()]

seen = {}

res = 0

while xs:
    j = xs.index(xs[0], 1)
    res += j - 1
    xs = xs[1:j] + xs[j+1:]

print(res)
",O(n ^ 2)
"class Solution(object):
    def largestDivisibleSubset(self, nums):
        if not nums:
            return []

        nums.sort()
        dp = [1] * len(nums)
        prev = [-1] * len(nums)
        largest_idx = 0
        for i in range(len(nums)):
            for j in range(i):
                if nums[i] % nums[j] == 0:
                    if dp[i] < dp[j] + 1:
                        dp[i] = dp[j] + 1
                        prev[i] = j
            if dp[largest_idx] < dp[i]:
                largest_idx = i

        result = []
        i = largest_idx
        while i != -1:
            result.append(nums[i])
            i = prev[i]
        return result[::-1]",O(n ^ 2)
"class Solution(object):
    def probabilityOfHeads(self, prob, target):
        dp = [0.0]*(target+1)
        dp[0] = 1.0
        for p in prob:
            for i in reversed(range(target+1)):
                dp[i] = (dp[i-1] if i >= 1 else 0.0)*p + dp[i]*(1-p)
        return dp[target]",O(n ^ 2)
"class Solution(object):
    def numRookCaptures(self, board):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        r, c = None, None
        for i in range(8):
            if r is not None:
                break
            for j in range(8):
                if board[i][j] == 'R':
                    r, c = i, j
                    break

        result = 0
        for d in directions:
            nr, nc = r+d[0], c+d[1]
            while 0 <= nr < 8 and 0 <= nc < 8:
                if board[nr][nc] == 'p':
                    result += 1
                if board[nr][nc] != '.':
                    break
                nr, nc= nr+d[0], nc+d[1]
        return result",O(1)
"def interact(c, d): return max(min((a ^ c) - (b ^ d), 1), -1)

def main():
	def ask(c, d):

		print(""?"", c, d, flush = True)
		return int(input())

	relative = ask(0, 0)
	curA = 0
	curB = 0

	for i in range(29, -1, -1):
		q1 = ask(curA ^ 2 ** i, curB)
		q2 = ask(curA, curB ^ 2 ** i)

		if q1 == q2:
			if relative == 1:
				curA ^= 2 ** i
			else:
				curB ^= 2 ** i
			relative = q1
		elif q2 == 1:
			curA ^= 2 ** i
			curB ^= 2 ** i
	return curA, curB
print(""!"", *main())",O(1)
"class Solution(object):
    def sumZero(self, n):
        return [i for i in range(-(n//2), n//2+1) if not (i == 0 and n%2 == 0)]",O(n)
"n = int(input())
tr = {}
p = [int(s) for s in input().split()]
for i in range(n-1):
    if not tr.get(p[i]-1):
        tr[p[i]-1] = []
    tr[p[i]-1].append(i+1)

lc = [-1 for i in range(n)]
def get_lc(i):
    if lc[i] == -1:
        if tr.get(i):
            lc[i] = 0
            for j in tr[i]:
                lc[i] += get_lc(j)
        else:
            lc[i] = 1
    return lc[i]
for i in range(n-1, -1, -1):
    get_lc(i)
print(*sorted(lc))",O(n)
"class Solution2(object):
    def diameterOfBinaryTree(self, root):
        def dfs(root):
            if not root: 
                return 0, 0
            left_d, left_h = dfs(root.left)
            right_d, right_h = dfs(root.right)
            return max(left_d, right_d, left_h+right_h), 1+max(left_h, right_h)
 
        return dfs(root)[0]",O(n)
"n=int(input())
for i in range(n//3):
    print(2*i,0)
    print(2*i+1,0)
    print(2*i+1,3)
for i in range(n%3):
    print(2*(n//3)+i,0)",O(n)
"class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [0] * n
        pref = [0] * n
        suff = [0] * n

        pref[0] = suff[n - 1] = 1
        for i in range(1, n):
            pref[i] = nums[i - 1] * pref[i - 1]
        for i in range(n - 2, -1, -1):
            suff[i] = nums[i + 1] * suff[i + 1]
        for i in range(n):
            res[i] = pref[i] * suff[i]
        return res
",O(n)
"import io
import os

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

n = int(input())

arr = [int(z) for z in input().split()]

q = int(input())

inv = 0

for i in range(n):

    for j in range(n):

        if i < j and arr[i] > arr[j]:

            inv += 1

        inv = inv % 2

for query in range(q):

    l, r = map(int, input().split())

    diff = r - l

    s = diff//2

    if diff % 2:
        s += 1

    inv = (inv + (s % 2)) % 2

    if inv:
        print(""odd"")
    else:
        print(""even"")
",O(n ^ 2)
"from math import ceil

n=int(input())
r=list(map(int,input().split()))
l=[-1]
l.extend(r)
a=['']*(n+1)
d={}
rd={}
ind={}
for i in range(1,n+1):
    x=l[i]
    ind[x]=i
    d.setdefault(i,[])
    s=x+i
    while s<=n:
        if l[s]>x:
            d[i].append(s)
            if s not in rd:
                rd[s]=[]
            rd[s].append(i)
        s+=x
    s = i-x
    while s >=1:
        if l[s] > x:
            d[i].append(s)
        s -= x

ans=0

for i in d:
    if len(d[i])==0:
        a[i]='B'
        ans+=1

while ans!=n:
    for i in d:
        dont=False
        if a[i]!='':
            continue
        for j in d[i]:
            if a[j]=='B':
                a[i]='A'
                ans+=1
                break
            if a[j]=='':
                dont=True
        else:
            if not dont:
                a[i]='B'
                ans+=1

print(''.join(a))",O(nlogn)
"n=int(input())
s=list()
for i in range(n):
    x=input()
    s.append(x)
a=sorted(s,key=len)
c=1
for i in range(n-1):
    if(a[i] not in a[i+1]):
        c=0
        break
if(c==0):
    print('NO')
else:
    print('YES')
    for i in range(n):
        print(a[i])",O(nlogn)
"from sys import stdin, stdout

n = int(stdin.readline())
values = list(map(int, stdin.readline().split()))

cnt = 0
for i in range(n):
    for j in range(i + 1, n):
        if values[i] > values[j]:
            cnt += 1

m = int(stdin.readline())
for i in range(m):
    l, r = map(int, stdin.readline().split())
    n = r - l + 1

    cnt += n * (n - 1) // 2
    cnt &= 1

    if cnt == 1:
        stdout.write('odd\n')
    else:
        stdout.write('even\n')",O(n ^ 2)
"n, m = map(int, input().split())

for i in range(n):
    s = input()
    left = s.find('B')
    if left != -1:
        right = s.rfind('B')
        c = (right - left) // 2 + 1
        print(i + c, left + c)
        break
",O(n ^ 2)
"n, k = map(int, input().split())
s = input()
a = [0] * 26
for i in s:
    a[ord(i) - ord('a')] = 1
ans = 0
i = 0
while i < 26:
    if a[i] > 0:
        ans += i + 1
        k -= 1
        i += 1
        if k == 0:
            print(ans)
            break
    i += 1
else:
    print(-1)",O(n)
"MAX = 1000
f = [0]
for i in range(1, MAX):
    f.append(f[i - 1] + (1 << (2 * i - 2)))

g = [0]
for i in range(1, MAX):
    g.append(g[i - 1] + (1 << i) - 1)

t = int(input())
for _ in range(t):
    n, k = map(int, input().split(' '))
    ans = False
    for i in range(1, n + 1):
        if k >= g[i]:
            if n >= MAX:
                print(""YES %d"" % (n - i))
                ans = True
            elif k <= f[n] - ((1 << (i + 1)) - 1) * f[n - i]:
                print(""YES %d"" % (n - i))
                ans = True
        if ans == True:
            break
    if ans == False:
        print(""NO"")
",O(n)
"import collections


class Solution(object):
    def distinctSubseqII(self, S):
        MOD = 10**9+7
        result, dp = 0, [0]*26
        for c in S:
            result, dp[ord(c)-ord('a')] = (result+((result+1)-dp[ord(c)-ord('a')]))%MOD, (result+1)%MOD
        return result",O(n)
"n = int(input())
visit = [0 for i in range(n+1)]
res = []
c = 0
s,t=0,0
def do(i):
	global c,s,t
	for j in range(i,n+1,2*i):
		res.append(i)
		c += 1
		if c >= (n-1) and n>2:
			if s == 0:
				s = j
			else:
				t = j
	return res
curr = 0
i = 1
while(i<=n):

	do(i)
	i = 2*i
if n>2:
	res[n-1] = max(s,t)

for i in res:
	print(i,end="" "")",O(nlogn)
"class Solution(object):
    def sumOfPower(self, nums):
        MOD = 10**9+7
        nums.sort()
        result = dp = 0
        for x in nums:
            result = (result+(x**2)*(dp+x))%MOD
            dp = (dp+(dp+x))%MOD
        return result",O(nlogn)
"n = int(input())
import math
print(math.ceil(n/2) * (math.floor(n/2)+1))",O(n)
"import collections


class Solution(object):
    def numSplits(self, s):
        left_count, right_count = collections.Counter(), collections.Counter(s)
        result = 0
        for c in s:
            left_count[c] += 1
            right_count[c] -= 1
            if not right_count[c]:
                del right_count[c]
            if len(left_count) == len(right_count):
                result += 1
        return result",O(n)
"class Solution(object):
    def firstPalindrome(self, words):
        def is_palindrome(s):
            i, j = 0, len(s)-1
            while i < j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True

        for w in words:
            if is_palindrome(w):
                return w
        return """"",O(n)
"x=int(input())
s=input()

def substring(x,s):
    count=0
    ans=0

    for i in range(x):
        if s[i]==""x"":
            count+=1
        else:
            if count>=3:
                ans+=count-2
            count=0
    if count>=3:
        ans+=count-2

    return ans
print(substring(x,s))",O(n)
"n, a, b = map(int, input().split())
arr = list(map(int, input().split()))
arr.sort()
end_b = arr[b-1]
start_a = arr[b]
if end_b < start_a:
    print(start_a - end_b)
else:
    print(0)
",O(nlogn)
"n=int(input())
A=list(map(int,input().split()))

if n==1:
    print(A[0])

elif n==2:
    print(abs(A[0]-A[1]))

else:
    SUM=0
    for i in range(n):
        SUM+=abs(A[i])
    ANS=0

    for i in range(n-1):
        if ANS<SUM-abs(A[i])-abs(A[i+1])+abs(A[i]-A[i+1]):
            ANS=SUM-abs(A[i])-abs(A[i+1])+abs(A[i]-A[i+1])

    print(ANS)
",O(n)
"def process(S):
    n = len(S)
    h_count = 0
    answer = float('inf')
    for c in S:
        if c=='H':
            h_count+=1
    current = 0
    for i in range(h_count):
        if S[i]=='H':
            current+=1
    answer = min(answer, h_count-current)
    for i in range(h_count, n+h_count):
        if i > n-1:
            i1 = i-n
        else:
            i1 = i
        i2 = i-h_count
        if S[i1]=='H':
            current+=1
        if S[i2]=='H':
            current-=1
        answer = min(answer, h_count-current)
    return answer

n = int(input())
S = input()
print(process(S))",O(n)
"s = input()
n = len(s)
ans = 0
c = 0
l = []
for i in range(n):
    a = int(s[i])%3
    if a==0:
        ans+=1
        c = 0
        l = []
    else:
        if c==0:
            l.append(int(s[i]))
            c+=1
        elif c==1:
            if (a+l[0])%3==0:
                ans+=1
                c = 0
                l = []
            else:
                c+=1
        else:
            ans+=1
            c=0
            l = []
print(ans)",O(n)
"from itertools import combinations
n, l, r, x = map(int,input().split())
a = list(map(int,input().split()))
print(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))
",np
"k=int(input(''))
sol=''
cnt=0
for i in range(1,13):
    inc=9*(10**(i-1))*i
    if cnt+inc>=k:
        break
    else:
        cnt+=inc
lft=k-cnt
dig=(lft)/i
if dig!=int(dig):
    dig=int(dig+1)
else:
    dig=int(dig)
num=(10**(i-1))+dig-1
left=k-(cnt+dig*i)
sol=str(num)
print(sol[left-1])
",O(logn)
"import sys;input = sys.stdin.readline
def topological_sorted(digraph):
    n = len(digraph);indegree = [0] * n
    for v in range(n):
        for nxt_v in digraph[v]:indegree[nxt_v] += 1
    tp_order = [i for i in range(n) if indegree[i] == 0];stack = tp_order[:]
    while stack:
        v = stack.pop()
        for nxt_v in digraph[v]:
            indegree[nxt_v] -= 1
            if indegree[nxt_v] == 0:stack.append(nxt_v);tp_order.append(nxt_v)
    return len(tp_order) == n, tp_order
n, m, k = map(int, input().split());p = [input()[:-1] for i in range(n)];s = [list(input().split()) for i in range(m)];memo = {};graph = [[] for i in range(n)]
for idx, ptn in enumerate(p):val = sum([(ord(ptn[i]) - 96) * (27 ** i) for i in range(k) if ptn[i] != ""_""]);memo[val] = idx
for i, (string, idx) in enumerate(s):s[i] = tuple(map(ord, string)), int(idx)
for string, idx in s:
    idxs = []
    idx -= 1
    for bit_state in range(1 << k):
        val = 0
        for i in range(k):
            if (bit_state >> i) & 1:
                continue
            val += (string[i] - 96) * (27 ** i)
        if val in memo:
            idxs.append(memo[val])
    if idx not in idxs:print(""NO"");exit()

    for idx_to in idxs:
        if idx == idx_to:
            continue
        graph[idx].append(idx_to)

flag, res = topological_sorted(graph)
if flag:print(""YES"");print(*[i + 1 for i in res])
else:print(""NO"")",np
"l = input().split()
if l[0]==l[1] and l[1]==l[2]:
    print(0)
    exit(0)
def shuntsu(li):
    li.sort()
    return li[0][1]==li[1][1] and li[1][1]==li[2][1] and int(li[1][0])==int(li[0][0])+1 and int(li[2][0])==int(li[1][0])+1
if shuntsu(l):
    print(0)
    exit(0)
for k in l:
    if len([x for x in l if x==k]) > 1:
        print(1)
        exit(0)
    if len([x for x in l if x[1]==k[1] and int(x[0]) == int(k[0])+1]) !=0:
        print(1)
        exit(0)
    if len([x for x in l if x[1]==k[1] and int(x[0]) == int(k[0])+2]) != 0:
        print(1)
        exit(0)
print(2)
",O(nlogn)
"import collections


class Solution(object):
    def snakesAndLadders(self, board):
        def coordinate(n, s):
            a, b = divmod(s-1, n)
            r = n-1-a
            c = b if r%2 != n%2 else n-1-b
            return r, c

        n = len(board)
        lookup = {1: 0}
        q = collections.deque([1])
        while q:
            s = q.popleft()
            if s == n*n:
                return lookup[s]
            for s2 in range(s+1, min(s+6, n*n)+1):
                r, c = coordinate(n, s2)
                if board[r][c] != -1:
                    s2 = board[r][c]
                if s2 not in lookup:
                    lookup[s2] = lookup[s]+1
                    q.append(s2)
        return -1",O(n ^ 2)
"import bisect


class Solution(object):
    def sortedSquares(self, A):
        right = bisect.bisect_left(A, 0)
        left = right-1
        result = []
        while 0 <= left or right < len(A):
            if right == len(A) or \
               (0 <= left and A[left]**2 < A[right]**2):
                result.append(A[left]**2)
                left -= 1
            else:
                result.append(A[right]**2)
                right += 1
        return result",O(n)
"class Solution(object):
    def findBestValue(self, arr, target):
        arr.sort(reverse=True)
        max_arr = arr[0]
        while arr and arr[-1]*len(arr) <= target:
            target -= arr.pop()
        return max_arr if not arr else (2*target+len(arr)-1)//(2*len(arr))",O(nlogn)
"class Solution(object):
    def simulationResult(self, windows, queries):
        lookup = [False]*len(windows)
        result = []
        for x in reversed(queries):
            if lookup[x-1]:
                continue
            lookup[x-1] = True
            result.append(x)
        result.extend(x for x in windows if not lookup[x-1])
        return result",O(n)
"import sys, math

n = int(sys.stdin.readline())
arr = list(map(int, sys.stdin.readline().rstrip()))
if len(set(arr)) == 1:
    print('YES')
else:
    val = sum(arr)
    factor = set()
    for i in range(1, int(val ** 0.5) + 1):
        if val % i == 0:
            factor.add(i)
            factor.add(val // i)
    can = False
    for i in factor:
        each = val // i
        if 1 < i <= n:
            idx = 0
            temp = 0
            cnt = 0
            while idx < n:
                if temp + arr[idx] < each:
                    temp += arr[idx]
                elif temp + arr[idx] > each:
                    temp = 0
                else:
                    temp = 0
                    cnt += 1
                idx += 1
            if cnt == i:
                can = True
    print('YES' if can else 'NO')
",O(n ^ 2)
"def main():
	k = int(input())
	digit = 1; low=1; high=9; totalDigit=9; lastTotalDigit=0
	while (totalDigit < k) :
		low *= 10
		high = 10*low-1
		digit += 1
		lastTotalDigit = totalDigit
		totalDigit += (high+1-low)*digit
	k -= lastTotalDigit
	cur = str(low+(k-1) // digit)
	print(cur[(k-1)%digit])

main()
",O(logn)
"n = int(input())
a = []
for i in range(n):
    a.append(list(map(int,input().split()))+[i+1])
a.sort(key = lambda e:e[0])
f = 0
for i in range(n-1):
    if a[i][0] == a[i+1][0]:
        if a[i][1] >= a[i+1][1]:
            print(a[i+1][2],a[i][2])
        else:print(a[i][2],a[i+1][2])
        f =1
        break
    if a[i][1] >= a[i+1][1]:
        f = 1
        print(a[i+1][2],a[i][2])
        break
if f == 0:print(-1,-1)
",O(nlogn)
"class Solution(object):
    def maxScore(self, nums):
        result = mx = 0
        for i in reversed(range(1, len(nums))):
            mx = max(mx, nums[i])
            result += mx
        return result",O(n)
"n, u = map(int, input().split())
e = list(map(int, input().split()))
ans = -1
k = 2
for i in range(n-2):
    while k<n-1 and e[k+1] - e[i] <= u:
        k+=1
    if i < k-1 and e[k] - e[i] <= u:
        ans = max(ans,(e[k]-e[i+1]) / (e[k]-e[i]))
print(ans)",O(nlogn)
"class Solution(object):
    def canFormArray(self, arr, pieces):
        lookup = {x[0]: i for i, x in enumerate(pieces)}
        i = 0
        while i < len(arr): 
            if arr[i] not in lookup:
                return False
            for c in pieces[lookup[arr[i]]]:
                if i == len(arr) or arr[i] != c:
                    return False
                i += 1
        return True",O(n)
"class Solution(object):
    def maxSumDivThree(self, nums):
        dp = [0, 0, 0]
        for num in nums:
            for i in [num+x for x in dp]:
                dp[i%3] = max(dp[i%3], i)
        return dp[0]",O(n)
"n=int(input())
d,l,m,a=[0]*(n+1),[0]*2,[0]*(n+1),0
for _ in range(n-1):
    a=int(input())
    l.append(a)
    m[a]+=1
for i in range(1,n+1):
    if m[i]==0:
        d[l[i]]+=1
for i in range(1,n+1):
    if m[i]>0 and d[i]<3:
        print(""No"")
        break
else:
    print(""Yes"")",O(n)
"import sys, math
import io, os

from bisect import bisect_left as bl, bisect_right as br, insort
from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n')
def out(var): sys.stdout.write(str(var) + '\n')
from decimal import Decimal

mod = int(1e9) + 7
INF=float('inf')

n=int(data())
l=mdata()
c=mdata()
d=dict()
for i in range(n):
    if d.get(l[i]):
        d[l[i]]=min(d[l[i]],c[i])
    else:
        d[l[i]]=c[i]
for i in l:
    lis=list(d.keys())
    for j in lis:
        g = math.gcd(i, j)
        if d.get(g):
            d[g]=min(d[g],d[i]+d[j])
        else:
            d[g] = d[i] + d[j]
if 1 in d:
    out(d[1])
else:
    out(-1)
",np
"hell=1000000007
id1=0
id2=0
a = []
def check(n,m,x):
    global id1,id2
    b = [0]*(1<<m)
    idx = [0]*(1<<m)
    for i in range(n):
        mask=0
        for j in range(m):
            if a[i][j]>=x:
                mask=mask^(1<<j)
        b[mask]=1
        idx[mask]=i+1
    for i in range(1<<m):
        if b[i]:
            for j in range(1<<m):
                if b[j]:
                    mask=i|j
                    if mask==((1<<m)-1):
                        id1=idx[i]
                        id2=idx[j]
                        return 1
    return 0
def meowmeow321():
    n,m = map(int,input().split())
    for i in range(n):
        dog = [int(x) for x in input().split()]
        a.append(dog)
    lo=0
    hi=hell
    while hi-lo>0:
        mid=(hi+lo+1)//2
        if check(n,m,mid):
            lo=mid
        else:
            hi=mid-1
    check(n,m,lo)
    print(id1,id2)

t=1

for xxx in range(t):
    meowmeow321()",np
"
class Solution(object):
    def deleteNode(self, node):
        if node and node.__next__:
            node_to_delete = node.__next__
            node.val = node_to_delete.val
            node.next = node_to_delete.__next__
            del node_to_delete

",O(1)
"class Solution(object):
    def maximumSetSize(self, nums1, nums2):
        lookup1, lookup2 = set(nums1), set(nums2)
        n, c = len(nums1), len(lookup1&lookup2)
        d1, d2 = min(len(lookup1)-c, n//2), min(len(lookup2)-c, n//2)
        return min(n, d1+d2+c)",O(n)
"class Window(object):
    def __init__(self):
        self.__count = collections.defaultdict(int)

    def add(self, x):
        self.__count[x] += 1

    def remove(self, x):
        self.__count[x] -= 1
        if self.__count[x] == 0:
            self.__count.pop(x)
            
    def size(self):
        return len(self.__count)


class Solution2(object):
    def subarraysWithKDistinct(self, A, K):
        window1, window2 = Window(), Window()
        result, left1, left2 = 0, 0, 0
        for i in A:
            window1.add(i)
            while window1.size() > K:
                window1.remove(A[left1])
                left1 += 1
            window2.add(i)
            while window2.size() >= K:
                window2.remove(A[left2])
                left2 += 1
            result += left2-left1
        return result",O(n)
"class Solution(object):
    def minIncrementOperations(self, nums, k):
        W = 3
        dp = [0]*W
        for i, x in enumerate(nums):
            dp[i%W] = min(dp[j%W] for j in range(i-W, i))+max(k-x, 0)
        return min(dp)",O(n)
"n, m = map(int, input().split())

np1 = n + 1
mp1 = m + 1

for i in range(1, 1 + n // 2):
  for j in range(1, mp1):

    print('%d %d\n%d %d' % (i,j,np1-i,mp1-j))

if n & 1:
  i = 1 + n // 2
  for j in range(1, 1 + m // 2):

    print('%d %d\n%d %d' % (i,j,i,mp1-j))

  if m & 1:
    print(i, 1 + m // 2)
",O(n ^ 2)
"x,k=map(int,input().split())
mod=1000000007
if x==0: print(0)
else:
    print((x*pow(2,(k+1),mod)-pow(2,k,mod)+1)%mod)
",O(logn)
"class Solution(object):
    def tribonacci(self, n):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) \
                     for col in ZB] for row in A]

        T = [[1, 1, 0],
             [1, 0, 1],
             [1, 0, 0]]
        return matrix_mult([[1, 0, 0]], matrix_expo(T, n))[0][1]",O(logn)
"n=int(input())
g=n//2
print(g+n)",O(1)
"
class Solution(object):
    def __init__(self, iterator):
        self.iterator = iterator
        self.val_ = None
        self.has_next_ = iterator.hasNext()
        self.has_peeked_ = False


    def peek(self):
        if not self.has_peeked_:
            self.has_peeked_ = True
            self.val_ = next(self.iterator)
        return self.val_

    def __next__(self):
        self.val_ = self.peek()
        self.has_peeked_ = False
        self.has_next_ = self.iterator.hasNext()
        return self.val_

    def hasNext(self):
        return self.has_next_



",O(1)
"n, m = map(int, input().split())

mp = []

for i in range(n):
    line = input().strip()

    mp.append(list(map(lambda c: c == '

mp1 = [[False for _ in range(m)] for _ in range(n)]

for i in range(1, n - 1):
    for j in range(1, m - 1):
        f = all(mp[i - 1][j - k] for k in range(-1, 1+1))
        f = f and all(mp[i + 1][j - k] for k in range(-1, 1+1))
        f = f and (mp[i][j - 1] and mp[i][j + 1])

        if not f:
            continue

        for ik in range(-1, 2):
            for jk in range(-1, 2):
                if ik == 0 and jk == 0:
                    continue
                mp1[i + ik][j + jk] = True

if all(all(mp[i][j] == mp1[i][j] for j in range(m)) for i in range(n)):
    print('YES')
else:
    print('NO')
",O(n ^ 2)
"s=input().strip()
s=s+s

n=len(s)
an=1
m=1

for i in range(1,n):
    if s[i]!=s[i-1]:
        m+=1
        an = max(an, m)
    else:
        an = max(an, m)
        m=1

print(min(an,n//2))",O(n)
"a= int(input())
i=1
amount=a
while amount>i*((10**i)-(10**(i-1))):
    amount =amount - i*((10**i)-(10**(i-1)))
    i=i+1
x= amount//i
y=amount%i

if y==0:
    if i==1:
        print(x%10)
    else:
        print((10**(i-1) + x -1)%10)
else:
    if i==1:
        print(x%10)
    else:
        print(((10**(i-1) + x)//(10**(i-y)))%10)",O(logn)
"d4i=[0,-1,0,1]
d4j=[-1,0,1,0]

def main():

    n,m,k=readIntArr()
    horizontalEdges=[]
    for _ in range(n):
        horizontalEdges.append(readIntArr())
    verticalEdges=[]
    for _ in range(n-1):
        verticalEdges.append(readIntArr())

    if k%2==1:
        ans=makeArr(-1,[n,m])
    else:
        dp=makeArr(inf,[n,m,k//2+1])
        for i in range(n):
            for j in range(m):
                dp[i][j][0]=0
        for nM in range(1,k//2+1):
            for i in range(n):
                for j in range(m):

                    if j+1<m:
                        dp[i][j][nM]=min(dp[i][j][nM],
                                         dp[i][j+1][nM-1]+horizontalEdges[i][j])

                    if j-1>=0:
                        dp[i][j][nM]=min(dp[i][j][nM],
                                         dp[i][j-1][nM-1]+horizontalEdges[i][j-1])

                    if i+1<n:
                        dp[i][j][nM]=min(dp[i][j][nM],
                                         dp[i+1][j][nM-1]+verticalEdges[i][j])

                    if i-1>=0:
                        dp[i][j][nM]=min(dp[i][j][nM],
                                         dp[i-1][j][nM-1]+verticalEdges[i-1][j])
        ans=makeArr(0,[n,m])
        for i in range(n):
            for j in range(m):
                ans[i][j]=dp[i][j][k//2]*2

    multiLineArrayOfArraysPrint(ans)

    return

import sys
input=sys.stdin.buffer.readline

def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))

def readIntArr():
    return [int(x) for x in input().split()]

def makeArr(defaultVal,dimensionArr):
    dv=defaultVal;da=dimensionArr
    if len(da)==1:return [dv for _ in range(da[0])]
    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]

def queryInteractive(x,y):
    print('? {} {}'.format(x,y))
    sys.stdout.flush()
    return int(input())

def answerInteractive(ans):
    print('! {}'.format(ans))
    sys.stdout.flush()

inf=float('inf')

MOD=998244353

for _abc in range(1):
    main()",O(n ^ 3)
"n,x = list(map(int, input().split()))
arr = list(map(int, input().split()))
f = [0]*100100
s = [0]*100100
can = [False]*100100
for i in range(n):
    f[arr[i]]+=1
    s[arr[i]&x]+=1
    if (arr[i]&x != arr[i]):
        can[arr[i]&x] = True
ans = 3
for i in range(len(f)):
    if f[i] >= 2:
        ans = 0
        break
    if f[i] == 1 and s[i] >= 1:
        if can[i]:
            ans = min(ans,1)
    if s[i] >= 2:
        ans = min(ans,2)
if ans == 3:
    print(-1)
else:
    print(ans)
",O(n)
"import math
n=int(input())

a=[9]
for i in range(2,20):
    a.append(10**i   - 10**(i-1) )
b=[0]
for i in range(1,20):
    b.append(b[-1]+ i*a[i-1])
for i in range(20):
    if n<=b[i]:
        break
p=b[i-1]
k=n-p

ans=10**(i-1) - 1 + math.ceil(k/(i))

if k%i==0:
    print(('0'+str(ans))[i])
else:
    print(('0'+str(ans))[k%i])",O(1)
"n = int(input())
w = list(map(int, input().split()))
ent = input()
mp = {w[i]: i+1 for i in range(n)}
sorted(mp)
w.sort()
ptr = 0
stk = []
for i in range(2 * n):
    if ent[i] == ""0"":
        print(mp[w[ptr]], end="" "")
        stk.append(mp[w[ptr]])
        ptr += 1
    else:
        print(stk.pop(), end="" "")

print()
",O(nlogn)
"class Solution2(object):
    def sortVowels(self, s):
        VOWELS = ""AEIOUaeiou""
        LOOKUP = set(VOWELS)
        vowels = [x for x in s if x in LOOKUP]
        vowels.sort(reverse=True)
        return """".join(vowels.pop() if x in LOOKUP else x for x in s)",O(nlogn)
"def m():
	[x, y, k] = [int(i) for i in input().split()]
	d=min(x, y)
	x-=d
	y-=d
	k-=d

	if k-x-y<0:
		print(-1)
	else:
		x+=y
		if x%2 > 0 and k%2>0:
			print(d+k-1)
		elif x%2 >0:
			print(d+k-1)
		elif k%2>0:
			print(d+k-2)
		else:
			print(d+k)

n=int(input())
for i in range(n):
	m()",O(1)
"import collections
import itertools



class Solution(object):
    def maxJumps(self, arr, d):
        def dp(arr, d, i, left, right, lookup):
            if lookup[i]:
                return lookup[i]
            lookup[i] = 1
            for j in itertools.chain(left[i], right[i]):
                lookup[i] = max(lookup[i], dp(arr, d, j, left, right, lookup)+1)
            return lookup[i]

        left, decreasing_dq = [[] for _ in range(len(arr))], collections.deque()
        for i in range(len(arr)):
            if decreasing_dq and i - decreasing_dq[0] == d+1:
                decreasing_dq.popleft()
            while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]:
                if left[i] and arr[left[i][-1]] != arr[decreasing_dq[-1]]:
                    left[i] = []
                left[i].append(decreasing_dq.pop())
            decreasing_dq.append(i)
        right, decreasing_dq = [[] for _ in range(len(arr))], collections.deque()
        for i in reversed(range(len(arr))):
            if decreasing_dq and decreasing_dq[0] - i == d+1:
                decreasing_dq.popleft()
            while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]:
                if right[i] and arr[right[i][-1]] != arr[decreasing_dq[-1]]:
                    right[i] = []
                right[i].append(decreasing_dq.pop())
            decreasing_dq.append(i)

        lookup = [0]*len(arr)
        return max(map(lambda x: dp(arr, d, x, left, right, lookup), range(len(arr))))",O(n)
"class Solution(object):
    def countQuadruplets(self, nums):
        dp = [0]*len(nums) 
        result = 0
        for l in range(len(nums)):
            cnt = 0
            for j in range(l):
                if nums[j] < nums[l]:
                    cnt += 1
                    result += dp[j]
                elif nums[j] > nums[l]:
                    dp[j] += cnt
        return result",O(n ^ 2)
"from heapq import *

n,k=map(int,input().split())
p=[int(X) for X in input().split()]
c=[int(x) for x in input().split()]
p=[[p[i],c[i],i] for i in range(n)]
p.sort()
j=0
an=[0]*n
an[p[0][2]]=p[0][1]
z=[]
heapify(z)

for i in range(1,n):

     s=p[i][1]
     if p[i][0]!=p[i-1][0]:
         while (j<i):

             heappush(z,(-1)*p[j][1])
             j+=1

     tt=[]
     for __ in range(k):

         tt.append(heappop(z))
         if not z:
             break

     for v in tt:
         s+=abs(v)
         heappush(z, v )

     an[p[i][2]]=s

print(*an)
",O(nlogn)
"import collections



class Solution(object):
    def minGroups(self, intervals):
        events = collections.Counter()
        for l, r in intervals:
            events[l] += 1
            events[r+1] -= 1
        result = curr = 0
        for t in sorted(events.keys()):
            curr += events[t]
            result = max(result, curr)
        return result",O(nlogn)
"def d(n):
    ret = 0
    n = list(str(n))
    for i in range(len(n)):
        ret += int(n[i])
    return ret

def main():
    n, s = map(int, input().split())

    l, h = 0, n
    for i in range(2000):
        m = (l + h) // 2
        if m - d(m) >= s:
            h = m
        else:
            l = m

    for i in range(-100, 100):
        t = m + i
        if t < 0 or t > n:
            continue
        if abs(t - d(t)) >= s:
            print(n - t + 1)
            exit()
    print(0)

if __name__ == '__main__':
    main()
",O(logn)
"R, G, B = list(map(int, input().split()))
r = sorted([int(x) for x in input().split()], reverse=True)
g = sorted([int(x) for x in input().split()], reverse=True)
b = sorted([int(x) for x in input().split()], reverse=True)

ans = 0
dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
            if j<G and k<B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])
            if i<R and k<B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])
            ans = max(ans, dp[i][j][k])
print(ans)
",O(n ^ 3)
"from collections import defaultdict, Counter
import os
import sys
from io import BytesIO, IOBase

ii = lambda: int(input())
lmii = lambda: list(map(int, input().split()))
slmii = lambda: sorted(map(int, input().split()))
li = lambda: list(input())
mii = lambda: map(int, input().split())
msi = lambda: map(str, input().split())

class SortedList:
    def __init__(self, iterable=[], _load=200):

        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):

        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):

        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):

        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):

        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):

        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):

        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):

        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):

        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):

        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):

        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):

        return self._len

    def __getitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):

        return (value for _list in self._lists for value in _list)

    def __reversed__(self):

        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):

        return 'SortedList({0})'.format(list(self))

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

def lcm(a, b): return (a * b) // gcd(a, b)

def main():

    w, h, n = mii()
    ws, dws, hs, dhs, hsm, wsm = SortedList([]), defaultdict(int), SortedList([]), defaultdict(int), SortedList(
        []), SortedList([])
    hsm.add(h);
    wsm.add(w);
    hs.add(0);
    ws.add(0);
    hs.add(h);
    ws.add(w);
    dhs[h] = 1;
    dhs[0] = 1;
    dws[0] = 1;
    dws[w] = 1
    for i in range(n):
        t, p = map(str, input().split())
        p = int(p)
        if t == ""H"":
            if dhs[p] == 0:
                hs.add(p)
                dhs[p] = 1
            ind = hs.bisect_left(p)
            pre, nex = hs[ind - 1], hs[ind + 1]
            hsm.__delitem__(hsm.bisect_left(nex - pre));
            hsm.add(p - pre);
            hsm.add(nex - p)
        else:
            if dws[p] == 0:
                ws.add(p)
                dws[p] = 1
            ind = ws.bisect_left(p)
            pre, nex = ws[ind - 1], ws[ind + 1]
            wsm.__delitem__(wsm.bisect_left(nex - pre));
            wsm.add(p - pre);
            wsm.add(nex - p)
        print(wsm[-1] * hsm[-1])
    pass

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(nlogn)
"import re


class Solution(object):

    def __init__(self, compressedString):
        self.__result = re.findall(r""([a-zA-Z])(\d+)"", compressedString)
        self.__index, self.__num, self.__ch = 0, 0, ' '

    def __next__(self):
        if not self.hasNext():
            return ' '
        if self.__num == 0:
            self.__ch = self.__result[self.__index][0]
            self.__num = int(self.__result[self.__index][1])
            self.__index += 1
        self.__num -= 1
        return self.__ch


    def hasNext(self):
        return self.__index != len(self.__result) or self.__num != 0",O(1)
"import math
n, r = [int(x) for x in input().split()]
x = [int(x) for x in input().split()]
ans = []
for i in range(n):
    t = r
    for j in range(i):
        a = abs(x[i] - x[j])
        if a <= 2 * r:
            t2 = (2 * r)**2
            t2 -= a**2
            t2 = math.sqrt(t2) + ans[j]
            t = max(t, t2)
    ans.append(t)
for k in ans:
    print(k)
",O(n ^ 2)
"inp = input().split()
totNums, mod = int(inp[0]), int(inp[1])

def Exp(b,exp):
	if exp==0: return 1
	temp = Exp(b,exp>>1)**2
	if exp%2==1: temp*=b
	return temp%mod

n = 410

fact, inv = [0 for i in range(n)],[0 for i in range(n)]
fact[0] = inv[0] = 1;
for i in range(1,totNums+1):
	fact[i] = fact[i-1]*i%mod
	inv[i] = Exp(fact[i],mod-2)

dp, choose = [[0 for i in range(n)] for j in range(n)], [[0 for i in range(n)] for j in range(n)]
for i in range(0,totNums+1):
	for j in range(0,i+1):
		choose[i][j] = fact[i]*inv[j]*inv[i-j]%mod
pow2 = [Exp(2,i) for i in range(n)]

dp[0][0] = 1
for i in range(totNums):
	for j in range(i+1):
		for k in range(1,totNums-i+1):
			dp[i+k+1][j+k] += dp[i][j]*pow2[k-1]*choose[j+k][k]
			dp[i+k+1][j+k] %= mod

ans = 0
for i in range(0,totNums+1):
	ans = (ans+dp[totNums+1][i])%mod
print(ans)",O(n ^ 3)
"import sys

n = int(input())
l = list(map(int,input().split()))
c = list(map(int,input().split()))

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

a = {0:0}

for i in range(n):
    b = a.copy()
    for p in a.items():
        d = gcd(p[0], l[i])
        cost = p[1] + c[i]
        if d not in b: b[d] = cost
        elif b[d] > cost: b[d] = cost
    a = b.copy()

if 1 not in a: a[1] = -1
print(a[1])
",np
"x, k = (int(x) for x in input().split())
mod = 10**9 + 7
if x == 0:
    print(0)
    quit()
if k == 0:
    print(x * 2 % mod)
    quit()
ans = pow(2, k + 1, mod)
ans *= x
ans %= mod
ans -= pow(2, k, mod) - 1
ans %= mod
ans += mod
ans %= mod
print(ans)
",O(logn)
"n = int(input())
ans = 1+n//2
print(ans)
",O(1)
"idx = {}
idx[0] = 0
s = 0
num = 9
for digit in range(1,12):
    s += num*digit

    idx[digit] = s
    num = num*10

N = int(input())

nubmer = 0
r = 0
d = 0
for digit in range(1,12):
    if N<=idx[digit] and N>idx[digit-1]:

        number = (N-idx[digit-1])//digit
        r = (N-idx[digit-1])%digit
        d = digit
        break

if r!=0:
    number += 1

num = 10**(d-1) + number - 1

digit = [int(i) for i in str(num)]
if r==0:
    print(digit[-1])

else:
    print(digit[r-1])",O(logn)
"class Solution2(object):
    def verifyPreorder(self, preorder):
        low = float(""-inf"")
        path = []
        for p in preorder:
            if p < low:
                return False
            while path and p > path[-1]:
                low = path[-1]
                path.pop()
            path.append(p)
        return True",O(n)
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n,m = inpl()
abc = [inpl() for _ in range(m)]

def sol(X):
    g = [[] for _ in range(n)]
    ny = [0]*n
    for a,b,c in abc:
        if c > X:
            g[a-1].append(b-1)
            ny[b-1] += 1
    seen = [0]*n
    q = deque()
    for i,x in enumerate(ny):
        if x==0: q.append(i); seen[i] = 1
    while q:
        v = q.popleft()
        for u in g[v]:
            if seen[u]: continue
            ny[u] -= 1
            if ny[u] == 0:
                q.append(u)
                seen[u]= 1
    return all(seen)

def sol2(X):
    g = [[] for _ in range(n)]
    ny = [0]*n
    for a,b,c in abc:
        if c > X:
            g[a-1].append(b-1)
            ny[b-1] += 1
    tps = [-1]*n; T = 0
    seen = [0]*n
    q = deque()
    for i,x in enumerate(ny):
        if x==0: q.append(i); seen[i] = 1
    while q:
        v = q.popleft()
        tps[v] = T; T += 1
        for u in g[v]:
            if seen[u]: continue
            ny[u] -= 1
            if ny[u] == 0:
                q.append(u)
                seen[u]= 1
    return tps

ok = 10**9+10; ng = -1
while abs(ok-ng)>1:
    mid = (ok+ng)//2
    if sol(mid): ok = mid
    else: ng = mid

res = []
tps = sol2(ok)
for i,(a,b,c) in enumerate(abc):
    if c <= ok:
        if tps[a-1] > tps[b-1]: res.append(i+1)
print(ok,len(res))
print(*res)",O(nlogn)
"class Solution2(object):
    def maxFrequencyScore(self, nums, k):
        nums.sort()
        result = left = curr = 0
        for right in range(len(nums)):
            curr += nums[right]-nums[(left+right)//2]
            while not curr <= k:
                curr -= nums[((left+1)+right)//2]-nums[left]
                left += 1
            result = max(result, right-left+1)
        return result",O(nlogn)
"a = int(input())
c = [1] * 30
for i in range (1,20):
	c[i] = 9 * i * pow(10,i-1)
for i in range (1,15):
	if (a > c[i]):
		a -= c[i]
	else:
		d = int((a-1) / i + pow(10,i-1) - 1)
		e = (a-1) % i + 1
		f = str(d+1)
		print(f[e-1])
		exit()",O(1)
"import sys
import math
from collections import OrderedDict
def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def minput():   return map(int, input().split())
def listinput(): return list(map(int, input().split()))
n,k=minput()
for i in range(1,n+1):
	if (i*(i+1))/2 -n+i==k:
		print(n-i)
		break",O(logn)
"def mul(x, y, md):
	return x * y % md;

def power(x, y, md) :
	res = 1;
	while (y != 0):
		if (y & 1):
			res = mul(res, x, 1000000007);
		x = mul(x, x, 1000000007);
		y >>= 1;
	return res

def inv(x, md):
	return power(x, md - 2, 1000000007);

t = input().split()
a = int(t[0])
k = int(t[1])
if (a == 0):
	print(0)
else:
	first = power(2, 2 * k, 1000000007);
	second = power(2, k, 1000000007);
	ans = mul(first, 2 * a - 1, 1000000007) + second;
	third = inv(second, 1000000007);
	ans = mul(ans, third, 1000000007);
	print(ans)",O(logn)
"print(""? 0 0"")
ans00 = input()
xr = 0
a = 0
b = 0
cb = 2 ** 29
while cb:
    print(""?"", xr + cb, cb)
    ans11 = input()
    print(""?"", xr, cb)
    if ans11 == ans00:
        ans01 = input()
        if ans01 == '1':
            a += cb
            b += cb
    else:
        ans00 = input()
        if ans11 == '1':
            b += cb
        else:
            a += cb
        xr += cb
    cb //= 2
print(""!"", a, b)",O(logn)
"if __name__ == '__main__':
    cin = input
    n, m = map(int, cin().split())
    s, l, f = [[] for _ in range(n)], [0] * m, 0

    for i in range(n):
        t = cin()
        for j in range(m):
            if t[j] == ""1"":
                l[j] += int(t[j])
                s[i].append(j)
    for i in range(n):
        r = set(l[c] - 1 for c in s[i])
        if not 0 in r:
            f = not f
            break
    print(""YNEOS""[not f::2])",O(n ^ 2)
"class Solution2(object):
    def canAliceWin(self, nums):
        return sum(x for x in nums if x < 10) != sum(x for x in nums if x >= 10)",O(n)
"import sys
import math
import bisect
from sys import stdin, stdout
from math import gcd, floor, sqrt, log2, ceil
from collections import defaultdict as dd
from bisect import bisect_left as bl, bisect_right as br
from bisect import insort
from collections import Counter
from collections import deque
from heapq import heappush,heappop,heapify
from itertools import permutations,combinations
from itertools import accumulate as ac
mod = int(1e9)+7

ip = lambda : int(stdin.readline())
inp = lambda: map(int,stdin.readline().split())
ips = lambda: stdin.readline().rstrip()
out = lambda x : stdout.write(str(x)+""\n"")

t = 1
for _ in range(t):
    q = ""? {} {}"".format(0,0)
    print(q,flush = True)
    cond = ip()
    cur_a = 0
    cur_b = 0
    for i in range(29,-1,-1):
        xor = (1<<i)
        query_a = cur_a^xor
        query_b = cur_b^xor
        q = ""? {} {}"".format(query_a,query_b)
        print(q,flush = True)
        val = ip()
        if val != cond:
            if cond == -1 and val == 1:
                cur_b ^= xor
                query_a = cur_a
                query_b = cur_b
                q = ""? {} {}"".format(query_a,query_b)
                print(q,flush = True)
                val = ip()
                cond = val
            else:
                cur_a ^= xor
                query_a = cur_a
                query_b = cur_b
                q = ""? {} {}"".format(query_a,query_b)
                print(q,flush = True)
                val = ip()
                cond = val
        else:
            cond = val
            query_a = cur_a^xor
            query_b = cur_b
            q = ""? {} {}"".format(query_a,query_b)
            print(q,flush = True)
            val = ip()
            if val == -1:
                cur_a ^= xor
                cur_b ^= xor
            else:
                pass
    ans = ""! {} {}"".format(cur_a,cur_b)
    print(ans,flush = True)
",O(1)
"n = int(input())
a = [int(i) for i in input().split()]
c = 0
for i in range(n):
    if a[i] > c:
        print(i+1)
        break
    else:
        c = max(a[i]+1, c)
else:
    print(-1)
",O(n)
"class Solution(object):
    def fixedPoint(self, A):
        left, right = 0, len(A)-1
        while left <= right:
            mid = left + (right-left)//2
            if A[mid] >= mid:
                right = mid-1
            else:
                left = mid+1
        return left if A[left] == left else -1",O(logn)
"d = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"", ""orange"":""Soul"", ""red"":""Reality"", ""yellow"":""Mind""}
s = set()
n = int(input())
for _ in range(n):
	w = input()
	s.add(w)
print(6 - n)
for (key, value) in d.items():
	if key not in s:
		print(value)",O(1)
"class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        for num in nums :
            idx = abs(num) - 1
            if nums[idx] < 0 :
                return abs(num)
            nums[idx] *= -1
        return -1
",O(n)
"import sys;input = sys.stdin.readline
def topological_sorted(digraph):
    n = len(digraph);indegree = [0] * n
    for v in range(n):
        for nxt_v in digraph[v]:indegree[nxt_v] += 1
    tp_order = [i for i in range(n) if indegree[i] == 0];stack = tp_order[:]
    while stack:
        v = stack.pop()
        for nxt_v in digraph[v]:
            indegree[nxt_v] -= 1
            if indegree[nxt_v] == 0:stack.append(nxt_v);tp_order.append(nxt_v)

    return len(tp_order) == n, tp_order
n, m, k = map(int, input().split());p = [input()[:-1] for i in range(n)];s = [list(input().split()) for i in range(m)];memo = {}
for idx, ptn in enumerate(p):
    val = 0
    for i in range(k):
        if ptn[i] != ""_"":val += (ord(ptn[i]) - 96) * (27 ** i)
    memo[val] = idx

for i, (string, idx) in enumerate(s):s[i] = tuple(map(ord, string)), int(idx)

graph = [[] for i in range(n)]
for string, idx in s:
    idxs = []
    idx -= 1
    for bit_state in range(1 << k):
        val = 0
        for i in range(k):
            if (bit_state >> i) & 1:
                continue
            val += (string[i] - 96) * (27 ** i)
        if val in memo:
            idxs.append(memo[val])
    if idx not in idxs:
        print(""NO"")
        exit()

    for idx_to in idxs:
        if idx == idx_to:
            continue
        graph[idx].append(idx_to)

flag, res = topological_sorted(graph)
if flag:print(""YES"");print(*[i + 1 for i in res])
else:print(""NO"")",np
"from collections import deque

class Solution(object):

    def __init__(self, width,height,food):
        self.__width = width
        self.__height = height
        self.__score = 0
        self.__f = 0
        self.__food = food
        self.__snake = deque([(0, 0)])
        self.__direction = {""U"": (-1, 0), ""L"": (0, -1), ""R"": (0, 1), ""D"": (1, 0)}
        self.__lookup = {(0, 0)}

    def move(self, direction):
        def valid(x, y):
            return 0 <= x < self.__height and \
                   0 <= y < self.__width and \
                   (x, y) not in self.__lookup
        d = self.__direction[direction]
        x, y = self.__snake[-1][0] + d[0], self.__snake[-1][1] + d[1]
        self.__lookup.remove(self.__snake[0])
        tail = self.__snake.popleft()
        if not valid(x, y):
            return -1
        elif self.__f != len(self.__food) and (self.__food[self.__f][0], self.__food[self.__f][1]) == (x, y):
            self.__score += 1
            self.__f += 1
            self.__snake.appendleft(tail)
            self.__lookup.add(tail)
        self.__snake.append((x, y))
        self.__lookup.add((x, y))
        return self.__score",O(1)
"class Solution(object):
    def nextPalindrome(self, num):
        def next_permutation(nums, begin, end):
            def reverse(nums, begin, end):
                left, right = begin, end-1
                while left < right:
                    nums[left], nums[right] = nums[right], nums[left]
                    left += 1
                    right -= 1

            k, l = begin-1, begin
            for i in reversed(range(begin, end-1)):
                if nums[i] < nums[i+1]:
                    k = i
                    break
            else:
                reverse(nums, begin, end)
                return False
            for i in reversed(range(k+1, end)):
                if nums[i] > nums[k]:
                    l = i
                    break
            nums[k], nums[l] = nums[l], nums[k]
            reverse(nums, k+1, end)
            return True
        
        nums = list(num)
        if not next_permutation(nums, 0, len(nums)//2):
            return """"
        for i in range(len(nums)//2):
            nums[-1-i] = nums[i]
        return """".join(nums)",O(n)
"n = int(input())
l = [4,7,47,74,444,447,474,477,747,744,774,777]

for i in l:
    if n % i == 0:
        print('YES')
        break
    else:
        pass
else:
    print('NO')
",O(1)
"a=input()
c1=a.count('1')
a=a.split('2')
lex='0'*a[0].count('0')+'1'*c1
n=len(a)
for i in range(1,n):
  lex=lex+'2'+'0'*a[i].count('0')
print(lex)
",O(n)
"def solve():
    k = [int(x) for x in input().split(' ')]
    k.sort()
    if min(k) == 1:
        return ""YES""
    elif k.count(2) >= 2:
        return ""YES""
    elif k.count(3) == 3:
        return ""YES""
    elif k == [2, 4, 4]:
        return ""YES""
    return ""NO""

print(solve())",O(1)
"a = [0 for i in range(100)]
b = [0 for i in range(100)]
for i in range(1, 100):
	a[i] = a[i - 1] * 2 + 1
	b[i] = b[i - 1] + a[i]
def calc(x):
	return (4 ** x - 1) // 3
for i in range(int(input())):
	n, k = map(int, input().split())
	if n > 35:
		print(""YES "" + str(n - 1))
	elif 1 + calc(n - 1) >= k:
		print(""YES "" + str(n - 1))
	elif calc(n) < k:
		print(""NO"")
	else:
		for i in range(1, (n + 1)):
			if b[i] <= k and k <= calc(n) - (2 ** (i + 1) - 1) * calc(n - i):
				print(""YES "" + str(n - i))
				break
		else:
			print(""NO"")",O(logn)
"import math

inp = input().split(' ')
m = int(inp[0])
n = int(inp[1])

result = []

for column in range(1, math.ceil(m/2) + 1):

    rowRange = range(1, n + 1)
    if column == math.ceil(m / 2) and m % 2 == 1:
        rowRange = range(1, math.ceil(n/2) + 1)

    for row in rowRange:
        result.append(str(column) + ' ' + str(row))
        if row == math.ceil(n/2) and n % 2 == 1 and column == math.ceil(m / 2) and m % 2 == 1:
            continue
        result.append(str(m + 1 - column) + ' ' + str(n + 1 - row))

print('\n'.join(result))
",O(n ^ 2)
"import collections


class Solution(object):
    def restoreArray(self, adjacentPairs):
        adj = collections.defaultdict(list)
        for u, v in adjacentPairs: 
            adj[u].append(v)
            adj[v].append(u)
        result = next([x, adj[x][0]] for x in adj if len(adj[x]) == 1)
        while len(result) != len(adjacentPairs)+1:
            result.append(adj[result[-1]][adj[result[-1]][0] == result[-2]])
        return result",O(n)
"a = input()
lst = []
a_1 = """"
for i in range(len(a)):
    if a[i] != "" "":
        a_1 = a_1 + a[i]
    else:
        lst.append(int(a_1))
        a_1 = """"
lst.append(int(a_1))
if lst[1] > 2 * lst[0] - 1:
    print(0)
else:
    countr = 0
    if lst[1] % 2 == 1:
        countr = (lst[1] - 1) // 2
    else:
        countr = (lst[1] - 2) // 2
    if lst[1] > lst[0] + 1:
        countr = countr - lst[1] + lst[0] + 1
    print(countr)",O(1)
"from math import *
n,x,y=map(int,input().split());g=gcd(x,y);n,x,y,r,h=n//g,x//g,(x+y)//g,n%g,lambda n:max(f(n,0),f(n,1))
def f(n,s):
 d=[-n,-n];d[s]=0
 for i in range(y):d=[max(d[0],d[1]),d[0]+n//y+(i*x%y<n%y)]
 return d[s]
print(h(n+1)*r+h(n)*(g-r))",np
"n, m = map(int, input().split())
a = list(map(int, input().split()))
h = max(a)
a.sort()
a.reverse()
a.append(0)
ans = sum(a)
for i in range(n):
    if a[i + 1] >= a[i]:
        a[i + 1] = a[i] - 1
    ans -= max(a[i] - a[i + 1], 1)
print(ans)",O(nlogn)
"from math import ceil
def main():
    n=int(input())
    a=list(map(int,input().split( )))
    ans=10**6
    value=10**9+7
    for i in range(n):
        t=ceil((a[i]-i)/n)
        tmp=i+n*t
        if tmp<value:
            value=tmp
            ans=i+1
    print(ans)
main()",O(n)
"from sys import stdin, stdout

N = 55

f = [0]
for i in range(1, N):
    f.append(f[-1]*4 + 1)
    if f[-1] > 1e18:
        break

t = int(stdin.readline().strip().split()[0])

for ca in range(0, t):
    n, m = [int(x) for x in stdin.readline().strip().split()]
    if n > 31:
        stdout.write(""YES {}\n"".format(n-1))
    else:

        start = 0
        found = False
        res = -1
        for i in range(1, n+1):
            start += 2**i -1
            end = start
            for k in range(1, i+1):
                end += f[n-k] * (2**(k+1) - 3)
            if m >= start and m <= end:
                found = True
                res = i
                break
        if found:
            stdout.write(""YES {}\n"".format(n-res))
        else:
            stdout.write(""NO\n"")
",O(logn)
"s = input()

count = 0

i = 0

while i < len(s):

    if int(s[i]) % 3 == 0:

        count += 1
        i += 1

    elif i < len(s)-1 and (int(s[i:i+2]) % 3 == 0 or int(s[i+1]) % 3 == 0 ):

        count += 1
        i +=2

    elif i < len(s)-2 and ( int(s[i+1:i+3]) % 3 == 0 or int(s[i:i+3]) % 3 == 0 or s[i+2] == '0') :

        count += 1
        i += 3

    else:

        i +=1

print(count)
",O(n)
"a, b = map(int, input().split("" ""))

a, b = min(a, b), max(a, b)

bina = str(bin(a))[2:]
binb = str(bin(b))[2:]

lena = len(bina)
lenb = len(binb)

ans = 0
if lena != lenb:
	ans = 2**lenb-1
else:
	a = '0'*(lena-lenb) + bina
	for i in range(lenb):
		if (bool(int(bina[i])) != bool(int(binb[i]))):
			ans = 2**(lenb-i) - 1
			break

print(ans)",O(logn)
"parent = [i for i in range(100002)]
def findSet(u):
    if parent[u] != u:
        parent[u] = findSet(parent[u])
    return parent[u]

def unionSet(u, v):
    up = findSet(u)
    vp = findSet(v)
    parent[up] = vp

if __name__ == '__main__':
    n, a, b = map(int, input().split())
    lst = list(map(int, input().split()))
    temp = {lst[i]: i for i in range(n)}
    for i in range(n):
        if a - lst[i] in temp:
            unionSet(i, temp[a - lst[i]])
        else:
            unionSet(i, n)
        if b - lst[i] in temp:
            unionSet(i, temp[b - lst[i]])
        else:
            unionSet(i, n + 1)

    pa = findSet(n)
    pb = findSet(n + 1)
    if pa == pb:
        print('NO')
    else:
        print('YES')
        lst = [0 if findSet(i) == pb else 1 for i in range(n)]
        print(*lst)",O(n)
"import sys
from array import array

def readline(): return sys.stdin.buffer.readline().decode('utf-8')

n, k = map(int, readline().split())
mod = 998244353

if k == 1:
    print(0)
    exit()

dp1 = [array('i', [0])*n for _ in range(n)]
dp2 = [array('i', [0])*n for _ in range(n)]
dp1[0][0] = 1

for i in range(n-1):
    for j in range(i+1):
        for l in range(j+1):
            dp2[j][0] += dp1[j][l]
            if dp2[j][0] >= mod:
                dp2[j][0] -= mod

            dp2[j+1 if j == l else j][l+1] += dp1[j][l]
            if dp2[j+1 if j == l else j][l+1] >= mod:
                dp2[j+1 if j == l else j][l+1] -= mod

            dp1[j][l] = 0

    dp1, dp2 = dp2, dp1

ans = 0
for i in range(1, n+1):
    t = (k-1) // i
    if t == 0:
        break

    dps1 = array('i', [0])*(t+1)
    dps2 = array('i', [0])*(t+1)
    dps1[0] = 1

    for j in range(n-1):
        for l in range(min(j+1, t)):
            dps2[0] += dps1[l]
            if dps2[0] >= mod:
                dps2[0] -= mod

            dps2[l+1] += dps1[l]
            if dps2[l+1] >= mod:
                dps2[l+1] -= mod

            dps1[l] = 0

        dps1, dps2 = dps2, dps1

    x = sum(dp1[i-1]) % mod
    ans = (ans + x * sum(dps1[:-1])) % mod

print(ans * 2 % mod)
",O(n ^ 3)
"class Solution(object):
    def kthCharacter(self, k):
        def popcount(x):
            return bin(x)[2:].count('1')

        return chr(ord('a')+popcount(k-1)%26)",O(1)
"class Solution2(object):
    def isFascinating(self, n):
        s = str(n)+str(2*n)+str(3*n)
        return '0' not in s and len(s) == 9 and len(set(s)) == 9",O(logn)
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1

        while l <= r:

            m = l + ((r - l) // 2)

            if nums[m] > target:
                r = m - 1
            elif nums[m] < target:
                l = m + 1
            else:
                return m
        return -1
",O(logn)
"import sys
input = lambda: sys.stdin.readline().rstrip()

from collections import deque, defaultdict
def topological_sort(In, Out):
    dq, L = deque(), []
    for i, I in enumerate(In):
        if not I:
            dq.append(i)
    while dq:
        v = dq.popleft()
        L.append(v)
        for w in Out[v]:
            In[w].remove(v)
            if not In[w]:
                dq.append(w)
    if len(L) < len(In):
        return False
    return L

def main():
    n, m, k = map(int,input().split())

    def edges(s):
        Ans = set()
        for i in range(2**k):
            ans = ''
            for j in range(k):
                if i>>j&1:
                    ans = ''.join([ans, s[j]])
                else:
                    ans = ''.join([ans, '_'])
            Ans.add(ans)
        return Ans

    D = defaultdict(lambda : -1)
    for i in range(n):
        D[input()] = i

    flag = 1
    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]
    for _ in range(m):
        S, t = input().split()
        t = int(t)

        for e in edges(S):
            if D[e]+1:
                Out[t-1].add(D[e])
                In[D[e]].add(t-1)
        if t-1 not in Out[t-1]:
            flag = 0
            break
        else:
            Out[t-1].remove(t-1)
            In[t-1].remove(t-1)

    T = topological_sort(In, Out)
    if flag == 0 or not T:
        print('NO')
    else:
        print('YES')
        print(*[t+1 for t in T], sep = ' ')

main()",np
"from collections import Counter;

n = int(input())

a = input()
b = input()
c = input()

fa = Counter(a);
fb = Counter(b);
fc = Counter(c);

la = min(fa.most_common(1)[0][1] + n, len(a))
lb = min(fb.most_common(1)[0][1] + n, len(a))
lc = min(fc.most_common(1)[0][1] + n, len(a))

if fa.most_common(1)[0][1] == len(a) and n == 1:
    la = len(a)-1

if fb.most_common(1)[0][1] == len(b) and n == 1:
    lb = len(b)-1

if fc.most_common(1)[0][1] == len(c) and n == 1:
    lc = len(c)-1

if la > max(lb, lc):
    print(""Kuro"")
elif lb > max(la, lc):
    print(""Shiro"")
elif lc > max(la, lb):
    print(""Katie"")
else:
    print(""Draw"")
",O(n)
"import math
def check(n):

    if n==1:
        return 1
    if n==2:
        return 2
    if n==3:
        return 6

    if n&1:
        return ((n-1)*(n-2)*(n))
    if math.gcd(n,n-3)==1:
        return (n*(n-1)*(n-3))
    else:
        return ((n-1)*(n-2)*(n-3))

n =int(input())
print(check(n))
",O(1)
"import collections
import heapq


class Solution(object):
    def avoidFlood(self, rains):
        lookup = collections.defaultdict(list)
        i = len(rains)-1
        for lake in reversed(rains):
            lookup[lake].append(i)
            i -= 1
        result, min_heap = [], []
        for i, lake in enumerate(rains):
            if lake:
                if len(lookup[lake]) >= 2:
                    lookup[lake].pop()
                    heapq.heappush(min_heap, lookup[lake][-1])
                result.append(-1)
            elif min_heap:
                j = heapq.heappop(min_heap)
                if j < i:
                    return []
                result.append(rains[j])
            else:
                result.append(1)
        return result if not min_heap else []",O(nlogn)
"import sys
input = sys.stdin.readline
maxn = int(1510)
ST = [0 for _ in range(4 * maxn)]
def update(id, l, r, val):
    if l == r == val:
        ST[id] = 1
        return
    if l > val or r < val:
        return
    mid = int((l + r) / 2)
    update(id * 2, l, mid, val)
    update(id * 2 + 1, mid + 1, r, val)
    ST[id] = ST[id * 2] + ST[id * 2 + 1]
    return
def get(id, l, r, x, y):
    if l > y or r < x:
        return 0
    if x <= l and r <= y:
        return ST[id]
    mid = int((l + r) / 2)
    return get(id * 2, l, mid, x, y) + get(id * 2 + 1, mid + 1, r, x, y)
n, res = int(input()), 0
for x in list(map(int, input().split())):
    res ^= get(1, 1, n, x + 1, n) % 2
    update(1, 1, n, x)
for i in range (int(input())):
    x, y = list(map(int, input().split()))
    if int((y - x) * (y - x + 1) / 2) & 1:
        res ^= 1
    if res:
        print(""odd"")
    else:
        print(""even"")",O(n ^ 2)
"class Solution(object):
    def topKFrequent(self, nums, k):
        counts = collections.Counter(nums)
        buckets = [[] for _ in range(len(nums)+1)]
        for i, count in counts.items():
            buckets[count].append(i)

        result = []
        for i in reversed(range(len(buckets))):
            for j in range(len(buckets[i])):
                result.append(buckets[i][j])
                if len(result) == k:
                    return result
        return result",O(n)
"class Solution2(object):
    def countOfPairs(self, n, x, y):
        x, y = x-1, y-1
        result = [0]*n
        for i in range(n):
            for j in range(i+1, n):
                result[min(abs(i-j), abs(i-x)+1+abs(y-j), abs(i-y)+1+abs(x-j))-1] += 2
        return result",O(n ^ 2)
"import itertools



class Solution(object):
    def paintWalls(self, cost, time):
        dp = [float(""inf"")]*(len(cost)+1)
        dp[0] = 0
        for c, t in zip(cost, time):
            for j in reversed(range(1, len(cost)+1)):
                dp[j] = min(dp[j], dp[max(j-(t+1), 0)]+c)
        return dp[-1]",O(n ^ 2)
"n, s = map(int, input().split())
ans = s
for i in range(n):
    f, t = map(int, input().split())
    if(t>(s-f)):
        ans +=  t - (s-f)
        s += t - (s-f)

print(ans)",O(n)
"n = int(input())
arr = list(map(int,input().split()))
arr.sort()
if n>=2 and  arr[0]==arr[1]==0:
	print(""cslnb"")
else:
	flag=0
	for i in range(n-2):
		if arr[i]==arr[i+1]==arr[i+2]:
			flag=1
			break
	if flag==1:
		print(""cslnb"")
	else:
		flag=0
		ind=0
		for i in range(n-1):
			if arr[i]==arr[i+1]:
				ind = i
				flag+=1
		if flag==1 and ind>0 and arr[ind-1]==arr[ind]-1:
			print(""cslnb"")

		elif flag>=2:
			print(""cslnb"")
		else:
			safe = 0
			for i in range(n):

				if arr[i]-i>=0:
					safe+=arr[i]-i

			if safe%2==0:
				print(""cslnb"")
			else:
				print(""sjfnb"")",O(nlogn)
"class Solution(object):
    def badSensor(self, sensor1, sensor2):
        for i in range(len(sensor1)-1):
            if sensor1[i] == sensor2[i]:
                continue
            while i+1 < len(sensor2) and sensor2[i+1] == sensor1[i]:
                i += 1
            return 1 if i+1 == len(sensor2) else 2
        return -1",O(n)
"import sys

int1 = lambda x: int(x) - 1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.readline())
def MI(): return map(int, sys.stdin.readline().split())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def SI(): return sys.stdin.readline()[:-1]

def main():
    inf=10**9
    n=II()
    aa=LI()
    dp1=[[-1]*n for _ in range(n)]
    dp2=[[inf]*n for _ in range(n)]
    for i in range(n):
        dp1[i][i]=aa[i]
        dp2[i][i]=1
    for w in range(2,n+1):
        for l in range(n-w+1):
            r=l+w-1
            for m in range(l,r):
                if dp1[l][m]!=-1 and dp1[l][m]==dp1[m+1][r]:
                    dp1[l][r]=dp1[l][m]+1
                    dp2[l][r]=1
    for m in range(n):
        for l in range(m+1):
            for r in range(m+1,n):
                dp2[l][r]=min(dp2[l][r],dp2[l][m]+dp2[m+1][r])
    print(dp2[0][n-1])

main()",O(n ^ 3)
"n, a, b = map(int, input().split())

h = sorted(map(int, input().split()))

print(h[b] - h[b-1])
",O(nlogn)
"class Solution(object):
    def alphabetBoardPath(self, target):
        x, y = 0, 0
        result = []
        for c in target:
            y1, x1 = divmod(ord(c)-ord('a'), 5)
            result.append('U' * max(y-y1, 0))
            result.append('L' * max(x-x1, 0))
            result.append('R' * max(x1-x, 0))
            result.append('D' * max(y1-y, 0))
            result.append('!')
            x, y = x1, y1
        return """".join(result)",O(n)
"n=input();print(max(map(int,(n,n[:-1],n[:-2]+n[-1]))))",O(1)
"mod = 1000000000+7
def fp(x ,y):
    if y == 1:
        return x
    if y == 0:
        return 1
    t = fp(x,y//2)%mod
    if y%2 == 1:
        return (t*t*x)%mod
    else:
        return (t*t)%mod

def inv(x):
    return fp(x%mod,mod-2)%mod

n,k=list(map(int,input().split()))
if not n:
    print(0)
    exit()
if not k:
    print( (2*n)%mod )
    exit()
numberOfPro =fp(2,k)
last = n*numberOfPro
first = (n-1)*numberOfPro+1
sumOfLast = (last)*(last+1)*inv(2)
sumOfFirst = first*(first-1)*inv(2)
num = 2*(sumOfLast - sumOfFirst)*inv(numberOfPro)
print(num%mod)
",O(logn)
"class Solution(object):
    def intersectionSizeTwo(self, intervals):
        intervals.sort(key = lambda s_e: (s_e[0], -s_e[1]))
        cnts = [2] * len(intervals)
        result = 0
        while intervals:
            (start, _), cnt = intervals.pop(), cnts.pop()
            for s in range(start, start+cnt):
                for i in range(len(intervals)):
                    if cnts[i] and s <= intervals[i][1]:
                        cnts[i] -= 1
            result += cnt
        return result",O(n ^ 2)
"def whb(a,b,c,d):
    dim = (c-a+1)*(d-b+1)
    col1 = dim//2
    col2 = dim-col1
    if (a+b)%2==0:
        return [col2, col1]
    else:
        return [col1, col2]

def insegment(a, b, a1, b1):
    li = [[a,1], [b,1], [a1,2], [b1,2]]
    li.sort()
    if li[0][1] == li[1][1]:
        if li[1][0] == li[2][0]:
            return [li[1][0], li[2][0]]
        else:
            return -1
    else:
        return [li[1][0], li[2][0]]

def inrect(a,b,c,d,a1,b1,c1,d1):
    xra = insegment(a,c,a1,c1)
    yra = insegment(b,d,b1,d1)
    if xra==-1 or yra==-1:
        return -1
    else:
        return [xra[0], yra[0], xra[1], yra[1]]

q = int(input())
for quer in range(q):
    [n, m] = [int(i) for i in input().split()]
    [x1, y1, x2, y2] = [int(i) for i in input().split()]
    [x3, y3, x4, y4] = [int(i) for i in input().split()]
    [white, black] = whb(1,1,n,m)
    [w1, b1] = whb(x1, y1, x2, y2)
    [w2, b2] = whb(x3, y3, x4, y4)
    black+= w2-b1
    white+= b1-w2
    inter = inrect(x1, y1, x2, y2, x3, y3, x4, y4)
    if type(inter)==list:
        [w3, b3] = whb(inter[0], inter[1],inter[2], inter[3])
        black += b3
        white -= b3
    print(white, black)",O(1)
"k1,k2,k3=map(int,input().split())
a=[k1,k2,k3];a=sorted(a)

i=0
while i<=5000:
 if dp[i]==0 and i+a[0]<=5000:
   while i+a[0]<=5000:
     dp[i]=1
     i=i+a[0]
 else:i+=1

while i<=5000:
 if dp[i]==0 and i+a[1]<=5000:
   while i+a[1]<=5000:
     dp[i]=1
     i=i+a[1]
 else:i+=1

while i<=5000:
 if dp[i]==0 and i+a[2]<=5000:
   while i+a[2]<=5000:
     dp[i]=1
     i=i+a[2]
 else:i+=1

if dp.count(0)==0:print(""YES"")
else:print(""NO"")
",O(1)
"class Solution2(object):
    def maxAncestorDiff(self, root):
        def maxAncestorDiffHelper(node, mx, mn): 
            if not node:
                return 0
            result = max(mx-node.val, node.val-mn)
            mx = max(mx, node.val)
            mn = min(mn, node.val)
            result = max(result, maxAncestorDiffHelper(node.left, mx, mn))
            result = max(result, maxAncestorDiffHelper(node.right, mx, mn))
            return result

        return maxAncestorDiffHelper(root, 0, float(""inf""))",O(n)
"class Solution(object):
    def getStrongest(self, arr, k):
        arr.sort()
        m = arr[(len(arr)-1)//2]
        result = []
        left, right = 0, len(arr)-1
        while len(result) < k:
            if m-arr[left] > arr[right]-m:
                result.append(arr[left])
                left += 1
            else:
                result.append(arr[right])
                right -= 1
        return result",O(nlogn)
"import math
import sys
from collections import deque,defaultdict
read=sys.stdin.read
readline=sys.stdin.readline
readlines=sys.stdin.readlines

def Extended_Euclid(n,m):
    stack=[]
    while m:
        stack.append((n,m))
        n,m=m,n%m
    if n>=0:
        x,y=1,0
    else:
        x,y=-1,0
    for i in range(len(stack)-1,-1,-1):
        n,m=stack[i]
        x,y=y,x-(n//m)*y
    return x,y

class MOD:
    def __init__(self,p,e=1):
        self.p=p
        self.e=e
        self.mod=self.p**self.e

    def Pow(self,a,n):
        a%=self.mod
        if n>=0:
            return pow(a,n,self.mod)
        else:
            assert math.gcd(a,self.mod)==1
            x=Extended_Euclid(a,self.mod)[0]
            return pow(x,-n,self.mod)

    def Build_Fact(self,N):
        assert N>=0
        self.factorial=[1]
        self.cnt=[0]*(N+1)
        for i in range(1,N+1):
            ii=i
            self.cnt[i]=self.cnt[i-1]
            while ii%self.p==0:
                ii//=self.p
                self.cnt[i]+=1
            self.factorial.append((self.factorial[-1]*ii)%self.mod)
        self.factorial_inv=[None]*(N+1)
        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)
        for i in range(N-1,-1,-1):
            ii=i+1
            while ii%self.p==0:
                ii//=self.p
            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod

    def Fact(self,N):
        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod

    def Fact_Inv(self,N):
        if self.cnt[N]:
            return None
        return self.factorial_inv[N]

    def Comb(self,N,K,divisible_count=False):
        if K<0 or K>N:
            return 0
        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod
        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]
        if divisible_count:
            return retu,cnt
        else:
            retu*=pow(self.p,cnt,self.mod)
            retu%=self.mod
            return retu

def Bell_Numbers(N,mod,prime=False):
    bell_numbers=[0]*(N+1)
    bell_numbers[0]=1
    MD=MOD(mod)
    if prime:
        MD.Build_Fact(min(mod-2,N-1))
        for i in range(1,min(mod,N+1)):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
        for i in range(mod,N+1):
            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod
    else:
        MD.Build_Fact(N-1)
        for i in range(1,N+1):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
    return bell_numbers

M,N=map(int,readline().split())
S=[readline().rstrip() for i in range(N)]
dct=defaultdict(int)
for i in range(M):
    tpl=()
    for j in range(N):
        tpl+=(S[j][i],)
    dct[tpl]+=1
ans=1
mod=10**9+7
bell=Bell_Numbers(M,mod)
for c in dct.values():
    ans*=bell[c]
    ans%=mod
print(ans)",O(n ^ 2)
"a, v = list(map(int, input().split("" "")))
l, d, w = list(map(int, input().split("" "")))

if(v <= w or w * w > 2 * a * d):
    if(v * v > 2 * a * l):
        print((2 * l / a) ** 0.5)
    else:
        print(l / v + v / 2 / a)
else:
    u = (w * w / 2 + a * d) ** 0.5
    if(u > v):
        m =  v / a + (v - w) / a + (d - (v * v / 2 / a) - (v * v - w * w) / 2 / a) / v
    else:
        m = (2 * u - w) / a

    if(v * v > 2 * a * (l - d + w * w / 2 / a)):
        print(m - w / a + (2 * (l - d + (w * w / 2 / a)) / a) ** 0.5)
    else:
        print(m - w / a + (l - d + w * w / 2 / a) / v + v / 2 / a)",O(1)
"class Solution3(object):
    def minimumScore(self, nums, edges):
        def dfs(u, p, result):
            total = nums[u]
            for v in adj[u]:
                if v == p:
                    continue
                total ^= dfs(v, u, result)
            result.append(total)
            return total
                
        adj = [[] for _ in range(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        total = reduce(lambda x, y: x^y, nums)
        result = float(""inf"")
        for u, v in edges: 
            left = []
            dfs(u, v, left)
            right = []
            dfs(v, u, right)
            for candidates in (left, right):
                total2 = candidates.pop()
                for x in candidates:
                    a, b, c = total^total2, x, total2^x
                    result = min(result, max(a, b, c)-min(a, b, c))
        return result",O(n ^ 2)
"n = int(input())
print(0, 0, n)",O(1)
"n = int(input())
sum = 0

for i in range(2, n + 1):
  j = 2
  while(j * i <= n):
    sum += i
    j += 1
print(4 * sum)",O(n)
"def main():
    buf = input()
    buflist = buf.split()
    hand = buflist;
    t = []
    for i in range(3):
        t.append([])
        for j in range(9):
            t[i].append(0)
    for x in hand:
        idx = 0
        if x[1] == 'm':
            idx = 0
        elif x[1] == 'p':
            idx = 1
        elif x[1] == 's':
            idx = 2
        t[idx][int(x[0])-1] += 1
    max_cons = 0
    max_mult = 0
    for i in range(3):
        cons = [0, 0, 0]
        for j in range(9):
            cons[0] = cons[1]
            cons[1] = cons[2]
            if t[i][j] > 0:
                cons[2] = 1
            else:
                cons[2] = 0
            max_cons = max(sum(cons), max_cons)
            max_mult = max(max_mult, t[i][j])
    print(3 - max(max_cons, max_mult))

if __name__ == '__main__':
    main()
",O(n)
"def clc(mid):
    sm , i , cp = 0 , 1 , n
    cur = 1
    while(cp + 1 > cur):
        sm = sm + i * cur
        i+= 1
        cp -= cur
        cur = cur * mid
    return sm + i * cp

n , s = map(int,input().split())

sm = n * (n + 1) // 2
dp = [0] * 100005
x = [0] * 100005
y = [0] * 100005
x[0] = 1
if s + 1 < 2 * n:
    print(""No"")
    exit()
if s > sm:
    print(""No"")
    exit()
else:
    print(""Yes"")

l = 0
r = n
while r - l > 1:
    mid = (r + l) // 2
    if(clc(mid) > s):
        l = mid
    else:
        r = mid
i = 2
while( i < n + 1):
    y[i] = i + r
    y[i] -= 2
    y[i] = y[i] // r
    x[i] = x[y[i]] + 1
    if(dp[x[i]] == 0):
        dp[x[i]] = i
    i = i + 1
mx = x[n]
ip = n
s = s - clc(r)
while(s != 0):
    if(x[ip] != x[ip - 1]):
        ip = ip - 1;
    if(s > mx - x[ip]):
        y[ip] = dp[mx]
        mx = mx + 1
        s -= mx - x[ip]
        x[ip] = mx
        dp[mx] = ip
    else:
        y[ip] = dp[s + x[ip] - 1]
        s = 0
    ip = ip - 1
i = 2
while(i < n + 1):
    print(y[i])
    i = i + 1
",O(n)
"k = int(input())

mul = 1
d = 1

while k>mul*9*d:
    k-=mul*9*d
    d+=1
    mul*=10

x = k%d
y = k//d
y+=mul

if x==0:
    print((y-1)%10)
else:
    y = y//pow(10,d-x)
    print(y%10)
",O(logn)
"n = int(input())
l = list(map(int,input().split()))
m = 0
for i in range(n):
	if l[i] >= 0:
		l[i] = -l[i] - 1
for i in range(n):
	if l[i] < 0 :
		m += 1
if m % 2 == 0:
	for i in range(n):
		print(l[i], end = "" "")
else:
	maksi = -1000000000000
	for i in range(n):
		if abs(l[i]) > maksi:
			maksi = abs(l[i])
			mk = i
	l[mk] = -l[mk] - 1
	for i in range(n):
		print(l[i], end = "" "")",O(n)
"n = int(input())
a = list(map(int,input().split()))
cost = list(map(int,input().split()))
ans  = float(""inf"")
for i in range(n):
    m,r = float(""inf""),float(""inf"")
    for j in range(i):
        if a[j]<a[i]:
            m = min(m,cost[j])
    for k in range(i+1,n):
        if a[k]>a[i]:
            r = min(r,cost[k])
    ans = min(ans,cost[i]+m+r)
print(ans if ans!=float(""inf"") else -1)
",O(n ^ 2)
"class Solution(object):
    def findTheCity(self, n, edges, distanceThreshold):
        dist = [[float(""inf"")]*n for _ in range(n)]
        for i, j, w in edges:
            dist[i][j] = dist[j][i] = w
        for i in range(n):
            dist[i][i] = 0
        for k in range(n): 
            for i in range(n): 
                for j in range(n): 
                    dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]) 
        result = {sum(d <= distanceThreshold for d in dist[i]): i for i in range(n)}
        return result[min(result.keys())]",O(n ^ 3)
"from sys import stdin
input = stdin.buffer.readline

n=int(input())
arr=[int(x) for x in input().split()]

arr.sort()
s=set(arr)
flag=False
for ele in arr:
    for i in range(31):
        if ((ele-2**i) in s) and ((ele+2**i) in s):
            ans=[ele,ele-2**i,ele+2**i]
            flag=True
            break
    if flag:
        break
if flag:
    print(3)
    print(*ans)
    exit()
for ele in arr:
    for i in range(31):
        if (ele+2**i) in s:
            ans=[ele,ele+2**i]
            flag=True
            break
    if flag:
        break
if flag:
    print(2)
    print(*ans)
else:
    print(1)
    print(arr[0])",O(nlogn)
"from scipy.optimize import linear_sum_assignment as hungarian
import itertools



class Solution2(object):
    def maximumANDSum(self, nums, numSlots):
        adj = [[-((nums[i] if i < len(nums) else 0) & (1+x//2)) for x in range(2*numSlots)] for i in range(2*numSlots)]
        return -sum(adj[i][j] for i, j in zip(*hungarian(adj)))",O(n ^ 3)
"import sys,math
from collections import deque,defaultdict
import operator as op
from functools import reduce
from itertools import permutations

I=sys.stdin.readline

def ii():
	return int(I().strip())
def li():
	return list(map(int,I().strip().split()))
def mi():
	return map(int,I().strip().split())

def ncr(n, r):
    r = min(r, n-r)
    numer = reduce(op.mul, range(n, n-r, -1), 1)
    denom = reduce(op.mul, range(1, r+1), 1)
    return numer // denom

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def isPrime(n):
	if n<=1:
		return False
	elif n<=2:
		return True
	else:

		for i in range(2,int(n**.5)+1):
			if n%i==0:
				return False
		return True

def main():
	n=ii()
	arr=li()
	sett=set(arr)
	ans=[arr[0]]
	flag=0
	for x in range(31):
		for i in arr:
			if (i-2**x) in sett and (i+2**x) in sett:
				ans=[i-2**x,i,i+2**x]
				flag=1
				break
			elif i-2**x in sett:
				ans=[i-2**x,i]
			elif i+2**x in sett:
				ans=[i,i+2**x]

		if flag:
			break
	print(len(ans))
	print(*ans)

if __name__ == '__main__':
	main()",O(nlogn)
"s=input()

while(1):
        if(len(s)==1):
                print(0)
                break

        elif(s==s[::-1]):

            s=s[1:]

        else:
            print(len(s))
            break",O(n)
"class Solution(object):
    def countDistinctStrings(self, s, k):
        MOD = 10**9+7
        return pow(2, len(s)-k+1, MOD)",O(logn)
"import sys
keta=29
print(""?"",0,0,flush=True)

A00=int(input())
if A00==0:
    ANS=0
    for k in range(keta,-1,-1):
        print(""?"",2**k,0,flush=True)
        if int(input())==-1:
            ANS+=2**k
    print(""!"",ANS,ANS,flush=True)
    sys.exit()

A=0
B=0
for k in range(keta,-1,-1):
    LIST=[]
    print(""?"",2**k+A,B,flush=True)
    LIST.append(int(input()))
    print(""?"",A,2**k+B,flush=True)
    LIST.append(int(input()))

    if LIST[0]!=LIST[1]:
        if LIST[0]==-1:
            A+=2**k
            B+=2**k

    else:
        if A00==1:
            A+=2**k
        else:
            B+=2**k
        A00=LIST[0]
print(""!"",A,B,flush=True)
",O(1)
"def problem(s, p):
    for i in range(len(p)):
        l = p[:i] + ' '
        r = p[i:] + ' '

        dp = [0] + [None] * i

        for x in s:
            for j in range(i, -1, -1):
                if dp[j] is None:
                    continue

                if l[j] == x:
                    dp[j + 1] = dp[j] if dp[j + 1] is None else max(dp[j], dp[j + 1])

                temp = r[dp[j]]
                if r[dp[j]] == x:
                    dp[j] += 1

        if dp[-1] == len(r) - 1:
            return 'YES'

    return 'NO'

for _ in range(int(input())):
    print(problem(input(), input()))
",O(n ^ 3)
"class Solution(object):
    def isValid(self, code):
        def validText(s, i):
            j = i
            i = s.find(""<"", i)
            return i != j, i

        def validCData(s, i):
            if s.find(""<![CDATA["", i) != i:
                return False, i
            j = s.find(""]]>"", i)
            if j == -1:
                return False, i
            return True, j+3

        def parseTagName(s, i):
            if s[i] != '<':
                return """", i
            j = s.find('>', i)
            if j == -1 or not (1 <= (j-1-i) <= 9):
                return """", i
            tag = s[i+1:j]
            for c in tag:
                if not (ord('A') <= ord(c) <= ord('Z')):
                    return """", i
            return tag, j+1

        def parseContent(s, i):
            while i < len(s):
                result, i = validText(s, i)
                if result:
                    continue
                result, i = validCData(s, i)
                if result:
                    continue
                result, i = validTag(s, i)
                if result:
                    continue
                break
            return i

        def validTag(s, i):
            tag, j = parseTagName(s, i)
            if not tag:
                return False, i
            j = parseContent(s, j)
            k = j + len(tag) + 2
            if k >= len(s) or s[j:k+1] != ""</"" + tag + "">"":
                return False, i
            return True, k+1

        result, i = validTag(code, 0)
        return result and i == len(code)",O(n)
"class Solution(object):
    def decompressRLElist(self, nums):
        return [nums[i+1] for i in range(0, len(nums), 2) for _ in range(nums[i])]",O(n)
"def subsets(S):
    sets = []
    len_S = len(S)
    for i in range(1 << len_S):
        subset = [S[bit] for bit in range(len_S) if i & (1 << bit)]
        sets.append(subset)
    return sets

n, l, r, x = list(map(int, input().split()))
problems = list(map(int, input().split()))
res = 0
for m in subsets(problems):
    if l <= sum(m) <= r and (max(m) - min(m)) >= x:
        res += 1
print(res)",np
"class Solution2(object):
    def maxSumBST(self, root):
        def dfs(node, result):
            if not node:
                return True, 0, float(""inf""), float(""-inf"")
            lvalid, lsum, lmin, lmax = dfs(node.left, result)
            rvalid, rsum, rmin, rmax = dfs(node.right, result)
            if lvalid and rvalid and lmax < node.val < rmin:
                total = lsum + node.val + rsum
                result[0] = max(result[0], total)
                return True, total, min(lmin, node.val), max(node.val, rmax)
            return False, 0, 0, 0

        result = [0]
        dfs(root, result)
        return result[0]",O(n)
"class Solution(object):
    def isSelfCrossing(self, x):
        if len(x) >= 5 and x[3] == x[1] and x[4] + x[0] >= x[2]:
            return True

        for i in range(3, len(x)):
            if x[i] >= x[i - 2] and x[i - 3] >= x[i - 1]:
                return True
            elif i >= 5 and x[i - 4] <= x[i - 2] and x[i] + x[i - 4] >= x[i - 2] and \
                            x[i - 1] <= x[i - 3] and x[i - 5] + x[i - 1] >= x[i - 3]:
                return True
        return False",O(n)
"class Solution2(object):
    def countVowelPermutation(self, n):
        MOD = 10**9 + 7
        a, e, i, o, u = 1, 1, 1, 1, 1
        for _ in range(1, n):
            a, e, i, o, u = (e+i+u) % MOD, (a+i) % MOD, (e+o) % MOD, i, (i+o) % MOD
        return (a+e+i+o+u) % MOD",O(n)
"import sys
n,m,k = map(int,input().split())

if k%2:
    ans = [[-1]*m for _ in range(n)]
    for row in ans:
        print(*row)
    exit()
A = []
B = []
inf = float('inf')
for _ in range(n):
    A.append(list(map(int,input().split())))
for _ in range(n-1):
    B.append(list(map(int,input().split())))

dp = [[inf]*m for _ in range(n)]
ans = [[None]*m for _ in range(n)]

for l in range(k//2+1):
    new_dp = [[inf]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            if l == 0:
                new_dp[i][j] = 0
                continue

            up = B[i-1][j]*2 + dp[i-1][j] if i-1>=0 else inf
            right = A[i][j]*2 + dp[i][j+1] if j+1<m else inf
            left = A[i][j-1]*2 + dp[i][j-1] if j-1>=0 else inf
            down = B[i][j]*2 + dp[i+1][j] if i+1<n else inf

            new_dp[i][j] = min(up,right,left,down)
            if l == k//2:
                ans[i][j] = new_dp[i][j]
    dp = new_dp
for row in ans:
    print(*row)
",O(n ^ 3)
"class Solution(object):
    def projectionArea(self, grid):
        result = 0
        for i in range(len(grid)):
            max_row, max_col = 0, 0
            for j in range(len(grid)):
                if grid[i][j]:
                    result += 1
                max_row = max(max_row, grid[i][j])
                max_col = max(max_col, grid[j][i])
            result += max_row + max_col
        return result",O(n ^ 2)
"from collections import defaultdict
n,k = map(int,input().split())
arr = list(map(int,input().split()))
xors = defaultdict(int)
xors[0]=1
comp = (1<<k)-1
ans = n*(n+1)//2
xor = 0
for a in arr:
	xor^=a
	if xors[xor]>xors[comp^xor]:
		xor^=comp
	ans-=xors[xor]
	xors[xor]+=1
print(ans)",O(n)
"from math import inf

if True:
    n,m,k = map(int,input().split())
    cosp = [[int(x) for x in input().split()]+[inf] for _ in range(n)]
    cosv = [[int(x) for x in input().split()]for _ in range(n-1)]+[[inf]*m]
    if k%2==1:
        for _ in range(n):
            print(*[-1]*m)

    else:
        dp = [[0]*m for i in range(n)]
        xx,yy = [0,0,1,-1],[1,-1,0,0]
        for _ in range(k//2):
            dp1 = [[inf]*m for _ in range(n)]
            for i in range(n):
                for j in range(m):
                    for kk in range(4):
                        x1,y1 = i+xx[kk],j+yy[kk]
                        if kk < 2:
                            if kk==1:
                                edge = cosp[i][j-1]
                            else:
                                edge=cosp[i][j]
                        else:
                            if kk==3 :
                                edge = cosv[i-1][j]
                            else:
                                edge = cosv[i][j]
                        if edge != inf:
                            dp1[i][j] = min(dp1[i][j],2*edge+dp[x1][y1])
            dp = dp1[:]
        for i in dp:
            print(*i)",O(n ^ 3)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        pass


class Solution(object):
    def swapNodes(self, head, k):
        left, right, curr = None, None, head
        while curr:
            k -= 1
            if right:
                right = right.__next__
            if k == 0:
                left = curr
                right = head
            curr = curr.__next__
        left.val, right.val = right.val, left.val
        return head",O(n)
"

class Solution(object):
    def numberOfEmployeesWhoMetTarget(self, hours, target):
        return sum(x >= target for x in hours)
",O(n)
"I=lambda:map(int,input().split())
n,m=I()
q={}
for i in range(1,n+1):q[i]=0
for i in I():q[i]+=1
print(min(q.values()))",O(n ^ 2)
"import collections
import functools


class Solution(object):
    def minimumLengthEncoding(self, words):
        words = list(set(words))
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()

        nodes = [functools.reduce(dict.__getitem__, word[::-1], trie)
                 for word in words]

        return sum(len(word) + 1
                   for i, word in enumerate(words)
                   if len(nodes[i]) == 0)",O(n)
"n, a, b = map(int, input().split())
if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:
    print('NO')
    exit()
print('YES')
f = int(a == 1)
g = [a, b][f]
r = [[f] * n for i in range(n)]
for i in range(n):
    r[i][i] = 0
for i in range(n - g):
    r[i][i + 1] ^= 1
    r[i + 1][i] ^= 1
for x in r:
    print(*x, sep='')
",O(n ^ 2)
"def s(n):
    return (n*(n+1))//2

def diff(st,en):
    return s(en) - s(st-1)

def bs(k,n):
    st = 1
    en = k
    while(st < en):
        mid = (st+en)//2
        sum = diff(mid,k)
        if sum == n:
             return k-mid+1
        if sum > n:
            st = mid+1
        else:
            en = mid
    return k-st+2

if __name__ == '__main__':
   n,k = map(int,input().split())
   if n == 1:
       print(0)
   elif n <= k:
       print(1)
   else:
       n-=1
       k-=1
       if s(k) < n:
            print(-1)
       else:
           print(bs(k,n))
",O(logn)
"from math import pi, sin

n, r = map(float, input().split())
ang = pi / n
k = sin(ang)
print(k * r /  (1 - k))
",O(1)
"n,s=map(int,input().split())

def ver(i):
	t=str(i)
	ans=0
	for j in t:
		ans+=int(j)
	return(ans)
l=len(str(s))
if n<s:
	print(0)
	exit()
if s+10*(l**2+1)<=n:
	ans=n-s+1-10*(l**2+1)
	for i in range(s,s+10*(l**2+1)):
		if s+ver(i)<=i:ans+=1
else:
	ans=0
	for i in range(s,n+1):
		if s+ver(i)<=i:ans+=1
print(ans)",O(logn)
"N = 1030
MOD = int(1e9+7)
c = [[0] * N for i in range(N)]
for i in range(N):
    c[i][0] = 1
for i in range(1, N):
    for j in range(1, N):
        c[i][j] = (c[i-1][j] + c[i-1][j-1]) % MOD

arr = list(map(int, list(input())))
cnt = int(input())
if cnt == 0:
    print(1)
    exit()

dp = [0] * N
for i in range(2, N):
    dp[i] = dp[bin(i).count('1')] + 1
res = 0
for i in range(1, N):
    if dp[i] != cnt - 1:
        continue
    n, k = len(arr)-1, i
    for pos in range(len(arr)):
        if arr[pos] == 1:
            res = (res + c[n][k]) % MOD
            k -= 1
        n -= 1
    if n == -1 and k == 0:
        res += 1
if cnt == 1:
    res -= 1
print(res)",O(n)
"n=int(input())
arr=list(map(int, input().split()))
dict={}
rawsum=0
a=n-1
b=1
for i in range(n):
    if i == 0:
	    rawsum = rawsum - (arr[i] * (a))
	    a-=1
    elif i == n - 1:
        rawsum = rawsum + (arr[i] * (b))
        b+=1
    else:
        rawsum = rawsum + (arr[i] * (b))
        rawsum = rawsum - ((arr[i] * (a)))
        a-=1
        b+=1
i=n-1
while i>=0:
    if dict.get(arr[i])==None:
        dict[arr[i]]=1
    else:
        dict[arr[i]]=dict[arr[i]]+1
    s=arr[i]-1
    g=arr[i]+1
    if dict.get(s)!=None:
        rawsum+=dict[s]
    if dict.get(g)!=None:
        rawsum-=dict[g]
    i-=1
print(rawsum)",O(nlogn)
"n = int(input())
ls= [list(map(int, input().split())) for i in range(n)]

lsr = [[max(ls[i][0]-ls[i][1], 0), ls[i][0]+ls[i][1]] for i in range(n)]
lsr.sort(key=lambda x: x[1])
idx = 0
ans = 0

for l in lsr:
    if idx <= l[0]:
        idx = l[1]
        ans+=1

print(ans)",O(nlogn)
"n, m = map(int, input().split())
a = []
b = []
check = True
while n >= 0:
    if check == True:
        a.append(5)
        n -= 5
        b.append(4)
        check = False
    else:
         check = True
         a.append(4)
         n -= 4
         b.append(5)

if m != 1:
    a.append(5)
    b.append(6)
else:
    a.append(5)
    b.append(5)

print(*a, sep = """")
print(*b, sep = """")
",O(1)
"n = int(input())
b = list(map(int, input().split(' ')))
e = [[-1] * (n+1) for _ in range(2048)]

d = [[] for _ in range(n)]
for i, v in enumerate(b):
	e[v][i] = i
	d[i].append(i)

for v in range(1, 2048):
	for i in range(n):
		j = e[v][i]
		if j != -1:
			h = e[v][j+1]
		else:
			h = -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)

a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		if s > 0:
			temp = a[s-1]+1
		else :
			temp = 1
		a[e] = min(a[e], temp)
print(a[n-1])",O(n ^ 3)
"n = int(input())
m = int(n**.5)
a = []

for i in range(0, n, m):
    for j in range(i, min(i+m, n)):
        a.append(min(i+m, n)-j + i)

print(' '.join(str(_) for _ in a))
",O(n)
"from math import ceil
n = int(input())
if n == 1:
    print(1)
    exit(0)
if n == 2:
	print('1 2')
	exit(0)
elif n == 3:
	print('1 1 3')
	exit(0)
o = 0
if n&1:
	n -= 1
	o = 1
ans, i, t = '1 ' * ceil(n / 2), 1, n
n = ceil(n/2)
j = 2
while n > 1:
	ans += (str(j) + ' ') * ((n // 2) if t&1 else ceil(n/2))
	i += 1
	j = pow(2, i)
	n //= 2
print(('1 ' if o else '') + ans + str((j//2)*(t//(j//2))))
",O(nlogn)
"def main():
    n = int(input())
    a = list(map(int, input().split(' ')))
    array = []
    array.append(a)

    for i in range(n - 1):
        aux = []
        for j in range(1, len(array[-1])):
            xor = array[-1][j-1] ^ array[-1][j]
            aux.append(xor)
        array.append(aux)

    for j in range(1, len(array)):
        for k in range(len(array[j])):
            maximo = max(array[j][k], array[j-1][k], array[j - 1][k + 1])
            array[j][k] = maximo

    q = int(input())
    aux2 = []
    for i in range(q):
        l, r = map(int, input().split(' '))
        aux2.append((l,r))

    for i in aux2:
        l, r = i[0], i[1]
        print(str(array[r - l][l - 1]))

main()
",O(n ^ 2)
"import sys

def main():
    pass

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def lts(l):
    s = ''.join(map(str, l))
    return s

def stl(s):

    l = list(s)

    return l

def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans

def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1

    return (cnt)

def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)

mod = int(1e9) + 7
def ssinp(): return sys.stdin.readline().strip()

def iinp(): return int(input())

def nninp(): return map(int, sys.stdin.readline().strip().split())

def llinp(): return list(map(int, sys.stdin.readline().strip().split()))

def p(xyz): print(xyz)
def p2(a, b): print(a, b)
import math

n,k=nninp()
s=ssinp()
ans=[]
lb=k//2
rb=k//2
for c in s:
    if(lb>0):
        if(c==""(""):
            lb-=1
        else:
            rb-=1
        ans.append(c)
    elif(rb>0):
        if(c=="")""):
            ans.append(c)
            rb-=1
    elif(lb==0 and rb==0):
        break
p(lts(ans))
",O(n)
"a = input().split()
b = [int(i) for i in a]
inputs = []
diff = []
sinComprimir = 0
for i in range(b[0]):
    input1 = input().split()
    input2 = [int(i) for i in input1]
    inputs.append(input2)

comprimido = 0
for k in range(len(inputs)):
    sinComprimir = sinComprimir + inputs[k][0]
    diff.append(inputs[k][0] - inputs[k][1])
    comprimido = comprimido + inputs[k][1]

difference = sorted(diff)
invDifference = difference[::-1]
newTotal = sinComprimir
iteraciones = 0
iterador = 0
if sinComprimir <= b[1]:
    print(""0"")
elif comprimido > b[1]:
    print(""-1"")
else:
    while newTotal > b[1]:
        iterador = iterador + 1
        newTotal = newTotal - invDifference[iterador-1]
        iteraciones += 1
    print(iteraciones)",O(nlogn)
"if __name__ == ""__main__"":
	n, k = map(int, input().split())
	ais = []
	for i in range(n):
		ais.append(list(map(int, input().split())))
	ais.sort(key = lambda x: (-x[0], x[1]))
	print(ais.count(ais[k-1]))
",O(nlogn)
"import sys
import math
import bisect
from sys import stdin, stdout
from math import gcd, floor, sqrt, log2, ceil
from collections import defaultdict as dd
from bisect import bisect_left as bl, bisect_right as br
from bisect import insort
from collections import Counter
from collections import deque
from heapq import heappush,heappop,heapify
from itertools import permutations,combinations
from itertools import accumulate as ac
mod = int(1e9)+7

ip = lambda : int(stdin.readline())
inp = lambda: map(int,stdin.readline().split())
ips = lambda: stdin.readline().rstrip()
out = lambda x : stdout.write(str(x)+""\n"")

t = 1
for _ in range(t):
    q = ""? {} {}"".format(0,0)
    print(q,flush = True)
    cond = ip()
    cur_a = 0
    cur_b = 0
    for i in range(29,-1,-1):
        xor = (1<<i)
        query_a = cur_a^xor
        query_b = cur_b^xor
        q = ""? {} {}"".format(query_a,query_b)
        print(q,flush = True)
        val = ip()
        if val != cond:
            if cond == -1 and val == 1:
                cur_b ^= xor
                query_a = cur_a
                query_b = cur_b
                q = ""? {} {}"".format(query_a,query_b)
                print(q,flush = True)
                val = ip()
                cond = val
            else:
                cur_a ^= xor
                query_a = cur_a
                query_b = cur_b
                q = ""? {} {}"".format(query_a,query_b)
                print(q,flush = True)
                val = ip()
                cond = val
        else:
            cond = val
            query_a = cur_a^xor
            query_b = cur_b
            q = ""? {} {}"".format(query_a,query_b)
            print(q,flush = True)
            val = ip()
            if val == -1:
                cur_a ^= xor
                cur_b ^= xor
            else:
                pass
    ans = ""! {} {}"".format(cur_a,cur_b)
    print(ans,flush = True)
",O(logn)
"class Solution(object):
    def solveQueries(self, nums, queries):
        dist = [len(nums)]*len(nums)
        left = {}
        for i in range(2*len(nums)-1):
            x = nums[i%len(nums)]
            if x in left:
                dist[i%len(dist)] = min(dist[i%len(dist)], i-left[x])
            left[x] = i
        right = {}
        for i in reversed(range(2*len(nums)-1)):
            x = nums[i%len(nums)]
            if x in right:
                dist[i%len(dist)] = min(dist[i%len(dist)], right[x]-i)
            right[x] = i
        result = [-1]*len(queries)
        for i, x in enumerate(queries):
            if dist[x] < len(nums):
                result[i] = dist[x]
        return result",O(n)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

prime = [True for i in range(50001)]
pp=[]
def SieveOfEratosthenes(n=50000):

    p = 2
    while (p * p <= n):

        if (prime[p] == True):

            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    for i in range(50001):
        if prime[i]:
            pp.append(i)

n,m,k=map(int,input().split())
a=list(map(int,input().split()))
a.sort(reverse=True)
if k>=m:
    print(0)
else:
    curr=k
    count=0
    for i in range (n):
        curr+=a[i]-1
        count+=1
        if curr>=m:
            break
    if curr>=m:
        print(count)
    else:
        print(-1)",O(nlogn)
"class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        stack = []
        curr = root

        while stack or curr:
            while curr:
                stack.append(curr)
                curr = curr.left
            curr = stack.pop()
            k -= 1
            if k == 0:
                return curr.val
            curr = curr.right
",O(n)
"class Solution(object):
    def findSolution(self, customfunction, z):
        result = []
        x, y = 1, 1
        while customfunction.f(x, y) < z:
            y += 1
        while y > 0:
            while y > 0 and customfunction.f(x, y) > z:
                y -= 1
            if y > 0 and customfunction.f(x, y) == z:
                result.append([x, y])
            x += 1
        return result",O(n)
"x2=input()
x=x2.split(' ')
n=int(x[0])
k=int(x[1])
n,k=n-1,k-1
l=0
r=k
g=k*(k+1)//2
ans=-1
while l<=r:
	m=(l+r)//2
	if (g-m*(m+1)//2)>=n:
		ans=k-m
		l=m+1
	else:
		r=m-1
print(ans)
",O(logn)
"import math
input_list =   lambda:  list(map(int, input().split()))

n = int(input())
a = input_list()
rows, cols = (n+1, n+1)
dp = [[-1 for i in range(rows)] for j in range(cols)]
for i in range(n):
    dp[i][i] = a[i]
for last in range(1, n):
    for first in range(last - 1, -1, -1):
        for mid in range(last, first, -1):
            if dp[first][mid-1]!=-1 and dp[mid][last]!=-1 and dp[first][mid-1] == dp[mid][last]:
                dp[first][last] = dp[first][mid-1] + 1

ans = [0 for i in range(n)]
for i in range(n):
    ans[i] = i+1

for i in range(n):
    for j in range(i, -1, -1):
        if (j-1>=0):
            if (dp[j][i]!=-1):
                ans[i] = min(ans[i], ans[j-1] + 1)
        elif (dp[0][i]!=-1):
            ans[i] = 1

print(ans[n-1])
",O(n ^ 3)
"my_list = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"", ""orange"":""Soul"", ""yellow"":""Mind"", ""red"":""Reality""}

n = int(input())
for i in range(n):
    my_list.pop(input())

print(len(my_list))
for i in my_list:
    print(my_list[i])",O(1)
"class Solution2(object):
    def connect(self, root):
        if root is None:
            return
        if root.left:
            root.left.next = root.right
        if root.right and root.__next__:
            root.right.next = root.next.left
        self.connect(root.left)
        self.connect(root.right)",O(n)
"n,l,r,x=map(int,input().split())
num=list(map(int,input().split()))
ans=0
for i in range(2**n):
    st=bin(i)[2:]
    st='0'*(n-len(st))+st
    if st.count('1')>=2:
        pt=[]
        for i in range(len(st)):
            if st[i]=='1':
                pt.append(num[i])
        if sum(pt)<=r and sum(pt)>=l and max(pt)-min(pt)>=x:
            ans+=1
print(ans)",np
"class Solution(object):
    def stringHash(self, s, k):
        result = (chr(ord('a')+reduce(lambda accu, x: (accu+x)%26,  (ord(s[i+j])-ord('a') for j in range(k)), 0)) for i in range(0, len(s), k))
        return """".join(result)",O(n)
"class Solution(object):
    def reorderSpaces(self, text):
        text = list(text)
        space_count, word_count = 0, 0
        for i, c in enumerate(text):
            if c == ' ':
                space_count += 1
            elif i == 0 or text[i-1] == ' ':
                word_count += 1

        left, i = 0, 0
        while i < len(text):
            has_word = False
            while i < len(text) and text[i] != ' ':
                text[left], text[i] = text[i], text[left]
                left += 1
                i += 1
                has_word = True
            if has_word:
                left += 1 
            i += 1

        equal_count = space_count//(word_count-1) if word_count-1 > 0 else 0
        extra_count = space_count%(word_count-1) if word_count-1 > 0 else space_count
        right, i = len(text)-1-extra_count, len(text)-1
        while i >= 0:
            has_word = False
            while i >= 0 and text[i] != ' ':
                text[right], text[i] = text[i], text[right]
                right -= 1
                i -= 1
                has_word = True
            if has_word:
                right -= equal_count 
            i -= 1
        return """".join(text)",O(n)
"n=int(input())

a=list(map(int,input().split()))
b=list(map(int,input().split()))

s=[0]*n

ans=True

for i in range(n):
    ans=ans and a[i]<=i and b[i]<=(n-i-1)
    s[i]=n-a[i]-b[i]

def qwe(s,j):
    l,r=0,0
    for i in range(len(s)):
        if i<j and s[i]>s[j]: l+=1
        elif i>j and s[i]>s[j]: r+=1
    return l,r

if ans:
    for i in range(n):
        l,r=qwe(s,i)
        ans=ans and a[i]==l and b[i]==r

if ans:
    print('YES')
    for i in range(n):
        print(n-a[i]-b[i],end=' ')
else: print('NO')
",O(n ^ 2)
"from itertools import chain, combinations
def powerset(iterable):
    xs = list(iterable)

    return list(chain.from_iterable(combinations(xs,n) for n in range(2,len(xs)+1)))
n,l,r,x=map(int,input().split())
sett=list(map(int,input().split()))
psett=powerset(sett)
count=0
for i in psett:
    k=sorted(i)
    j=sum(k)
    if j>=l and j<=r and k[-1]-k[0]>=x:
        count+=1
print(count)
",np
"class Solution(object):
    def totalNumbers(self, digits):
        cnt = [0]*10
        for x in digits:
            cnt[x] += 1
        even = sum(cnt[i] != 0 for i in range(0, len(cnt), 2))
        odd = sum(cnt[i] != 0 for i in range(1, len(cnt), 2))
        result = 0
        for i in range(2, len(cnt), 2):
            if cnt[i] >= 3:
                result += 1 
        result += even*(odd+even-1)*(odd+even-2) 
        if cnt[0]:
            result -= 1*(even-1)*(odd+even-2) 
        for i in range(len(cnt)):
            if cnt[i] < 2:
                continue
            if i == 0:
                result += (odd+even)-1 
            elif i%2:
                result += even 
            else:
                result += 3*(even-1)-int(cnt[0] != 0) 
                result += 2*odd 
        return result",O(n)
"class Solution(object):
    def flipAndInvertImage(self, A):
        for row in A:
            for i in range((len(row)+1) // 2):
                row[i], row[~i] = row[~i] ^ 1, row[i] ^ 1
        return A",O(n ^ 2)
"a = [0,1]
n = int(input())
i=2
r=0
while r<n:
     r = a[i-1]+a[i-2]
     a.append(r)
     i+=1
l = len(a)-1
if n>3:
    print(a[l-4],a[l-3],a[l-1])
elif n==3:
    print(1,1,1)
elif n==2:
    print(0,1,1)
elif n==1:
    print(0,0,1)
elif n==0:
    print(0,0,0)",O(1)
"import math

N,r=map(int,input().split())

print(r*math.sin(math.pi/N)/(1-math.sin(math.pi/N)))
",O(1)
"def add(x,j):
	x = x % (1000000000+7)
	j=j % (1000000000+7)
	return (x+j) % (1000000000+7)

statements = []
n  =int(input())
i=1
j=1
temp = [[0 for i in range(n)] for i in range(n)]
earlier = [[0 for i in range(n)] for i in range(n)]
temp[0][0]=1
earlier[0][0]=1

while(i<=n):
	s = input()
	statements.append(s)
	i+=1
while(j<n):
	temp[0][j]=0
	earlier[0][j] = temp[0][j] + earlier[0][j-1]
	j+=1
i=1
while(i<n):
	if(statements[i-1]=='f'):
		j=1
		while(j<n):
			temp[i][0]=0
			earlier[i][0]=0
			temp[i][j] = temp[i-1][j-1]
			earlier[i][j] = add(earlier[i][j-1],temp[i][j])

			j+=1
	else:
		j=0
		while(j<n):
			if(j==0):
				temp[i][j] = earlier[i-1][n-1]
			else:
				temp[i][j] = earlier[i-1][n-1] - earlier[i-1][j-1]
			earlier[i][j] = add(earlier[i][j-1],temp[i][j])
			j+=1
	i+=1

ans = 0
j=0
while(j<n):
	ans=add(ans,temp[n-1][j])
	j+=1

print(ans%(1000000000+7))",O(n ^ 2)
"mod=1000000007
def fastexp(base,exp):
    if(exp==0):
        return 1;
    if(exp==1):
        return base%mod;
    t=fastexp(base,exp//2);
    if(exp%2==0):
        return (t%mod*t%mod)%mod;
    else:
        return (t%mod*t%mod*base%mod)%mod;
x,k=map(int,input().split())
if(x==0):
    print(0);
else:
    t=fastexp(2,k)%mod;
    before=((2*t)%mod*x%mod)%mod-(t+mod-1)%mod
    while(before<0):
        before+=mod;
    before=before%mod;
    print(before)
",O(logn)
"n=int(input())
s=input()
cur=0
for a in s:
    cur=max(cur,0)
    if(a=='-'):
        cur-=1
    else: cur+=1
    cur=max(cur,0)
print(cur)",O(n)
"modulo = 10 ** 9 + 7
x, k = [int(s) for s in input().split()]

if x == 0:
    print(0)
    exit(0)

k2 = pow(2, k, modulo)
ans = (x * k2 * 2 - k2 + 1) % modulo
print(ans)
",O(logn)
"import sys

n = int(sys.stdin.readline())
a = list(map(int, sys.stdin.readline().split(' ')))
Array = [a]

for i in range(n - 1):
    aux = []
    for j in range(1, len(Array[-1])):
        aux.append(Array[-1][j-1] ^ Array[-1][j])
    Array.append(aux)

for j in range(1, len(Array)):
    for k in range(len(Array[j])):
        Array[j][k] = max(Array[j][k], Array[j-1][k], Array[j - 1][k + 1])

q = int(sys.stdin.readline())
for i in range(q):
    l, r = map(int, sys.stdin.readline().split(' '))
    sys.stdout.write(str(Array[r - l][l - 1]) + '\n')
",O(n ^ 2)
"class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        n = len(digits)
        for i in range(n - 1, -1, -1):
            if digits[i] < 9:
                digits[i] += 1
                return digits
            digits[i] = 0

        return [1] + digits
",O(n)
"a=list(input())
b=list(input())
num=int(''.join(b))
a.sort()
a.reverse()
al=len(a)
ans=[]
if(len(a)==len(b) and len(a)!=1):
	c=[]
	count=0
	hogya=0
	for i in range(al):
		if(hogya==1):
			o.reverse()
			f=list(c+o)
			ans.append(''.join(f))
			count+=1
			break
		t=len(a)
		j=0
		mittal=t
		abhinhi=0
		while(t):

			if(j>len(a)-1):
				break
			if(int(a[j])<=int(b[i])):
				c.append(a[j])
				temp=a[j]
				a.remove(a[j])
				o=a.copy()
				o.sort()
				f=list(c+o)

				if(temp<b[i]):

					hogya=1
					break
				if(int(''.join(f))<=num):
					ans.append(''.join(f))
					count+=1
					break
				else:
					a.append(temp)
					c=c[:len(c)-1]

				t-=1
			else:
				j+=1
				t-=1
		if(mittal==len(a)):

			break

	print(ans[count-1])
elif(len(a)==1):
	print(''.join(a))
else:
	print(''.join(a))
",O(n ^ 3)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def inv_cnt(b):
    c = 0
    visited = set()
    for i in range(len(b)):
        if i + 1 in visited:
            pass
        else:
            visited.add(i)
            path = [i + 1]
            while b[path[-1] - 1] != path[0]:
                visited.add(b[path[-1] - 1])
                path.append(b[path[-1] - 1])
            c += len(path) - 1
    return c % 2

def solve():
    n = int(input())
    a = [int(x) for x in input().split(' ')]
    x = inv_cnt(a)
    m = int(input())
    for query in range(m):
        l, r = [int(x) for x in input().split(' ')]
        x = (x + (r - l + 1) // 2) % 2
        if x:
            print(""odd"")
        else:
            print(""even"")

solve()
",O(n ^ 2)
"t=int(input())
for ca in range(t):
    asd=input().split()
    n=int(asd[0])
    k=int(asd[1])
    if n>=40:
        print(""YES ""+str(n-1))
    else:
        ans=-1
        for m in range(1,n+1):
            asd=(4**m-1)//3
            asd2=(2**m-1)**2
            asd2*=(4**(n-m)-1)//3
            asd+=asd2
            if asd>=k and m*m<=k:
                ans=n-m
                break
        if ans==-1:
            print(""NO"")
        else:
            print(""YES ""+str(ans))
",O(logn)
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
n,m=map(int,input().split())
a=[list(map(int,input().split())) for i in range(n)]
l=-1;r=10**9+1
ans1,ans2=-1,-1
while r-l>1:
    x=(l+r)//2
    idx={}
    for i in range(n):
        v=0
        for j in range(m):
            if a[i][j]>=x:
                v+=1
            v<<=1
        idx[v>>1]=i
    ok=False
    idx1,idx2=0,0
    for aa,bb in idx.items():
        for cc,dd in idx.items():
            for d in range(m):
                if (aa|cc)==(2**m)-1:
                    ok=True
                    idx1=bb+1
                    idx2=dd+1
    if ok:
        l=x
        ans1=idx1
        ans2=idx2
    else:
        r=x
print(ans1,ans2)",np
"class Solution(object):
    def subsequenceCount(self, nums):
        MOD = 10**9+7
        return pow(2, len(nums)-1, MOD) if any(x%2 for x in nums) else 0",O(n)
"n,m = map(int,input().split())
for _ in range(m):
    x,y = map(int,input().split())

cnt = 0
ans = []
for i in range(n):
    if cnt%2 == 0:
        ans.append(""0"")

    else:
        ans.append(""1"")

    cnt += 1

print("""".join(ans))",O(n)
"def main():
    n = int(input())
    piles = list(map(int,input().split()))
    piles.sort()
    num = piles[0]
    count = 1
    two = 0
    two_num = 0
    for i in range(1,n):
        if piles[i] == num:
            count += 1
        else:

            if count > 2:
                print('cslnb')
                return
            elif count == 2:
                two_num = num
                two += 1
            num = piles[i]
            count = 1

    if count == 2:
        two_num = num
        two += 1
    if count > 2:
        print('cslnb')
        return
    if two > 1:
        print('cslnb')
        return

    if two == 1:
        if (two_num-1) in piles:
            print('cslnb')
            return

    if n >= 2:
        if piles[0] == piles[1] and piles[0] == 0:
            print('cslnb')
            return
    moves = 0
    curr = 0
    for i in range(n):
        if piles[i] >= curr:
            moves += piles[i]-curr
            piles[i] = curr
            curr += 1

    for i in piles:
        if i > 0:
            moves += 1
            break

    if n == 1:
        moves += 1
    if moves%2 != 0:
        print('cslnb')
    else:
        print('sjfnb')

main()
",O(nlogn)
"
import math


class Solution(object):
    def bulbSwitch(self, n):
        return int(math.sqrt(n))

",O(1)
"N, M, K, L = list(map(int, input().split()))

each = (K + L) // M

if (K + L) % M != 0:
    each += 1

if each * M > N:
    print(-1)
else:
    print(each)
",O(1)
"n,k=map(int,input().split())
a=list(map(int,input().split()))
d={}
for i in range(n):
    d[a[i]]=1
a.sort(reverse=True)
ans=0
for i in range(n):
    if d[a[i]]>0:
        if a[i]%k==0:
            x=a[i]//k
            if x in d:
                d[x]-=1
        ans+=1
print(ans)",O(nlogn)
"from os import path
import sys,time, collections as c , math , pprint as p , itertools as it , operator as op
maxx , localsys , mod = float('inf'), 0 , int(1e9 + 7)
if (path.exists('input.txt')):  sys.stdin=open('input.txt','r') ;   sys.stdout=open('output.txt','w')
input = sys.stdin.readline
n = int(input()) ; s = list(map(int , input().split())) ; c = list(map(int , input().split()))
ans = maxx
for mid in range(1 , n - 1):
    l = [maxx] + [c[i] for i in range(mid) if s[i] < s[mid]]
    r = [maxx] + [c[i] for i in range(mid+1 , n) if s[i] > s[mid]]
    ans = min(ans , min(l) + c[mid] + min(r))
print(ans if ans != float('inf') else -1)
",O(n ^ 2)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def pathSum(self, root, sum):
        return self.pathSumRecu([], [], root, sum)


    def pathSumRecu(self, result, cur, root, sum):
        if root is None:
            return result

        if root.left is None and root.right is None and root.val == sum:
            result.append(cur + [root.val])
            return result

        cur.append(root.val)
        self.pathSumRecu(result, cur, root.left, sum - root.val)
        self.pathSumRecu(result, cur,root.right, sum - root.val)
        cur.pop()
        return result

",O(n)
"class Solution(object):
    def maximumScore(self, a, b, c):
        return min((a+b+c)//2, a+b+c - max(a, b, c))",O(1)
"n,k=map(int,input().split())
p=list(map(int,input().split()))

arr=[[] for i in range(256)]
ans=[]
for i in p:
    j=i
    if len(arr[i])==0:
        c=0
        while c<k and j>=0:
            if len(arr[j])+c>k:
                break

            if len(arr[j])!=0:
                arr[i].extend(arr[j])
                break
            arr[j]=arr[i]
            arr[j].append(j)
            j-=1
            c+=1
        arr[i].sort()
    ans.append(arr[i][0])
print(*ans)
",O(n ^ 2)
"n = int(input())
melody = [int(x) for x in input().split()]
ref = [[-1] * 5 for _ in range(n)]
can_finish = [[False] * 5 for _ in range(n)]
can_finish[0] = [True] * 5

for idx, key in enumerate(melody[:-1]):
    if not any(can_finish[idx]):
        break
    for finger in range(5):
        if melody[idx] < melody[idx + 1] and can_finish[idx][finger]:
            for i in range(finger + 1, 5):
                can_finish[idx + 1][i] = True
                ref[idx + 1][i] = finger
            break
        elif melody[idx] > melody[idx + 1] and can_finish[idx][finger] and finger > 0:
            for i in range(finger):
                can_finish[idx + 1][i] = True
                ref[idx + 1][i] = finger
        elif melody[idx] == melody[idx + 1] and can_finish[idx][finger]:
            tmp_val, tmp_ref = can_finish[idx + 1][finger], ref[idx + 1][finger]
            can_finish[idx + 1] = [True] * 5
            ref[idx + 1] = [finger] * 5
            can_finish[idx + 1][finger], ref[idx + 1][finger] = tmp_val, tmp_ref

finger = next((i for i in range(5) if can_finish[n - 1][i]), None)
if finger is None:
    print(-1)
else:
    seq = [finger]
    for i in range(n - 1, 0, -1):
        finger = ref[i][finger]
        seq.append(finger)
    print(' '.join(str(x + 1) for x in seq[::-1]))
",O(n ^ 2)
"from collections import defaultdict, deque
from heapq import heappush, heappop
from math import inf

def solve():
    n, m = map(int, input().split())
    cnt = defaultdict(int)
    res = []
    for i in range(n):
        A = list(map(int, list(input())))
        res.append(A)
        for j in range(m):
            if A[j]:
                cnt[j] += 1
    valid = False
    for r in res:
        j = [i for i in range(m) if r[i]]
        if all(cnt[i] > 1 for i in j):
            valid = True
            break
    if valid:
        print(""YES"")
    else:
        print(""NO"")

t = 1

while t:
    t -= 1
    solve()
",O(n ^ 2)
"from collections import defaultdict, deque, Counter
from sys import stdin, stdout
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

def mapin():
    return map(int, input().split())

def solve(final, n):
    fifi = [[final[j][i] for j in range(n)] for i in range(n)]

    k = []
    for i in range(n):
        k.append(sum(final[i]))
    a = max(k)-min(k)

    a = a*a
    k = []
    for i in range(n):
        k.append(sum(fifi[i]))
    b = max(k)-min(k)

    b = b*b

    return a+b

def inte(a, b, c, d):
    a = max(a, c)
    b = min(b, d)

    return [a, b]

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

n = int(input())
l = []
for i in range(n):
    a, b = mapin()
    l.append([a, b])

f= []
ff = []
a = 0
b = 10000000000000
f.append([a, b])
for i in range(n):
    x = inte(a, b, l[i][0], l[i][1])
    a = x[0]
    b = x[1]
    f.append([a, b])
a = 0
b = 10000000000000
ff = [[] for i in range(n)]
for i in reversed(range(n)):
    x = inte(a, b, l[i][0], l[i][1])
    a = x[0]
    b = x[1]
    ff[i] = [a, b]
ff.append([0, 100000000000000])
ans = 0
for i in range(n):
    a = f[i]
    b = ff[i+1]
    y = inte(a[0], a[1], b[0], b[1])
    if(y[1]>= y[0]):
        ans = max(ans, y[1]-y[0])

print(ans)
",O(n)
"import sys
input=sys.stdin.readline
def fun(k):
    global li,t
    tem=[]
    count=0
    for i in li:
        if(i[0]>=k):
            tem.append(i)
            count+=1
    if(count>=k):
        ans=0
        for i in range(k):
            ans+=tem[i][1]
        if(ans<=t):
            return True
        else:
            return False
    else:
        return False

n,t=map(int,input().split())
li=[]
for _ in range(n):
    li.append(list(map(int,input().split()))+[_])
li.sort(key=lambda x:x[1])
l=0
r=n
while(r-l>1):
    mid=(l+r)//2
    if(fun(mid)):
        l=mid
    else:
        r=mid
fin=0
for i in range(l,r+1):
    if(fun(i)):
        fin=i
print(fin)
print(fin)
tem=[]
for i in range(n):
    if(li[i][0]>=fin):
        tem.append(li[i][2]+1)
print(*tem[:fin])",O(nlogn)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def upsideDownBinaryTree(self, root):
        p, parent, parent_right = root, None, None

        while p:
            left = p.left
            p.left = parent_right
            parent_right = p.right
            p.right = parent
            parent = p
            p = left

        return parent


",O(n)
"n, m = map(int, input().split())
a = list(map(int, input().split()))
a.sort()
h = 0
ans = 0
for i in range(n - 1):
    ans += a[i] - 1
    if a[i] > h:
        h += 1
if h < max(a):
    ans += h
else:
    ans += a[-1] - 1
print(ans)
",O(nlogn)
"n, m = map(int,input().split())
b = []
d = []
for x in range(n):
	if x == 0:
		a,c = map(int,input().split())
		if (a * 60) + c > m:b.append(""0 0"")
		d.append((a * 60) + c)
	else:
		a ,c = map(int,input().split())
		if ((a * 60) + c) - d[-1] > (m * 2) + 1:
			f = d[-1] + m + 1
			b.append(str(f // 60) + "" "" + str((f % 60)))
		d.append((a * 60) + c)
if len(b) == 0:
	f = d[-1] + m + 1
	b.append(str(f // 60) + "" "" + str((f % 60)))
print(b[0])",O(n)
"n = int(input())

a = list(map(int, input().split()))

a.sort(reverse=True)

cnt = 0
while a:
    f = a.pop()
    rm = []
    for x in a:
        if x % f == 0:
            rm.append(x)
    for x in rm:
        a.remove(x)
    cnt += 1

print(cnt)
",O(n ^ 2)
"from os import path;import sys,time
mod = int(1e9 + 7)
from math import ceil, floor,gcd,log,log2 ,factorial,sqrt
from collections import defaultdict ,Counter , OrderedDict , deque;from itertools import combinations,permutations
from string import ascii_lowercase ,ascii_uppercase
from bisect import *;from functools import reduce;from operator import mul;maxx = float('inf')
I = lambda :int(sys.stdin.buffer.readline())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().strip('\n')
grid = lambda  r :[lint() for i in range(r)]
localsys = 0
start_time = time.time()

nCr = lambda n, r: reduce(mul, range(n - r + 1, n + 1), 1) // factorial(r)
def ceill(n,x):
    return (n+x -1 )//x
T =0

def solve():
	arr = list(map(int , S()))
	d ,s, ans  = {0} , 0 , 0
	for i in arr:
		s+=i
		s%=3
		if s in d :
			ans+=1
			s =0
			d = {0}
		d.add(s)
	print(ans)

def run():
    if (path.exists('input.txt')):
        sys.stdin=open('input.txt','r')
        sys.stdout=open('output.txt','w')

run()
T = I() if T else 1
for _ in range(T):
    solve()

if localsys:
    print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")
",O(n)
"def power(x, y, p) :
    res = 1

    x = x % p

    while (y > 0) :

        if ((y & 1) == 1) :
            res = (res * x) % p

        y = y >> 1
        x = (x * x) % p

    return res

x,k = map(int,input().split())
if x==0:
    print(0)
else:
    ans = power(2,k,1000000007)
    ans = ans * ((2*x)-1)
    ans = ans+1
    ans=ans%1000000007
    print(ans)",O(logn)
"n = int(input())
(ax, ay) = [int(x) for x in input().split()]
(bx, by) = [int(x) for x in input().split()]
(cx, cy) = [int(x) for x in input().split()]

if (bx < ax < cx) or (bx > ax > cx) or (by < ay < cy) or (by > ay > cy):
    print(""NO"")
else:
    print(""YES"")",O(1)
"import collections



class Solution(object):
    def minimumKeypresses(self, s):
        return sum(cnt*(i//9+1) for i, cnt in enumerate(sorted(iter(collections.Counter(s).values()), reverse=True)))",O(n)
"import math
import sys

def minPut(n):
    return math.ceil((-1 + math.sqrt(1-4*(-n*2))) / 2)
def nCandies(n):
    return int(n*(n+1)/2)

actions, candies = map(int, sys.stdin.readline().split())

put = minPut(candies)
putCandies = nCandies(put)

eat = putCandies - candies

while put + eat < actions:
    eat += put + 1
    put += 1

print(eat)",O(logn)
"n=int(input())
l=list(map(int,input().split()))
r=list(map(int,input().split()))

cost=[(l[i]+r[i],i) for i in range(n)]

cost.sort()

CANDIES=[None]*n
CANDIES[cost[0][1]]=n

candy=n
for i in range(1,n):
    if cost[i][0]==cost[i-1][0]:
        CANDIES[cost[i][1]]=candy
    else:
        candy-=1
        CANDIES[cost[i][1]]=candy

check=1
for i in range(n):
    lc=0
    rc=0
    for j in range(i):
        if CANDIES[j]>CANDIES[i]:
            lc+=1
    for j in range(i+1,n):
        if CANDIES[j]>CANDIES[i]:
            rc+=1

    if lc!=l[i] or rc!=r[i]:
        check=0

if check==1:
    print(""YES"")
    for c in CANDIES:
        print(c,end="" "")

else:
    print(""NO"")
",O(n ^ 2)
"class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        maxArea = 0
        stack = []

        for i in range(n + 1):
            while stack and (i == n  or heights[stack[-1]] >= heights[i]):
                height = heights[stack.pop()]
                width = i if not stack else i - stack[-1] - 1
                maxArea = max(maxArea, height * width)
            stack.append(i)
        return maxArea
",O(n)
"from sys import stdout

def get_ans(c, d, curaM, curbM):
    a_ = a ^ c ^ curaM
    b_ = b ^ d ^ curbM

    if a_ > b_:
        return 1

    if a_ < b_:
        return -1

    return 0

def get_ans_(c, d, curaM, curbM):
    a_ = c ^ curaM
    b_ = d ^ curbM

    print('? {} {}'.format(a_, b_))
    stdout.flush()

    return int(input())

curaM  = 0
curbM  = 0
curC   = get_ans_(0,0,0,0)

for i in range(29, -1, -1):
    ans1 = get_ans_(1<<i, 0, curaM, curbM)
    ans2 = get_ans_(0, 1<<i, curaM, curbM)

    if ans1 * ans2 >= 0:
        if curC == 1:
            curaM |= 1 << i
        elif curC == -1:
            curbM |= 1 << i

        curC = ans1
    else:
        if ans1 < 0:
            curaM |= 1 << i
            curbM |= 1 << i

print('! {} {}'.format(curaM, curbM))",O(logn)
"import sys
import copy
input = sys.stdin.readline
n,k=map(int,raw_input().split())
C=list(raw_input().strip())
def JUDGE(C):
    ANS_one=0
    ANS_zero=0
    for c in C:
        if c==""0"":
            ANS_zero+=1
        else:
            break
    for c in C[::-1]:
        if c==""0"":
            ANS_zero+=1
        else:
            break
    for c in C:
        if c==""1"":
            ANS_one+=1
        else:
            break
    for c in C[::-1]:
        if c==""1"":
            ANS_one+=1
        else:
            break
    if ANS_zero>=n-k or ANS_one>=n-k:
        return 1
    else:
        return 0
if JUDGE(C)==1:
    print(""tokitsukaze"")
    sys.exit()
if k>=n-1:
    print(""quailty"")
    sys.exit()
if k<n/2:
    print(""once again"")
    sys.exit()
CAN1=copy.copy(C)
CAN2=copy.copy(C)
if C[0]==""0"":
    for i in range(1,k+1):
        CAN1[i]=""1""
else:
    for i in range(1,k+1):
        CAN1[i]=""0""
if C[-1]==""0"":
    for i in range(n-1,n-k-1,-1):
        CAN2[i]=""1""
else:
    for i in range(n-2,n-k-2,-1):
        CAN2[i]=""0""
if JUDGE(CAN1)==1 and JUDGE(CAN2)==1:
    print(""quailty"")
    sys.exit()
else:
    print(""once again"")
    sys.exit()",O(n)
"k = int(input())
s = k
i = 1
number_digits = 1
while s - (i * (9 * 10 ** (i - 1))) > 0:
    number_digits = number_digits + 1
    s = s - (i * (9 * 10 ** (i - 1)))
    i += 1
v = (s - 1) // number_digits
s = s - v * number_digits
ans = 10 ** (number_digits - 1) + v
ans = str(ans)
fans = ans[s - 1]
print(fans)
",O(logn)
"N = int(input())
map_1 = [list(input()) for i in range(N)]
map_2 = [list(input()) for i in range(N)]

maps = list()

maps.append([[map_2[i][j] for j in range(N)] for i in range(N)])
maps.append([[map_2[i][N - 1 - j] for j in range(N)] for i in range(N)])
maps.append([[map_2[N - 1 - i][j] for j in range(N)] for i in range(N)])
maps.append([[map_2[N - 1 - i][N - 1 - j] for j in range(N)] for i in range(N)])
maps.append([[map_2[j][i] for j in range(N)] for i in range(N)])
maps.append([[map_2[j][N - 1 - i] for j in range(N)] for i in range(N)])
maps.append([[map_2[N - 1 - j][i] for j in range(N)] for i in range(N)])
maps.append([[map_2[N - 1 - j][N - 1 - i] for j in range(N)] for i in range(N)])

print(('No', 'Yes')[any(map_1 == el for el in maps)])
",O(n ^ 2)
"import sys
def getSum(a):
    sum1 = a * (a + 1) // 2
    return sum1
def getSumOfTwo(a, b):
    if a <= 1:
        return getSum(b)
    return getSum(b) - getSum(a - 1)

n, k = [int(elem) for elem in input().split()]
if n == 1:
    print(0)
    sys.exit(0)
if n <= k:
    print(1)
    sys.exit(0)
if getSum(k - 1) < n - 1:
    print(-1)
    sys.exit(0)

n -= 1
k -= 1
left, right = 1, k
while left < right:
    mid = (left + right) // 2
    sum1 = getSumOfTwo(mid, k)
    if sum1 == n:
        print(k - mid + 1)
        sys.exit(0)
    if sum1 > n :
        left = mid + 1
    else:
        right = mid
print(k - left + 2)
",O(logn)
"class Solution2(object):
    def findUnsortedSubarray(self, nums):
        a = sorted(nums)
        left, right = 0, len(nums) -1
        while (nums[left] == a[left] or nums[right] == a[right]):
            if right - left <= 1:
                return 0
            if nums[left] == a[left]:
                left += 1
            if nums[right] == a[right]:
                right -= 1
        return right - left + 1",O(nlogn)
"import sys
import math

prime=[True for _ in range(1000001)]

def solve():
    n,e,h,a,b,c=map(int,input().split())
    ans=1e9
    for i in range(1,1000001):
        su=0
        ntmp=n
        tmp1=e
        tmp2=h
        tmp1-=i
        tmp2-=i
        if (tmp1<0 or tmp2<0 or i>ntmp):
            break
        ntmp-=i
        su+=(c*i)
        if (ntmp==0):
            ans=min(ans,su)
            continue
        if (a<=b):
            if ((tmp1//2)>=ntmp):
                su+=int(a*ntmp)
                ntmp-=ntmp
            else:
                su+=int(a*(tmp1//2))
                ntmp-=(tmp1//2)
                if (ntmp<=(tmp2//3)):
                    su+=int(b*ntmp)
                    ntmp-=ntmp
                else:
                    su+=int(b*(tmp2//3))
                    ntmp-=(tmp2//3)
        else:
            if ((tmp2//3)>=ntmp):
                su+=int(b*ntmp)
                ntmp-=ntmp
            else:
                su+=int(b*(tmp2//3))
                ntmp-=(tmp2//3)
                if (ntmp<=(tmp1//2)):
                    su+=int(a*ntmp)
                    ntmp-=ntmp
                else:
                    su+=int(a*(tmp1//2))
                    ntmp-=(tmp1//2)
        if (ntmp==0):
            ans=min(ans,su)

    if (ans==1e9):
        print(""-1"")
    else:
        print(ans)

def main():
    n=int(input())
    s=input()
    m={}
    have={}
    cc=0
    for c in s:
        if (c not in m):
            m[c]=1
        else:
            m[c]+=1
    ct=len(m)
    l=0
    ans=1e9
    for i in range(0,n):
        if (s[i] not in have):
            have[s[i]]=0
            cc+=1
        have[s[i]]+=1
        while(l<=i and have[s[l]]>1):
            have[s[l]]-=1
            l+=1
        if (cc==ct):
            ans=min(ans,i-l+1)
    print(ans)

if __name__ == ""__main__"":
    main()",O(n)
"import math
from decimal import Decimal

def sum2(s, e):
    return sum1(e) - sum1(s - 1) - (e - s)

def sum1(i):
    return i * (i + 1) / 2

n, k = map(Decimal, input().split())

if(n == 1):
    print(0)
elif(k > n):
    print(1)
elif(sum2(Decimal(2),k) < n):
    print(-1)
else:
    c = 2 * n + k - k * k
    discriminant = (9 - 4 * c).sqrt()
    res1 = math.floor((3 + discriminant) / 2)
    res2 = math.floor((3 - discriminant) / 2)
    res1 = max(res1, res2)
    print(k - res1 + 1);",O(logn)
"import sys
import copy
input = sys.stdin.readline

n,k=map(int,input().split())
C=list(input().strip())

def JUDGE(C):
    ANS_one=0
    ANS_zero=0

    for c in C:
        if c==""0"":
            ANS_zero+=1
        else:
            break

    for c in C[::-1]:
        if c==""0"":
            ANS_zero+=1
        else:
            break

    for c in C:
        if c==""1"":
            ANS_one+=1
        else:
            break

    for c in C[::-1]:
        if c==""1"":
            ANS_one+=1
        else:
            break

    if ANS_zero>=n-k or ANS_one>=n-k:
        return 1
    else:
        return 0

if JUDGE(C)==1:
    print(""tokitsukaze"")
    sys.exit()

if k>=n-1:
    print(""quailty"")
    sys.exit()
if k<n/2:
    print(""once again"")
    sys.exit()

CAN1=copy.copy(C)
CAN2=copy.copy(C)

if C[0]==""0"":
    for i in range(1,k+1):
        CAN1[i]=""1""
else:
    for i in range(1,k+1):
        CAN1[i]=""0""

if C[-1]==""0"":
    for i in range(n-1,n-k-1,-1):
        CAN2[i]=""1""
else:
    for i in range(n-2,n-k-2,-1):
        CAN2[i]=""0""

if JUDGE(CAN1)==1 and JUDGE(CAN2)==1:
    print(""quailty"")
    sys.exit()
else:
    print(""once again"")
    sys.exit()
",O(n)
"import os,sys,math
from io import BytesIO, IOBase
from collections import defaultdict,deque,OrderedDict
import bisect as bi
def yes():print('YES')
def no():print('NO')
def I():return (int(input()))
def In():return(map(int,input().split()))
def ln():return list(map(int,input().split()))
def Sn():return input().strip()
BUFSIZE = 8192

def find_gt(a, x):
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:
        return len(a)

def solve():
    n,m,k=In()

    rt,do=[list(In()) for i in range(n)],[list(In()) for i in range(n-1)]

    dp=[[0]*m for i in range(n)]
    if k%2==1:
        for i in range(n):
            print(*[-1]*m)
        return
    k//=2
    dp_next=[[P]*m for i in range(n)]
    for op in range(k):
        for i in range(n):
            for j in range(m):
                ans=Inf
                if i!=0:
                    ans=min(ans,dp[i-1][j]+do[i-1][j])
                if j!=0:
                    ans=min(ans,dp[i][j-1]+rt[i][j-1])
                if i!=n-1:
                    ans = min( ans , dp[i+1][j]+do[i][j])
                if j!=m-1 :
                    ans=min( ans , dp[i][j+1]+rt[i][j])
                dp_next[i][j]=ans

        for i in range(n):
            for j in range(m):
                dp[i][j]=dp_next[i][j]

    for i in range(n):
        for j in range(m):
            print(2*dp[i][j],end=' ')
        print()

def main():
    T=1
    for i in range(T):
        solve()

M = 998244353
P = 1000000007
Inf=float('inf')

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

def print(*args, **kwargs):

    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()

if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(n ^ 3)
"import math

k,n,s,p = input().split()
k = int(k)
n = int(n)
s = int(s)
p = int(p)

sheet_for_each_person = math.ceil(n/s)

total_sheets_required = k*sheet_for_each_person

no_of_packs = math.ceil( total_sheets_required/p )
print(no_of_packs)",O(1)
"def get_colors(x1, y1, x2, y2):
    w = x2 - x1 + 1
    h = y2 - y1 + 1
    if w % 2 == 0 or h % 2 == 0:
        black = w * h // 2
        white = w * h // 2
    else:
        oddx = w // 2
        if x1 % 2 == 1 and x2 % 2 == 1:
            oddx += 1
        oddy = h // 2
        if y1 % 2 == 1 and y2 % 2 == 1:
            oddy += 1
        evenx = w // 2
        if x1 % 2 == 0 and x2 % 2 == 0:
            evenx += 1
        eveny = h // 2
        if y1 % 2 == 0 and y2 % 2 == 0:
            eveny += 1
        white = oddx * oddy + evenx * eveny
        black = w * h - white
    return white, black

def get_intersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):
    if ax1 > bx2:
        return None, None, None, None
    if bx1 > ax2:
        return None, None, None, None
    if ay1 > by2:
        return None, None, None, None
    if by1 > ay2:
        return None, None, None, None
    return max(ax1, bx1), max(ay1, by1), min(ax2, bx2), min(ay2, by2)

t = int(input())
for i in range(t):
    n, m = map(int, input().split())
    white, black = get_colors(1, 1, m, n)
    wx1, wy1, wx2, wy2 = map(int, input().split())
    w, b = get_colors(wx1, wy1, wx2, wy2)
    white += b
    black -= b
    bx1, by1, bx2, by2 = map(int, input().split())
    ix1, iy1, ix2, iy2 = get_intersection(wx1, wy1, wx2, wy2, bx1, by1, bx2, by2)
    if ix1 is not None:
        w, b = get_colors(ix1, iy1, ix2, iy2)
        white -= b
        black += b
    w, b = get_colors(bx1, by1, bx2, by2)
    white -= w
    black += w
    print(white, black)",O(1)
"n = int(input())
x, y = list(map(int, input().split()))
d0 = max(x - 1, y - 1)
d1 = max(n - x, n - y)
print('White' if d0 <= d1 else 'Black')
",O(1)
"n,l,r,x = [int(x) for x in input().split()]

a = [int(x) for x in input().split()]

cnt =0

for i in range(0,1<<n):

  sum=0;mn=int(1e18);mx=0;

  for j in range(0,n):

    if((i>>j)&1):
      sum += a[j]
      mn = min(mn,a[j])
      mx = max(mx,a[j])

  if (sum>=l and sum<=r and (mx-mn)>=x):
      cnt +=1

print(cnt)",np
"from collections import defaultdict, Counter
from bisect import bisect, bisect_left
from math import sqrt, gcd

def read(): return list(map(int, input().strip().split()))

ans_ = []

t_p = [2**i for i in range(31)]
n = int(input());
arr = Counter(read())
d = defaultdict(int)
m = 1; ans_lis = [list(arr.keys())[0]]

for i in arr:
    for j in t_p:
        a, b, c = i, i+j, i+2*j
        s = (arr[a] > 0) + (arr[b] > 0) + (arr[c] > 0)
        if s > m:
            m = s
            ans_lis = [x for x in [a, b, c] if arr[x]]

ans_.append(m)
t = """"
for i in ans_lis:t += (str(i)+"" "")
ans_.append(t)

for i in ans_:
    print(i)
",O(nlogn)
"class Solution(object):
    def countArrays(self, original, bounds):
        left, right = bounds[0]
        result = right-left+1
        for i in range(1, len(original)):
            diff = original[i]-original[i-1]
            left = max(left+diff, bounds[i][0])
            right = min(right+diff, bounds[i][1])
            result = min(result, max(right-left+1, 0))
        return result",O(n)
"from bisect import bisect_left as bl
from bisect import bisect_right as br
from heapq import heappush,heappop,heapify
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
input = sys.stdin.readline

from itertools import accumulate
from functools import lru_cache

M = mod = 998244353
def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
def inv_mod(n):return pow(n, mod - 2, mod)

def li():return [int(i) for i in input().rstrip('\n').split()]
def st():return input().rstrip('\n')
def val():return int(input().rstrip('\n'))
def li2():return [i for i in input().rstrip('\n')]
def li3():return [int(i) for i in input().rstrip('\n')]

a = val()
b = val()

n = len(str(a))

a = [int(i) for i in str(a)]
a.sort()
if len(str(b)) > n:

    print(*sorted(a, reverse = 1), sep = '')
    exit()

b = str(b)
b = [int(i) for i in b]

def makenum(s):return int(''.join(str(e) for e in s))

def givemax(a, b):
    if len(a) > len(b):return a
    elif len(b) > len(a):return b
    else:
        for j in range(len(a)):
            if a[j] > b[j]:return a
            elif b[j] > a[j]:return b
        return a

@lru_cache(None)
def dp(l, equal = 1):

    if len(l) == 1:return str(-float('inf')) if l[0] > b[-1] and equal else str(l[0])
    if not equal:return ''.join(str(e) for e in sorted(l, reverse = 1))
    ans = ''
    l = list(l)
    curr = b[n - len(l)]
    for i in range(len(l)):
        if l[i] < curr and dp(tuple(l[:i] + l[i + 1:]), 0) != '-inf':
            ans = givemax(ans, str(l[i]) + dp(tuple(l[:i] + l[i + 1:]), 0))
        elif l[i] == curr and dp(tuple(l[:i] + l[i + 1:]), 1) != '-inf':
            ans = givemax(ans, str(l[i]) + dp(tuple(l[:i] + l[i + 1:]), 1))

    return str(ans)

print(dp(tuple(a), 1))",O(n ^ 3)
"
class Solution(object):
    def checkString(self, s):
        return ""ba"" not in s
",O(n)
"import math

ln = [int(i) for i in input().split("" "")]

n = ln[0]
m = ln[1]
k = ln[2]

p = [int(i) for i in input().split("" "")]

i = 0
ct = 0
ops = 0
while i < len(p):
    nm = p[i] - ct
    if nm % k == 0:
        mnm = nm
    else:
        mnm = (nm // k) * k + k
    si = i
    while p[i] - ct <= mnm:
        i += 1
        if i >= len(p):
            break
    ct += i - si
    ops += 1
    if i >= len(p):
        break
print(ops)
",O(n)
"from sys import stdin,stdout
from collections import Counter
nmbr=lambda:int(stdin.readline())
lst = lambda: list(map(int,stdin.readline().split()))
for _ in range(1):
    n=nmbr()
    a=lst()
    b=sorted(a)
    op=0
    for i in range(n):
        if a[i]==b[i]:continue
        op+=1
    if op==0 or op==2:print('YES')
    else:print('NO')",O(nlogn)
"class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        n = len(nums)
        nums.sort()
        for i in range(n):
            if nums[i] != i:
                return i
        return n
",O(nlogn)
"class Solution(object):
    def sumBase(self, n, k):
        result = 0
        while n:
            n, r = divmod(n, k)
            result += r
        return result",O(logn)
"n, m, k, l = map(int, input().split())
if m > n or (l + k + m - 1) // m * m > n:
    print(-1)
else:
    x = (l + k + m - 1) // m
    print(x)",O(1)
"n=int(input())
a=list(map(int,input().split()))
b=list(map(int,input().split()))
ha={}
for i in range(n):
    ha[a[i]]=i
removed=0
out=""""
for i in range(n):
    if ha[b[i]]<removed:
        out+=""0 ""
    else:
        out+=str(ha[b[i]]-removed+1)+"" ""
        removed=ha[b[i]]+1
print(out[:-1])",O(n)
"import pandas as pd



def Solution(employees: pd.DataFrame) -> pd.DataFrame:
    return employees.assign(salary=2*employees[""salary""])",O(n)
"class Solution2(object):
    def isUnivalTree(self, root):
        return (not root.left or (root.left.val == root.val and self.isUnivalTree(root.left))) and \
               (not root.right or (root.right.val == root.val and self.isUnivalTree(root.right)))",O(n)
"n = int(input())
a = sorted(list(map(int, input().split())))
tmp = 0
if a.count(0) > 1:
    print('cslnb')
    exit()
if n - len(set(a)) > 1:
    print('cslnb')
    exit()
if n == 1:
    print('cslnb' if not a[0] % 2 else 'sjfnb')
    exit()
if n - len(set(a)) == 1:
    for i in range(1, n):
        if a[i] == a[i - 1]:
            if a[i] - 1 in a:
                print('cslnb')
                exit()
            break
for i in range(n):
    tmp += a[i] - i
print('cslnb' if not tmp % 2 else 'sjfnb')
",O(nlogn)
"import os, sys
from io import BytesIO, IOBase

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class dict(dict):
    def __missing__(self, key):
        return 0

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
valid = lambda x, y: -1 < x < n and -1 < y < m
dx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1)

n, m, k = inp(int)
if k & 1:
    [print(*([-1] * m)) for _ in range(n)]
    exit()

right, down = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]
mem = [[[float('inf')] * (k // 2 + 1) for _ in range(m + 1)] for _ in range(n + 1)]

for _ in range(n):
    for i, j in enumerate(inp(int)):
        right[_][i] = j

for _ in range(n - 1):
    for i, j in enumerate(inp(int)):
        down[_][i] = j

for i in range(n):
    for j in range(m):
        mem[i][j][0] = 0

for k1 in range(1, k // 2 + 1):
    for i in range(n):
        for j in range(m):
            ans = []
            ans.append(mem[i - 1][j][k1 - 1] + down[i - 1][j])
            ans.append(mem[i + 1][j][k1 - 1] + down[i][j])
            ans.append(mem[i][j - 1][k1 - 1] + right[i][j - 1])
            ans.append(mem[i][j + 1][k1 - 1] + right[i][j])
            mem[i][j][k1] = min(ans)

[print(*[mem[i][x][-1] * 2 for x in range(m)]) for i in range(n)]
",O(n ^ 3)
"from collections import defaultdict

def read_line():
    return [int(x) for x in input().split()]

def solve2(n, m, x1, y1, x2, y2,
                x3, y3, x4, y4):
    def inside(x, y):
        return 1 <= x <= m and 1 <= y <= n

    def col(a, b):
        assert inside(a, b)
        return 'WB'[(a+b)%2]

    d = {}
    for i in range(1, m+1):
        for j in range(1, n+1):
            d[(i, j)] = col(i, j)
    for i in range(x1, x2+1):
        for j in range(y1, y2+1):
            d[(i, j)] = 'W'
    for i in range(x3, x4+1):
        for j in range(y3, y4+1):
            d[(i, j)] = 'B'
    return len([P for P in d if d[P] == 'W']), len([P for P in d if d[P] == 'B'])

def rnd_test():
    from random import randint
    n = randint(1, 50)
    m = randint(1, 50)
    x1, x2, x3, x4 = [randint(1, m) for _ in range(4)]
    y1, y2, y3, y4 = [randint(1, n) for _ in range(4)]
    x1, x2 = min(x1, x2), max(x1, x2)
    y1, y2 = min(y1, y2), max(y1, y2)
    x3, x4 = min(x3, x4), max(x3, x4)
    y3, y4 = min(y3, y4), max(y3, y4)
    assert solve(n, m, x1, y1, x2, y2,
                x3, y3, x4, y4) == solve2(n, m, x1, y1, x2, y2,
                x3, y3, x4, y4)

def solve(n, m, x1, y1, x2, y2,
                x3, y3, x4, y4):

    def inside(x, y):
        return 1 <= x <= m and 1 <= y <= n

    def col(a, b):
        assert inside(a, b)
        return 'WB'[(a+b)%2]

    def cols(x1, y1, x2, y2):
        assert inside(x1, y1) and inside(x2, y2)
        assert x1 <= x2 and y1 <= y2
        w, h = x2+1-x1, y2+1-y1
        if w % 2 == 0 or h % 2 == 0:
            return w*h // 2, w*h // 2
        else:
            WH, BL = w*h // 2, w*h // 2
            if col(x1, y1) == 'W':
                WH += 1
            else: BL += 1
            return WH, BL

    def overlap():
        X1 = max(x1, x3)
        X2 = min(x2, x4)
        Y1 = max(y1, y3)
        Y2 = min(y2, y4)
        if X1 > X2 or Y1 > Y2: return None
        return X1, Y1, X2, Y2

    tot_wh, tot_bl = cols(1, 1, m, n)

    A_wh, A_bl = cols(x1, y1, x2, y2)
    ovrlp = overlap()
    if ovrlp is not None:
        O_wh, O_bl = cols(*ovrlp)
        assert A_wh >= O_wh and A_bl >= O_bl
        A_wh -= O_wh
        A_bl -= O_bl

    B_wh, B_bl = cols(x3, y3, x4, y4)

    tot_wh += A_bl
    tot_bl -= A_bl

    tot_wh -= B_wh
    tot_bl += B_wh
    return(tot_wh, tot_bl)

t = int(input())

for _ in range(t):
    n, m = read_line()
    x1, y1, x2, y2 = read_line()
    x3, y3, x4, y4 = read_line()
    print(*solve(n, m, x1, y1, x2, y2, x3, y3, x4, y4))
",O(1)
"import random



class Solution(object):
    def maxSubsequence(self, nums, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        partition = nums[:]
        nth_element(partition, k-1, compare=lambda a, b: a > b)
        cnt = sum(partition[i] == partition[k-1] for i in range(k))
        result = []
        for x in nums:
            if x > partition[k-1]:
                result.append(x)
            elif x == partition[k-1] and cnt > 0:
                cnt -= 1
                result.append(x)
        return result",O(n)
"import itertools
import heapq



class Solution(object):
    def maxScore(self, nums1, nums2, k):
        result = curr = 0
        min_heap = []
        for a, b in sorted(zip(nums1, nums2), key=lambda x: x[1],  reverse=True):
            curr += a
            heapq.heappush(min_heap, a)
            if len(min_heap) > k:
                curr -= heapq.heappop(min_heap)
            if len(min_heap) == k:
                result = max(result, curr*b)
        return result",O(nlogn)
"class Solution(object):
    def distinctDifferenceArray(self, nums):
        result = [0]*len(nums)
        lookup = set()
        for i in range(len(nums)):
            lookup.add(nums[i])
            result[i] = len(lookup)
        lookup.clear()
        for i in reversed(range(len(nums))):
            result[i] -= len(lookup)
            lookup.add(nums[i])
        return result",O(n)
"import collections


class Solution(object):
    def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):
        result = 0
        q = collections.deque(initialBoxes)
        while q:
            changed = False
            for _ in range(len(q)):
                box = q.popleft()
                if not status[box]:
                    q.append(box)
                    continue
                changed = True
                result += candies[box]
                for contained_key in keys[box]:
                    status[contained_key] = 1
                for contained_box in containedBoxes[box]:
                    q.append(contained_box)
            if not changed:
                break
        return result",O(n ^ 2)
"s = input().split()
s.sort()
if s[0] == s[1] == s[2]:
	print(0)
	exit()
if s[0][1] == s[1][1] == s[2][1]:
	if ord(s[0][0]) + 1 == ord(s[1][0]) == ord(s[2][0]) - 1:
		print(0)
		exit()
if s[0][1] == s[1][1] and ord(s[0][0]) + 2 >= ord(s[1][0]) or s[1][1] == s[2][1] and ord(s[1][0]) + 2 >= ord(s[2][0]) or s[0][1] == s[2][1] and ord(s[0][0]) + 2 >= ord(s[2][0]):
	print(1)
	exit()
if s[0] == s[1] or s[1] == s[2] or s[0] == s[2]:
	print(1)
	exit()
print(2)
",O(nlogn)
"import sys
import os
from io import IOBase, BytesIO

def main():
    n = int(input())
    x = 2 * n - 1
    ans = x
    x -= 2
    curr = 0
    while x > 0:
        curr += x
        x -= 2
    print(ans + 2 * curr)

BUFSIZE = 8192

class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        py2 = round(0.5)
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2 == 1:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode(""ascii""))
            self.read = lambda: self.buffer.read().decode(""ascii"")
            self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def get_array(): return list(map(int, sys.stdin.readline().split()))

def get_ints(): return map(int, sys.stdin.readline().split())

def input(): return sys.stdin.readline().strip()

if __name__ == ""__main__"":
    main()
",O(n)
"def maxlen():
    string = input()
    maxi = 0;
    for x in range(len(string)):
        substring = """"
        for y in string[x:]:
            substring +=y;
            if string[x:].rfind(substring) != string[x:].find(substring):
                maxi = max(maxi, len(substring))
                continue
    print(maxi)

maxlen()
",O(n ^ 3)
"from sys import stdin
n=int(stdin.readline().strip())
s=list(map(int,stdin.readline().strip().split()))
s.sort()
f=False
z=s.count(0)
p=0
for i in range(2,n):
    if s[i]==s[i-1] and s[i-1]==s[i-2]:
        f=True
for i in range(1,n):
    if s[i]==s[i-1]:
        p+=1
        if i-2>=0 and s[i-2]==s[i-1]-1:
            f=True
y=sum(s)
t=(n)*(n-1)//2
r=y-t
if r%2==0 or f or y==0 or z>=2 or p>=2:
    print(""cslnb"")
else:
    print(""sjfnb"")
",O(nlogn)
"import math
def mint(): return map(int, input().split())
n, m, k = mint()
horizontal = [list(mint()) for i in range(n)]
vertical = [list(mint()) for i in range(n-1)]
if k%2 or max(n, m)==1:
    for i in range(n):
        print(*[-1]*m)
    exit()
dp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)]
for length in range(1, k//2+1):
    for i in range(n):
        for j in range(m):
            left_path = math.inf if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]
            right_path = math.inf if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]
            top_path = math.inf if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]
            bottom_path = math.inf if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]
            dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])
for i in range(n):
    print(*[dp[i][j][k//2]*2 for j in range(m)])
",O(n ^ 3)
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

def main():

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc=ri()
    for _ in range(tc):
        n=ri()
        a=ria()
        d=Counter(a)
        a=sorted(list(set(a)))
        s=[]
        c=0
        for i in a:
            if d[i]>=4:
                c=1
                print(i,i,i,i)
                break
            if d[i]>=2:
                s.append(i)
        if c==0:
            lx=9999999999999999999999999999999
            bx=1
            for i in range(len(s)-1):
                l=s[i+1]
                b=s[i]
                if l*bx<lx*b:
                    lx=l
                    bx=b
            print(lx,lx,bx,bx)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(nlogn)
"import sys
from enum import Enum

class flag(Enum):
    UNVISITED = -1
    EXPLORED = -2
    VISITED = -3

def match(p, s):
    for i in range(len(p)):
        if p[i] != ""_"" and p[i] != s[i]:
            return False
    return True

def cycleCheck(u):
    global AL
    global dfs_num
    global dfs_parent
    global sol

    dfs_num[u] = flag.EXPLORED.value
    for v in AL[u]:
        if dfs_num[v] == flag.UNVISITED.value:
            dfs_parent[v] = u
            cycleCheck(v)
        elif dfs_num[v] == flag.EXPLORED.value:
            sol = False
    dfs_num[u] = flag.VISITED.value

def toposort(u):
    global AL
    global dfs_num
    global ts

    dfs_num[u] = flag.VISITED.value
    for v in AL[u]:
        if dfs_num[v] == flag.UNVISITED.value:
            toposort(v)
    ts.append(u)

sol = True
n, m, k = map(int, sys.stdin.readline().strip().split())
pd = {}
ps = set()
pa = []
for i in range(n):
    p = sys.stdin.readline().strip()
    pd[p] = i + 1
    ps.add(p)
    pa.append(p)

AL = [[] for _ in range(n)]

for _ in range(m):
    s, fn = sys.stdin.readline().strip().split()
    fn = int(fn)
    if not match(pa[fn-1], s):
        sol = False

    mm = [""""]
    for i in s:
        mm = list(map(lambda x: x + ""_"", mm)) + list(map(lambda x: x + i, mm))
    for i in mm:
        if i in ps:
            if pd[i] != fn:
                AL[fn-1].append(pd[i]-1)

try:
    if not sol:
        print(""NO"")
    else:
        dfs_num = [flag.UNVISITED.value] * n
        dfs_parent = [-1] * n
        for u in range(n):
            if dfs_num[u] == flag.UNVISITED.value:
                cycleCheck(u)
        if not sol:
            print(""NO"")
        else:
            dfs_num = [flag.UNVISITED.value] * n
            ts = []
            for u in range(n):
                if dfs_num[u] == flag.UNVISITED.value:
                    toposort(u)
            ts = ts[::-1]
            print(""YES"")
            print(' '.join(map(lambda x: str(x+1), ts)))
except:
    print(""NO"")",np
"import sys

def main():
    pass

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def lts(l):
    s = ''.join(map(str, l))
    return s

def stl(s):

    l = list(s)

    return l

def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans

def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1

    return (cnt)

def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)

mod = int(1e9) + 7
def ssinp(): return sys.stdin.readline().strip()

def iinp(): return int(input())

def nninp(): return map(int, sys.stdin.readline().strip().split())

def llinp(): return list(map(int, sys.stdin.readline().strip().split()))

def p(xyz): print(xyz)
def p2(a, b): print(a, b)
import math

n,k=nninp()
if(k>=2*n):
    p(0)
elif(k<=n):
    if(k%2==1):
        p(k//2)
    else:
        p(k//2-1)
else:
    if(k%2==1):
       print(k//2-(k-n)+1)
    else:
        print(k//2 - (k - n))
",O(1)
"
import itertools


class Solution(object):
    def heightChecker(self, heights):
        return sum(i != j for i, j in zip(heights, sorted(heights)))
",O(nlogn)
"class Solution(object):
    def nextGreaterElements(self, nums):
        result, stk = [0] * len(nums), []
        for i in reversed(range(2*len(nums))):
            while stk and stk[-1] <= nums[i % len(nums)]:
                stk.pop()
            result[i % len(nums)] = stk[-1] if stk else -1
            stk.append(nums[i % len(nums)])
        return result",O(n)
"n=int(input())
if n<3:
    print(n)
else:
    if n%2!=0:
        print(n*(n-1)*(n-2))
    else:
        if n==6:
            print(60)
        elif n%3==0:
            print((n-1)*(n-2)*(n-3))
        else:
            print(n*(n-1)*(n-3))
",O(1)
"import collections


class Solution(object):
    def getImportance(self, employees, id):
        if employees[id-1] is None:
            return 0
        result = employees[id-1].importance
        for id in employees[id-1].subordinates:
            result += self.getImportance(employees, id)
        return result",O(n)
"def fastio():
	import sys
	from io import StringIO
	from atexit import register
	global input
	sys.stdin = StringIO(sys.stdin.read())
	input = lambda : sys.stdin.readline().rstrip('\r\n')
	sys.stdout = StringIO()
	register(lambda : sys.__stdout__.write(sys.stdout.getvalue()))
fastio()

MOD = 10**9 + 7
I = lambda:list(map(int,input().split()))

t, = I()
while t:
	t -= 1
	n, = I()
	a = I()
	a.sort()
	if n == 2:
		print(0)
	else:
		print(min(n-2, a[-2]-1))
",O(nlogn)
"class Solution(object):
    def maxDistance(self, arrays):
        result, min_val, max_val = 0,  arrays[0][0], arrays[0][-1]
        for i in range(1, len(arrays)):
            result = max(result, \
                         max(max_val - arrays[i][0], \
                             arrays[i][-1] - min_val))
            min_val = min(min_val, arrays[i][0])
            max_val = max(max_val, arrays[i][-1])
        return result",O(n)
"def main_function():
    counter = int(input())
    max_counter = 9
    digits_per_number = 1
    while max_counter < counter:
        digits_per_number += 1
        max_counter = max_counter + digits_per_number * 9 * 10 ** (digits_per_number - 1)
    max_real_number = int(str(9) * digits_per_number)
    dif  = max_counter - counter
    rem = dif % digits_per_number
    real_number = max_real_number - dif // digits_per_number
    print(str(real_number)[-1-rem])

main_function()",O(logn)
"class Solution(object):
    def maxFrequency(self, nums, k, numOperations):
        nums.sort()
        result = 0
        left, right = 0, -1
        cnt = collections.defaultdict(int)
        for i in range(len(nums)):
            while right+1 < len(nums) and nums[right+1]-nums[i] <= k:
                cnt[nums[right+1]] += 1 
                right += 1
            while nums[i]-nums[left] > k:
                cnt[nums[left]] -= 1
                left += 1
            result = max(result, cnt[nums[i]]+min((right-left+1)-cnt[nums[i]], numOperations))
        left = 0
        for right in range(len(nums)):
            while nums[left]+k < nums[right]-k:
                left += 1
            result = max(result, min(right-left+1, numOperations))
        return result
    
import collections",O(nlogn)
"import collections


class Solution2(object):
    def countTriplets(self, A):
        count = collections.defaultdict(int)
        for i in range(len(A)):
            for j in range(len(A)):
                count[A[i]&A[j]] += 1
        result = 0
        for k in range(len(A)):
            for v in count:
                if A[k]&v == 0:
                    result += count[v]
        return result",O(n ^ 3)
"n,m=map(int,input().split())
x=list(map(int,input().split()))
y=list(map(int,input().split()))
l=list()
for i in range(m):
    for j in range(n):
        if(y[i]==x[j]):
            l.append(j)
print(' '.join(map(str,[x[i] for i in sorted(l)])))",O(n ^ 2)
"n = int(input())
T = input().split(' ')
for i in range(n):
    T[i]=int(T[i])
L=[]
M=[]
t=0
ip=0
IP=[]
for i in range(n):
    if T[i]>=2:
        L.append(i+1)
        M.append(T[i])
        t+=T[i]
    else:
        ip+=1
        IP.append(i+1)
if t-(2*len(L)-2)<ip:
    print(""NO"")
else:
    for i in range(1, len(L)-1):
        M[i]-=2
    if len(L)>=2:
        M[0]-=1
        M[-1]-=1
    print(""YES"",end=' ')
    if ip==0:
        print(len(L)-1)
    elif ip==1:
        print(len(L))
    else:
        print(len(L)+1)
    print(len(L)-1+ip)
    if ip>=1:
        print(IP[0], end=' ')
        print(L[0])
        M[0]-=1
    if ip>=2:
        print(IP[-1], end=' ')
        print(L[-1])
        M[-1]-=1
    k=1
    ind=0
    while k < ip-1:
        if M[ind]==0:
            ind+=1
        else:
            print(IP[k], end=' ')
            print(L[ind])
            M[ind]-=1
            k+=1
    for i in range(len(L)-1):
        print(L[i], end=' ')
        print(L[i+1])
",O(n)
"n, m = map(int, input().split())
sun, su, ans = 0, 0, 0
arr, brr, dif = [], [], []
for i in range(n):
    a, b = map(int, input().split())

    sun += a; su += b
    dif.append(a - b)
if(su > m):print(-1)
elif(sun == m):print(0)
else:
    dif.sort()
    j = n - 1
    while(sun > m):
        sun -= dif[j]
        ans += 1
        j -= 1
    print(ans)",O(nlogn)
"n,k=map(int,input().split())
if n>=k:
    print((k-1)//2)
elif n*2>k:
    print(n-k//2)
else: print(0)
",O(1)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def findNeartestRightNode(self, root, u):
        q = [root]
        while q:
            new_q = []
            for i, node in enumerate(q):
                if node == u:
                    return q[i+1] if i+1 < len(q) else None
                if node.left:
                    new_q.append(node.left)
                if node.right:
                    new_q.append(node.right)
            q = new_q
        return None",O(n)
"import math

def countDigit(n):
	return math.floor(math.log(n, 10)+1)

n=int(input())
count=countDigit(n)
if count==1:
	print(n)
else:
	low=1
	high=9
	sum=[]
	digit=0
	sum.append(0)
	sum.append(9)
	for i in range(2,16):
		low=low*10
		high=high*10+9

		sum.append((high-low+1)*i+sum[i-1])

		if n<sum[i]:
			digit=i
			break
	x=n-sum[digit-1]
	q=x/(digit)
	r=x%(digit)
	low=math.pow(10,digit-1)
	low=low+q-1

	if r==0:
		print(int(low%10))
	else:
		n=low+1
		stringnum=str(n)
		print(int(stringnum[r-1]))",O(logn)
"import collections


class Solution3(object):
    def majorityElement(self, nums):
        return sorted(list(collections.Counter(nums).items()), key=lambda a: a[1], reverse=True)[0][0]",O(nlogn)
"def crear_intervalo(x,a):
    lim_inf = x-a/2
    lim_sup = x+a/2
    intervalo = (lim_inf, lim_sup)
    return intervalo

def calcular_posibles_posiciones(i1, i2, t):
    espacio_disponible = i2[0] - i1[1]
    espacio_sobrante = espacio_disponible - t
    if espacio_sobrante > 0:
        return 2
    elif espacio_sobrante == 0:
        return 1
    else:
        return 0

intervalos = []
posibilidades = 2

datos = input().split()
n,t = int(datos[0]), int(datos[1])

for i in range(n):
    casas = input().split()
    x, a = int(casas[0]), int(casas[1])
    intervalo = crear_intervalo(x,a)
    intervalos.append(intervalo)

intervalos.sort()

for i in range(n-1):
    posibilidades = posibilidades + calcular_posibles_posiciones(intervalos[i], intervalos[i+1],t)

print(posibilidades)
",O(nlogn)
"class Solution(object):
    def incremovableSubarrayCount(self, nums):
        for j in reversed(range(1, len(nums))):
            if not nums[j-1] < nums[j]:
                break
        else:
            return (len(nums)+1)*len(nums)//2
        result = len(nums)-j+1
        for i in range(len(nums)-1):
            while j < len(nums) and not (nums[i] < nums[j]):
                j += 1
            result += len(nums)-j+1
            if not (nums[i] < nums[i+1]):
                break
        return result",O(n)
"import pandas as pd



def Solution(report: pd.DataFrame) -> pd.DataFrame:
    return report.melt(
        id_vars=[""product""],
        value_vars=[f""quarter_{i}"" for i in range(1, 4+1)],
        var_name=""quarter"",
        value_name=""sales"",
    )",O(n)
"R=lambda:map(int,input().split())
a,b=R()
x,y,z=R()
print(max(0,2*x+y-a)+max(0,y+3*z-b))",O(1)
"lst = list()

lst.append(0)
lst.append(1)

now = 1
while now <= 1e25 :
	now = now * 4 + 1

	lst.append(now)

t = int(input())

for i in range(t):
	s = input().split()
	n = int(s[0])
	k = int(s[1])
	if(n >= 34):
		print(""YES "" + str(n - 1))
		continue

	sek = 0
	ambil = 1
	nyak = 0
	cnt = 0

	sudah = False
	while (sek < n):
		cnt = cnt + (1 << (sek + 1)) - 1

		if cnt > k:
			print(""NO"")
			sudah = True
			break

		next_ambil = (ambil + 1) * 2 - 1
		sisa = 4 * ambil - next_ambil
		ambil = next_ambil

		sek += 1
		nyak = nyak + sisa * lst[n - sek]
		if (nyak + cnt) >= k :
			print(""YES "" + str(n - sek))
			sudah = True
			break

	if sudah == False:
		print(""NO"")
",O(logn)
"r,g,b = list(map(int, input().split()))
ls_r = sorted(list(map(int, input().split())))
ls_g = sorted(list(map(int, input().split())))
ls_b = sorted(list(map(int, input().split())))

dp = [[[None for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)]

for i in range(r+1):
    dp[i][0][0] = 0
for i in range(g+1):
    dp[0][i][0] = 0
for i in range(b+1):
    dp[0][0][i] = 0

dp[1][1][0] = ls_r[0] * ls_g[0]
dp[0][1][1] = ls_g[0] * ls_b[0]
dp[1][0][1] = ls_r[0] * ls_b[0]

for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            res1 = 0
            res2 = 0
            res3 = 0
            if i-1>=0 and j-1>=0:
                res1 += dp[i-1][j-1][k] + ls_r[i-1] * ls_g[j-1]
            if i-1>=0 and k-1>=0:
                res2 += dp[i-1][j][k-1] + ls_r[i-1] * ls_b[k-1]
            if j-1>=0 and k-1>=0:
                res3 += dp[i][j-1][k-1] + ls_g[j-1] * ls_b[k-1]
            dp[i][j][k] = max(res1,res2,res3)
print(dp[r][g][b])",O(n ^ 3)
"
class Solution(object):
    def isPalindrome(self, head):
        reverse, fast = None, head
        while fast and fast.__next__:
            fast = fast.next.__next__
            head.next, reverse, head = reverse, head, head.next

        tail = head.__next__ if fast else head

        is_palindrome = True
        while reverse:
            is_palindrome = is_palindrome and reverse.val == tail.val
            reverse.next, head, reverse = head, reverse, reverse.next
            tail = tail.__next__

        return is_palindrome

",O(n)
"n = int(input())
dp = [0]*101
dp[1] = 1
dp[2] = 2
for i in range(3, 101):
    dp[i] = dp[i-2]+i
print(dp[n])
",O(n)
"import sys
input = sys.stdin.readline

n,m=map(int,input().split())
MAP=[list(input().strip()) for i in range(n)]

T0=[[0]*(m+1) for i in range(n+1)]
T1=[[0]*(m+1) for i in range(n+1)]
Y0=[[0]*(m+1) for i in range(n+1)]
Y1=[[0]*(m+1) for i in range(n+1)]

for i in range(n):
    for j in range(m):
        if MAP[i][j]==""*"":
            T0[i][j]=T0[i-1][j]+1
            Y0[i][j]=Y0[i][j-1]+1

for i in range(n-1,-1,-1):
    for j in range(m-1,-1,-1):
        if MAP[i][j]==""*"":
            T1[i][j]=T1[i+1][j]+1
            Y1[i][j]=Y1[i][j+1]+1

ANS=[[0]*m for i in range(n)]

for i in range(n):
    for j in range(m):
        score=min(T0[i][j],T1[i][j],Y0[i][j],Y1[i][j])
        if score>=2:
            ANS[i][j]=score

T0=[[0]*(m+1) for i in range(n+1)]
T1=[[0]*(m+1) for i in range(n+1)]
Y0=[[0]*(m+1) for i in range(n+1)]
Y1=[[0]*(m+1) for i in range(n+1)]

for i in range(n):
    for j in range(m):
        T0[i][j]=max(ANS[i][j],T0[i-1][j]-1)
        Y0[i][j]=max(ANS[i][j],Y0[i][j-1]-1)

for i in range(n-1,-1,-1):
    for j in range(m-1,-1,-1):
        T1[i][j]=max(ANS[i][j],T1[i+1][j]-1)
        Y1[i][j]=max(ANS[i][j],Y1[i][j+1]-1)

SUF=[["".""]*m for i in range(n)]
for i in range(n):
    for j in range(m):
        if T0[i][j] or T1[i][j] or Y0[i][j] or Y1[i][j]:
            SUF[i][j]=""*""

if SUF!=MAP:
    print(-1)
else:
    ANSLIST=[]
    for i in range(n):
        for j in range(m):
            if ANS[i][j]!=0:
                ANSLIST.append((i+1,j+1,ANS[i][j]-1))

    print(len(ANSLIST))
    for ans in ANSLIST:
        print(*ans)
",O(n ^ 2)
"n, s = map(int, input().split())
times = []
result = 0
need = True
for i in range (n):
    h, m = map(int, input().split())
    times.append(60*h + m)

if n == 1:
    if 0 + s + 1 <= times[0]:
        need = False
for i in range(n-1):
    if 0 + s + 1 <= times[0]:
        need = False
        break
    if times[i+1] - times[i] >= 2 + 2*s:
        result = times[i] + 1 + s
        break
if result == 0 and need:
    result = times[n-1] + 1 + s

hour = result // 60
minute = result % 60

print(hour, minute)",O(n)
"class Solution(object):
    def unhappyFriends(self, n, preferences, pairs):
        friends = [[0]*n for _ in range(n)]
        for i in range(len(preferences)):
            for j in range(len(preferences[i])):
                friends[i][preferences[i][j]] = j
        pairing = [0]*n
        for i, j in pairs:
            pairing[i], pairing[j] = j, i
        return sum(any(friends[i][j] < friends[i][pairing[i]] and friends[j][i] < friends[j][pairing[j]]
                       for j in range(len(friends[i])) if j != i and j != pairing[i])
                   for i in range(len(friends)))",O(n ^ 2)
"n = int(input())
a = [int(s) for s in input().split()]
ans = [None]*n

def get(p):

    if ans[p] is not None:
        return ans[p]
    elif a[p] == 1:
        ans[p] = ""A""
    elif a[p] == n:
        ans[p] = ""B""
    else:
        for i in range(p+a[p], n, a[p]):
            if a[i] > a[p]:
                if get(i) == ""B"":
                    ans[p] = ""A""
                    return ans[p]
        for i in range(p-a[p], -1, -a[p]):
            if a[i] > a[p]:
                if get(i) == ""B"":
                    ans[p] = ""A""
                    return ans[p]
        ans[p] = ""B""
    return ans[p]

if n == 1:
    print(""B"")
else:
    for i in range(n-1, -1, -1):
        get(i)
    print(''.join(ans))",O(n)
"nums = [0, 1]
dp = [0, 1]
class Solution(object):
    def getMaximumGenerated(self, n):
        if n+1 > len(dp):
            for i in range(len(nums), n+1):
                if i%2 == 0:
                    nums.append(nums[i//2])
                else:
                    nums.append(nums[i//2] + nums[i//2+1])
                dp.append(max(dp[-1], nums[-1]))
        return dp[n]",O(n)
"import os
import sys
from io import BytesIO, IOBase

def main():
    from math import sqrt
    for _ in range(int(input())):
        n = int(input())
        if (round(sqrt(n)) ** 2 == n and n % 2 == 0) or round(sqrt(n * 2)) ** 2 == 2 * n:
            print(""YES"")
        else:
            print(""NO"")

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(1)
"n = int(input())
s = [["""" for _ in range(n)] for __ in range(4)]
for i in range(3):
    for j in range(n):
        s[i][j] = input()
    input()
for j in range(n):
    s[3][j] = input()
res = int(1e13)
for i in range(24):
    perm = [0, 1, 2, 3]
    L = [0]*4
    tmp = i
    for j in range(4):
        L[j] = tmp % (4-j)
        tmp //= (4-j)
    LL = [0]*4
    for j in range(4):
        LL[j] = perm[L[j]]
        for k in range(L[j], 3-j):
            perm[k] = perm[k+1]
    lu, ru, ld, rd = LL[0], LL[1], LL[2], LL[3]
    Map = [s[lu][_][:]+s[ru][_][:] for _ in range(n)] + [s[ld][_][:]+s[rd][_][:] for _ in range(n)]
    cnt0, cnt1 = 0, 0
    for j in range(2*n):
        for k in range(2*n):
            if (j+k) % 2:
                if Map[j][k] == '0':
                    cnt0 += 1
                else:
                    cnt1 += 1
            else:
                if Map[j][k] == '1':
                    cnt0 += 1
                else:
                    cnt1 += 1
    res = min(res, cnt0, cnt1)
print(res)",O(n ^ 2)
"
import collections


class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        return True


class Solution(object):
    def smallestStringWithSwaps(self, s, pairs):
        union_find = UnionFind(len(s))
        for x,y in pairs: 
            union_find.union_set(x, y)
        components = collections.defaultdict(list)
        for i in range(len(s)): 
            components[union_find.find_set(i)].append(s[i])
        for i in components.keys(): 
            components[i].sort(reverse=True)
        result = []
        for i in range(len(s)): 
            result.append(components[union_find.find_set(i)].pop())
        return """".join(result)


",O(nlogn)
"import collections


class Solution(object):
    def findLeastNumOfUniqueInts(self, arr, k):
        count = collections.Counter(arr)
        result, count_count = len(count), collections.Counter(iter(count.values()))
        for c in range(1, len(arr)+1): 
            if k < c*count_count[c]:
                result -= k//c
                break
            k -= c*count_count[c]
            result -= count_count[c]                
        return result",O(n)
"n, m = map(int, input().split())
u = []
u1 = []
for i in range(n):
    u.append(list(input()))
    u1.append(['.'] * m)
for i in range(n - 2):
    for j in range(m - 2):
        ok = True
        for k in range(3):
            if u[i][j + k] != '
                ok = False
                break

        if ok:
            if u[i + 2][j + 1] != '
                ok = False
            else:
                for k in range(3):
                    u1[i][j + k] = '
                    u1[i + k][j] = '
                u1[i + 2][j + 1] = '
                u1[i + 2][j + 2] = '
                u1[i + 1][j + 2] = '
ok = True

for i in range(n):
    for j in range(m):
        if u[i][j] != u1[i][j]:
            ok = False
            break
    if not ok:
        break
if ok:
    print('YES')
else:
    print('NO')
",O(n ^ 2)
"import collections,sys,functools,heapq,bisect,math

def binary(s):
    ans = set()
    for i in range(2**len(s)):
        x = []
        for j in range(len(s)):
            if (i>>j) & 1:
                x.append(s[j])
            else:
                x.append('_')
        ans.add(''.join(x))
    return ans

seen = set()
visited = set()
ans = []
def dfs(i):
    visited.add(i)
    seen.add(i)
    for j in graph[i]:
        if j in visited:
            return True
        if j in seen:
            continue
        if dfs(j):
            return True
    ans.append(str(i))
    visited.remove(i)
    return False

def topo(graph):
    seen.clear()
    for i in range(1,n+1):
        if i in seen:
            continue
        if dfs(i):
            return False
    return True

input = sys.stdin.readline
mod = 10**9 + 7

for _ in range(1):
    n,m,k = map(int,input().strip().split())
    d = {}
    dop = {}
    for i in range(1,n+1):
        d[i] = input().strip()
        dop[d[i]] = i

    graph = collections.defaultdict(list)
    for i in range(m):
        s = input().strip().split()
        ind = int(s[1])
        sset = binary(s[0])

        if d[ind] not in sset:
            print('NO')
            break
        for i in sset:
            if i in dop and dop[i] != ind :
                graph[dop[i]].append(ind)
    else:

        if topo(graph):
            print('YES')
            print(' '.join(ans))
        else:
            print('NO')
",np
"n,k = map(int,input().split())
a = list(map(int,input().split()))
p = sorted(a)
p = p[-k:]
s = sum(p)
print(s)
idx = 0
i = 0
count = 0
ans = []
while len(ans)<k-1:
    idx+=1
    count+=1
    if a[i] in p:
        p.remove(a[i])
        ans.append(count)
        count = 0
    i+=1
for i in ans:
    print(i,end = "" "")
print(n-idx)
",O(nlogn)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except ModuleNotFoundError:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

Q, = getIntList()
for _ in range(Q):
    N, M, K  = getIntList()
    if max(N,M) >K:
        print(-1)
        continue
    r = K
    if N%2!= K%2:
        r-=1
    if M%2!= K%2:
        r-=1
    print(r)
",O(1)
"class Solution(object):
    def minimumPartition(self, s, k):
        result = 1
        curr = 0
        for c in s:
            if int(c) > k:
                return -1
            if curr*10+int(c) > k:
                result += 1
                curr = 0
            curr = curr*10+int(c)
        return result",O(n)
"def solution():
    n = int(input())
    for _ in range(n):
        s = input()
        p = s.find('C')

        if s[0] == 'R' and s[1].isdigit() and p > 1:
            r = int(s[1:p])
            c = int(s[(p + 1):])

            v = list()
            while c > 0:
                if c % 26 == 0:
                    v.append('Z')
                    c = (c - 1) // 26
                else:
                    v.append(chr(ord('A') + (c % 26 - 1)))
                    c //= 26

            v.reverse()
            print(""%s%d"" % ("""".join(v), r))

        else:
            p = 0
            while p < len(s):
                if s[p].isdigit():
                    break
                p += 1

            sr = s[:p]
            sc = s[p:]

            c = 0
            for x in sr:
                c = c * 26 + (ord(x) - ord('A') + 1)

            print(""R%sC%d"" % (sc, c))

if __name__ == ""__main__"":
    solution()
",O(n)
"size = int(input())
s = input()

ct = 0
F = 0
for i in range(size-2):
    if s[i]==s[i+1] and s[i+1]==s[i+2] and s[i] == 'x':
        ct += 1
        F = 1

if F == 0:
    print(0)
else:
    print(ct)",O(n)
"class Solution2(object):
    def largestSumAfterKNegations(self, A, K):
        A.sort()
        remain = K
        for i in range(K):
            if A[i] >= 0:
                break
            A[i] = -A[i]
            remain -= 1
        return sum(A) - (remain%2)*min(A)*2",O(nlogn)
"class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        indices = {}

        for i, n in enumerate(nums):
            indices[n] = i

        for i, n in enumerate(nums):
            diff = target - n
            if diff in indices and indices[diff] != i:
                return [i, indices[diff]]
",O(n)
"import sys
n = int(input())
l = list(map(int, input().split()))
r = list(map(int, input().split()))
res = [0] * n
for i in range(n):
    res[i] = n - l[i] - r[i]
for i in range(n):
    ok = 0
    for j in range(i):
        if res[j] > res[i]:
            ok += 1
    if ok != l[i]:
        print(""NO"")
        sys.exit(0)
    ok = 0
    for j in range(i + 1, n):
        if res[j] > res[i]:
            ok += 1
    if ok != r[i]:
        print(""NO"")
        sys.exit(0)
print(""YES"")
print(' '.join(map(str, res)))
",O(n ^ 2)
"import sys, math
debug = 0
if debug:
    f = open(""input.txt"", ""r"")
    input = f.readline
def mp():
    return list(map(int,input().split()))

m = 1000000007

def pow(k):
    if k == 0:
        return 1;
    z = pow(k // 2)
    if k % 2 == 1:
        return (2 * z * z) % m
    else:
        return (z * z) % m

def _main():
    x, k = mp()
    if(x == 0):
        print(0)
        return
    t = pow(k)
    a = x * t
    b = a - t + 1;
    print((a + b) % m)

_main()",O(logn)
"n = int(input())
fib = [0,1]

for x in range(1,200):

    z = fib[x] + fib[x-1]
    if z <= n:

        fib.append(z)
    else:
        break

fib = fib[::-1]
lis = []
for y in range(len(fib)):

    if fib[y] <= n:
        if (sum(lis) + fib[y]) <= n:
            if len(lis) < 3:
                lis.append(fib[y])
if sum(lis) == n:
    if len(lis) == 1:
        lis.append(0)
        lis.append(0)
        print(*lis)
    elif len(lis) == 2:
        lis.append(0)
        print(*lis)
    else:
        print(*lis)
else:
    print(""I'm too stupid to solve this problem"")
",O(1)
"class Solution:
    def canAttendMeetings(self, intervals: List[Interval]) -> bool:
        intervals.sort(key=lambda i: i.start)

        for i in range(1, len(intervals)):
            i1 = intervals[i - 1]
            i2 = intervals[i]

            if i1.end > i2.start:
                return False
        return True
",O(nlogn)
"import sys
input = sys.stdin.readline

q=int(input())

for testcases in range(q):
    n,k=map(int,input().split())
    S=list(input().strip())

    for i in range(n):
        if S[i]==""R"":
            S[i]=0
        elif S[i]==""G"":
            S[i]=1
        else:
            S[i]=2

    ANS=1<<50

    for mod in range(3):
        SUM=0
        for i in range(k):
            if S[i]%3!=(mod+i)%3:
                SUM+=1

        ANS=min(ANS,SUM)

        for i in range(k,n):
            if S[i-k]!=(mod+(i-k))%3:
                SUM-=1
            if S[i]!=(mod+i)%3:
                SUM+=1

            ANS=min(ANS,SUM)

    print(ANS)
",O(n)
"def func():
    N = 520
    K = 12
    C = 100 * 1000 + 11
    n, k = [int(x) for x in list(raw_input().split(' '))]
    c = [0 for _ in range(C)]
    f = [0 for _ in range(C)]

    dp = [[0 for _ in range(K*(N))] for _ in range(N)]

    a = [int(x) for x in list(raw_input().split(' '))]
    for x in a:
        c[x] += 1

    b = [int(x) for x in list(raw_input().split(' '))]
    for x in b:
        f[x] += 1

    h = [0]+[int(x) for x in list(raw_input().split(' '))]

    for i in range(n):
        for j in range(n*k + 1):
            for cur in range(k+1):
                dp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur])

    ans = 0
    for i in range(C):
        if f[i] != 0:
            ans += dp[f[i]][c[i]]

    return ans

if __name__ == ""__main__"":
    print(func())
",O(n ^ 3)
"class Solution(object):
    def countQuadruples(self, firstString, secondString):
        lookup1 = [-1]*26
        for i in reversed(range(len(firstString))):
            lookup1[ord(firstString[i])-ord('a')] = i
        lookup2 = [-1]*26
        for i in range(len(secondString)):
            lookup2[ord(secondString[i])-ord('a')] = i
        result, diff = 0, float(""inf"")
        for i in range(26):
            if lookup1[i] == -1 or lookup2[i] == -1:
                continue
            if lookup1[i]-lookup2[i] < diff:
                diff = lookup1[i]-lookup2[i]
                result = 0
            result += int(lookup1[i]-lookup2[i] == diff)
        return result",O(n)
"n, k =map(int,input().split())
a = list(map(int, input().split()))
if n == 1:
    print(a[0])
    print(1)
else:
    lst = sorted(a)[-k:]
    ans = sum(lst)
    print(ans)
    c = 0
    ln = len(lst)
    ans = [0]
    cnt = 0
    for i in range(n):
        if cnt == k - 1:
            break
        for j in range(ln):
            if a[i] == lst[j]:
                lst[j] = -1
                ans.append(i + 1)
                cnt += 1
                break
    ln = len(ans)
    for i in range(1,ln):
        print(ans[i] - ans[i - 1], end = "" "")
    print(n - ans[-1])
",O(nlogn)
"import math
import random
import heapq,bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
import threading
from collections import defaultdict
threading.stack_size(10**8)
mod = 10 ** 9 + 7
mod1 = 998244353

import os
import sys
from io import BytesIO, IOBase
sys.setrecursionlimit(300000)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class TreeNode:
    def __init__(self, k, v):
        self.key = k
        self.value = v
        self.left = None
        self.right = None
        self.parent = None
        self.height = 1
        self.num_left = 1
        self.num_total = 1

class AvlTree:

    def __init__(self):
        self._tree = None

    def add(self, k, v):
        if not self._tree:
            self._tree = TreeNode(k, v)
            return
        node = self._add(k, v)
        if node:
            self._rebalance(node)

    def _add(self, k, v):
        node = self._tree
        while node:
            if k < node.key:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(k, v)
                    node.left.parent = node
                    return node.left
            elif node.key < k:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(k, v)
                    node.right.parent = node
                    return node.right
            else:
                node.value = v
                return

    @staticmethod
    def get_height(x):
        return x.height if x else 0

    @staticmethod
    def get_num_total(x):
        return x.num_total if x else 0

    def _rebalance(self, node):

        n = node
        while n:
            lh = self.get_height(n.left)
            rh = self.get_height(n.right)
            n.height = max(lh, rh) + 1
            balance_factor = lh - rh
            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)
            n.num_left = 1 + self.get_num_total(n.left)

            if balance_factor > 1:
                if self.get_height(n.left.left) < self.get_height(n.left.right):
                    self._rotate_left(n.left)
                self._rotate_right(n)
            elif balance_factor < -1:
                if self.get_height(n.right.right) < self.get_height(n.right.left):
                    self._rotate_right(n.right)
                self._rotate_left(n)
            else:
                n = n.parent

    def _remove_one(self, node):

        replacement = node.left or node.right
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = replacement
            else:
                node.parent.right = replacement
            replacement.parent = node.parent
            node.parent = None
        else:
            self._tree = replacement
            replacement.parent = None
        node.left = None
        node.right = None
        node.parent = None
        self._rebalance(replacement)

    def _remove_leaf(self, node):
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = None
            else:
                node.parent.right = None
            self._rebalance(node.parent)
        else:
            self._tree = None
        node.parent = None
        node.left = None
        node.right = None

    def remove(self, k):
        node = self._get_node(k)
        if not node:
            return
        if AvlTree._is_leaf(node):
            self._remove_leaf(node)
            return
        if node.left and node.right:
            nxt = AvlTree._get_next(node)
            node.key = nxt.key
            node.value = nxt.value
            if self._is_leaf(nxt):
                self._remove_leaf(nxt)
            else:
                self._remove_one(nxt)
            self._rebalance(node)
        else:
            self._remove_one(node)

    def get(self, k):
        node = self._get_node(k)
        return node.value if node else -1

    def _get_node(self, k):
        if not self._tree:
            return None
        node = self._tree
        while node:
            if k < node.key:
                node = node.left
            elif node.key < k:
                node = node.right
            else:
                return node
        return None

    def get_at(self, pos):
        x = pos + 1
        node = self._tree
        while node:
            if x < node.num_left:
                node = node.left
            elif node.num_left < x:
                x -= node.num_left
                node = node.right
            else:
                return (node.key, node.value)
        raise IndexError(""Out of ranges"")

    @staticmethod
    def _is_left(node):
        return node.parent.left and node.parent.left == node

    @staticmethod
    def _is_leaf(node):
        return node.left is None and node.right is None

    def _rotate_right(self, node):
        if not node.parent:
            self._tree = node.left
            node.left.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.left
            node.left.parent = node.parent
        else:
            node.parent.right = node.left
            node.left.parent = node.parent
        bk = node.left.right
        node.left.right = node
        node.parent = node.left
        node.left = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    def _rotate_left(self, node):
        if not node.parent:
            self._tree = node.right
            node.right.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.right
            node.right.parent = node.parent
        else:
            node.parent.right = node.right
            node.right.parent = node.parent
        bk = node.right.left
        node.right.left = node
        node.parent = node.right
        node.right = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    @staticmethod
    def _get_next(node):
        if not node.right:
            return node.parent
        n = node.right
        while n.left:
            n = n.left
        return n

class SegmentTree1:
    def __init__(self, data, default=2**51, func=lambda a, b: a & b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: max(a , b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m

def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z

def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por

def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        if (arr[mid] < key):
            count = mid + 1
            left = mid + 1

        else:
            right = mid - 1

    return count

def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    leftGreater = n

    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        else:
            l = m + 1

    return (n - leftGreater)

n=int(input())
l=list(map(int,input().split()))
cost=list(map(int,input().split()))
dp=defaultdict(int)
dp[0]=0
se=set([0])
for i in range(n):
    for j in se:
        k=int(math.gcd(j,l[i]))
        if dp[k]==0:
            dp[k]=dp[j]+cost[i]
        dp[k]=min(dp[k],dp[j]+cost[i])
    se=set(dp.keys())
if dp[1]==0:
    print(-1)
else:
    print(dp[1])",np
"import sys
sys.setrecursionlimit(10**5+1)

inf     =  int(10 ** 20)
max_val =  inf
min_val = -inf

RW  = lambda : sys.stdin.readline().strip()
RI  = lambda : int(RW())
RMI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]
RWI = lambda : [x for x in sys.stdin.readline().strip().split()]

n, k = map(int, input().split())

print(int((2*n+3-(8*n+8*k+9)**(1/2))//2))",O(logn)
"
class Solution(object):
    def uniqueMorseRepresentations(self, words):
        MORSE = ["".-"", ""-..."", ""-.-."", ""-.."", ""."", ""..-."", ""--."",
                 ""...."", "".."", "".---"", ""-.-"", "".-.."", ""--"", ""-."",
                 ""---"", "".--."", ""--.-"", "".-."", ""..."", ""-"", ""..-"",
                 ""...-"", "".--"", ""-..-"", ""-.--"", ""--..""]

        lookup = {"""".join(MORSE[ord(c) - ord('a')] for c in word) \
                  for word in words}
        return len(lookup)

",O(n)
"n=int(input())
l=list(map(int,input().split()))
l.sort()
for x in range(1,n):
	if l[x]>l[0]:
		print(l[x])
		break
else:
	print('NO')",O(nlogn)
"class Solution(object):
    def maxDistinctElements(self, nums, k):
        result = 0
        nums.sort()
        curr = float(""-inf"")
        for x in nums:
            if curr > x+k:
                continue
            curr = max(curr, x-k)+1
            result += 1
        return result",O(nlogn)
"class Solution(object):

    def __init__(self, n):
        self.__size = n
        self.__rows = [[0, 0] for _ in range(n)]
        self.__cols = [[0, 0] for _ in range(n)]
        self.__diagonal = [0, 0]
        self.__anti_diagonal = [0, 0]

    def move(self, row, col, player):
        i = player - 1
        self.__rows[row][i] += 1
        self.__cols[col][i] += 1
        if row == col:
            self.__diagonal[i] += 1
        if col == len(self.__rows) - row - 1:
            self.__anti_diagonal[i] += 1
        if any(self.__rows[row][i] == self.__size,
               self.__cols[col][i] == self.__size,
               self.__diagonal[i] == self.__size,
               self.__anti_diagonal[i] == self.__size):
            return player

        return 0",O(1)
"import collections



class Solution(object):
    def maximumSubarraySum(self, nums, k):
        prefix = collections.defaultdict(lambda: float(""inf""))
        curr = 0
        result = float(""-inf"")
        for x in nums:
            prefix[x] = min(prefix[x], curr)
            curr += x
            result = max(result, curr-prefix[x-k], curr-prefix[x+k])
        return result if result != float(""-inf"") else 0",O(n)
"n,m=map(int,input().split())
l=list()
r=list()
for _ in range(m):
    a,b=map(int,input().split())
    l.append(a)
    r.append(b)
for i in range(n):
    if(i%2==0):
        print(0,end='')
    else:
        print(1,end='')
",O(n)
"import sortedcontainers


class Solution(object):
    def maxDepthBST(self, order):
        depths = sortedcontainers.SortedDict({float(""-inf""):0, float(""inf""):0})
        values_view = list(depths.values())
        result = 0
        for x in order:
            i = depths.bisect_right(x)
            depths[x] = max(values_view[i-1:i+1])+1
            result = max(result, depths[x])
        return result",O(nlogn)
"rank = 1
n = int(input())
score = sum(map(int,input().split()))
for i in range(n-1):
    student = sum(map(int,input().split()))
    if(student > score):
        rank += 1
print(rank)",O(n)
"import collections



class Solution2(object):
    def numberOfPairs(self, nums):
        cnt = collections.Counter(nums)
        pair_cnt = sum(x//2 for x in cnt.values())
        return [pair_cnt, len(nums)-2*pair_cnt]",O(n)
"class Node(object):
    def __init__(self, val=0, left=None, right=None, random=None):
        self.val = val
        self.left = left
        self.right = right
        self.random = random



class NodeCopy(object):
    def __init__(self, val=0, left=None, right=None, random=None):
        pass


class Solution(object):
    def copyRandomBinaryTree(self, root):
        def iter_dfs(node, callback):
            result = None
            stk = [node]
            while stk:
                node = stk.pop()
                if not node:
                    continue
                left_node, copy = callback(node)
                if not result:
                    result = copy
                stk.append(node.right)
                stk.append(left_node)
            return result
    
        def merge(node):
            copy = NodeCopy(node.val)
            node.left, copy.left = copy, node.left
            return copy.left, copy
        
        def clone(node):
            copy = node.left
            node.left.random = node.random.left if node.random else None
            node.left.right = node.right.left if node.right else None
            return copy.left, copy
        
        def split(node):
            copy = node.left
            node.left, copy.left = copy.left, copy.left.left if copy.left else None
            return node.left, copy
    
        iter_dfs(root, merge)
        iter_dfs(root, clone)
        return iter_dfs(root, split)",O(n)
"import sys
input = sys.stdin.readline

a,b,c = list(map(int,input().split()))

x = list(map(int,input().split()))
y = list(map(int,input().split()))
z = list(map(int,input().split()))

x.sort(reverse=True)
y.sort(reverse=True)
z.sort(reverse=True)

a+=1
b+=1
c+=1

x = [0] + x
y = [0] + y
z = [0] + z

tmp = [[0]*c for _ in range(b)]
best = [tmp for _ in range(a)]

ans = 0

for i in range(a):
    for j in range(b):
        for k in range(c):
            if (i+j+k) % 2 == 0:
                aa,bb,cc = 0,0,0
                if i>0 and j>0:
                    aa = best[i-1][j-1][k] + x[i] * y[j]
                if i>0 and k>0:
                    bb = best[i-1][j][k-1] + x[i] * z[k]
                if j>0 and k>0:
                    cc = best[i][j-1][k-1] + y[j] * z[k]

                best[i][j][k] = max(aa,bb,cc)
                ans = max(ans, best[i][j][k])

print(ans)
",O(n ^ 3)
"class Solution(object):
    def numberOfChild(self, n, k):
        q, r = divmod(k, n-1)
        return r if q&1 == 0 else (n-1)-r",O(1)
"class Solution(object):
    def maxOperations(self, nums):
        result = 1
        target = nums[0]+nums[1]
        for i in range(2, len(nums)-1, 2):
            if nums[i]+nums[i+1] != target:
                break
            result += 1
        return result",O(n)
"import sys
input = sys.stdin.readline

n,k=map(int,input().split())

MIN=0
MAX=n

while True:
    ANS=(MIN+MAX)//2

    if (n-ANS)*(n-ANS+1)//2-ANS>k:
        MIN=ANS+1
    elif (n-ANS)*(n-ANS+1)//2-ANS<k:
        MAX=ANS-1
    else:
        print(ANS)
        break
",O(logn)
"from sortedcontainers import SortedList



class Solution(object):
    def resultArray(self, nums):
        sl1, sl2 = SortedList([nums[0]]), SortedList([nums[1]])
        a, b = [nums[0]], [nums[1]]
        for i in range(2, len(nums)):
            cnt1 = len(sl1)-sl1.bisect_right(nums[i])
            cnt2 = len(sl2)-sl2.bisect_right(nums[i])
            if cnt1 > cnt2 or (cnt1 == cnt2 and len(a) <= len(b)):
                sl1.add(nums[i])
                a.append(nums[i])
            else:
                sl2.add(nums[i])
                b.append(nums[i])
        return a+b",O(nlogn)
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque

n, k = map(int,input().split())
s = input()

def judge(needed):

    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0

    effect = [[inf]*(n+1) for j in range(k)]

    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
            effect[j][i] = min(effect[j][i+4-4],effect[j][i+3-3],inf*inf)

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index])

        minstate[state] = minimum

    if minstate[-1]<=n:  return True
    return False

front = 0
rear = n//k+1

while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)

    if flag:
        front = mid + 1
    else:
        rear = mid

print(front-1)
",np
"s=input()
while(len(s)>0):
    if s!=s[::-1]:
        break
    else:
        s=s[1:]
print(len(s))",O(n)
"n, d, k = map(int, input().split())
num = d+2

def solve():
  global num
  if n == 1: return 'NO'
  if n == 2:
    if d != 1:
      return 'NO'
    else:
      return ""YES\n1 2""
  if k < 2: return 'NO'
  if d > n-1: return 'NO'

  depth = [min(i, d-i) for i in range(d+1)]
  ans = [(i+1, i+2) for i in range(d)]

  def dfs(v, depth):
    global num
    if depth == 0: return
    for i in range(k-1):
      if len(ans) == n-1: return
      v2 = num
      num += 1
      ans.append((v, v2))
      dfs(v2, depth-1)

  for v in range(d+1):
    if depth[v] == 0: continue
    for i in range(k-2):
      if len(ans) == n-1: break
      v2 = num
      num += 1
      ans.append((v+1, v2))
      if depth[v] > 1: dfs(v2, depth[v]-1)

  if len(ans) < n-1: return ""NO""
  return ""YES\n%s""%""\n"".join([""%d %d""%i for i in ans])

print(solve())",O(n ^ 2)
"class Solution(object):
    def partitionString(self, s):
        result, left = 1, 0
        lookup = {}
        for i, x in enumerate(s):
            if x in lookup and lookup[x] >= left:
                left = i
                result += 1
            lookup[x] = i
        return result",O(n)
"string=input()
n=len(string)
count1=[]
long=0
for s_i in range(n):
    for end_i in range(s_i+1,n+1):
        sub=string[s_i:end_i]
        if sub not in count1:
            count1.append(sub)
        else:
            if len(sub)>long:
                long=len(sub)

print(long)
",O(n ^ 3)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')
from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

def main():
    n, k = RL()
    cds = RLL()
    fn = RLL()
    sc = [0]+RLL()

    rec = set(fn)
    uses = 0
    dic = defaultdict(int)
    for i in cds:
        if i in rec:
            dic[i]+=1
            uses+=1

    dp = [[0]*(n*k+1) for _ in range(n+1)]

    for i in range(1, n+1):
        for j in range(1, n*k+1):
            for l in range(k+1):
                if l>j: break
                val = sc[l]
                dp[i][j] = max(dp[i][j], dp[i-1][j-l]+val)
    res = 0

    for i, v in Counter(fn).items():
        res+=dp[v][dic[i]]

    print(res)

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"class Solution(object):
    def minOperations(self, nums):
        result = 0
        for i in range(len(nums)-2):
            if nums[i]:
                continue
            nums[i+1] ^= 1
            nums[i+2] ^= 1
            result += 1
        return result if nums[-2] == nums[-1] == 1 else -1",O(n)
"import collections
import heapq


class Solution3(object):
    def medianSlidingWindow(self, nums, k):
        def lazy_delete(heap, to_remove, sign):
            while heap and sign*heap[0] in to_remove:
                to_remove[sign*heap[0]] -= 1
                if not to_remove[sign*heap[0]]:
                    del to_remove[sign*heap[0]]
                heapq.heappop(heap)

        min_heap, max_heap = [], []
        for i in range(k):
            if i%2 == 0:
                heapq.heappush(min_heap, -heapq.heappushpop(max_heap, -nums[i]))
            else:
                heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))
        result = [float(min_heap[0])] if k%2 else [(min_heap[0]-max_heap[0])/2.0]
        to_remove = collections.defaultdict(int)
        for i in range(k, len(nums)):
            heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))
            if nums[i-k] > -max_heap[0]:
                heapq.heappush(min_heap, -heapq.heappop(max_heap))
            to_remove[nums[i-k]] += 1
            lazy_delete(max_heap, to_remove, -1)
            lazy_delete(min_heap, to_remove, 1)
            result.append(float(min_heap[0]) if k%2 else (min_heap[0]-max_heap[0])/2.0)
        return result",O(nlogn)
"class Solution(object):
    def validUtf8(self, data):
        count = 0
        for c in data:
            if count == 0:
                if (c >> 5) == 0b110:
                    count = 1
                elif (c >> 4) == 0b1110:
                    count = 2
                elif (c >> 3) == 0b11110:
                    count = 3
                elif (c >> 7):
                    return False
            else:
                if (c >> 6) != 0b10:
                    return False
                count -= 1
        return count == 0",O(n)
"l,r=map(int,input().split())
s=bin(l)[2:]
t=bin(r)[2:]
z=max(len(s),len(t))
s='0'*(z-len(s))+s
t='0'*(z-len(t))+t
i=0
while i<z and s[i]==t[i]:
    i=i+1
print(pow(2,z-i)-1)",O(logn)
"def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]

n = INT()
arr = LIST()
mx = max(arr)
x = -1
if mx == 1 :
    x = 2
else:
    x = 1

arr.remove(mx)
arr.append(x)
arr.sort()
print(*arr)
",O(nlogn)
"n = int(input())
m = int(input())
a = [int(i) for i in input().split()]
b = [int(i) for i in input().split()]

low = 1
high = 1000000000
ans = -1

while low<=high:
	if high-low < 0.000001: low = high
	mid = low+(high-low)/2
	try_val = mid
	init_wt = m+try_val
	isPossible = True
	for i in range(n):
		req1 = init_wt/a[i]
		try_val -= req1
		if try_val<=0:
			isPossible = False
			break
		j=(i+1)%n
		init_wt -= req1
		req2 = init_wt/b[j]
		try_val -= req2
		if try_val<0 or (i<n-1 and try_val==0):
			isPossible = False
			break
		init_wt -= req2
	if isPossible:
		ans = mid
		high = mid-0.000001
	else: low = mid+0.000001

if (ans==-1):
	isPossible = True
	try_val = 1000000000.000001
	init_wt = m+try_val
	for i in range(n):
		req1 = init_wt/(a[i])
		try_val -= req1
		if try_val<=0:

			isPossible = False
			break
		j=(i+1)%n
		init_wt -= req1
		req2 = init_wt/(b[j])
		try_val -= req2
		if try_val<0 or (i<n-1 and try_val==0):
			isPossible = False
			break
		init_wt -= req2
	if isPossible: ans = 1000000000
print(ans)",O(n)
"n, m, q = map(int, input().split())
a = sorted(map(int, input().split()), reverse=True)
b = sorted(map(int, input().split()), reverse=True)
c = sorted(map(int, input().split()), reverse=True)
dp = [[[0] * 201 for _ in range(201)] for _ in range(201)]
for ijk in range(n + m + q + 1):
    for i in range(min(n + 1, ijk + 1)):
        for j in range(min(m + 1, ijk - i + 1)):
            k = ijk - i - j
            if k < 0 or k > q:
                continue
            if i + 1 <= n:
                dp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k])
            if j + 1 <= m:
                dp[i][j + 1][k] = max(dp[i][j + 1][k], dp[i][j][k])
            if k + 1 <= q:
                dp[i][j][k + 1] = max(dp[i][j][k + 1], dp[i][j][k])
            if i + 1 <= n and j + 1 <= m:
                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[i] * b[j])
            if i + 1 <= n and k + 1 <= q:
                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[i] * c[k])
            if j + 1 <= m and k + 1 <= q:
                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + b[j] * c[k])
print(dp[n][m][q])",O(n ^ 3)
"import sys
input = sys.stdin.readline
t = int(input())
for i in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    if len(set(a)) == 1:
        print(a[0],a[0],a[0],a[0])
    else:
        a.sort()
        g1 = False
        d = {}
        mx = 10001
        for i in a:
            if i not in d.keys():
                d[i] = 1
            else:
                d[i] += 1
            if d[i] == 4:
                g1 = True
                if i < mx:
                    mx = i
        if g1:
            print(mx, mx, mx, mx)
        else:
            res = []
            for k in d.keys():
                if d[k] >= 2:
                    res.append(k)
            m = len(res)
            minj = 0
            for j in range(m - 1):
                if res[j]*res[j+1]*(res[minj]**2 + res[minj+1]**2) > res[minj]*res[minj+1]*(res[j]**2+res[j+1]**2):
                    minj = j
            print(res[minj],res[minj],res[minj+1],res[minj+1])",O(nlogn)
"class Solution(object):
    def maxScore(self, edges):
        def iter_dfs():
            result = [(0, 0) for _ in range(len(adj))]
            stk = [(1, 0)]
            while stk:
                step, u = stk.pop()
                if step == 1:
                    if not adj[u]:
                        continue
                    stk.append((2, u))
                    for v, _ in adj[u]:
                        stk.append((1, v))
                elif step == 2:
                    without_u = sum(max(result[v]) for v, w in adj[u])
                    with_u = max(without_u-max(result[v])+(result[v][1]+w) for v, w in adj[u])
                    result[u] = (with_u, without_u)
            return max(result[0])
            
        adj = [[] for _ in range(len(edges))]
        for i, (p, w) in enumerate(edges):
            if i == 0:
                continue
            adj[p].append((i, w))
        return iter_dfs()",O(n)
"def rec(r,g,b):
    if(dp[r][g][b]!=-1):
        return dp[r][g][b]
    ans=0
    if r<R and g<G:
        ans=max(ans, red[r]*green[g]+rec(r+1, g+1, b))
    if r<R and b<B:
        ans=max(ans, red[r]*blue[b]+rec(r+1, g, b+1))
    if b<B and g<G:
        ans=max(ans, blue[b]*green[g]+rec(r, g+1, b+1))
    dp[r][g][b]=ans
    return ans
R,G,B=map(int,input().split())
red=sorted(list(map(int, input().split())), reverse=True)
green=sorted(list(map(int, input().split())), reverse=True)
blue=sorted(list(map(int, input().split())), reverse=True)
dp=[[[-1]*(B+1) for _ in range(G+1)] for _ in range(R+1)]
print(rec(0,0,0))",O(n ^ 3)
"n = int(input())
b = [int(w) for w in input().split()]
a = [0]*n

l = n//2 - 1
r = n//2

a[l] = b[l] // 2
a[r] = b[l] - a[l]

while l > 0:
    if b[l-1] >= b[l]:
        a[l-1] = a[l]
        a[r+1] = b[l-1] - a[l]
    else:
        a[r+1] = a[r]
        a[l-1] = b[l-1] - a[r]
    l -= 1
    r += 1

print(*a)
",O(n)
"n = int(input())
s = input()
want = len(set(s))
d = {}
j = 0
count = 0
ans = float(""inf"")
for i in range(n):
    if s[i] not in d:
        d[s[i]] = 0
        count+=1
    d[s[i]]+=1
    if count==want:
        while d[s[j]]>1:
            d[s[j]]-=1
            j+=1
        ans = min(ans,i-j+1)
print(ans)",O(n)
"def get(self, index):
       pass

   def length(self):
       pass


class Solution(object):
    def findInMountainArray(self, target, mountain_arr):
        def binarySearch(A, left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left
        
        peak = binarySearch(mountain_arr, 0, mountain_arr.length()-1,
                            lambda x: mountain_arr.get(x) >= mountain_arr.get(x+1))
        left = binarySearch(mountain_arr, 0, peak,
                            lambda x: mountain_arr.get(x) >= target)
        if left <= peak and mountain_arr.get(left) == target:
            return left
        right = binarySearch(mountain_arr, peak, mountain_arr.length()-1,
                             lambda x: mountain_arr.get(x) <= target)
        if right <= mountain_arr.length()-1 and mountain_arr.get(right) == target:
            return right
        return -1",O(logn)
"class Solution(object):
    def largestAltitude(self, gain):
        result = curr = 0
        for g in gain:
            curr += g
            result = max(result, curr)
        return result",O(n)
"import sys

if __name__ == '__main__':
    cin = sys.stdin

    n = int(next(cin))
    a = list(map(int, next(cin).split()))

    n2idx = {a[i]: i for i in range(n)}

    f = [False] * (n+1)

    for i in range(n, 0, -1):
        idx_lg = n2idx[i]

        win_flag = False
        for j in range(idx_lg%i, n, i):
            if a[j] > i and not f[a[j]]:
                win_flag = True
                break
        f[i] = win_flag

    f = ''.join(['A' if f[a_i] else 'B' for a_i in a])
    print(f, flush=True)
",O(n ^ 2)
"class Solution(object):
    def maxSubarraySum(self, nums, k):
        dp = [float(""inf"")]*k
        dp[-1] = 0
        curr = 0
        result = float(""-inf"")
        for i, x in enumerate(nums):
            curr += x
            result = max(result, curr-dp[i%k])
            dp[i%k] = min(dp[i%k], curr)
        return result",O(n)
"from sys import stdin
from collections import Counter

rstr = lambda: stdin.readline().strip()
a, b = list(rstr()), list(rstr())

if len(a) < len(b) or len(a) == 1:
    print(''.join(sorted(a)[::-1]))
else:
    ans, tem = 0, []

    for i in range(len(b)):
        for j in range(int(b[i]) - 1, -1, -1):
            if str(j) in a and not (j == i == 0):
                a.remove(str(j))
                ans = max(ans, int(''.join(tem) + str(j) + ''.join(sorted(a)[::-1])))
                a.append(str(j))
                break

        if b[i] not in a:
            break

        tem.append(b[i])
        a.remove(b[i])

    if tem:
        ans = max(ans, int(''.join(tem)))

    print(ans)
",O(n ^ 3)
"class Solution2(object):
    def maxRectangleArea(self, points):
        result = -1
        points.sort()
        for i in range(len(points)-3):
            if points[i][0] != points[i+1][0]:
                continue
            j = next((j for j in range(i+2, len(points)-1) if points[i][1] <= points[j][1] <= points[i+1][1]), len(points)-1)
            if j == len(points)-1 or not (points[j][0] == points[j+1][0] and points[i][1] == points[j][1] and points[i+1][1] == points[j+1][1]):
                continue
            result = max(result, (points[i+1][1]-points[i][1])*(points[j][0]-points[i][0]))
        return result",O(n ^ 2)
"a = int(input())
print(a * (a - 1) * 2 + 1)",O(1)
"s=input()
n=len(s)
m=n-1;
while m>0:
    f=False
    for i in range(0,n-m):
        for j in range(i+1,n-m+1):
            x=True
            for k in range(0,m):
                if s[i+k]!=s[j+k]:
                    x=False
                    break
            if x:
                f=True
                break
        if f:
            break
    if f:
        break
    m -= 1
print(m)",O(n ^ 3)
"n = int(input())
above = n // 3
below = n - above
for i in range(above):
    print(2 * i + 1, 3)
for i in range(below):
    print(i, 0)
",O(n)
"a,b = map(int,input().split())
d = list(map(int,input().split()))
e = []
e1= []
mx = 0
current = 0
for i in range(len(d)):
    if i%2 == 0:
        e.append(d[i]-current)
    else:
        e1.append(d[i]-current)
    current=d[i]
if i%2 == 0:
    e1.append(b-current)
else:
    e.append(b-current)
mx = sum(e)
su = 0
su2 = sum(e1)
for i in range(len(e)):
    su+=e[i]
    mx = max(mx,su+su2-1)
    try:
        su2-=e1[i]
    except:
        break
print(mx)
",O(n)
"
import threading


class Solution(object):
    def __init__(self):
        self.__cv = threading.Condition()
        self.__has_first = False
        self.__has_second = False

    def first(self, printFirst):
        with self.__cv:
            printFirst()            
            self.__has_first = True
            self.__cv.notifyAll()

    def second(self, printSecond):
        with self.__cv:
            while not self.__has_first:
                self.__cv.wait()
            printSecond()
            self.__has_second = True
            self.__cv.notifyAll()
              
    def third(self, printThird):
        with self.__cv:
            while not self.__has_second:
                self.__cv.wait()
            printThird()
            self.__cv.notifyAll()
        
",O(1)
"class Solution(object):
    def maximumLength(self, nums):
        cnt = collections.Counter(nums)
        dp = {}
        result = 0
        for x in cnt.keys():
            if x == 1:
                result = max(result, cnt[x]-(1 if cnt[x]%2 == 0 else 0))
                continue
            stk = []
            while x not in dp and x in cnt and cnt[x] >= 2:
                stk.append(x)
                x *= x
            if x not in dp:
                if x not in cnt:
                    x = stk.pop()
                dp[x] = 1
            l = dp[x]
            while stk:
                l += 2
                dp[stk.pop()] = l
            result = max(result, l)
        return result 
    
    
import collections",O(n)
"n = [int(x) for x in input().split()]
a = []
for i in range(3):
	a.append([int(x) for x in input().split()])
	a[i].sort(reverse=True)

dp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]
ans = 0
for i in range(n[0] + 1):
	for j in range(n[1] + 1):
		for k in range(n[2] + 1):
			if i < n[0] and j < n[1]:
				dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])
			if i < n[0] and k < n[2]:
				dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])
			if j < n[1] and k < n[2]:
				dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])
			ans = max(ans, dp[i][j][k])

print(ans)",O(n ^ 3)
"import math
n,pos,l,r = map(int, input().strip().split(' '))

if l==1 and r==n:
    print(0)
elif l==1:
    if pos==r:
        print(1)
    elif pos>r:
        print(pos-r+1)
    elif pos<r:
        print(r-pos+1)
elif r==n:
    if pos==l:
        print(1)
    elif pos<l:
        print(l-pos+1)
    else:
        print(pos-l+1)
else:
    if pos>=l and pos<=r:
        if pos-l<r-pos:
            print(2+pos-l+r-l)
        else:
            print(2+r-l+r-pos)
    else:
        if pos>r:
            print(pos-r+2+r-l)
        else:
            print(l-pos+2+r-l)",O(1)
"class Solution(object):
    def numberOfUniqueGoodSubsequences(self, binary):
        MOD = 10**9+7
        ends0, ends1 = 0, 0
        has_zero = False
        for b in binary:
            if b == '1':
                ends1 = (ends0+ends1+1)%MOD 
            else:
                ends0 = (ends0+ends1)%MOD 
                has_zero = True
        return (ends0+ends1+int(has_zero))%MOD",O(n)
"n = int(input())
ans = 1
for i in range(n):
    ans += 4 * i
print(ans)
",O(n)
"import sys
input = lambda : sys.stdin.readline().rstrip()

sys.setrecursionlimit(2*10**5+10)
write = lambda x: sys.stdout.write(x+""\n"")
debug = lambda x: sys.stderr.write(x+""\n"")
writef = lambda x: print(""{:.12f}"".format(x))

def zeta_super(val, n):

    out = val[:]
    for i in range(n):
        for j in range(1<<n):
            if not j>>i&1:
                out[j] += out[j^(1<<i)]
    return out

n = int(input())
a = list(map(int, input().split()))
m = max(a).bit_length()
M = 10**9+7
v = [0]*(1<<m)
for item in a:
    v[item] += 1
v2 = [1]
for i in range(n+1):
    v2.append(v2[-1]*2%M)
nv = zeta_super(v, m)
ans = 0
for b in range(1<<m):
    ans += (v2[nv[b]]-1)*pow(-1, bin(b).count(""1""))
    ans %= M
print(ans%M)",np
"n, m = list(map(int, input().split()))
a = list(map(int, input().split()))
b = list(map(int, input().split()))
lst = []
for i in range(len(a)):
    if (a[i] in b):
        lst.append(a[i])
if (len(lst) == 0):
    pass
else:
    print(*lst)
",O(n ^ 2)
"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        q = deque()
        if root:
            q.append(root)

        level = 0
        while q:
            for i in range(len(q)):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            level += 1
        return level
",O(n)
"import itertools
import heapq


class Solution(object):
    def maxPerformance(self, n, speed, efficiency, k):
        MOD = 10**9 + 7
        result, s_sum = 0, 0
        min_heap = []
        for e, s in sorted(zip(efficiency, speed), reverse=True):
            s_sum += s
            heapq.heappush(min_heap, s)
            if len(min_heap) > k:
                s_sum -= heapq.heappop(min_heap)
            result = max(result, s_sum*e)
        return result % MOD",O(nlogn)
"class Solution2(object):
    def maximumSumScore(self, nums):
        total = sum(nums)
        prefix = 0
        result = float(""-inf"")
        for x in nums:
            prefix += x
            result = max(result, prefix, total-prefix+x)
        return result",O(n)
"import bisect



class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda _: 0,
                 query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),
                 update_fn=lambda x: x):
        self.tree = [None]*(2*2**((N-1).bit_length()))
        self.base = len(self.tree)//2
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in range(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(range(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

    def update(self, i, h):
        x = self.base+i
        self.tree[x] = self.update_fn(h)
        while x > 1:
            x //= 2
            self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

    def query(self, L, R):
        if L > R:
            return 0
        L += self.base
        R += self.base
        left = right = None
        while L <= R:
            if L & 1:
                left = self.query_fn(left, self.tree[L])
                L += 1
            if R & 1 == 0:
                right = self.query_fn(self.tree[R], right)
                R -= 1
            L //= 2
            R //= 2
        return self.query_fn(left, right)



class Solution(object):
    def lengthOfLIS(self, nums, k):
        sorted_nums = sorted({x-1 for x in nums})
        num_to_idx = {x:i for i, x in enumerate(sorted_nums)}
        st = SegmentTree(len(num_to_idx))
        for x in nums:
            x -= 1
            st.update(num_to_idx[x], st.query(bisect.bisect_left(sorted_nums, x-k), num_to_idx[x]-1)+1)
        return st.tree[1]",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import gcd, ceil

def pre(s):
    n = len(s)
    pi = [0] * n
    for i in range(1, n):
        j = pi[i - 1]
        while j and s[i] != s[j]:
            j = pi[j - 1]
        if s[i] == s[j]:
            j += 1
        pi[i] = j
    return pi

def prod(a):
    ans = 1
    for each in a:
        ans = (ans * each)
    return ans

def lcm(a, b): return a * b // gcd(a, b)

def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

for _ in range(int(input()) if not True else 1):
    r, g, b = map(int, input().split())

    rr = list(map(int, input().split()))
    gg = list(map(int, input().split()))
    bb = list(map(int, input().split()))

    dp = [[[0]*(b+1) for __ in range(g+1)] for ___ in range(r+1)]
    def f(a):return sorted(a,reverse=True)
    rr,gg,bb=f(rr),f(gg),f(bb)
    ans=0
    r+=1
    g+=1
    b+=1
    for i in range(r):
        for j in range(g):
            for k in range(b):
                try:dp[i+1][j+1][k] = max(dp[i+1][j+1][k],dp[i][j][k] + rr[i]*gg[j])
                except:pass
                try:dp[i][j+1][k+1] = max(dp[i][j+1][k+1],dp[i][j][k] + gg[j]*bb[k])
                except:pass
                try:dp[i+1][j][k+1] = max(dp[i+1][j][k+1],dp[i][j][k] + rr[i]*bb[k])
                except:pass
                ans=max(ans,dp[i][j][k])
    print(ans)",O(n ^ 3)
"class Solution2(object):
    def permute(self, n, k):
        result = []
        fact = [1]*(((n-1)+1)//2+1)
        for i in range(len(fact)-1):
            fact[i+1] = fact[i]*(i+1)
        lookup = [False]*n
        for i in range(n):
            cnt = fact[(n-1-i)//2]*fact[((n-1-i)+1)//2]
            for j in range(n):
                if not (not lookup[j] and ((i == 0 and n%2 == 0) or (j+1)%2 == (1 if not result else (result[-1]%2)^1))):
                    continue
                if k <= cnt:
                    break
                k -= cnt
            else:
                return []
            lookup[j] = True
            result.append(j+1)
        return result",O(n ^ 2)
"from sys import stdin, stdout
from collections import defaultdict
import sys
input = stdin.readline
def gen(temp,i):
    global s,k,outs
    if i==k:
        j=''
        for o in range(k):
            if temp[o]==1:
                j+=s[o]
            else:
                j+='_'
        outs.add(j)
        return
    temp[i]=1
    gen(temp,i+1)
    temp[i]=-1
    gen(temp,i+1)

class Graph:
    def __init__(self, vertices):
        self.graph = defaultdict(list)
        self.V = vertices

    def addEdge(self, u, v):
        self.graph[u].append(v)

    def isCyclicUtil(self, v, visited, recStack):
        visited[v] = True
        recStack[v] = True
        for neighbour in self.graph[v]:
            if visited[neighbour] == False:
                if self.isCyclicUtil(neighbour, visited, recStack) == True:
                    return True
            elif recStack[neighbour] == True:
                return True
        recStack[v] = False
        return False

    def isCyclic(self):
        visited = [False] * self.V
        recStack = [False] * self.V
        for node in range(self.V):
            if visited[node] == False:
                if self.isCyclicUtil(node, visited, recStack) == True:
                    return True
        return False
    def topologicalSortUtil(self, v, visited, stack):
        visited[v] = True
        for i in self.graph[v]:
            if visited[i] == False:
                self.topologicalSortUtil(i, visited, stack)
        stack.append(v)

    def topologicalSort(self):
        visited = [False] * self.V
        stack = []
        for i in range(self.V):
            if visited[i] == False:
                self.topologicalSortUtil(i, visited, stack)
        stack=stack[::-1]
        print(""yes"")
        for i in stack:
            stdout.write(str(i+1)+"" "")

n,m,k=map(int,input().split())
patterns={}
all=[]
for i in range(n):
    s=input()[:-1]
    patterns[s]=i
    all.append(s)
strs=[]
dg=Graph(n)
for i in range(m):
    s,mt=input().split()
    mt=int(mt)-1
    outs=set()
    temp=[0 for o in range(k)]
    gen(temp,0)
    if all[mt] not in outs:
        print(""no"")
        sys.exit()
    for i in outs:
        if i!=all[mt] and i in patterns:
            dg.addEdge(mt,patterns[i])
if dg.isCyclic():
    print(""no"")
else:
    dg.topologicalSort()
",np
"class Solution(object):
    def answerString(self, word, numFriends):
        if numFriends == 1:
            return word
        idx = l = 0
        for i in range(1, len(word)):
            if word[i] == word[idx+l]:
                l += 1
            elif word[i] < word[idx+l]:
                l = 0
            elif word[i] > word[idx+l]:
                if word[i-l] >= word[i]:
                    idx = i-l
                else:
                    idx = i
                l = 0
        return word[idx:len(word)-max((numFriends-1)-idx, 0)]",O(n)
"class Solution(object):
    def brokenCalc(self, X, Y):
        result = 0
        while X < Y:
            if Y%2:
                Y += 1
            else:
                Y /= 2
            result += 1
        return result + X-Y",O(logn)
"n = int(input())
a = {}
ans = 0
sum = 0
i = 0
for t in map(int, input().split()):
    sum += t
    a[t] = a.get(t, 0) + 1

    ans += (i - a.get(t, 0) - a.get(t - 1, 0) - a.get(t + 1, 0) + 1) * t - (sum - a.get(t, 0) * t - a.get(t - 1, 0) * (t - 1) - a.get(t + 1, 0) * (t + 1))
    i += 1

print(ans)
",O(nlogn)
"class Solution:
    def longestPalindrome(self, s: str) -> str:
        def manacher(s):
            t = '
            n = len(t)
            p = [0] * n
            l, r = 0, 0
            for i in range(n):
                p[i] = min(r - i, p[l + (r - i)]) if i < r else 0
                while (i + p[i] + 1 < n and i - p[i] - 1 >= 0
                       and t[i + p[i] + 1] == t[i - p[i] - 1]):
                    p[i] += 1
                if i + p[i] > r:
                    l, r = i - p[i], i + p[i]
            return p

        p = manacher(s)
        resLen, center_idx = max((v, i) for i, v in enumerate(p))
        resIdx = (center_idx - resLen) // 2
        return s[resIdx : resIdx + resLen]
",O(n)
"n = int(input())
queen = list(map(int,input().split("" "")))
king = list(map(int,input().split("" "")))
target = list(map(int,input().split("" "")))

def done():
	print(""NO"")
	exit()

def complete():
	print(""YES"")
	exit()

if king[0] < queen[0]:
	if target[0] > queen[0]:
		done()

	if king[1] > queen[1]:
		if target[1] < queen[1]:
			done()
		complete()
	else:
		if target[1] > queen[1]:
			done()
		complete()
else:
	if target[0] < queen[0]:
		done()
	if king[1] > queen[1]:
		if target[1] < queen[1]:
			done()
		complete()
	else:
		if target[1] > queen[1]:
			done()
		complete()
",O(1)
"import pandas as pd



def Solution2(student_data: List[List[int]]) -> pd.DataFrame:
    return pd.DataFrame({k:[x[i] for x in student_data] for i, k in enumerate([""student_id"", ""age""])})",O(n)
"from collections import*
R=lambda:map(int,input().split())
n,m=R()
a=Counter(R()).values()
i=1
while sum(x//i for x in a)>=n:i+=1
print(i-1)
",O(nlogn)
"n = int(input())
l = list(map(int, input().split()))
to = l.index(max(l))
ok = 1
for i in range(1, to):
    if (l[i] <= l[i - 1]):
        ok = 0
        break
for i in range(to + 1, n):
    if (l[i] >= l[i - 1]):
        ok = 0
        break
if ok:
    print('YES')
else:
    print('NO')",O(n)
"class Solution2(object):
    def maximumLength(self, nums):
        cnt = collections.Counter(nums)
        result = 0
        for x in cnt.keys():
            if x == 1:
                result = max(result, cnt[x]-(1 if cnt[x]%2 == 0 else 0))
                continue
            l = 0
            while x in cnt and cnt[x] >= 2:
                l += 2
                x *= x
            l += 1 if x in cnt else -1
            result = max(result, l)
        return result",O(n)
"class Solution2(object):
    ugly = sorted(2**a * 3**b * 5**c
                  for a in range(32) for b in range(20) for c in range(14))

    def nthUglyNumber(self, n):
        return self.ugly[n-1]",O(n)
"from itertools import product
import itertools

import sys
import heapq
from collections import deque
MOD=1000000000007

def find(parent,i):

    if parent[i] != i:
        parent[i]=find(parent,parent[i])
    return parent[i]

def union(parent,rank,xx,yy):
    x=find(parent,xx)
    y=find(parent,yy)
    if rank[x]>rank[y]:
        parent[y]=x
    elif rank[y]>rank[x]:
        parent[x]=y
    else:
        parent[y]=x
        rank[x]+=1
ans=0

x=0
y=0

MAX=1000000000
N,M,K=list(map(int,sys.stdin.readline().strip().split()))
W=[[[MAX,MAX,MAX,MAX] for j in range(M)] for i in range(N)]
for i in range(N):
    l=list(map(int,sys.stdin.readline().strip().split()))
    for j in range(M-1):
        W[i][j][1]=l[j]
        W[i][j+1][0]=l[j]
for i in range(N-1):
    l=list(map(int,sys.stdin.readline().strip().split()))
    for j in range(M):

        W[i][j][3]=l[j]
        W[i+1][j][2]=l[j]

if K%2==1:
    for i in range(N):
        ans=[]
        for j in range(M):
            ans.append(""-1"")
        print("" "".join(ans))
else:

    K=K//2
    dp=[[[0 for j in range(M)] for i in range(N)] for k in range(K+1)]
    for kt in range(1,K+1):

        dl=((0,-1),(0,1),(-1,0),(1,0))
        for i in range(N):
            for j in range(M):
                ans=MAX
                for t in range(4):

                    ii,jj=dl[t]

                    if i+ii>=0 and i+ii<N and j+jj>=0 and j+jj<M:
                        ans=min(ans,dp[kt-1][i+ii][j+jj]+W[i][j][t]*2)

                dp[kt][i][j]=ans

    for i in range(N):
        ans=[]
        for j in range(M):
            ans.append(str(dp[-1][i][j]))
        print("" "".join(ans))
",O(n ^ 3)
"input()
l=[int(x)%2 for x in input().split()]
print(l.index(sum(l)==1)+1)",O(n)
"class Solution(object):
    def missingInteger(self, nums):
        total = nums[0]
        for i in range(1, len(nums)):
            if nums[i] != nums[i-1]+1:
                break
            total += nums[i]
        lookup = set(nums)
        while total in lookup:
            total += 1
        return total",O(n)
"n,k=[int(x)for x in input().split()]
ns=[int(x) for x in input().split()]
done=[None]*256
ans=[None]*n
for i in range(n):
    c=ns[i]
    if done[c]==None:
        j=c
        while True:
            if j<0 or c-j>=k or (done[j]!=None and done[j]!=-1):
                break
            j-=1
        j+=1
        for kk in range(k):
            if kk+j>=256 or (done[kk+j]!=None and done[kk+j]!=-1):
                break
            if kk+j<=c:
                done[kk+j]=j
            else:
                done[kk+j]=-1
    elif done[c]==-1:
        j=c
        while True:
            if done[j]!=None and done[j]!=-1:
                break
            j-=1
        a=done[j]
        for kk in range(j,c+1):
            done[kk]=a
    else:
        pass
    ans[i]=done[c]

ans=[str(x)for x in ans]
print(' '.join(ans))
",O(n ^ 2)
"class Solution:
    def countBits(self, n: int) -> List[int]:
        dp = [0] * (n + 1)
        for i in range(n + 1):
            dp[i] = dp[i >> 1] + (i & 1)
        return dp
",O(n)
"class Solution2(Node):
    ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}
    
    def __init__(self, val):
        self.val = val
        self.left = None 
        self.right = None

    def evaluate(self):
        if self.val.isdigit():
            return int(self.val)
        return Solution2.ops[self.val](self.left.evaluate(), self.right.evaluate())
        

class TreeBuilder2(object):
    def buildTree(self, postfix):
        stk = []
        for c in postfix:
            if c.isdigit():
                stk.append(Solution2(c))
            else:
                node = Solution2(c)
                node.right = stk.pop()
                node.left = stk.pop()
                stk.append(node)
        return stk.pop()",O(n)
"n = int(input())
s = input()

for sum in range(9 * n + 1):
    cnt = 0
    cursum = 0
    for i in s:
        cursum += int(i)
        if cursum == sum:
            cnt += 1
            cursum = 0

    if cursum == 0 and cnt > 1:
        print(""YES"")
        exit(0)

print(""NO"")",O(n ^ 2)
"import math
a=input()
b=input()
c=int(0)
d=int(0)
q=int(0)
for i in range(len(a)):
    if a[i]==""+"":
        c+=1
    elif a[i]==""-"":
        c-=1
for i in range(len(b)):
    if b[i]==""+"":
        d+=1
    elif b[i]==""-"":
        d-=1
    else:
        q+=1
if c == d:
    print((math.factorial(q)/(math.factorial(q/2)*math.factorial(q/2)))/(2**q))
else:
    mx=d+q
    mn=d-q
    if c>mx or c<mn:
        print(0.0)
    else:
        ans=c-d
        if ans > 0:
            print((math.factorial(q)/(math.factorial(((q-ans)/2)+ans)*math.factorial((q-ans)/2)))/(2**q))
        else:
            print((math.factorial(q)/(math.factorial((q-ans)/2)*math.factorial(((q-ans)/2)+ans)))/(2**q))",np
"if __name__ == '__main__':
    a = [int(c) for c in str(input())]
    b = [int(c) for c in str(input())]
    b_len = len(b)
    a_len = len(a)
    carCountPrefix = [[ 0 for c in range(2)] for _ in range(b_len+1)]
    b_zero_count = 0
    b_one_count = 0
    for b_i in range(b_len):
        if b[b_i] == 0:
            b_zero_count += 1
        elif b[b_i] == 1:
            b_one_count += 1
        carCountPrefix[b_i+1][1] = b_one_count
        carCountPrefix[b_i+1][0] = b_zero_count
    res = 0
    for cur in range(0, a_len):
        for dig in range(2):
            res += (carCountPrefix[b_len - a_len + cur + 1][dig] - carCountPrefix[cur][dig]) * abs(a[cur] -dig)
    print(res)
",O(n)
"class Solution2(object):
    def checkIfCanBreak(self, s1, s2):
        return not {1, -1}.issubset(set(cmp(a, b) for a, b in zip(sorted(s1), sorted(s2))))",O(n)
"import os
import sys
from io import BytesIO, IOBase
from collections import Counter,defaultdict
from heapq import heappush, heappop
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))

def main():
    def fn(s, e, qs, qe):
        if qs <= s <= e <= qe: return True
        return False

    for _ in range(1):
        n = nmbr()
        ans = [-1, -1]
        a = [lst() for i in range(n)]
        a = [[a[i][0], a[i][1], i] for i in range(n)]
        a.sort(key=lambda x: (x[0], x[1]))
        for i in range(n - 1):
            if fn(a[i][0], a[i][1], a[i + 1][0], a[i + 1][1]):
                ans = [a[i][2] + 1, a[i + 1][2] + 1]
                break
            elif fn(a[i + 1][0], a[i + 1][1], a[i][0], a[i][1]):
                ans = [a[i + 1][2] + 1, a[i][2] + 1]
                break
        print(*ans)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    for t in range(1):main()",O(nlogn)
"class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        cur = head
        group = 0
        while cur and group < k:
            cur = cur.next
            group += 1

        if group == k:
            cur = self.reverseKGroup(cur, k)
            while group > 0:
                tmp = head.next
                head.next = cur
                cur = head
                head = tmp
                group -= 1
            head = cur
        return head
",O(n)
"k=int(input())
i=0
r=1
while(k>=r):
    r+=9*(i+1)*10**i
    i+=1
r=r-(9*i*10**(i-1))
ans=str(((k-r)//i)+10**(i-1))[(k-r)%i]
print(ans)",O(logn)
"import sys

n=int(input())
A=list(map(int,input().split()))

if sum(A)<2*n-2:
    print(""NO"")
    sys.exit()

ONES=A.count(1)
print(""YES"",min(n-1,n-ONES+1))

NOONE=[]
for i in range(n):
    if A[i]!=1:
        NOONE.append([A[i],i+1])

ANS=[]
for i in range(1,len(NOONE)):
    ANS.append((NOONE[i-1][1],NOONE[i][1]))
    NOONE[i-1][0]-=1
    NOONE[i][0]-=1

NOONE=[[1,NOONE[-1][1]]]+NOONE[0:-1]+[[NOONE[-1][0]-1,NOONE[-1][1]]]

LENNO=len(NOONE)

j=0
for i in range(n):
    while j<LENNO and NOONE[j][0]==0:
        j+=1
    if A[i]!=1:
        continue
    ANS.append((i+1,NOONE[j][1]))
    NOONE[j][0]-=1

print(len(ANS))
for a,b in ANS:
    print(a,b)
",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def canMerge(self, trees):
        def find_leaves_and_roots(trees, leaf_vals_set, val_to_root):
            for root in trees:
                val_to_root[root.val] = root
                q = [root]
                while q:
                    new_q = []
                    for node in q:
                        if node.left is None and node.right is None:
                            if node is not root:
                                leaf_vals_set.add(node.val)
                            continue
                        if node.left:
                            new_q.append(node.left)
                        if node.right:
                            new_q.append(node.right)
                    q = new_q

        def find_root(trees, left_vals_set, val_to_root):
            root = None
            for node in trees:
                if node.val in leaf_vals_set:
                    continue
                if root: 
                    return None
                root = node
            return root

        def merge_bsts(root, left_vals_set, val_to_root):
            if not root:
                return None
            del val_to_root[root.val]
            q = [(root, float(""-inf""), float(""inf""))]
            while q:
                new_q = []
                for node, left, right in q:
                    if not (left < node.val < right):
                        return None
                    if node.left:
                        if node.left.val in leaf_vals_set and node.left.val in val_to_root:
                            node.left = val_to_root[node.left.val]
                            del val_to_root[node.left.val]
                        new_q.append((node.left, left, node.val))
                    if node.right:
                        if node.right.val in leaf_vals_set and node.right.val in val_to_root:
                            node.right = val_to_root[node.right.val]
                            del val_to_root[node.right.val]
                        new_q.append((node.right, node.val, right))
                q = new_q
            return root if not val_to_root else None

        leaf_vals_set, val_to_root = set(), {}
        find_leaves_and_roots(trees, leaf_vals_set, val_to_root)    
        root = find_root(trees, leaf_vals_set, val_to_root)
        return merge_bsts(root, leaf_vals_set, val_to_root)",O(n)
"n=input()
ans=0
r,c=0,0
for i in n:
    r+=int(i)
    c+=1
    if int(i)%3==0 or r%3==0 or c==3:
        ans+=1
        r,c=0,0
print(ans)",O(n)
"class Solution(object):
    def minDamage(self, power, damage, health):
        def ceil_divide(a, b):
            return (a+b-1)//b
        
        idxs = list(range(len(health)))
        idxs.sort(key=lambda i: float(ceil_divide(health[i], power))/damage[i])
        result = t = 0
        for i in idxs:
            t += ceil_divide(health[i], power)
            result += t*damage[i]
        return result",O(nlogn)
"n = int(input())
arr = list(map(int, input().split()))
ans = 0
sum = 0
mp = {}
for i in range(n):
    x = arr[i]
    ans += (x * i) - sum;
    ans -= (mp.get(x - 1, 0));
    ans += (mp.get(x + 1, 0));
    mp[x] = mp.get(x, 0) + 1;
    sum += x;
print(ans)",O(nlogn)
"n=int(input())
a=[int(i) for i in input().split()]
a.sort()
tot = 0
d={}
for i in range(len(a)):
    if a[i] not in d:
        tot+=1
        for j in range(i+1,len(a),1):
            if a[j]%a[i] == 0:
                d[a[j]]=1
print(tot)",O(n ^ 2)
"
import bisect



class Solution(object):
    def minOperations(self, nums):
        def longest_non_increasing_subsequence(arr):
            result = []
            for x in arr:
                right = bisect.bisect_right(result, -x)
                if right == len(result):
                    result.append(-x)
                else:
                    result[right] = -x
            return len(result)
        
        return longest_non_increasing_subsequence(nums)
",O(nlogn)
"i=input
i()
m=int(i())
v=m
try:
 for a in map(int, (i()+' '+i()).split()):v*=a/(a-1)
except:v=m-1
print(v-m)",O(n)
"import sys, math, queue, bisect

MOD = 10**9+7
sys.setrecursionlimit(1000000)

def ok(x):
    y = sum(map(int, list(str(x))))
    return x-y >= s

n, s = map(int, input().split())
l, h = 0, n
a = n
while l <= h:
    m = (l+h)>>1
    if ok(m):
        a = m-1
        h = m-1
    else:
        l = m+1
print(n-a)",O(logn)
"class Solution(object):
    def calculateTime(self, keyboard, word):
        lookup = {c:i for i, c in enumerate(keyboard)}
        result, prev = 0, 0
        for c in word:
            result += abs(lookup[c]-prev)
            prev = lookup[c]
        return result",O(n)
"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        A = []
        cur = []
        res = float('-inf')

        for num in nums:
            res = max(res, num)
            if num == 0:
                if cur:
                    A.append(cur)
                cur = []
            else:
                cur.append(num)

        if cur:
            A.append(cur)

        for sub in A:
            negs = sum(1 for i in sub if i < 0)
            prod = 1
            need = negs if negs % 2 == 0 else negs - 1
            negs = 0
            j = 0

            for i in range(len(sub)):
                prod *= sub[i]
                if sub[i] < 0:
                    negs += 1
                    while negs > need:
                        prod //= sub[j]
                        if sub[j] < 0:
                            negs -= 1
                        j += 1
                if j <= i:
                    res = max(res, prod)

        return res
",O(n)
"import collections


class Solution(object):
    def longestSubsequence(self, arr, difference):
        result = 1
        lookup = collections.defaultdict(int)
        for i in range(len(arr)):
            lookup[arr[i]] = lookup[arr[i]-difference] + 1
            result = max(result, lookup[arr[i]])
        return result",O(n)
"
import itertools



class Solution(object):
    def relocateMarbles(self, nums, moveFrom, moveTo):
        lookup = set(nums)
        for a, b in zip(moveFrom, moveTo):
            lookup.remove(a)
            lookup.add(b)
        return sorted(lookup)
",O(nlogn)
"n, s = list(map(int, input().split()))
num_1 = s // n
if s % n == 0:
    print(num_1)
else:
    print(num_1 + 1)",O(1)
"from math import *
n = int(input())
if n%2==0:
    print(n-8,n-(n-8))
else:
    print((n-9),n-(n-9))
",O(1)
"import math;
def getIntList():
    return list(map(int, input().split()));
def getTransIntList(n):
    first=getIntList();
    m=len(first);
    result=[[0]*n for _ in range(m)];
    for i in range(m):
        result[i][0]=first[i];
    for j in range(1, n):
        curr=getIntList();
        for i in range(m):
            result[i][j]=curr[i];
    return result;
n, a, b = getIntList();
if a>1 and b>1:
    print('NO');
elif a==b==1 and (n==2 or n==3):
    print('NO');
else:
    c=max(a, b);
    m=[[0]*n for _ in range(n)];
    for i in range(n-c):
        m[i][i+1]=1;
        m[i+1][i]=1;
    if b>1:
        for i in range(n):
            for j in range(n):
                if i!=j:
                    m[i][j]=1-m[i][j];
    print('YES');
    for i in range(n):
        print(''.join(map(str, m[i])));",O(n ^ 2)
"n=int(input())
a=[*map(int,input().split())]
s=[0]*n
m=n
while m:
 for i,x in enumerate(a):
  if s[i]==0:
   r=range(i%x,n,x)
   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1
   elif any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1
print(''.join(s))",O(n ^ 2)
"class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []


class Solution(object):
    def diameter(self, root):
        def iter_dfs(root):
            result = [0]*2
            stk = [(1, (root, result))]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    for child in reversed(node.children):
                        ret2 = [0]*2
                        stk.append((2, (ret2, ret)))
                        stk.append((1, (child, ret2)))
                else:
                    ret2, ret = params
                    ret[0] = max(ret[0], ret2[0], ret[1]+ret2[1]+1)
                    ret[1] = max(ret[1], ret2[1]+1)
            return result
        
        return iter_dfs(root)[0]",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def minimumLevel(self, root):
        q = [root]
        d = 1
        result = ((float(""inf""), float(""inf"")))
        while q:
            new_q = []
            total = 0
            for u in q:
                if u.left:
                    new_q.append(u.left)
                if u.right:
                    new_q.append(u.right)
                total += u.val
            result = min(result, (total, d))
            q = new_q
            d += 1
        return result[-1]",O(n)
"n=int(input())
l=[int(x) for x in input().split()]
ans=0;
while len(l)>0:
	a=l[0]
	l=l[1:]
	ans+=l.index(a)
	l.remove(a)
print(ans)",O(n ^ 2)
"n = int(input())
ax, ay = map(int, input().split())
bx, by = map(int, input().split())
cx, cy = map(int, input().split())

if bx < ax < cx:
    print(""NO"")
elif cx < ax < bx:
    print(""NO"")
elif by < ay < cy:
    print(""NO"")
elif cy < ay < by:
    print(""NO"")
else:
    print(""YES"")",O(1)
"class Solution(object):
    def findDuplicates(self, nums):
        result = []
        for i in nums:
            if nums[abs(i)-1] < 0:
                result.append(abs(i))
            else:
                nums[abs(i)-1] *= -1
        return result",O(n)
"
import itertools



class Solution(object):
    def maxUpgrades(self, count, upgrade, sell, money):
        return [min(c+(m-c*u)//(u+s), c) for c, u, s, m in zip(count, upgrade, sell, money)]
",O(n)
"class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        leftMax = [0] * n
        rightMax = [0] * n

        leftMax[0] = nums[0]
        rightMax[n - 1] = nums[n - 1]

        for i in range(1, n):
            if i % k == 0:
                leftMax[i] = nums[i]
            else:
                leftMax[i] = max(leftMax[i - 1], nums[i])

            if (n - 1 - i) % k == 0:
                rightMax[n - 1 - i] = nums[n - 1 - i]
            else:
                rightMax[n - 1 - i] = max(rightMax[n - i], nums[n - 1 - i])

        output = [0] * (n - k + 1)

        for i in range(n - k + 1):
            output[i] = max(leftMax[i + k - 1], rightMax[i])

        return output
",O(n)
"MOD = int(1e9+7)
n = int(input())
a = [input() for i in range(n)]
dp = [1]
for i in range(n):
    if a[i] == 'f':
        dp.append(0)
        continue
    for j in range(1, len(dp)):
        dp[j] = (dp[j] + dp[j-1]) % MOD
print(dp[-1])
",O(n ^ 2)
"import bisect
import collections
import copy
import functools
import heapq
import itertools
import math
import random
import re
import sys
import time
import string
from time import time_ns
from typing import List
sys.setrecursionlimit(99999)

def II():return int(sys.stdin.readline().strip())
def IIs():return list(map(int,sys.stdin.readline().strip().split()))
def SI():return sys.stdin.readline().strip()

n=II()
if n&1:
    print(9,n-9)
else:
    print(8,n-8)",O(1)
"def process(a):
    assert len(a) >= 2

    n    = len(a)
    min_ = float('inf')

    for i, [cnt, c] in enumerate(a):
        if i == 0 or i == n-1:
            min_ = min(min_, cnt)
        else:
            min_ = min(min_, (cnt+1) //2)

    b    = []
    for i, [cnt, c] in enumerate(a):
        if i == 0 or i == n-1:
            remain = cnt - min_
        else:
            remain = cnt - min_ * 2

        if remain <= 0:
            continue

        if len(b) == 0 or c != b[-1][1]:
            b.append([remain, c])
        else:
            pre_cnt, pre_c  = b.pop()
            b.append([pre_cnt+remain, c])

    return b, min_

S   = input() + ' '
cur = []

cnt = 0
pre = ''
for x in S:
    if cnt == 0:
        cnt+= 1
        pre = x
    elif x!=pre:
        cur.append([cnt, pre])
        cnt = 1
        pre = x
    else:
        cnt+=1

cnt = 0
while len(cur) not in [0, 1]:
    cur, min_ = process(cur)
    cnt+=min_

print(cnt)",O(n)
"n,k = map(int, input().split())

l = 0
r = n
while True:
    m = int((l+r)/2)
    S = int(((n-m)**2 + n - 3 * m)/2)
    if S == k:
        print(m)
        break
    elif S < k:
        r = m
    else:
        l = m",O(logn)
"r,g,b = map(int,input().split())

R = list(map(int,input().split()))
G = list(map(int,input().split()))
B = list(map(int,input().split()))

R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)

dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]

for j in range(g-1,-1,-1):
    for k in range(b-1,-1,-1):
        dp[r][j][k] = G[j]*B[k] + dp[r][j+1][k+1]

for i in range(r-1,-1,-1):
    for k in range(b-1,-1,-1):
        dp[i][g][k] = R[i]*B[k] + dp[i+1][g][k+1]

for i in range(r-1,-1,-1):
    for j in range(g-1,-1,-1):
        dp[i][j][b] = R[i]*G[j] + dp[i+1][j+1][b]

for i in range(r-1,-1,-1):
    for j in range(g-1,-1,-1):
        for k in range(b-1,-1,-1):
            case1 = dp[i+1][j][k]
            case2 = dp[i][j+1][k]
            case3 = dp[i][j][k+1]

            case4 = R[i]*G[j] + dp[i+1][j+1][k]
            case5 = R[i]*B[k] + dp[i+1][j][k+1]
            case6 = G[j]*B[k] + dp[i][j+1][k+1]

            dp[i][j][k] = max(case1,case2,case3,case4,case5,case6)

print(dp[0][0][0])
",O(n ^ 3)
"n=int(input())
ls=list(map(int,input().split()))
ls.sort()
if ls.count(min(ls))==len(ls):
	print('NO')
for i in range(n):
	if ls[i]!=min(ls):
		print(ls[i])
		break
",O(nlogn)
"class Solution(object):
    def longestValidParentheses(self, s):
        def length(it, start, c):
            depth, longest = 0, 0
            for i in it:
                if s[i] == c:
                    depth += 1
                else:
                    depth -= 1
                    if depth < 0:
                        start, depth = i, 0
                    elif depth == 0:
                        longest = max(longest, abs(i - start))
            return longest

        return max(length(range(len(s)), -1, '('), \
                   length(reversed(range(len(s))), len(s), ')'))",O(n)
"from math import factorial, pow

def wifi(s1, s2):
    count1, count2, count3 = 0, 0, 0
    for i in range(len(s1)):
        if s1[i] == '+':
            count1 += 1
        elif s1[i] == '-':
            count2 += 1
        if s2[i] == ""+"":
            count1 -= 1
        elif s2[i] == '-':
            count2 -= 1
        else:
            count3 += 1
    if count1 < 0 or count2 < 0:
        return '{:.9f}'.format(0)
    q = factorial(count1 + count2) / (factorial(count1) * factorial(count2))
    r = q / pow(2, count3)
    return r

t1 = input()
t2 = input()
print(wifi(t1, t2))
",np
"n,k=map(int,input().strip().split())
v = []
for i in range(2,n+1):
	if all(i%j!=0 for j in v):
		v.append(i)
c = 0
for i in range(len(v)-1):
	if 1+v[i]+v[i+1] in v:
		c += 1
if c >= k:
	print(""YES"")
else:
	print(""NO"")",O(n)
"a,b,c = input().split()
if a[1] == b[1] == c[1]:
    t = sorted([int(a[0]),int(b[0]),int(c[0])])
    if (t[1] == t[0] + 1 == t[2] - 1) or (t[0] == t[2]):print(0)
    elif t[0] == t[1] or t[1] == t[2]:print(1)
    elif t[0] + 1 == t[1] or t[1] + 1 == t[2] or t[0] + 2 == t[1] or t[1] + 2 == t[2]:print(1)
    else:print(2)
elif a[1] == b[1]:
    s,t = int(a[0]),int(b[0])
    if s == t:print(1)
    elif min(s,t) + 1 == max(s,t) or min(s,t) + 2 == max(s,t):print(1)
    else:print(2)
elif c[1] == b[1]:
    s,t = int(c[0]),int(b[0])
    if s == t:print(1)
    elif min(s,t) + 1 == max(s,t) or min(s,t) + 2 == max(s,t):print(1)
    else:print(2)
elif a[1] == c[1]:
    s,t = int(a[0]),int(c[0])
    if s == t:print(1)
    elif min(s,t) + 1 == max(s,t) or min(s,t) + 2 == max(s,t):print(1)
    else:print(2)
else:print(2)
",O(nlogn)
"n, values, wrong = int(input()), [int(i) for i in input().split()], 0
sorted_values = list(sorted(values))
for i in range(n):
    if values[i] != sorted_values[i]:
        wrong += 1
if wrong > 2:
    print(""NO"")
else:
    print(""YES"")",O(nlogn)
"n, k = map(int, input().split())
v = list(map(int, input().split()))

d = {}
ans = 0

for x in v:
  num_d, mod_k = len(str(x)), x % k
  d.setdefault(num_d, {}).setdefault(mod_k, []).append(x)

for x in v:
  num_d, mod_k = len(str(x)), x % k
  for add, mods in d.items():
    val_mod = (mod_k * 10 ** add) % k
    need_mod = (k - val_mod) % k
    ans += len(mods.get(need_mod, []))
    if need_mod == mod_k and add == num_d:
      ans -= 1

print(ans)
",O(nlogn)
"n = int(input())

if(n>=0):
    print(n)
    exit()
else:
    n=str(abs(n))
    n1=int(n[:len(n)-1])

    temp=n[len(n)-1]

    n2=n[:len(n)-2]

    n2=int(n2+temp)

if(n1<=n2):
    if(n1!=0):
        print('-'+str(n1))
    else:
        print(0)
else:
    if(n2!=0):
        print('-'+str(n2))
    else:
        print(0)",O(1)
"n=int(input())
s=[c=='1' for c in input()]
m=len(s)
z=[[0,0]]
for c in s:
 ind = z[-1][c]
 z[-1][c] = len(z)
 z.append(z[ind][:])
assert(len(z) == m+1)
z[m][0] = z[m][1] = m

dp = [0 for _ in range(m+1)]
dp[0] = 1
for i in range(n):
 ndp = [0 for _ in range(m+1)]
 for i in range(m+1):
  ndp[z[i][0]] += dp[i]
  ndp[z[i][1]] += dp[i]
 dp = ndp
res = dp[m]

for k in range(1, m):
 s0 = 0
 for c in s[-k:]:
  s0 = z[s0][c]
 dp = [0 for _ in range(m+1)]
 dp[s0] = 1
 for i in range(n - k):
  ndp = [0 for _ in range(m+1)]
  for i in range(m+1):
   ndp[z[i][0]] += dp[i]
   ndp[z[i][1]] += dp[i]
  dp = ndp
 for s1 in range(m):
  v = dp[s1]
  for c in s[-k:]:
   if s1 == m: v = 0
   s1 = z[s1][c]
  if s1 == m: res += v
print(res)",np
"import sys
input = sys.stdin.readline
from collections import deque
class Graph:
  def __init__(self, N, M=-1):
    self.V = N
    if M>=0: self.E = M
    self.edge = [[] for _ in range(self.V)]
    self.edge_rev = [[] for _ in range(self.V)]
    self.order = []
    self.to = [0]*self.V
    self.visited = [False]*self.V
    self.dp = [0]*self.V

  def add_edge(self, a, b, dist=-1, bi=False, rev=False):
    if dist>=0:
      self.edge[a].append((dist, b))
      if rev: self.edge_rev[b].append((dist, a))
      if bi: self.edge[b].append((dist, a))
    else:
      self.edge[a].append(b)
      self.to[b] += 1
      if rev: self.edge_rev[b].append(a)
      if bi: self.edge[b].append(a)

  def topo_sort(self):
    updated = [0]*self.V
    for start in range(self.V):
      if self.to[start] or updated[start]: continue
      stack = deque([start])
      while stack:
        v = stack.popleft()
        self.order.append(v+1)
        updated[v] = 1
        for u in self.edge[v]:
          self.to[u] -= 1
          if self.to[u]: continue
          stack.append(u)

N, M, K = map(int, input().split())

from collections import defaultdict
dic = defaultdict(lambda: -1)
for i in range(N):
  S = input()[:-1]
  dic[S] = i
G = Graph(N)
for _ in range(M):
  t, mt = input().split()
  mt = int(mt)-1
  lis = []
  for S in range(1<<K):
    s = ''
    for i in range(K):
      if (S>>i)%2:
        s += '_'
      else:
        s += t[i]
    if dic[s]>=0: lis.append(dic[s])
  if mt not in lis:
    print('NO')
    exit()
  for l in lis:
    if l!=mt:
      G.add_edge(mt, l, bi=False, rev=False)
G.topo_sort()
if len(G.order)==N:
  print('YES')
  print(*G.order)
else:
  print('NO')",np
"import bisect


class Solution(object):
    def minimumMountainRemovals(self, nums):
        left_lis_len = [0]*len(nums)
        lis = []
        for i in range(len(nums)-1):
            j = bisect.bisect_left(lis, nums[i])
            if j == len(lis):
                lis.append(nums[i])
            else:
                lis[j] = nums[i]
            left_lis_len[i] = j
        max_len = 0
        lis = []
        for i in reversed(range(1, len(nums))):
            j = bisect.bisect_left(lis, nums[i])
            if j == len(lis):
                lis.append(nums[i])
            else:
                lis[j] = nums[i]
            if i < len(nums)-1:
                max_len = max(max_len, left_lis_len[i]+j)
        return len(nums) - (1+max_len)",O(nlogn)
"
import itertools


class Solution(object):
    def destCity(self, paths):
        A, B = list(map(set, zip(*paths)))
        return (B-A).pop()
",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


import collections



class Solution(object):
    def flipEquiv(self, root1, root2):
        dq1, dq2 = collections.deque([root1]), collections.deque([root2])
        while dq1 and dq2:
            node1, node2 = dq1.pop(), dq2.pop()
            if not node1 and not node2:
                continue 
            if not node1 or not node2 or node1.val != node2.val:
                return False
            if (not node1.left and not node2.right) or \
               (node1.left and node2.right and node1.left.val == node2.right.val):
                dq1.extend([node1.right, node1.left])
            else:
                dq1.extend([node1.left, node1.right])
            dq2.extend([node2.left, node2.right])
        return not dq1 and not dq2",O(n)
"import sys
input = sys.stdin.readline
out = sys.stdout
t = int(input())
for i in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    if len(set(a)) == 1:
        out.write(str(a[0])+"" ""+str(a[0])+"" ""+str(a[0])+"" ""+str(a[0])+""\n"")
    else:
        a.sort()
        g1 = False
        d = {}
        mx = 10001
        for i in a:
            if i not in d.keys():
                d[i] = 1
            else:
                d[i] += 1
            if d[i] == 4:
                g1 = True
                if i < mx:
                    mx = i
        if g1:
            out.write(str(mx)+"" ""+str(mx)+"" ""+str(mx)+"" ""+str(mx)+""\n"")
        else:
            res = []
            for k in d.keys():
                if d[k] >= 2:
                    res.append(k)
            m = len(res)
            minj = 0
            for j in range(m - 1):
                if res[j]*res[j+1]*(res[minj]**2 + res[minj+1]**2) > res[minj]*res[minj+1]*(res[j]**2+res[j+1]**2):
                    minj = j
            out.write(str(res[minj])+"" ""+str(res[minj])+"" ""+str(res[minj+1])+"" ""+str(res[minj+1])+""\n"")",O(nlogn)
"import sys

class ADigitsSequenceEasyEdition:
    def solve(self):
        k = int(input()) + 1
        p = 1
        c = 0
        while c + p * (10 ** p - (10 ** (p - 1) if p > 1 else 0)) < k:
            c += p * (10 ** p - (10 ** (p - 1) if p > 1 else 0))
            p += 1
        k -= c
        bef = (10 ** (p - 1) if p > 1 else 0) + (k - 1) // p
        print(str(bef)[(k - 1) % p], end='')

solver = ADigitsSequenceEasyEdition()
input = sys.stdin.readline

solver.solve()
",O(logn)
"mod = int(1e9 + 7)

n = int(input())
a = [int(_) for _ in input().split()]

freq = {i: 0 for i in range(100001)}
power = {0: 1}
for i in range(1, 100001):
    power[i] = (2 * power[i - 1]) % mod

for v in a:
    freq[v] += 1

dp = {i: 0 for i in range(100001)}
for gcd in range(100000, 0, -1):
    mult = 2
    total = freq[gcd]
    complement = 0

    while mult * gcd <= 100000:
        total += freq[mult * gcd]
        complement += dp[mult * gcd]
        mult += 1
    dp[gcd] = (power[total] - 1 - complement + mod) % mod

print(dp[1])",np
"n, pos, a, b = map(int,input().split())

lf, rf = a - 1, n - b
if lf == rf == 0:
	print(""0"")
elif lf == 0:
	print(abs(pos-b)+1)
elif rf == 0:
	print(abs(pos-a)+1)
else:
	cl = abs(a-pos) + 1
	cr = abs(b-pos) + 1
	xn = abs(a-b) + 1
	if cl < cr:
		print(cl+xn)
	else:
		print(cr+xn)",O(1)
"def main():
    R, G, B = map( int, input().split())
    Rs = list( map( int, input().split()))
    Gs = list( map( int, input().split()))
    Bs = list( map( int, input().split()))

    Rs.sort(reverse=True)
    Gs.sort(reverse=True)
    Bs.sort(reverse=True)

    dp = [[[0]*(B+1) for _ in range(G+1)] for _ in range(R+1)]
    ans = 0
    for i in range(R+1):
        for j in range(G+1):
            for k in range(B+1):
                t = 0
                if i > 0 and j > 0:
                    if dp[i-1][j-1][k] + Rs[i-1]*Gs[j-1] > t:
                        t = dp[i-1][j-1][k] + Rs[i-1]*Gs[j-1]
                if j > 0 and k > 0:
                    if dp[i][j-1][k-1] + Gs[j-1]*Bs[k-1] > t:
                        t = dp[i][j-1][k-1] + Gs[j-1]*Bs[k-1]
                if k > 0 and i > 0:
                    if dp[i-1][j][k-1] + Bs[k-1]*Rs[i-1] > t:
                        t = dp[i-1][j][k-1] + Bs[k-1]*Rs[i-1]
                dp[i][j][k] = t
                if ans < t:
                    ans = t
    print(ans)

if __name__ == '__main__':
    main()
",O(n ^ 3)
"import sys
import math
from collections import defaultdict,deque

input = sys.stdin.readline
def inar():
    return [int(el) for el in input().split()]
def main():
    n,k=inar()
    st=input().strip()
    res=st
    pos=1
    cnt=1
    while cnt<k:
        suffix=0
        counter=0
        for i in range(pos,len(res)):
            if res[i]==st[suffix]:
                suffix+=1
            else:
                counter=1
                break
        if counter:
            pos+=1
            continue
        if pos>len(res):
            res+=st
            cnt+=1
            pos+=1
            continue
        res+=st[suffix:n]
        cnt+=1
        pos+=1
    print(res)

if __name__ == '__main__':
    main()
",O(n ^ 2)
"n, a, b = map(int, input().split())
if (n == 3 or n == 2) and (a == 1 and b == 1):
    print(""NO"")
    exit(0)
g = [[0 for i in range(n)] for j in range(n)]
if a > 1 and b == 1:
    for i in range(n - a - 1, -1, -1):
        g[i][i + 1] = g[i + 1][i] = 1
elif b > 1 and a == 1:
    a, b = b, a
    for i in range(n - a - 1, -1, -1):
        g[i][i + 1] = g[i + 1][i] = 1
    for i in range(n):
        for j in range(n):
            if g[i][j] == 0:
                g[i][j] = 1
            elif g[i][j] == 1:
                g[i][j] = 0
    for i in range(n):
        g[i][i] = 0
elif a == 1 and b == 1:
    for i in range(n - 1):
        g[i][i + 1] = g[i + 1][i] = 1
elif a > 1 and b > 1:
    print(""NO"")
    exit(0)
print(""YES"")
for i in range(n):
    for j in range(n):
        print(g[i][j], end='')
    print()",O(n ^ 2)
"class Solution(object):
    def minOperations(self, s):
        cnt = sum(int(c) == i%2 for i, c in enumerate(s))
        return min(cnt, len(s)-cnt)",O(n)
"import heapq



class Solution(object):
    def halveArray(self, nums):
        target = sum(nums)/2.0
        max_heap = [-x for x in nums]
        heapq.heapify(max_heap)
        result = 1
        while max_heap:
            x = -heapq.heappop(max_heap)/2.0
            target -= x
            if target <= 0.0:
                break
            heapq.heappush(max_heap, -x)
            result += 1
        return result",O(nlogn)
"class Solution2(object):
    def longestMonotonicSubarray(self, nums):
        result = cnt1 = cnt2 = 1
        for i in range(1, len(nums)):
            cnt1 = cnt1+1 if nums[i-1] < nums[i] else 1
            cnt2 = cnt2+1 if nums[i-1] > nums[i] else 1
            result = max(result, cnt1, cnt2)
        return result",O(n)
"class Solution:
    def maxArea(self, heights: List[int]) -> int:
        res = 0
        for i in range(len(heights)):
            for j in range(i + 1, len(heights)):
                res = max(res, min(heights[i], heights[j]) * (j - i))
        return res
",O(n ^ 2)
"l,r=map(int,input().split())
print(2**(l^r).bit_length()-1)",O(logn)
"import heapq
import sys
input = sys.stdin.readline

n, d, k = map(int, input().split())
if n == 1 or n <= d:
    ans = ""NO""
elif k == 1:
    ans = ""YES"" if n == 2 and d == 1 else ""NO""
    e = [(1, 2)]
else:
    e = [(i + 1, i + 2) for i in range(d)]
    h = []
    l, r = 1, d + 1
    if k > 2:
        for i in range(2, d + 1):
            heapq.heappush(h, (i, 2, min(i - l, r - i)))
    ans = ""YES""
    for i in range(d + 2, n + 1):
        if not h:
            ans = ""NO""
            break
        j, k0, d0 = heapq.heappop(h)
        e.append((j, i))
        if k0 + 1 < k:
            heapq.heappush(h, (j, k0 + 1, d0))
        if d0 - 1 > 0:
            heapq.heappush(h, (i, 1, d0 - 1))
print(ans)
if ans == ""YES"":
    for u, v in e:
        print(u, v)",O(n ^ 2)
"n = int(input())

string = input()
i = 0
j = 0
total = 0

while j < len(string):
    bool = False
    count = 0
    while j < len(string) and string[i] == 'x' and string[j] == 'x':
        count += 1
        bool = True
        j += 1

    if count >= 3:
        total += (count-3)+1
    if bool:
        i = j
    else:
        i += 1
        j += 1

print(total)
",O(n)
"n, m = map(int, input().split())
boys = list(map(int, input().split()))
girls = list(map(int, input().split()))
boys.sort(reverse=True)
girls.sort(reverse=True)
s = sum(boys)
ma = max(boys)

res = 0
for i in range(0, m):

    if girls[i] < ma:
        print(-1)
        exit(0)
    res += s
    if (girls[i] == ma):
        girls[i] = 0
j = 0
usage = 0
for i in range(0, m):
    if (usage == m - 1):
        j += 1
    if (j >= n):
        print(-1)
        exit(0)

    res += max(0, girls[i] - boys[j])
    usage += 1
print(res)",O(nlogn)
"class Solution2(object):
    def nextPermutation(self, nums):
        k, l = -1, 0
        for i in range(len(nums)-1):
            if nums[i] < nums[i+1]:
                k = i

        if k == -1:
            nums.reverse()
            return

        for i in range(k+1, len(nums)):
            if nums[i] > nums[k]:
                l = i
        nums[k], nums[l] = nums[l], nums[k]
        nums[k+1:] = nums[:k:-1]",O(n)
"n,k = map(int,input().split())
l = [int(x) for x in input().split()]
maps = []
for _ in range(256):
	maps.append(['empty',0])
output = []
for innum in l:
	if maps[innum][0] == 'chosen':
		outnum = maps[innum][1]
	elif maps[innum][0] == 'potential':
		outnum = maps[innum][1]
		i = innum
		while i >= 0 and maps[i][0] == 'potential':
			maps[i] = ['chosen',outnum]
			i -= 1
	else:
		i = innum
		while i >= 0 and i >= innum - (k-1) and maps[i][0] != 'chosen':
			i -= 1
		i += 1
		outnum = i
		for j in range(outnum,innum+1):
			maps[j] = ['chosen',outnum]
		if innum < 255:
			for j in range(innum+1,min(256,outnum+k)):
				if maps[j][0] != 'chosen':
					maps[j] = ['potential',outnum]
	output.append(str(outnum))
print(' '.join(output))
",O(n ^ 2)
"from collections import defaultdict
n = int(input())
arr = defaultdict(int)
for a0 in range(n):
	l,r = input().strip().split()
	l,r=int(l),int(r)
	arr[l]+=1
	arr[r+1]-=1

brr=[0]*(n+1)

l=sorted(arr.keys())
sum=arr[l[0]]
prevpoint=l[0]
for key in l[1:]:
	brr[sum]+=key-prevpoint
	prevpoint=key
	sum+=arr[key]
print(*brr[1:])",O(nlogn)
"class Solution(object):
    lookup = {'0':'0', '1':'1', '6':'9', '8':'8', '9':'6'}

    def isStrobogrammatic(self, num):
        n = len(num)
        for i in range((n+1) / 2):
            if num[n-1-i] not in self.lookup or \
               num[i] != self.lookup[num[n-1-i]]:
                return False
        return True",O(n)
"def f(l):
    n,m = l
    return ['5'*282,'4'*281+'5']

l = list(map(int,input().split()))
[print(r) for r in f(l)]
",O(1)
"k = 1000001
a = [True] * k
a[0] = a[1] = False

for i in range(k):
    if a[i]:
        j = 2 * i
        while j < k:
            a[j] = False
            j += i

n = int(input())
for i in range(4, n):
    if not a[i] and not a[n-i]:
        print(i, n-i)
        exit()",O(1)
"n, k = map(int, input().split())
r_n = n * 2
g_n = n * 5
b_n = n * 8
t = 0
t += r_n // k
if r_n % k != 0:
    t += 1
t += g_n // k
if g_n % k != 0:
    t += 1

t += b_n // k
if b_n % k != 0:
    t += 1
print(t)
",O(1)
"n = int(input())-1
x = 1
y = 9
while n > x * y:
    n -= x * y
    y *= 10
    x += 1
a = 10 ** (x - 1)
a += n // x
print(str(a)[n % x])",O(logn)
"import sys
import math
input = sys.stdin.readline
from functools import cmp_to_key;

def pi():
    return(int(input()))
def pl():
    return(int(input(), 16))
def ti():
    return(list(map(int,input().split())))
def ts():
    s = input()
    return(list(s[:len(s) - 1]))
def invr():
    return(map(int,input().split()))
mod = 998244353;
f = [];
def fact(n,m):
    global f;
    f = [1 for i in range(n+1)];
    f[0] = 1;
    for i in range(1,n+1):
        f[i] = (f[i-1]*i)%m;

def fast_mod_exp(a,b,m):
    res = 1;
    while b > 0:
        if b & 1:
            res = (res*a)%m;
        a = (a*a)%m;
        b = b >> 1;
    return res;

def inverseMod(n,m):
    return fast_mod_exp(n,m-2,m);

def ncr(n,r,m):
    if r == 0: return 1;
    return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m;

def main():
    B();

dp = [];
def D():
    [n,k] = ti();
    a = ti();
    a = sorted(a);
    cnt = [0 for i in range(n)];
    for i in range(n):
        c = 0;
        for j in range(i,n):
            if a[j]-a[i] <= 5: c+=1;
            else:break;
        cnt[i] = c;

    global dp;
    dp = [[0 for j in range(k+1)] for i in range(n+1)];
    ans = 0;
    for i in range(n):
        for j in range(k+1):
            dp[i+1][j] = max(dp[i+1][j], dp[i][j]);
            if j+1 <= k:
                dp[i+cnt[i]][j+1] = max(dp[i+cnt[i]][j+1], dp[i][j]+cnt[i]);
    print(dp[n][k]);

def B():
    n = pi();
    a = ti();
    q = pi();

    mat = [[0 for j in range(n)] for i in range(n)];
    dp = [[0 for i in range(n)] for j in range(n)];
    for i in range(n):
        for j in range(n):
            if i == j:
                mat[i][j] = a[i];
                dp[i][j] = a[i];
    i = 0;
    x = 1;
    while x < n:
        j = x;
        i = 0;
        while j < n:
            mat[i][j] = mat[i][j-1] ^ mat[i+1][j];
            j += 1;
            i += 1;
        x += 1;

    i = 0;
    x = 1;
    while x < n:
        j = x;
        i = 0;
        while j < n:
            dp[i][j] = max(mat[i][j], dp[i][j-1], dp[i+1][j]);
            j += 1;
            i += 1;
        x += 1;

    for i in range(q):
        [l,r] = ti();
        print(dp[l-1][r-1]);

main();",O(n ^ 2)
"import sys

p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def MI(): return map(int, sys.stdin.buffer.readline().split())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
def li(): return [int(i) for i in input().split()]
def lli(rows): return [li() for _ in range(rows)]
def si(): return input()
def ii(): return int(input())
def ins(): return input().split()

n,m=MI()
posf=(n*(n-1))//2
if(n%2!=0):
    negf=(n//2)*(n//2+1)
else:
    negf=(n//2)*(n//2-1)+n//2
ans=0
for i in range(m):
    x,d=MI()
    ans+=n*x
    if(d>=0):
        ans+=posf*d
    else:
        ans+=negf*d
print(ans/n)",O(n)
"import operator
from functools import reduce



class Solution(object):
    def xorAllNums(self, nums1, nums2):
        return (reduce(operator.xor, nums1) if len(nums2)%2 else 0) ^ \
               (reduce(operator.xor, nums2) if len(nums1)%2 else 0)",O(n)
"from collections import defaultdict
from sys import stdin
input=stdin.readline
t=int(input())
for _ in range(t):
  n=int(input())
  a=list(map(int,input().split()))
  dd=defaultdict(int)
  for i in range(n):
    dd[a[i]]+=1
  l=[]
  for aa in a:
    if dd[aa]>=2:
      l.append(aa)
      dd[aa]-=2
  l.sort()
  ans=[-1,-1,-1,-1]
  m=10**18
  for i in range(len(l)-1):
    x=(4*(l[i]+l[i+1])**2)/(l[i]*l[i+1])
    if x<m:
      ans=[l[i],l[i],l[i+1],l[i+1]]
      m=x
  print(*ans)",O(nlogn)
"n = [int(x) for x in input().split(' ')]
M = 1000000007

def a(k):
	M = 1000000007
	if(k>0):
		l = a(k//2)
		return (l*l*(k%2+1))%M
	else:
		return 1

if n[0]==0:
	print(0)
else:
	l = a(n[1])
	print((2*(n[0]%M)*l-l+1)%M)
",O(logn)
"string = input().strip()
mx = 0

for i in range(len(string)):
    for j in range(i+1, len(string)):
        m = 0
        while(j+m < len(string) and string[i+m] == string[j+m]):
            m += 1
        mx = max(mx, m)

print(mx)",O(n ^ 3)
"import collections



class Solution(object):
    def isPossibleToRearrange(self, s, t, k):
        cnt = collections.defaultdict(int)
        l = len(s)//k
        for i in range(0, len(s), l):
            cnt[s[i:i+l]] += 1
            cnt[t[i:i+l]] -= 1
        return all(v == 0 for v in cnt.values())",O(n)
"class Solution(object):
    def minTrioDegree(self, n, edges):
        adj = [set() for _ in range(n+1)]
        degree = [0]*(n+1)
        for u, v in edges:
            adj[min(u, v)].add(max(u, v))
            degree[u] += 1
            degree[v] += 1
        result = float(""inf"")
        for u in range(1, n+1):
            for v in adj[u]:
                for w in adj[u]:
                    if v < w and w in adj[v]:
                        result = min(result, degree[u]+degree[v]+degree[w] - 6)
        return result if result != float(""inf"") else -1",O(n ^ 3)
"class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        self.count -= 1
        return True


class Solution(object):
    def minimumCost(self, N, connections):
        connections.sort(key = lambda x: x[2])
        union_find = UnionFind(N)
        result = 0
        for u, v, val in connections:
            if union_find.union_set(u-1, v-1):
                result += val
        return result if union_find.count == 1 else -1",O(nlogn)
"N, M = map(int, input().split())
b = list(map(int, input().split()))
g = list(map(int, input().split()))

if max(b) > min(g):
    ans = -1
elif max(b) == min(g):
    ans = M*sum(b)
    maxi = max(b)
    for i in range(M):
        if maxi == g[i]:
            continue
        else:
            ans += g[i] - maxi
else:
    ans = M * sum(b)
    b.sort(reverse = True)
    for i in range(M):
        if i == 0:
            ans += g[i] - b[1]
        else:
            ans += g[i] - b[0]
print(ans)
",O(nlogn)
"class Solution(object):
    def maxProfit(self, prices):
        profit = 0
        for i in range(len(prices) - 1):
            profit += max(0, prices[i + 1] - prices[i])
        return profit

    def maxProfit2(self, prices):
        return sum([max(prices[x + 1] - prices[x], 0) for x in range(len(prices[:-1]))])",O(n)
"from collections import Counter

def main():
    n, m = map(int, input().split())
    l = list(map(int, input().split()))
    p = l.index(m)
    le, ri = Counter(), Counter()
    c = 0
    le[0] = ri[0] = 1
    for i in range(p + 1, n):
        if l[i] < m:
            c += 1
        else:
            c -= 1
        ri[c] += 1
    c = 0
    for i in range(p - 1, -1, -1):
        if l[i] < m:
            c -= 1
        else:
            c += 1
        le[c] += 1
    res = 0
    for c, x in le.items():
        res += x * (ri[c] + ri[c - 1])
    print(res)

if __name__ == '__main__':
    main()
",O(nlogn)
"rr = lambda: input().rstrip()
rri = lambda: int(rr())
rrm = lambda: list(map(int, rr().split()))

from functools import lru_cache;memo=lru_cache(None)
from sys import setrecursionlimit as srl;srl(10**5)

def solve(N, A):
    @memo
    def dp(i, j, left=0):
        if i == j:
            if left == 0:
                return 1
            if A[i] == left:
                return 1
            return 2
        if i > j:
            return 0 if left == 0 else 1

        ans = 1 + dp(i+1, j, A[i])
        if left >= 1:
            stack = []
            for k in range(i, j+1):
                stack.append(A[k])

                while len(stack) >= 2 and stack[-1] == stack[-2]:
                    stack.pop()
                    stack[-1] += 1
                if len(stack) == 1 and left == stack[-1]:
                    cand = dp(k+1, j, left+1)
                    if cand < ans:
                        ans = cand
        return ans

    return dp(1, N-1, A[0])

print(solve(rri(), rrm()))
",O(n ^ 3)
"first,last=input().split()
username=first[0]
first=first[1:]
while first!="""" and first[0]<last[0]:
    username=username+first[0]
    first=first[1:]
print(username+last[0])",O(n)
"import math

def c(k, n):
    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))

def main():
    sent = input()
    received = input()
    difference = abs((sent.count('+') - sent.count('-')) - (received.count('+') - received.count('-')))
    unrecognized = received.count('?')
    if difference > unrecognized:
        print(0)
        return

    k = (unrecognized - difference) // 2
    answer = c(k, unrecognized) * 0.5**unrecognized
    print(answer)

if __name__ == '__main__':
    main()
",np
"class Solution2(object):
    def reverseWords(self, s):
        reversed_words = [word[::-1] for word in s.split(' ')]
        return ' '.join(reversed_words)",O(n)
"import itertools



class Solution(object):
    def findMinimumOperations(self, s1, s2, s3):
        for i, (a, b, c) in enumerate(zip(s1, s2, s3)):
            if not a == b == c:
                break
        else:
            i += 1
        return len(s1)+len(s2)+len(s3)-3*i if i else -1",O(n)
"a, b = map(int, input().split())
arr = list(map(int, input().split()))
mn = float(""inf"")
for i in range(1, a+1):
    mn = min(mn, arr.count(i))

print(mn)
",O(n ^ 2)
"n = int(input())
a = list(map(int,input().split()))

dupes = 0
dupeVal = -1
d = set()
for el in a:
    if el in d:
        dupes += 1
        dupeVal = el
    else:
        d.add(el)

inPlay = True
if dupes > 1:
    print('cslnb')
    inPlay = False
elif dupes == 1:
    if dupeVal == 0 or (dupeVal - 1) in d:
        print('cslnb')
        inPlay = False

if inPlay:
    finalSum = (n*(n-1))//2
    Sum = sum(a)
    if (Sum - finalSum) % 2 == 0:
        print('cslnb')
    else:
        print('sjfnb')
",O(n)
"def x(a,b):
    if(a>b):
        return(1)
    else:
        return(0)
n=int(input())
a1,a2=map(int,input().split())
b1,b2=map(int,input().split())
c1,c2=map(int,input().split())
if((a1-a2)==(b1-b2)):
    print(""NO"")
elif((a1+a2)==(b1+b2)):
    print(""NO"")
elif(a1==b1):
    print(""NO"")
elif(a2==b2):
    print(""NO"")
elif((a1-a2)==(c1-c2)):
    print(""NO"")
elif((a1+a2)==(c1+c2)):
    print(""NO"")
elif(a1==c1):
    print(""NO"")
elif(a2==c2):
    print(""NO"")
else:
    if((x(a1,b1)==x(a1,c1)) and (x(a2,b2)==x(a2,c2))):
        print(""YES"")
    else:
        print(""NO"")",O(1)
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]

z, zz = fast, lambda: (map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())

def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer, end='\n'): stdout.write(str(answer) + end)

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]

n, m = zz()
arr = zzz()
s = sum(arr)
x = [[] for i in range(m)]
for i in range(n): x[arr[i] % m].append(i)
j = 0
for i in range(m):
    while len(x[i]) > n // m:
        while j < i or len(x[j % m]) >= n // m: j += 1
        k = x[i].pop()
        arr[k] += (j - i) % m
        x[j % m].append(k)
print(sum(arr) - s)
print(*arr)
",O(n)
"class Solution2(object):
    def arraysIntersection(self, arr1, arr2, arr3):
        intersect = reduce(set.intersection, list(map(set, [arr2, arr3])))
        return [x for x in arr1 if x in intersect]",O(n)
"class Solution(object):
    def reverseDegree(self, s):
        return sum(i*(26-(ord(x)-ord('a'))) for i, x in enumerate(s, 1))",O(n)
"n,t=list(map(int,input().split()))
a=sorted([list(map(int,input().split())) for i in range(n)])
b=[a[i][0]-a[i][1]/2-a[i-1][0]-a[i-1][1]/2 for i in range(1,n)]
c=2
for i in range(n-1):
    c+=int(b[i]>t)*2+int(b[i]==t)
print(c)",O(nlogn)
"w, h, n = map(int, input().split())
l, r = [-1] * (w+1), [-1] * (w+1)
t, b = [-1] * (h+1), [-1] * (h+1)
l[0], b[0], t[h], r[w] = 0, 0, h, w
V, H = [0] * n, [0] * n

for i in range(n):
    line, idx = input().split()
    idx = int(idx)
    if line == 'V':
        r[idx] = w
        V[i] = idx
    else:
        t[idx] = h
        H[i] = idx

left, max_w = 0, 0
for i in range(1, w+1):
    if r[i] != -1:
        l[i] = left
        r[left] = i
        max_w = max(max_w, i - left)
        left = i

bottom, max_h = 0, 0
for i in range(1 ,h+1):
    if t[i] != -1:
        b[i] = bottom
        t[bottom] = i
        max_h = max(max_h, i - bottom)
        bottom = i

res = [0] * n
res[n-1] = max_h * max_w
for i in range(n-1, 0, -1):
    if V[i] != 0:
        max_w = max(max_w, r[V[i]] - l[V[i]])
        r[l[V[i]]] = r[V[i]]
        l[r[V[i]]] = l[V[i]]
    else:
        max_h = max(max_h, t[H[i]] - b[H[i]])
        b[t[H[i]]] = b[H[i]]
        t[b[H[i]]] = t[H[i]]
    res[i-1] = max_h * max_w

for i in range(n):
    print(res[i])",O(nlogn)
"x, k = [int(x) for x in input().split()]

if x == 0:
    print(0)
    exit()

mod = 10 ** 9 + 7

res = x * pow(2, k + 1, mod) % mod
res = ((res - (pow(2, k, mod) - 1)) % mod + mod) % mod

print(res)
",O(logn)
"class Solution(object):
    def maxOutput(self, n, edges, price):
        def iter_dfs():
            result = 0
            stk = [(1, (0, -1, [price[0], 0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    stk.append((2, (u, p, ret, 0)))
                elif step == 2:
                    u, p, ret, i = args
                    if i == len(adj[u]):
                        continue
                    stk.append((2, (u, p, ret, i+1)))
                    v = adj[u][i]
                    if v == p:
                        continue
                    new_ret = [price[v], 0] 
                    stk.append((3, (u, new_ret, ret)))
                    stk.append((1, (v, u, new_ret)))
                elif step == 3:
                    u, new_ret, ret = args
                    result = max(result, ret[0]+new_ret[1], ret[1]+new_ret[0])
                    ret[0] = max(ret[0], new_ret[0]+price[u])
                    ret[1] = max(ret[1], new_ret[1]+price[u])
            return result
        
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()",O(n)
"import math
n,k=map(int,input().split())
for _ in range(k):
    l,r=map(int,input().split())
for i in range(1,n+1):
    if i%2==0:
        print('0',end='')
    else:
        print('1',end='')
print()
",O(n)
"class Solution(object):
    def findAnswer(self, parent, s):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P
    
        def iter_dfs(u):
            cnt = 0
            curr = []
            lookup = [None]*len(adj)
            stk = [(1, (0,))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u = args[0]
                    stk.append((2, (u, cnt)))
                    for v in reversed(adj[u]):
                        stk.append((1, (v,)))
                elif step == 2:
                    u, left = args
                    curr.append(s[u])
                    lookup[u] = (left, cnt)
                    cnt += 1
            return curr, lookup

        adj = [[] for _ in range(len(parent))]
        for v in range(1, len(parent)):
            adj[parent[v]].append(v)
        curr, lookup = iter_dfs(0)
        P = manacher(curr)
        return [P[(2*(left+1)+2*(right+1))//2] >= right-left+1 for left, right in lookup]",O(n)
"import sys

n = int(sys.stdin.readline().strip())
a = list(map(int, sys.stdin.readline().strip().split()))
i = a.index(max(a))
v = True
for j in range (0, i):
    if a[j] > a[j+1]:
        v = False
for j in range (i, n-1):
    if a[j] < a[j+1]:
        v = False
if v == True:
    print(""YES"")
else:
    print(""NO"")",O(n)
"import time
from copy import deepcopy
import itertools
from bisect import bisect_left
from bisect import bisect_right
import math
from collections import deque
from collections import Counter

def read():
    return int(input())

def readmap():
    return map(int, input().split())

def readlist():
    return list(map(int, input().split()))

n, m = readmap()
X = []
D = []
for _ in range(m):
    x, d = readmap()
    X.append(x)
    D.append(d)

summ = n * sum(X)

for i in range(m):
    d = D[i]
    if d < 0:
        if n % 2 == 1:
            summ += d * (n // 2) * (n // 2 + 1)
        else:
            summ += d * (n // 2) * (n // 2)
    else:
        summ += d * (n - 1) * n // 2

print(summ / n)",O(n)
"s1=input()
s2=input()
arr=list(s1)
arr.sort(reverse=True)
if(len(s2)>len(s1)):
  t=""""
  for i in arr:
    t+=i
  print(t)
else:
  t=""""
  l =len(s1)
  for i in range(l):
    index=-1
    ma = -1
    for j in range(len(arr)):
      temp = arr[j]
      tt=[]
      for k in range(len(arr)):
        if(k!=j):
          tt.append(arr[k])
      tt.sort()
      for k in tt:
        temp+=k
      temp = t+temp

      if(int(s2)>=int(temp)):

        if(int(arr[j])>ma):
          ma = int(arr[j])
          index = j
    t+=arr[index]
    del arr[index]

  print(t)
",O(n ^ 3)
"from sys import stdin,stdout
from collections import Counter
def ai(): return list(map(int, stdin.readline().split()))
def ei(): return map(int, stdin.readline().split())
def ip(): return  int(stdin.readline().strip())
def op(ans): return stdout.write(str(ans) + '\n')

n = ip()
s = input()
t = input()
value = {}
li = []
res1 = 0
res2 =res3 = -1
for i in range(n):
	if s[i] != t[i]:
		value[t[i]] = i
		res1 += 1
		li.append(i)
p = sq = False
for i in li:
	if s[i] in value:
		p = True
		res2 = i+1
		f = value[s[i]]
		res3 = f+1
		if s[f] == t[i]:
			sq = True
			break
print(res1-(2 if sq else 1 if p else 0))
print(res2,res3)",O(n)
"class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        if n == 0:
            return 0

        leftMax = [0] * n
        rightMax = [0] * n

        leftMax[0] = height[0]
        for i in range(1, n):
            leftMax[i] = max(leftMax[i - 1], height[i])

        rightMax[n - 1] = height[n - 1]
        for i in range(n - 2, -1, -1):
            rightMax[i] = max(rightMax[i + 1], height[i])

        res = 0
        for i in range(n):
            res += min(leftMax[i], rightMax[i]) - height[i]
        return res
",O(n)
"y = [2]
h = []
j = 0
for i in range(3,1000):
    z = 0
    for x in range(2, int(i**0.5)+1):
        if i%x == 0:
            z+=1
    if z == 0:
        y.append(i)
for i in range(0,len(y)-1):
    x = y[i]+y[i+1]
    h.append(x)

k = list(input().split())
a = int(k[0])
b = int(k[1])

for i in range(0,len(h)):
    h[i] = h[i] + 1

g = []

for i in h:
    z = 0
    for x in range(2, int(i**0.5)+1):
        if i%x == 0:
            z+=1

    if z == 0:
        g.append(i)

for i in g:
    if i>=2 and i<=a:
        j+=1
if j >= b:
    print(""YES"")
else:
    print(""NO"")
",O(n)
"class Solution(object):
    def isConsecutive(self, nums):
        return max(nums)-min(nums)+1 == len(nums) == len(set(nums))",O(n)
"class Solution(object):
    def maxIceCream(self, costs, coins):
        costs.sort()
        for i, c in enumerate(costs):
            coins -= c
            if coins < 0:
                return i
        return len(costs)",O(nlogn)
"def get_sign_1(fo):
	def res(s, f=fo):
		if f**2+s**2 == 2*f*s+1:
			return '1'
		else:
			return '0'
	return res

def get_signs_2(cf, rev):
	cf -= 1
	if rev:
		def res(fo, cff=cf):
			if fo >= cff:
				def res2(s, f=fo):
					if s == f:
						return '0'
					elif s >= cff:
						return '0'
					else:
						return '1'
			else:
				def res2(s, f=fo):
					if s == f:
						return '0'
					else:
						return '1'
			return res2
	else:
		def res(fo, cff=cf):
			if fo >= cff:
				def res2(s, f=fo):
					if s == f:
						return '0'
					elif s >= cff:
						return '1'
					else:
						return '0'
			else:
				def res2(s):
					return '0'
			return res2
	return res
n, a, b = map(int, input().split())
c = a*b
if a+b == c+1 and (c > 1 or n == 1 or n > 3):
	print(""YES"")
	if c == 1:
		get_sign_f = get_sign_1
	else:
		get_sign_f = get_signs_2(c, c == b)
	for foo in range(n):
		print(''.join(map(get_sign_f(foo), range(n))))
else:
	print(""NO"")
",O(n ^ 2)
"import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
def power(a,b,z):
    if b==0:
        return 1
    temp=power(a,b//2,z)
    if b%2==0:
        return (temp*temp)%z
    return (a*temp*temp)%z
x,k=list(map(int,input().split()))
if x==0:
    print(0)
else:
    z=(10**9)+7
    n=(power(2,k+1,z)*x)%z
    m=power(2,k,z)
    print((n-m+1)%z)",O(logn)
"n,m=map(int,input().split())
x=list(map(int,input().split()))
y=list(map(int,input().split()))
out=[]
first=11
for a in range(len(x)):
    for b in range(len(y)):

        if y[b]==x[a]:
            if first<a:
                first=a;
                out.append(y[b])

                b+=1

            else:
                out.insert(0,y[b])

                b+=1

        else:

            b+=1
out.reverse()
for a in out:
    print(a)",O(n ^ 2)
"n = int(input())
a = list(map(int, input().split()))
ans = 0
pos = 2*n - 2
for i in range(n):
	x = a[-1]
	a.pop(-1)
	y = a.index(x)
	ans += pos - y
	pos -= 2
	a.pop(y)
print(ans)
",O(n ^ 2)
"class Solution(object):
    def equalSubstring(self, s, t, maxCost):
        left = 0
        for right in range(len(s)):
            maxCost -= abs(ord(s[right])-ord(t[right]))
            if maxCost < 0:
                maxCost += abs(ord(s[left])-ord(t[left]))
                left += 1
        return (right+1)-left",O(n)
"class Solution(object):
    def minFallingPathSum(self, A):
        for i in range(1, len(A)):
            for j in range(len(A[i])):
                A[i][j] += min(A[i-1][max(j-1, 0):j+2])
        return min(A[-1])",O(n ^ 2)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def equalToDescendants(self, root):
        def iter_dfs(node):
            result = 0
            stk = [(1, [node, [0]])]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if not node:
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, [node, ret1, ret2, ret]))
                    stk.append((1, [node.right, ret2]))
                    stk.append((1, [node.left, ret1]))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    if node.val == ret1[0]+ret2[0]:
                        result += 1
                    ret[0] = ret1[0]+ret2[0]+node.val
            return result

        return iter_dfs(root)",O(n)
"input()
a=list(map(int,input().split()))
n=len(a)
u=n
for i in range(n):
	j=i
	k=0
	while a[j]>0:
		k+=1
		t=j
		j=a[j]-1
		a[t]=0
	if k>0:
		u+=1-k%2
s='Petr'
if u%2>0:
	s='Um_nik'
print(s)
",O(nlogn)
"a,b = list(input()),int(input())
ans = """"
a.sort(reverse=True)
while len(a)>0:
    for i in range(len(a)):
        num = ans+a[i]+"""".join(sorted(a[:i]+a[i+1:]))
        if int(num)<=b:
            ans += a[i]
            a = a[:i]+a[i+1:]
            break
print(ans)",O(n ^ 3)
"from math import *
from cmath import *
from itertools import *
from decimal import *
from fractions import *
from sys import *
from types import CodeType, new_class

k, n, s, p = map(int, input().split())
print((k*(n//s + (n%s != 0))) // p + ((k*(n//s + (n%s != 0))) % p != 0))",O(1)
"import math
from math import factorial

def combination(n,r):
    return float(factorial(n)) / float(factorial(r)) / float(factorial(n-r))

a = input()
ap = a.count('+')
am = a.count('-')
b = input()
bp = b.count('+')
bm = b.count('-')
n = b.count('?')
x = float(ap - bp)
y = float(am - bm)
if (x < 0 or y < 0 or x+y != n):
    print(0.0)
else:
    print(combination(n,x)/(1<<n))
",np
"class Solution(object):
    def minOperations(self, nums):
        result = 0
        for x in nums:
            if x^(result&1):
                continue
            result += 1
        return result",O(n)
"from sys import stdin, stdout
from math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial

n, s = map(int, stdin.readline().split())
stdout.write(str((s + n - 1) // n))",O(1)
"from sys import stdin,stdout
from itertools import accumulate
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int,stdin.readline().split()))
for _ in range(1):
    n,k=lst()
    a=lst()
    a.sort()
    s = set()
    for v in a:
        if (v % k != 0) or v // k not in s:
            s.add(v)
    print(len(s))",O(nlogn)
"n, m = map( int, input().split() )
b = list(map(int, input().split()))
g = list(map(int, input().split()))
b.sort()
g.sort()
if b[-1] > g[ 0 ]:
    print( -1 )
else:
    ans = sum(b)*m
    if g[ 0 ] != b[ -1 ]:
        ans += g[ 0 ] - b[ -2 ]
    for i in range( 1, m):
        ans += g[ i ] - b[ -1 ]
    print( ans )",O(nlogn)
"class Solution(object):
    def sumImbalanceNumbers(self, nums):
        right = [len(nums)]*len(nums)
        lookup = [len(nums)]*((len(nums)+1)+1)
        for i in reversed(range(len(nums))):
            right[i] = min(lookup[nums[i]], lookup[nums[i]+1]) 
            lookup[nums[i]] = i
        result = left = 0
        lookup = [-1]*((len(nums)+1)+1)
        for i in range(len(nums)):
            left = lookup[nums[i]+1]
            lookup[nums[i]] = i
            result += (i-left)*(right[i]-i)
        return result - (len(nums)+1)*len(nums)//2",O(n)
"def gen(n, b):
	a = [(x + b) % 3 for x in range(n)]
	s = """"
	for i in range(n):
		if a[i] == 0:
			s += ""R""
		if a[i] == 1:
			s += ""G""
		if a[i] == 2:
			s += ""B""
	return s

q = int(input())
for _ in range(q):
	n, k = map(int, input().split())
	s = input()
	ans = n
	for xi in range(3):
		t = gen(n, xi)
		diff = 0
		for i in range(k):
			if s[i] != t[i]:
				diff += 1
		ans = min(ans, diff)
		for j in range(k, n):
			if s[j - k] != t[j - k]:
				diff -= 1
			if s[j] != t[j]:
				diff += 1
			ans = min(ans, diff)
	print(ans)",O(n ^ 2)
"class Solution2(object):
    def findTheLongestBalancedSubstring(self, s):
        result = 0
        prev, cnt = [0]*2, [0]*2
        for c in s:
            cnt[int(c)] += 1
            if cnt[int(c)^1]:
                prev[int(c)^1], cnt[int(c)^1] = cnt[int(c)^1], 0
            result = max(result, 2*min(prev[0], cnt[1]))
        return result",O(n)
"import bisect
import collections
import copy
import functools
import heapq
import itertools
import math
import random
import re
import sys
import time
import string
from typing import List

n,k = map(int,input().split())
t = []
for _ in [0]*n:
    t.append(list(map(int,input().split())))
t.sort(key=lambda x:(-x[0],x[1]))

pt = t[k-1]

print(t.count(pt))
",O(nlogn)
"from sys import stdin, gettrace

if gettrace():
    def inputi():
        return input()
else:
    def input():
        return next(stdin)[:-1]

    def inputi():
        return stdin.buffer.readline()

def patterns(s):
    if len(s) == 1:
        return [s, '_']
    else:
        tp = patterns(s[1:])
        return [s[0] + t for t in tp] + ['_' + t for t in tp]

def main():
    n,m,k = map(int, input().split())
    pp = (input() for _ in range(n))
    ppm = {}
    for i, p in enumerate(pp):
        ppm[p] = i
    pre = [0]*n
    suc = [[] for _ in range(n)]
    for _ in range(m):
        s, ml = input().split()
        ml = int(ml) - 1
        ps = patterns(s)
        found = False
        for p in ps:
            if p in ppm:
                if ppm[p] == ml:
                    found = True
                else:
                    pre[ppm[p]] += 1
                    suc[ml].append(ppm[p])
        if not found:
            print(""NO"")
            return
    znodes = [i for i in range(n) if pre[i]==0]
    res = []
    while znodes:
        i = znodes.pop()
        res.append(i+1)
        for j in suc[i]:
            pre[j] -= 1
            if pre[j] == 0:
                znodes.append(j)
    if len(res) == n:
        print(""YES"")
        print(' '.join(map(str, res)))
    else:
        print(""NO"")

if __name__ == ""__main__"":
    main()
",np
"n, k = map(int, input().split())
t = input()
i = 1
while t[:-i] != t[i:]:
    i += 1
print(t[:i] * k + t[i:])",O(n ^ 2)
"import sys

def main():
    BITS = [1 << sh for sh in range(24)]
    B2N = {v: u for u, v in enumerate(BITS)}

    def getPt():
        return tuple(map(int, input().split()))

    def dist(ptA, ptB):
        return sum(((u - v) ** 2 for u, v in zip(ptA, ptB)))

    def getBits(val):
        return tuple(filter(lambda x: x & val, BITS))

    def chooseTwo(pool):
        n = len(pool)
        for i in range(n):
            for j in range(i + 1, n):
                yield (pool[i], pool[j])

    ori = getPt()
    pts = []
    N = int(input())

    for _ in range(N):
        pts.append(getPt())

    vis = set([0])
    mint = [0] + [1e8] * (1 << N)
    pres = [None] * (1 << N)
    allb = (1 << N) - 1
    B2P = {BITS[u]: v for u, v in enumerate(pts)}
    B2P[0] = ori
    alld = {u: {v: dist(B2P[u], B2P[v]) for v in B2P} for u in B2P}

    getDP = lambda x: mint[x]
    newDist = lambda stt, p: mint[stt] + alld[p[0]][p[1]] \
                             + alld[p[0]][0] \
                             + alld[p[1]][0]

    for stt in range(1 << N):
        if stt not in vis:
            continue

        bits = getBits(~stt & allb)

        sb = bits[0] if bits else None

        for bit in bits:

            newstt = stt | sb | bit
            nd = newDist(stt, (sb, bit))
            if getDP(newstt) > nd:
                mint[newstt] = nd
                pres[newstt] = sb | bit
                vis.add(newstt)

    print(mint[allb])
    path = ['0']
    stt = allb

    while stt:

        bits = getBits(pres[stt])
        for bit in bits:
            path.append(str(B2N[bit] + 1))
        path.append('0')

        stt ^= pres[stt]

    print(' '.join(path))

main()
",np
"ints=[int(x) for x in input().split()]
n=ints[0]
m=ints[1]
k=ints[2]
special=[int(x) for x in input().split()]
numOn=0
numOps=0
while numOn<m:
    numOps+=1
    op=((special[numOn]-numOn-1)//(k))*k+k+numOn+1
    while numOn<m and special[numOn]<op:
        numOn+=1
print(numOps)",O(n)
"a,b = map(int,input().split())
if a == b:
    print(0)
    exit()

e1 = bin(a)[2:]
e2 = bin(b)[2:]
diff = len(e2)-len(e1)
e1 = (""0""*diff)+e1
e1 = e1[::-1]
e2 = e2[::-1]
ans = [""0""]*len(e2)
for i in range(len(e2)):
    if b-a >= 2**i:
        ans[i] = ""1""

    else:
        if int(e1[i])^int(e2[i]) == 1:
            ans[i] = ""1""

print(int("""".join(ans[::-1]),2))",O(logn)
"n , s = map(int, input().split())
d = [0] * (n + 1)
cnt = 0
for i in range(0 , n - 1):
    a , b = map(int, input().split())
    d[a - 1] += 1
    d[b - 1] += 1
for i in range(0 , n):
    if(d[i] == 1):
        cnt += 1
print(2.0 * s / cnt)
",O(n)
"import sys
import heapq
input = sys.stdin.readline
n = int(input())
w = [int(z) for z in input().split()]; s = input()

idx = []
for i in range(n):
    idx.append((w[i], i+1))

idx.sort()
heapq.heapify(idx)
ones = []
heapq.heapify(ones)
res = []
for i in range(2*n):
    if s[i] == '0':
        l = idx[0]
        heapq.heappop(idx)
        res.append(l[1])
        heapq.heappush(ones, [-l[0], l[1]])
    else:
        l = ones[0]
        heapq.heappop(ones)
        res.append(l[1])
res = ' '.join([str(i) for i in res])
sys.stdout.write(res)",O(nlogn)
"

class Solution:
    def toArray(self, head):
        result = []
        while head:
            result.append(head.val)
            head = head.__next__
        return result
",O(n)
"n = int(input())
a = [int(_) & 1 for _ in input().split()]
v = [a[0]]
for i in range(1, n):
    if v and v[-1] == a[i]:
        v.pop()
    else:
        v.append(a[i])
print(""NO"" if len(v) > 1 else ""YES"")
",O(n)
"import math

n, r = map(int, input().split())
s = math.sin(math.pi / n)
print('%.7lf' % (r * s / (1 - s)))",O(1)
"k = int(input())
k -= 1

c = 9
s = 1
while k >= c * s:
    k -= c * s
    c *= 10
    s += 1

n = 10**(s - 1) + k // s
idx = k % s
print(str(n)[idx])",O(logn)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def deleteNodes(self, head, m, n):
        head = dummy = ListNode(next=head)
        while head:
            for _ in range(m):
                if not head.__next__:
                    return dummy.__next__
                head = head.__next__
            prev = head
            for _ in range(n):
                if not head.__next__:
                    prev.next = None
                    return dummy.__next__
                head = head.__next__
            prev.next = head.__next__
        return dummy.__next__",O(n)
"import itertools

n , l , r , x = map(int,input().split())

problems = list(map(int,input().split()))

ans = 0

for i in range(2 , n + 1 ):
    for j in itertools.combinations(problems ,i):
        if (l <= sum(j) <= r and max(j) - min(j) >= x):
            ans +=1

print(ans)
",np
"import sys
from random import *
from bisect import *
from heapq import *

pl=1
from math import gcd,sqrt,ceil
from copy import *
sys.setrecursionlimit(10**5)
if pl:
	input=sys.stdin.readline
else:
	sys.stdin=open('input.txt', 'r')
	sys.stdout=open('outpt.txt','w')

def li():
	return [int(xxx) for xxx in input().split()]
def fi():
	return int(input())
def si():
	return list(input().rstrip())
def mi():
	return 	map(int,input().split())

t=1

while t>0:
	t-=1
	s=input().rstrip()
	n=len(s)
	d={}
	for i in range(n):
		r=""""
		for j in range(i,n):
			r+=s[j]
			if r not in d:
				d[r]=1
			else:
				d[r]+=1
	maxi=0
	for i in d:
		if d[i]>=2:
			maxi=max(maxi,len(i))
	print(maxi)
",O(n ^ 3)
"class Solution(object):
    def appealSum(self, s):
        result = curr = 0
        lookup = [-1]*26
        for i, c in enumerate(s):
            result += (i-lookup[ord(c)-ord('a')])*(len(s)-i)
            lookup[ord(c)-ord('a')] = i
        return result",O(n)
"import atexit
import io
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER

@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())

def main():
    n = int(input())
    s = []
    for i in range(4):
        df = 0
        for k in range(n):
            l = input()
            for j in range(n):
                if int(l[j]) == (k + j) % 2:
                    df += 1
        if i <3 :
            input()
        s.append(df)

    print( min(s[0] + s[1] + n*n-s[2] + n*n-s[3],
        s[0] + s[2] + n*n-s[1] + n*n-s[3],
        s[0] + s[3] + n*n-s[1] + n*n-s[2],
        s[1] + s[2] + n*n-s[0] + n*n-s[3],
        s[1] + s[3] + n*n-s[0] + n*n-s[2],
        s[2] + s[3] + n*n-s[0] + n*n-s[1]))

if __name__ == '__main__':
    main()
",O(n ^ 2)
"class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        n, node = len(points), 0
        dist = [100000000] * n
        visit = [False] * n
        edges, res = 0, 0

        while edges < n - 1:
            visit[node] = True
            nextNode = -1
            for i in range(n):
                if visit[i]:
                    continue
                curDist = (abs(points[i][0] - points[node][0]) +
                           abs(points[i][1] - points[node][1]))
                dist[i] = min(dist[i], curDist)
                if nextNode == -1 or dist[i] < dist[nextNode]:
                    nextNode = i

            res += dist[nextNode]
            node = nextNode
            edges += 1

        return res
",O(n ^ 2)
"class Solution:
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        pair = [(p, s) for p, s in zip(position, speed)]
        pair.sort(reverse=True)

        fleets = 1
        prevTime = (target - pair[0][0]) / pair[0][1]
        for i in range(1, len(pair)):
            currCar = pair[i]
            currTime = (target - currCar[0]) / currCar[1]
            if currTime > prevTime:
                fleets += 1
                prevTime = currTime
        return fleets
",O(nlogn)
"class Solution(object):
    def evenOddBit(self, n):
        def popcount(x):
            return bin(x)[2:].count('1')

        return [popcount(n&0b0101010101), popcount(n&0b1010101010)]",O(1)
"rd = lambda: list(map(int, input().split()))
n, k = rd()
a = rd()
r = 0
s = [0]
for x in a:
    s.append(s[-1] + x)
for i in range(n - k + 1):
    for j in range(i + k, min(n + 1, i + 2 * k)):
        r = max(r, (s[j] - s[i]) / (j - i))
print(r)
",O(n ^ 2)
"class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        for i in range(len(nums)):
            flag = True
            for j in range(len(nums)):
                if i != j and nums[i] == nums[j]:
                    flag = False
                    break
            if flag:
                return nums[i]
",O(n ^ 2)
"class Solution(object):
    def maximumNumberOfOnes(self, width, height, sideLength, maxOnes):
        if width < height:
            width, height = height, width


        R, r = divmod(height, sideLength)
        C, c = divmod(width, sideLength)
        assert(R <= C)
        area_counts = [(r*c, (R+1)*(C+1)), \
                       (r*(sideLength-c), (R+1)*C), \
                       ((sideLength-r)*c, R*(C+1)), \
                       ((sideLength-r)*(sideLength-c), R*C)]
        result = 0
        for area, count in area_counts:
            area = min(maxOnes, area)
            result += count*area
            maxOnes -= area
            if not maxOnes:
                break
        return result",O(1)
"from collections import Counter

n,k=list(map(int,input().split()))
x=list(map(int,input().split()))

dd=Counter()
for i in range(k):

    dd[x[i]]=dd[x[i]]+1

final=0
for i in range(1,k+1):
    ans=0
    d=dd.copy()
    for j in range(n):
        for jj in d:
            if d[jj]>=i:
                d[jj]-=i
                ans=ans+1
                break
    if ans>=n:
        final=i
    else:
        break
print(final)",O(nlogn)
"import math
def binom(n, m):
    return math.factorial(n)//(math.factorial(m)*math.factorial(n-m))

correct = input()
received = input()
plus_correct = correct.count('+')
min_correct = correct.count('-')
pos_correct = plus_correct - min_correct
plus_received = received.count('+')
min_received = received.count('-')
unknown = received.count('?')
pos_received = plus_received - min_received
diff = abs(pos_correct - pos_received)
if (diff + unknown) % 2 != 0 or diff > unknown:
    prob = 0.0
else:
    m = (diff + unknown) // 2
    prob =  1.0 * binom(unknown, m) / (2 ** unknown)
print(prob)",np
"import functools
import time
from collections import Counter

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:

    def __init__(self):
        pass

    def __call__(self):
        n, m = map(int, input().strip().split())
        a = list(map(int, input().strip().split()))
        h = Counter()
        for ai in a:
            h[ai] = h[ai] + 1 if ai in h else 1
        days = 0
        while True:
            tot = 0
            for key, cnt in h.items():
                tot += cnt // (days + 1)
            if tot < n:
                print(days)
                return
            days += 1

solver()()",O(nlogn)
"n, k = map(int, input().split())

a, b, c = 0, k, 0

while a < b:
    c = (a + b) // 2
    if c * n < k:
        a = c + 1
    else:
        b = c

print(a)
",O(logn)
"n, k = map(int, input().split())
teams, freqs = [tuple(int(i) for i in input().split()) for _ in range(n)], {}
teams.sort(key = lambda x: (-x[0], x[1]))
for team in teams:
    freqs[team] = freqs.get(team, 0) + 1
print(freqs[teams[k - 1]])
",O(nlogn)
"class Solution(object):
    def minPairSum(self, nums):
        nums.sort()
        return max(nums[i]+nums[-1-i] for i in range(len(nums)//2))",O(nlogn)
"import heapq


class Solution(object):
    def maxTwoEvents(self, events):
        events.sort()
        result = best = 0
        min_heap = []
        for left, right, v in events:
            heapq.heappush(min_heap, (right, v))
            while min_heap and min_heap[0][0] < left:
                best = max(best, heapq.heappop(min_heap)[1])
            result = max(result, best+v)
        return result",O(nlogn)
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))
r.sort()
g.sort()
b.sort()
dp = [[[0]*202 for i in range(202)] for j in range(202)]
for i in range(R+1):
       for j in range(G+1):
              for k in range(B+1):
                     if i and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])
                     if i and k:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])
                     if k and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])
ans = 0
for i in dp:
       for j in i:
              ans = max(ans, max(j))

print(ans)
",O(n ^ 3)
"import math
import sys
from decimal import Decimal

def main(l,r):

  if l==r:
    return 0

  val=1

  while val*2<=r:
    val*=2

  if val<=l:
    return main(l-val,r-val)
  else:
    return 2*val-1

l,r=list(map(int,input().split()))
print(main(l,r))
",O(logn)
"import sys
import threading

def dfs(g, i, p):
    global ans
    count = 0
    for j in g[i]:
        if j == p:
            continue
        count += dfs(g, j, i)
    if count == 0:
        count = 1
    ans.append(count)
    return count

def solve():

    n = int(input())
    l = list(map(int, input().split()))
    g = [[] for i in range(n+1)]

    for i in range(1, n):
        g[i+1].append(l[i-1])
        g[l[i-1]].append(i+1)

    dfs(g, 1, 0)
    ans.sort()
    st = ' '.join(map(str, ans))
    print(st)

ans = []
max_recur_size = 10**5*2 + 1000
max_stack_size = max_recur_size*500

sys.setrecursionlimit(max_recur_size)
threading.stack_size(max_stack_size)
thread = threading.Thread(target=solve)
thread.start()",O(n ^ 2)
"import sys
import math
import collections
import heapq
import decimal
input=sys.stdin.readline
n,m,k = map(int,input().split())
a=[]
for i in range(n):
    a.append(list(map(int,input().split())))
b=[]
for i in range(n-1):
    b.append(list(map(int,input().split())))
if(k%2==1):
    for i in range(n):
        for j in range(m):
            print(-1,end = "" "")
        print()
else:
    k//=2
    pre=[[0 for i in range(m)]for j in range(n)]
    for x in range(k):
        curr = [[float(""inf"") for i in range(m)]for j in range(n)]
        for i in range(n):
            for j in range(m):
                if(j>0):
                    curr[i][j]=min(curr[i][j],pre[i][j-1]+a[i][j-1])
                if(i<n-1):
                    curr[i][j]=min(curr[i][j],pre[i+1][j]+b[i][j])
                if(j<m-1):
                    curr[i][j]=min(curr[i][j],pre[i][j+1]+a[i][j])
                if(i>0):
                    curr[i][j]=min(curr[i][j],pre[i-1][j]+b[i-1][j])
        pre=curr[:]
    for i in range(n):
        for j in range(m):
            print(2*pre[i][j],end = "" "")
        print()",O(n ^ 3)
"n,s = [int(x) for x in input().split()]
v=[ [] ]
for i in range(n):
	v.append([])

for i in range(n-1):
	a, b =[int(x) for x in input().split()]
	v[a].append(b)
	v[b].append(a)

ans =0
for i in range(1,n+1):
	if len(v[i])==1:
		ans+=1

print(2*s/ans)
",O(n)
"class Solution(object):
    def maximumTotalCost(self, nums):
        dp = [nums[0], float(""-inf"")]
        for i in range(1, len(nums)):
            dp[:] = [max(dp)+nums[i], dp[0]-nums[i]]
        return max(dp)",O(n)
"class Solution(object):
    def isBalanced(self, num):
        return sum(ord(num[i])-ord('0') for i in range(0, len(num), 2)) == sum(ord(num[i])-ord('0') for i in range(1, len(num), 2))",O(n)
"class Solution2(object):
    def arrayPairSum(self, nums):
        nums.sort()
        result = 0
        for i in range(0, len(nums), 2):
            result += nums[i]
        return result",O(nlogn)
"class Solution(object):
    def outerTrees(self, points):
        points = sorted(set(tuple(x) for x in points))

        if len(points) <= 1:
            return points

        def cross(o, a, b):
            return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

        lower = []
        for p in points:
            while len(lower) >= 2 and cross(lower[-2], lower[-1], p) < 0: 
                lower.pop()
            lower.append(p)

        upper = []
        for p in reversed(points):
            while len(upper) >= 2 and cross(upper[-2], upper[-1], p) < 0: 
                upper.pop()
            upper.append(p)

        result = lower[:-1] + upper[:-1]
        return result if result[1] != result[-1] else result[:len(result)//2+1]",O(nlogn)
"import collections

class Solution(object):
    def findRepeatedDnaSequences(self, s):
        dict, rolling_hash, res = {}, 0, []

        for i in range(len(s)):
            rolling_hash = ((rolling_hash << 3) & 0x3fffffff) | (ord(s[i]) & 7)
            if rolling_hash not in dict:
                dict[rolling_hash] = True
            elif dict[rolling_hash]:
                res.append(s[i - 9: i + 1])
                dict[rolling_hash] = False
        return res

    def findRepeatedDnaSequences2(self, s):
        l, r = [], []
        if len(s) < 10: return []
        for i in range(len(s) - 9):
            l.extend([s[i:i + 10]])
        return [k for k, v in list(collections.Counter(l).items()) if v > 1]",O(n)
"n = int(input())
print(n//2+n)",O(1)
"import sys

T = int(sys.stdin.readline().strip())
for t in range (0, T):
    n = int(sys.stdin.readline().strip())
    a = list(map(int, sys.stdin.readline().strip().split()))
    a.sort()
    print(min([len(a)-2, a[-2]-1]))",O(nlogn)
"class Solution(object):
    def stoneGameVIII(self, stones):
        for i in range(len(stones)-1):
            stones[i+1] += stones[i]
        return reduce(lambda curr, i: max(curr, stones[i]-curr), reversed(range(1, len(stones)-1)), stones[-1])",O(n)
"class Solution(object):
    def isIdealPermutation(self, A):
        return all(abs(v-i) <= 1 for i,v in enumerate(A))",O(n)
"def main():
    N, M, K = map(int, input().split())
    HEdge = [list(map(int, input().split())) for _ in range(N)]
    VEdge = [list(map(int, input().split())) for _ in range(N - 1)]
    if K % 2:
        for i in range(N):
            print(*[-1] * M)
        return
    dp = [[[0] * M for _ in range(N)] for _ in range(K // 2 + 1)]
    for i in range(1, K // 2 + 1):
        for j in range(N):
            for k in range(M):
                Val1 = Val2 = Val3 = Val4 = 10 ** 9
                if j > 0:
                    Val1 = dp[i - 1][j - 1][k] + VEdge[j - 1][k]
                if j < N - 1:
                    Val2 = dp[i - 1][j + 1][k] + VEdge[j][k]
                if k > 0:
                    Val3 = dp[i - 1][j][k - 1] + HEdge[j][k - 1]
                if k < M - 1:
                    Val4 = dp[i - 1][j][k + 1] + HEdge[j][k]
                dp[i][j][k] = min(Val1, Val2, Val3, Val4)
    for i in dp[K // 2]:
        print(*list(map(lambda x: x * 2, i)))

if __name__ == '__main__':
    main()",O(n ^ 3)
"import math
from collections import defaultdict
import os
import sys
from io import BytesIO, IOBase
from types import GeneratorType
from collections import defaultdict
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def process(s):
    b=[]
    for j in s:
        b.append(j)
    return b

for _ in range(1):

    n,m,k=map(int,input().split())
    d1=[[float(""inf"") for i in range(m+1)] for j in range(n+1)]
    d2 = [[float(""inf"") for i in range(m+1)] for j in range(n+1)]

    for i in range(n):
        l=list(map(int,input().split()))
        for j in range(m-1):
            d1[i][j]=l[j]

    for i in range(n-1):
        l=list(map(int,input().split()))
        for j in range(m):
            d2[i][j]=l[j]

    if k%2!=0:
        ans=[[-1 for j in range(m)] for i in range(n)]

    else:
        ans = [[float('inf') for j in range(m+1)] for i in range(n+1)]
        for i in range(n):
            for j in range(m):
                ans[i][j]=min(2*d1[i][j],2*d1[i][j-1],2*d2[i-1][j],2*d2[i][j])

        curr=2

        while(curr!=k):
            new = [[float('inf') for j in range(m+1)] for i in range(n+1)]
            for i in range(n):
                for j in range(m):

                    new[i][j] = min(ans[i][j-1]+2 * d1[i][j-1], ans[i][j+1]+2 * d1[i][j], ans[i-1][j]+2*d2[i-1][j], ans[i+1][j]+2 *d2[i][j])

            for i in range(n):
                for j in range(m):
                    ans[i][j] = new[i][j]

            curr+=2

    for i in range(n):
        print(*ans[i][:m])
",O(n ^ 3)
"class Solution(object):
    def minTimeToVisitAllPoints(self, points):
        return sum(max(abs(points[i+1][0] - points[i][0]),
                       abs(points[i+1][1] - points[i][1]))
                   for i in range(len(points)-1))",O(n)
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums)

        while l < r:
            m = l + ((r - l) // 2)
            if nums[m] >= target:
                r = m
            elif nums[m] < target:
                l = m + 1
        return l if (l < len(nums) and nums[l] == target) else -1
",O(logn)
"class Solution2(object):
    def diameter(self, root):
        def dfs(node):
            max_dia, max_depth = 0, 0
            for child in node.children:
                child_max_dia, child_max_depth = dfs(child)
                max_dia = max(max_dia, child_max_dia, max_depth+child_max_depth+1)
                max_depth = max(max_depth, child_max_depth+1)
            return max_dia, max_depth
        
        return dfs(root)[0]",O(n)
"money=input()
initi=money

if int(money)<0:
    lst_dig=money[-1]
    lsec_dig=money[-2]
    if int(lst_dig)>int(lsec_dig):money=money[:-2]+money[-2]
    else:money=money[:-2]+money[-1]
    print(int(money))
else:
    lst_dig=money[-1]
    lsec_dig=money[-2]
    if int(lst_dig)>int(lsec_dig):money=money[:-2]+money[-1]
    else:money=money[:-2]+money[-2]
    if int(initi)>=int(money):
        print(initi)
    else:
        print(money)
",O(1)
"n=int(input())
fa=[0,0]+list(map(int,input().split()))
delta=[0]*(n+1)
suml=[0]*(n+1)
for i in range(n,0,-1):
	if suml[i]==0:
		suml[i]=1
	delta[suml[i]]+=1
	suml[fa[i]]+=suml[i]

for i in range(1,n+1):
	delta[i]+=delta[i-1]
ans=0
for i in range(1,n+1):
	while delta[ans]<i:
		ans+=1
	print(""%d ""%ans,end="""")
print(""\n"")",O(n)
"R = lambda : map(int, input().split())
n = int(input())
s = input()
hc, tc = s.count('H'), s.count('T')
hr = min([s[i:i + hc].count('T') for i in range(n - hc)])
tr = min([s[i:i + tc].count('H') for i in range(n - tc)])
print(min(hr, tr))",O(n)
"n,m,k,l=map(int,input().split())
c=(k+l)//m
if (k+l)%m!=0:
    c+=1
if n>=m*c:
    print(c)
else :
    print(-1)",O(1)
"def power(x, y, p) :
    res = 1

    x = x % p

    while (y > 0) :

        if ((y & 1) == 1) :
            res = (res * x) % p

        y = y >> 1
        x = (x * x) % p

    return res

d,n=map(int,input().split())
ans =power(2,n+1,1000000007);
ans1=power(2,n,1000000007);
if(d==0):
    print(0)
else:
    print(((ans*(d%1000000007))%1000000007 - ans1 +1)%1000000007)",O(logn)
"class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        if sum(gas) < sum(cost):
            return -1

        total = 0
        res = 0
        for i in range(len(gas)):
            total += (gas[i] - cost[i])

            if total < 0:
                total = 0
                res = i + 1

        return res
",O(n)
"class Solution(object):
    def validSubarraySize(self, nums, threshold):
        stk = [-1]
        for i in range(len(nums)+1):
            while stk[-1] != -1 and (i == len(nums) or nums[stk[-1]] >= nums[i]):
                if nums[stk.pop()]*((i-1)-stk[-1]) > threshold:
                    return (i-1)-stk[-1]
            stk.append(i)
        return -1",O(n)
"from collections import defaultdict

n,k=[int(i) for i in input().strip().split()]
l=[int(i) for i in input().strip().split()]
if(k==1):
    print(n)
else:
    l.sort()
    ndict=defaultdict(list)
    for x in l:
        i=x
        while(i%k==0):
            i=i/k
        ndict[i].append(x)
    ans=0
    for i in ndict.values():
        count=0
        while(count<len(i)):
            if(count==len(i)-1):
                ans+=1
                break
            if(i[count]*k!=i[count+1]):
                ans+=1
                count+=1
            else:
                ans+=1
                count+=2
    print(ans)",O(nlogn)
"class Solution(object):
    def countGoodStrings(self, low, high, zero, one):
        MOD = 10**9+7
        result = 0
        dp = [0]*(high+1)
        dp[0] = 1
        for i in range(1, high+1):
            if i >= zero:
                dp[i] = (dp[i]+dp[i-zero])%MOD
            if i >= one:
                dp[i] = (dp[i]+dp[i-one])%MOD
            if i >= low:
                result = (result+dp[i])%MOD
        return result",O(n)
"read = lambda: map(int, input().split())
n, k = read()
s = input()
c = [0] * 26
for i in range(n):
    if s[i] <= chr(ord('A') + k - 1):
        c[ord(s[i]) - ord('A')] += 1
print(min(c[:k]) * k)",O(n)
"import sys
input = sys.stdin.readline
t = int(input())
for _ in range(t):
    n = int(input())
    if n % 2 == 1:
        print('NO')
        continue
    n //= 2
    l, r = 0, n + 2
    while r - l > 1:
        m = (l + r) // 2
        if m * m <= n:
            l = m
        else:
            r = m
    if l * l == n:
        print('YES')
        continue
    l, r = 0, n + 2
    while r - l > 1:
        m = (l + r) // 2
        if m * m * 2 <= n:
            l = m
        else:
            r = m
    if l * l * 2 == n:
        print('YES')
        continue
    print('NO')",O(logn)
"n = int(input())

lst = list(map(int, input().split()))

evens = []
odds = []

for e, x in enumerate(lst):
    if x % 2 == 0:
        evens.append(e + 1)
    else:
        odds.append(e + 1)

if len(evens) < len(odds):
    print(evens[0])
else:
    print(odds[0])
",O(n)
"s = input()
res = 0
for i in range(len(s)):
    for j in range(i,len(s)):
        for f in range(i+1,len(s)):
            if len(s) >= f + j-i:
                if (s[i:j]== s[f:f+j-i]):
                    res = max(res,j - i)

print(res)",O(n ^ 3)
"import sys

def rint():
    return map(int, sys.stdin.readline().split())

def writable(r, c):
    if r+2 >= n or c+2 >= m:
        return False
    t = set()
    t.add(cells[r][c])
    t.add(cells[r][c+1])
    t.add(cells[r][c+2])
    t.add(cells[r+1][c])
    t.add(cells[r+1][c+2])
    t.add(cells[r+2][c])
    t.add(cells[r+2][c+1])
    t.add(cells[r+2][c+2])
    return not '.' in t

def fill_ink(r,c):
    paper[r][c] = ""
    paper[r][c+1] = ""
    paper[r][c+2] = ""
    paper[r+1][c] = ""
    paper[r+1][c+2] = ""
    paper[r+2][c] = ""
    paper[r+2][c+1] = ""
    paper[r+2][c+2] = ""

n, m = rint()

cells = []
for i in range(n):
    cells.append(input())

paper = [[""."" for j in range(m)] for i in range(n)]

for r in range(n):
    for c in range(m):
        if writable(r,c) is True:
            fill_ink(r, c)

for r in range(n):
    for c in range(m):
        if cells[r][c] != paper[r][c]:
            print(""NO"")
            exit()

print(""YES"")
",O(n ^ 2)
"class Solution2(object):
    def maxScore(self, edges):
        def dfs(u):
            if not adj[u]:
                return (0, 0)
            children = [dfs(v) for v, _ in adj[u]]
            without_u = sum(max(with_v, without_v) for with_v, without_v in children)
            with_u = max(without_u-max(with_v, without_v)+(without_v+adj[u][i][1]) for i, (with_v, without_v) in enumerate(children))
            return (with_u, without_u)
            
        adj = [[] for _ in range(len(edges))]
        for i, (p, w) in enumerate(edges):
            if i == 0:
                continue
            adj[p].append((i, w))
        return max(dfs(0))",O(n)
"n,k=map(int,input().split())
if k>n+(n-1):
    print(0)
else:
    if k<=n:
        print((k-1)//2)
    else:
        x=n-(k-n)
        print((x+1)//2)
",O(1)
"n, m, k, l = list(map(int, input().split()))
if (l > n - k):
    print(-1)
else:
    am = ((l + k) // m + bool((l + k) % m))
    if am * m > n:
        print(-1)
    else:
        print(am)",O(1)
"import os

import string

from math import inf
from functools import lru_cache

if os.getcwd() == 'C:\\Users\\User\\Desktop\\python\\Prog\\CodeForces' \
        or os.environ['COMPUTERNAME'] == 'USER145':
    import pdb

    import sys

    pdb = pdb.Pdb(stdin=sys.stdin, stdout=sys.stdout)
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
    from pprint import pprint
    from hypothesis import given, settings
    from hypothesis import strategies as st

def ri():
    return [int(i) for i in input().split()]

def to_bits(l):
    ans = 0
    for i in l:
        ans |= (1 << i - 1)
    return ans

user_masks = [0 for i in range(1 << 10)]
pizzas = [[] for i in range(1 << 10)]

@lru_cache()
def count_sat_users(mask):
    ans = 0
    cmask = mask
    while cmask:
        ans += user_masks[cmask]
        cmask = (cmask - 1) & mask
    return ans

def main():
    n, m = ri()
    for _ in range(n):
        k, *a = ri()
        bits = to_bits(a)
        user_masks[bits] += 1

    ans = (float(-inf), float(inf), -1, -1)

    for i in range(m):
        c, k, *a = ri()
        bits = to_bits(a)
        pizzas[bits].append((c, i + 1, bits))
        pizzas[bits].sort()
        while len(pizzas[bits]) > 2:
            pizzas[bits].pop()

    for mask_F in range(1 << 9):
        for mask_S in range(1 << 9):
            if len(pizzas[mask_F]) and len(pizzas[mask_S]) \
                    and mask_F != mask_S:

                mask = mask_F | mask_S

                satisfied_users = count_sat_users(mask)

                f_pizza = next(iter(pizzas[mask_F]))
                s_pizza = next(iter(pizzas[mask_S]))

                summary_cost = 0
                summary_cost += f_pizza[0]
                summary_cost += s_pizza[0]

                ans = max(ans,
                          (satisfied_users,
                           -summary_cost,
                           s_pizza[1],
                           f_pizza[1]))

                bmask = mask
                while bmask:
                    satisfied_users += user_masks[bmask]
                    bmask = (bmask - 1) & mask

            if len(pizzas[mask_F]) == 2:
                satisfied_users = count_sat_users(mask_F)

                it = iter(pizzas[mask_F])

                f_pizza = next(it)
                s_pizza = next(it)
                summary_cost = 0
                summary_cost += f_pizza[0] + s_pizza[0]
                ans = max(ans,
                          (satisfied_users,
                           -summary_cost,
                           s_pizza[1],
                           f_pizza[1]))

            if len(pizzas[mask_S]) == 2:
                satisfied_users = count_sat_users(mask_S)

                it = iter(pizzas[mask_S])

                f_pizza = next(it)
                s_pizza = next(it)
                summary_cost = 0
                summary_cost += f_pizza[0] + s_pizza[0]
                ans = max(ans,
                          (satisfied_users,
                           -summary_cost,
                           s_pizza[1],
                           f_pizza[1]))

    aans = [ans[2],ans[3]]
    aans.sort()
    print(*aans, sep=' ')

main()
",np
"class Solution(object):
    def closetTarget(self, words, target, startIndex):
        INF = float(""inf"")
        result = INF
        for i, w in enumerate(words):
            if w == target:
                result = min(result, (i-startIndex)%len(words), (startIndex-i)%len(words))
        return result if result != INF else -1",O(n)
"import sys
input = sys.stdin.readline

n=int(input())
P=list(map(int,input().split()))
mod=998244353

INV=[None]*(n+1)
for i in range(1,n+1):
    INV[i]=pow(i,mod-2,mod)

BLA=P.count(-1)

if BLA==0 or BLA==1:
    ANS=0
else:
    LEFT=BLA*(BLA-1)//2*INV[BLA]%mod
    AVEP=BLA*(BLA-1)//2*pow(BLA-1,mod-2,mod)

    ANS=LEFT*AVEP%mod

y=1
for i in range(BLA):
    y=y*(BLA-i)%mod

KOSUU=pow(y,mod-2,mod)
BLALIST=[1]*(n+1)
NONBLA=[]
BLANUM=[0]*n
for i in range(n):
    if P[i]!=-1:
        BLALIST[P[i]]=0
        BLANUM[i]=BLANUM[i-1]
        NONBLA.append(P[i])

    else:
        BLANUM[i]=BLANUM[i-1]+1

BLALIST[0]=0
for i in range(1,n+1):
    BLALIST[i]=BLALIST[i-1]+BLALIST[i]

if BLA!=0:
    for i in range(n):
        if P[i]!=-1:
            ANS=(ANS+(BLANUM[i]*(BLA-BLALIST[P[i]])+(BLA-BLANUM[i])*BLALIST[P[i]])*INV[BLA])%mod

A=NONBLA

if A==[]:
    print(ANS)
    sys.exit()

n=len(A)
MAXA=max(A)
MINA=min(A)

BIT=[0]*(MAXA-MINA+2)

for i in range(n):
    bitobje=A[i]-MINA+1

    x=bitobje
    while x!=0:
        ANS=(ANS-BIT[x])%mod
        x-=(x&(-x))

    x2=MAXA-MINA+1

    while x2!=0:

        ANS=(ANS+BIT[x2])%mod
        x2-=(x2&(-x2))

    y=bitobje
    while y<=MAXA-MINA+1:
        BIT[y]+=1
        y+=(y&(-y))

print(ANS)
",O(nlogn)
"import os, sys
from io import BytesIO, IOBase

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class dict(dict):
    def __missing__(self, key):
        return 0

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [[i] + inp(dtype) for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
get_bit = lambda x, i: (x >> i) & 1

n = int(input())
a, masks, big = inp_2ds(float, n), dict(), 2 ** n - 1

if n == 1:
    exit(print(1))

for i in range(n):
    for j in range(i + 1, n):
        masks[big ^ (1 << j)] += a[i][j]
        masks[big ^ (1 << i)] += a[j][i]

for _ in range(2, n):
    tem = dict()
    for msk in masks:
        for bit in range(18):
            if get_bit(msk, bit):
                tem[msk ^ (1 << bit)] += sum([a[i][bit] for i in range(n) if get_bit(msk, i)]) * masks[msk]
    masks = tem

su = sum(masks.values())
print(*[masks[2 ** i] / su for i in range(n)])
",np
"import itertools


class Solution(object):
    def canConvertString(self, s, t, k):
        if len(s) != len(t):
            return False
        cnt = [0]*26
        for a, b in zip(s, t):
            diff = (ord(b)-ord(a)) % len(cnt)
            if diff != 0 and cnt[diff]*len(cnt) + diff > k:
                return False
            cnt[diff] += 1
        return True",O(n)
"from collections import defaultdict
from sys import setrecursionlimit,stdin
input=stdin.readline
setrecursionlimit(100000)

def dfs(r,g,b,rr,gg,bb):
    if r<0 or g<0 or b<0:
        return 0
    x=0
    y=0
    z=0

    if dp[r][g][b]!=-1:
        return dp[r][g][b]
    if r!=0 and g!=0:
        x=rr[r-1]*gg[g-1]+dfs(r-1,g-1,b,rr,gg,bb)
    if r!=0 and b!=0:
        y=rr[r-1]*bb[b-1]+dfs(r-1,g,b-1,rr,gg,bb)
    if b!=0 and g!=0:
        z=bb[b-1]*gg[g-1]+dfs(r,g-1,b-1,rr,gg,bb)
    dp[r][g][b]=max(x,y,z)
    return max(x,y,z)

r,g,b=map(int,input().split())
rr=list(map(int,input().split()))
gg=list(map(int,input().split()))
bb=list(map(int,input().split()))
rr.sort()
gg.sort()
bb.sort()
dp=[[[-1]*(b+1) for i in range(g+1)] for j in range(r+1)]

print(dfs(r,g,b,rr,gg,bb))
",O(n ^ 3)
"l=list(map(int,input().split()))
ans=0
for i in range(14):
	a=[]
	m=0
	a.extend(l)
	c=a[i]//14
	d=a[i]%14
	a[i]=0
	j=1
	while(j<=d):
		k=(i+j)%14
		a[k]+=1
		j+=1
	for j in range(14):
		a[j]+=c
		if a[j]%2==0:
			m+=a[j]
	ans=max(ans, m)
print(ans)",O(1)
"class Solution2(object):
    def maxOperations(self, s):
        result = curr = 0
        for i in range(len(s)):
            if s[i] != '1':
                continue
            curr += 1
            if i+1 < len(s) and s[i+1] == '0':
                result += curr
        return result",O(n)
"class Solution2(object):
    def numberOfPairs(self, nums1, nums2, diff):
        sorted_nums = sorted(set(x-y for x, y in zip(nums1, nums2)))
        num_to_idx = {x:i for i, x in enumerate(sorted_nums)}
        result = 0
        bit = BIT(len(num_to_idx))
        for x, y in zip(nums1, nums2):
            result += bit.query(bisect.bisect_right(sorted_nums, (x-y)+diff)-1)
            bit.add(num_to_idx[x-y], 1)
        return result",O(nlogn)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

p0 = getIntList()
p1 = getIntList()
p2 = getIntList()

zp = [p0, p1, p2]

def getpath( p0, p1):
    if p0[0] < p1[0]:
        sp = 1
    elif p0[0] > p1[0]:
        sp = -1
    else:
        sp =0
    zz = [tuple(p0), tuple(p1)]
    if sp!=0:
        for x in range(p0[0], p1[0]+ sp, sp):
            tp = (x, p0[1])
            zz.append(tp)
    if p0[1] < p1[1]:
        sp = 1
    elif p0[1] > p1[1]:
        sp = -1
    else:
        sp = 0
    if sp!=0:
        for y in range(p0[1], p1[1] + sp, sp):
            tp = (p1[0], y)
            zz.append(tp)
    return zz

nr = 1000000;
zr = set()
for i in range(3):
    for j in range(3):
        cx = zp[i][0]
        cy = zp[j][1]
        cp = (cx, cy)
        z1 = getpath(cp, zp[0])
        z2 =getpath(cp, zp[1])
        z3 =getpath(cp, zp[2])

        z0 = z1+z2+z3
        s1 = set(z0)
        dprint(cp,s1)
        if len(s1) < nr:
            nr = len(s1)
            zr = s1

print(len(zr))
for x in zr:
    print(x[0], x[1])
",O(1)
"import collections


class Solution2(object):
    def numberOfSubarrays(self, nums, k):
        result = 0
        dq = collections.deque([-1])
        for i in range(len(nums)):
            if nums[i]%2:
                dq.append(i)
            if len(dq) > k+1:
                dq.popleft()
            if len(dq) == k+1:
                result += dq[1]-dq[0]
        return result",O(n)
"n, q = map(int, raw_input().split())
l = raw_input()
cnt1, cnt0 = [0]*(n+1), [0]*(n+1)
mod = 10**9 + 7
for i in range(len(l)):
	if l[i] == '1':
		cnt1[i+1] = cnt1[i] + 1
		cnt0[i+1] = cnt0[i]
	else:
		cnt0[i+1] = cnt0[i] + 1
		cnt1[i+1] = cnt1[i]
pow2 = [1]
for i in range(1, 10**5 + 10):
	pow2.append((2*pow2[-1])%mod)
for i in range(q):
	l, r = map(int, raw_input().split())
	ones = cnt1[r] - cnt1[l-1]
	zeroes = cnt0[r] - cnt0[l-1]
	t1 = (pow2[ones] - 1)%mod
	t2 = (((pow2[ones] - 1)%mod)*(pow2[zeroes] - 1))%mod
	print((t1+t2)%mod)",O(n)
"n = int(input())
probs = list()
for i in range(n): probs.append(list(map(float, input().split())))
dp = [list([0 for i in range(1<<n)]) for i in range(n)]
dp[0][(1<<n)-1] = 1
ak = [list() for i in range(n+1)]
for i in range(1<<n):
    ak[bin(i).count(""1"")].append(i)
for k in range(1, n):
    for ele in ak[n-k+1]:
        for j in range(n):
            if (ele&(1<<j)):
                for w in range(n):
                    if (ele&(1<<w)) and j != w:
                        dp[k][ele-(1<<j)] += (dp[k-1][ele]*probs[w][j])/(((n-k+1)*(n-k))/2)
for i in range(n):
    print(dp[n-1][(1<<i)], end = "" "")
print()",np
"class Solution2(object):
    def minCost(self, costs):
        if not costs:
            return 0

        n = len(costs)
        for i in range(1, n):
            costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])
            costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])
            costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])

        return min(costs[n - 1])",O(n)
"from sys import stdin, stdout
from itertools import accumulate
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int, stdin.readline().split()))
for _ in range(1):
    n,k=lst()
    a=lst()
    b=lst()
    ps=list(accumulate(a))
    dp=[[0 for _ in range(2)] for _ in range(1+n)]
    for i in range(1,n+1):
        dp[i][0]=dp[i-1][0]+a[i-1]*b[i-1]
        dp[i][1]=max(dp[i-1][1]+a[i-1]*b[i-1],ps[i-1]-(ps[i-k-1] if i-k-1>=0 else 0)+dp[max(i-k,0)][0])

    print(max(max(v) for v in dp))",O(n)
"from math import inf

a=[0,0]
a[0]=[str(c)for c in list(input().strip()) ]
a[1]=[str(X) for X in list(input().strip())]

an = [-inf,-inf,-inf]
if a[0][0]==a[1][0]=='0':
    an[0]=0
elif  a[0][0]!=a[1][0]:
    an[1]=0
x=0
for i in range(1,len(a[0])) :

    if an[0]==0:
        if a[0][i]==a[1][i]=='0':
            x+=1

            an=[-inf,0 ,-inf]
        elif a[0][i]!=a[1][i]:
            x+=1
            an=[-inf]*3
        else:
            an = [-inf, -inf, -inf]
    elif an[1]==0:
        if a[0][i]==a[1][i]=='0':
            x+=1
            an=[-inf,-inf ,-inf]
        elif a[0][i]!=a[1][i]:
            pass
        else:
            an=[-inf,-inf ,-inf]
    else:
        if a[0][i]==a[1][i]=='0':

            an=[0,-inf ,-inf]
        elif a[0][i]!=a[1][i]:
            an=[-inf,0,-inf]
        else:
            an=[-inf,-inf ,-inf]

print(x)",O(1)
"R,G,B = list(map(int, input().split()))
r = sorted(list(map(int, input().split())), reverse =True)
g = sorted(list(map(int, input().split())), reverse =True)
b = sorted(list(map(int, input().split())), reverse =True)
def f(x,y,z):
    m1 = 0
    m2 = 0
    m3 = 0
    if(x<R and y<G):
        if(dpt[x+1][y+1][z]==-1):
            dpt[x+1][y+1][z] = f(x+1,y+1,z)
        m1 = r[x]*g[y] + dpt[x+1][y+1][z]
    if(y<G and z<B):
        if(dpt[x][y+1][z+1]==-1):
            dpt[x][y+1][z+1] = f(x,y+1,z+1)
        m2 = g[y]*b[z] + dpt[x][y+1][z+1]
    if(z<B and x<R):
        if(dpt[x+1][y][z+1]==-1):
            dpt[x+1][y][z+1] = f(x+1,y,z+1)
        m3 = r[x]*b[z] + dpt[x+1][y][z+1]
    dpt[x][y][z] = max(m1,m2,m3)
    return dpt[x][y][z]
dpt = [[[-1 for _ in range(B+1)]for _ in range(G+1)]for _ in range(R+1)]
print(f(0,0,0))",O(n ^ 3)
"class Solution:
    def lengthOfLIS(self, nums):
        n = len(nums)
        memo = [[-1] * (n + 1) for _ in range(n)]

        def dfs(i, j):
            if i == n:
                return 0
            if memo[i][j + 1] != -1:
                return memo[i][j + 1]

            LIS = dfs(i + 1, j)

            if j == -1 or nums[j] < nums[i]:
                LIS = max(LIS, 1 + dfs(i + 1, i))

            memo[i][j + 1] = LIS
            return LIS

        return dfs(0, -1)
",O(n ^ 2)
"from collections import defaultdict, Counter
import os
import sys
from io import BytesIO, IOBase

ii = lambda: int(input())
lmii = lambda: list(map(int, input().split()))
slmii = lambda: sorted(map(int, input().split()))
li = lambda: list(input())
mii = lambda: map(int, input().split())
msi = lambda: map(str, input().split())

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

def lcm(a, b): return (a * b) // gcd(a, b)

def main():

    s = li()
    n = len(s)
    cnt = 0
    sm = 0
    for i in range(n):
        s[i] = int(s[i]) % 3
    i = 0
    while i < n:
        if s[i] == 0:
            cnt += 1
            sm = 0
            i += 1
        else:
            sm += s[i]
            if sm % 3 == 0:
                sm = 0
                cnt += 1
                i += 1
            else:
                if i + 1 < n and s[i] + s[i + 1] == 3:
                    i += 2
                    cnt += 1
                    sm = 0
                else:
                    i += 1
    print(cnt)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(n)
"class Solution:
    def isBalanced(self, root):
        stack = []
        node = root
        last = None
        depths = {}

        while stack or node:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack[-1]
                if not node.right or last == node.right:
                    stack.pop()
                    left = depths.get(node.left, 0)
                    right = depths.get(node.right, 0)

                    if abs(left - right) > 1:
                        return False

                    depths[node] = 1 + max(left, right)
                    last = node
                    node = None
                else:
                    node = node.right

        return True
",O(n)
"n=input()
L=list(map(int,raw_input().split(' ')))
D=[0]*101000
mod=10**9+7
itt=[0]*101000
p=[0]*100010
D[0]=1
for i in range(100010):
  D[i+1]=(D[i]*2)%mod
for i in range(n):
  itt[L[i]]+=1
for i in range(1,100001):
  for j in range(i*2,100001,i):
    itt[i]+=itt[j]
  p[i]=(D[itt[i]]+mod-1)%mod
i=100000
while i>=1:
  for j in range(i*2,100001,i):
    p[i]-=p[j]
  p[i]=(p[i]%mod+mod)%mod
  i-=1
print(p[1])",np
"l,r=input().split("" "")
l,r=int(l),int(r)
if (l % 2 != 0):
    l+=1
if (l + 2 > r):
    print(-1);
else:
    print(l,l+1,l+2)
",O(1)
"from collections import namedtuple
vertex = namedtuple('vertex', ['degree', 'id'])
a, b, c = [], [], 0

n = int(input())
rr = list(map(int, input().split()))

for i in range(n):
    if rr[i] > 1:
        a.append(vertex(rr[i], i + 1))
    else:
        b.append(vertex(rr[i], i + 1))
    c += rr[i]

if c < (n - 1)*2:
    print('NO')
else:
    print('YES', len(a) - 1 + min(2, len(b)))
    print(n - 1)
    for i in range(1,len(a)):
        print(a[i - 1].id, a[i].id)
    if len(b) > 0:
        print(b[0].id, a[0].id)
    if len(b) > 1:
        print(b[1].id, a[-1].id)
    j, yes = 2, 0
    for i in range(len(a)):
        k = a[i].degree - 2
        for t in range(k):
            if j >= len(b):
                yes = 1
                break
            print(a[i].id, b[j].id)
            j += 1
        if yes == 1:
            break",O(n ^ 2)
"num=int(input())

a=input()

b=input()

dic={}

lis=[]

ham=0

swap1=-1

swap2=-1

p=False

q=False

for i in range(num):

    if a[i]!=b[i]:

        ham+=1

        lis.append(i)

        dic[b[i]]=i

for i in lis:

    if a[i] in dic:

        p=True

        swap1=i+1

        f=dic[a[i]]

        swap2=f+1

        if a[f]==b[i]:

            q=True

            break

print(ham-(2 if q else 1 if p else 0))

print(swap1,swap2)
",O(n)
"f1, f2 = map(int,input().split("" ""))
if f1==0:
  print(0)
else:
  print((pow(2,f2,1000000007)*(2*f1-1)+1)%1000000007)",O(logn)
"n = int(input())
l = [-1] * n
r = [-1] * n
a = list(map(int, input().split()))
for i in range(2 * n):
    x = a[i] - 1
    if l[x] == -1: l[x] = i
    r[x] = i
ans = 0
for i in range(n):
    for j in range(n):
        if l[i] < l[j] < r[j] < r[i]: ans += 2
for i in range(n):
    ans += r[i] - l[i] - 1
print(ans // 2)",O(n ^ 2)
"n = int(input())
a = []
for i in map(int, input().split()):
    if abs(-i-1)>abs(i):
        a.append(-i-1)
    else:
        a.append(i)

c = 0
for i in a:
    if i<0:
        c+=1
if c%2:
    me=0
    for i in range(len(a)):
        if a[i]<a[me]:
            me=i
    a[me]=-a[me]-1
print(*a)
",O(n)
"str=input()
m=0
n=len(str)
for i in range(n):
    for j in range(i,n+1) :
        if str[i:j] in str[i+1:n] and len(str[i:j])>m:
            m=len(str[i:j])
print(m)",O(n ^ 3)
"import collections



class Solution(object):
    def canBeEqual(self, s1, s2):
        return all(collections.Counter(s1[j] for j in range(i, len(s1), 2)) == collections.Counter(s2[j] for j in range(i, len(s2), 2)) for i in range(2))",O(n)
"n,l,r,x = map(int,input().split())
c = list(map(int,input().split()))
c.sort()
ans = 0
for i  in range(2**n):
    s = []
    for j in range(n):
        if i&2**j:
            s.append(c[j])
    if sum(s)>=l and sum(s)<=r and max(s)-min(s)>=x:
        ans+=1

print(ans)
",np
"mod = 10**9+7
x,k = [int(x) for x in input().split()]
if x ==0:
    print(0)
else:
    T = [1]
    for j in range(1024):
        T.append((2*T[-1])%(mod))
    L = [1]
    for i in range(10**6):
        L.append(((T[1024])*L[-1])%(mod))

    k =k % (mod-1)

    t1 = (k)%(1024)
    t2 =(k+1)%(1024)

    q1 = k//(1024)
    q2 =(k+1)//(1024)

    A = (L[q2]*T[t2])%(mod)
    A *= x
    A = A % (mod)

    B = (L[q1]*T[t1])%(mod)

    print((A-B+1)%(mod))
",O(logn)
"n = int(input())
chess = []
for w in range(3):
    chess.append([input() for i in range(n)])
    input()
chess.append([input() for i in range(n)])

issue = {0:0, 1:0, 2:0, 3:0}
reversed_issue = {0:0, 1:0, 3:0}

for w in range(4):
    chessdesk = [chess[0] + chess[3]] + [chess[1] + chess[2]]
    for s in range(2 * n):
        chessdesk[0][s] += chessdesk[1][s]
    chessdesk.pop(1)
    chessdesk = chessdesk[0]
    colour = chessdesk[0][0]

    for i in range(2 * n):
        for j in range(2 * n):
            if (i + j) % 2 == 0:
                if chessdesk[i][j] != colour:
                    issue[w] += 1
            else:
                if chessdesk[i][j] == colour:
                    issue[w] += 1

    reversed_issue[w] = 4 * n**2 - issue[w]
    if w == 0:
        chess[0], chess[3] = chess[3], chess[0]
    elif w == 1:
        chess[1], chess[3] = chess[3], chess[1]
    elif w == 2:
        chess[1], chess[2] = chess[2], chess[1]

print(min(min(issue.values()), min(reversed_issue.values())))",O(n ^ 2)
"l = list(map(int,input().split()))
n = 0
m=-1
while(n<14):
    c=0
    g = l.copy()
    div = l[n]//14
    h = l[n]%14
    i = n+1
    sum = div*14
    g[n]=0
    while(sum):
        if i==14:
            i=0
        g[i]+=div
        sum-=div
        i+=1
    i = n+1
    while(h):
        if i==14:
            i=0
        g[i]+=1
        h-=1
        i+=1
    for j in g:
        if j%2==0:
            c+=j

    m = max(c,m)
    n+=1
print(m)
",O(1)
"K = 998244353
def mu(a, n):
	if n == 0: return 1
	q = mu(a, n // 2)
	if n % 2 == 0: return q * q % K
	return q * q % K * a % K
MAXN = 200005
dd = [0 for i in range(MAXN)]
p = [0 for i in range(MAXN)]
s = [0 for i in range(MAXN)]
a = [0 for i in range(MAXN)]
fen = [0 for i in range(MAXN)]

def add(u, v):
	i = u
	while (i <= 200000):
		fen[i] += v
		i += i & -i

def get(u):
	res = 0
	i = u
	while (i > 0):
		res += fen[i]
		i -= i & -i
	return res

n = int(input())

data = input().split()

cnt = 0

for i in range(1, n + 1):
	p[i] = int(data[i - 1])
	if (p[i] > 0): dd[p[i]] = 1
	else: cnt += 1

for i in range(1, n + 1):
	if (dd[i] == 0):
		s[i] = s[i - 1] + 1
	else:
		s[i] = s[i - 1]

cnt1 = 0
P = 0
den = mu(cnt, K - 2)
for i in range(1, n + 1):
	if (p[i] == -1):
		cnt1 += 1
	else:
		u = cnt - cnt1
		P = (P + u * s[p[i]] % K * den % K) % K
		P = (P + cnt1 * (cnt - s[p[i]]) % K * den % K) % K

P = (P + cnt * (cnt - 1) * mu(4, K - 2)) % K

m = 0

for i in range(1, n + 1):
	if p[i] > 0:
		m += 1
		a[m] = p[i]

P1 = 0
for i in range(m, 0, -1):
	P1 = (P1 + get(a[i])) % K
	add(a[i], 1)

P = (P + P1) % K

print(P)
",O(nlogn)
"from math import sqrt

n, k = map(int, input().split())

answer = int(-1.5 + sqrt(9/4 + 2*(n+k)))

print(n - answer)
",O(1)
"n=int(input())
a,b=map(int,input().split())
white=abs(a-1)+abs(b-1)
black=abs(n-a)+abs(n-b)
if white<=black:
    print(""White"")
else:
    print(""Black"")",O(1)
"def main():
    k = int(input())
    n = []
    a = []
    for i in range(k):
        line = [int(x) for x in input().split()]
        ni = line[0]
        ai = []
        n.append(ni)
        a.append(ai)
        for j in range(ni):
            ai.append(line[1 + j])
    answer, c, p = solve(k, n, a)
    if answer:
        print(""Yes"")
        for i in range(k):
            print(c[i], p[i] + 1)
    else:
        print(""No"")

def solve(k, n, a):
    asum, sums = calc_sums(k, n, a)
    if asum % k != 0:
        return False, None, None
    tsum = asum / k
    num_map = build_num_map(k, n, a)
    masks = [None]*(1 << k)
    answer = [False]*(1 << k)
    left = [0]*(1 << k)
    right = [0]*(1 << k)
    for i in range(k):
        for j in range(n[i]):
            found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, dict())
            if found:
                answer[mask] = True
                masks[mask] = path
    for mask_right in range(1 << k):
        if not masks[mask_right]:
            continue
        zeroes_count = 0
        for u in range(k):
            if (1 << u) > mask_right:
                break
            if (mask_right & (1 << u)) == 0:
                zeroes_count += 1
        for mask_mask in range(1 << zeroes_count):
            mask_left = 0
            c = 0
            for u in range(k):
                if (1 << u) > mask_right:
                    break
                if (mask_right & (1 << u)) == 0:
                    if (mask_mask & (1 << c)) != 0:
                        mask_left = mask_left | (1 << u)
                    c += 1
            joint_mask = mask_left | mask_right
            if answer[mask_left] and not answer[joint_mask]:
                answer[joint_mask] = True
                left[joint_mask] = mask_left
                right[joint_mask] = mask_right
                if joint_mask == ((1 << k) - 1):
                    return build_answer(k, masks, left, right)
    if answer[(1 << k) - 1]:
        return build_answer(k, masks, left, right)
    return False, None, None

def build_answer(k, masks, left, right):
    c = [-1] * k
    p = [-1] * k
    pos = (1 << k) - 1
    while not masks[pos]:
        for key, val in masks[right[pos]].items():
            c[key] = val[0]
            p[key] = val[1]
        pos = left[pos]
    for key, val in masks[pos].items():
        c[key] = val[0]
        p[key] = val[1]
    return True, c, p

def build_num_map(k, n, a):
    result = dict()
    for i in range(k):
        for j in range(n[i]):
            result[a[i][j]] = (i, j)
    return result

def find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):
    if (mask & (1 << i)) != 0:
        if i == i_origin and j == j_origin:
            return True, mask, path
        else:
            return False, None, None
    mask = mask | (1 << i)
    a_needed = tsum - (sums[i] - a[i][j])
    if a_needed not in num_map:
        return False, None, None
    i_next, j_next = num_map[a_needed]
    path[i_next] = (a[i_next][j_next], i)
    return find_cycle(i_origin, j_origin, i_next, j_next, k, n, a, sums, tsum, num_map, mask, path)

def calc_sums(k, n, a):
    sums = [0] * k
    for i in range(k):
        for j in range(n[i]):
            sums[i] = sums[i] + a[i][j]
    asum = 0
    for i in range(k):
        asum = asum + sums[i]
    return asum, sums

if __name__ == ""__main__"":
    main()
",np
"class Solution(object):
    def asteroidCollision(self, asteroids):
        result = []
        for x in asteroids:
            if x > 0:
                result.append(x)
                continue
            while result and 0 < result[-1] < -x:
                result.pop()
            if result and 0 < result[-1]:
                if result[-1] == -x:
                    result.pop()
                continue
            result.append(x)
        return result",O(n)
"class Solution(object):
    def replaceElements(self, arr):
        curr_max = -1
        for i in reversed(range(len(arr))):
            arr[i], curr_max = curr_max, max(curr_max, arr[i])
        return arr",O(n)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, M = getIntList()

za  = getIntList()
za.sort(reverse = True)

re = 0

for i in range(N-1):
    a = za[i]
    b = za[i+1]
    g = b
    if g>=a:
        t = a-1
        if t<1: t = 1
        re +=  g-t
        za[i+1] = t
        re += a - 1
    else:
        re += g
print(re)
",O(nlogn)
"class Solution(object):
    def convert(self, s, numRows):
        if numRows == 1:
            return s
        step, zigzag = 2 * numRows - 2, """"
        for i in range(numRows):
            for j in range(i, len(s), step):
                zigzag += s[j]
                if 0 < i < numRows - 1 and j + step - 2 * i < len(s):
                    zigzag += s[j + step - 2 * i]
        return zigzag",O(n)
"class Solution(object):
    def findPrimePairs(self, n):
        def linear_sieve_of_eratosthenes(n):
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return spf 

        spf = linear_sieve_of_eratosthenes(n)
        return [[i, n-i] for i in range(2, n//2+1) if spf[i] == i and spf[n-i] == n-i]",O(n)
"class Solution(object):
    def minMovesToCaptureTheQueen(self, a, b, c, d, e, f):
        if a == e and not (a == c and (b-d)*(f-d) < 0):
            return 1
        if b == f and not (b == d and (a-c)*(e-c) < 0):
            return 1
        if c+d == e+f and not (c+d == a+b and (c-a)*(e-a) < 0):
            return 1
        if c-d == e-f and not (c-d == a-b and (d-b)*(f-b) < 0):
            return 1
        return 2",O(1)
"n=int(input())
a=(n//2)*3
print(a)",O(1)
"import collections


class Solution(object):
    def twoOutOfThree(self, nums1, nums2, nums3):
        K = 2
        cnt = collections.Counter()
        for nums in nums1, nums2, nums3:
            cnt.update(set(nums))
        return [x for x, c in cnt.items() if c >= K]",O(n)
"import sys
from array import array

def readline() -> str: return sys.stdin.buffer.readline().decode('utf-8')

n, k = map(int, readline().split())
mod = 998244353
dp = [[array('i', [0])*(2*n+3) for _ in range(n)] for _ in range(4)]
dp[0][0][1] = dp[3][0][1] = 1
dp[1][0][2] = dp[2][0][2] = 1

for i in range(n-1):
    for j in range(k+1):
        for sbit in range(4):
            for tbit in range(4):
                add = (
                    1 if sbit == 3 and tbit == 0 or sbit == 0 and tbit == 3 else
                    (1 if (sbit & 2) != (tbit & 2) and (tbit == 1 or tbit == 2) else 0)
                    + (1 if (sbit & 1) != (tbit & 1) and (tbit == 1 or tbit == 2) else 0)
                )
                dp[tbit][i+1][j+add] += dp[sbit][i][j]
                if dp[tbit][i+1][j+add] >= mod:
                    dp[tbit][i+1][j+add] -= mod

ans = sum(dp[bit][-1][k] for bit in range(4)) % mod
print(ans)
",np
"class Solution2(object):
    def buildArray(self, nums):
        return [nums[x] for x in nums]",O(n)
"def operations(a, b):
    less = min(a, b)
    more = max(a, b)
    ops = 0
    while less > 0 and more > 0:
        ops += more // less
        more -= less * (more // less)
        less, more = more, less
    return ops

n = int(input())
for i in range(n):
    a, b = map(int, input().split())
    print(operations(a, b))
",O(1)
"s = [0] * 10
m = [0] * 10
p = [0] * 10
D = list(input().split())
for i in D:
    if i[1] == 'p':
        p[int(i[0])] += 1
    elif i[1] == 'm':
        m[int(i[0])] += 1
    else:
        s[int(i[0])] += 1

need = 3
for i in range(1, 10):
    need = min(3 - p[i], need)
    need = min(3 - s[i], need)
    need = min(3 - m[i], need)
    if i <= 7:
        tmp = 0
        tmp += min(1, p[i])
        tmp += min(1, p[i + 1])
        tmp += min(1, p[i + 2])
        need = min(3 - tmp, need)
        tmp = 0
        tmp += min(1, m[i])
        tmp += min(1, m[i + 1])
        tmp += min(1, m[i + 2])
        need = min(3 - tmp, need)
        tmp = 0
        tmp += min(1, s[i])
        tmp += min(1, s[i + 1])
        tmp += min(1, s[i + 2])
        need = min(3 - tmp, need)

print(need)
",O(n)
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
import bisect
T = int(input())
r = 1
prime = [2]

for i in range(3,4*10**3,2):
    flag = False
    if i%2==0: continue
    for j in range(3,int(i**0.5)+1,2):
        if i%j==0:
            flag = True
            break
    if not flag:  prime.append(i)

def primefactor(num):

    index = 0
    output = []

    while num>=prime[index]**2:

        times = 0
        while num%prime[index]==0:
            num = num // prime[index]
            times += 1
        if times&1:  output.append(prime[index])
        index += 1

    if num>1: output.append(num)

    return tuple(output)

while r<=T:
    n,k = map(int,input().split())
    arr = list(map(int,input().split()))

    seg = 1
    fact = {}
    left = [[0 for j in range(k+1)] for i in range(n)]
    dp = [[300000 for j in range(k+1)] for i in range(n)]

    stack = [0]
    for i in range(n):
        factor = primefactor(arr[i])
        if factor in fact:
            bisect.insort(stack,fact[factor]+1)

        fact[factor] = i

        for j in range(k+1):
            if j<len(stack):  left[i][j] = stack[-j-1]

    for i in range(n):
        for j in range(k+1):
            for t in range(j+1):
                l = left[i][t]
                if l>0:
                    dp[i][j] = min(dp[l-1][j-t] + 1, dp[i][j])
                else:
                    dp[i][j] = 1

    print(dp[-1][-1])
    r += 1",O(n ^ 3)
"s=input()
for ln in range(len(s),0,-1):
    for L in range(len(s)-ln+1):
        if s[L:L+ln] in s[L+1:]:
            print(ln)
            exit()
print(0)
",O(n ^ 3)
"class Solution(object):
    def addDigits(self, num):
        return (num - 1) % 9 + 1 if num > 0 else 0",O(1)
"import functools
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:

    def __init__(self):
        pass

    def __call__(self):
        MOD = 998244353
        N = 1000007
        pow2 = [0] * N

        n = int(input())
        a = list(map(int, input().strip().split()))

        pow2[0] = 1
        for i in range(n):
            pow2[i + 1] = (2 * pow2[i]) % MOD

        res = 0
        for i in range(1, n):
            tmp = (a[i - 1] * (n + 2 - i)) % MOD
            res += (pow2[n - 1 - i] * tmp) % MOD
            res %= MOD
        res += a[n - 1]
        res %= MOD
        print(res)

solver()()",O(n)
"n = int(input())
a = sorted(list(map(int, input().split())))
duplicates = {}
d = None
delta = 0
for i, el in enumerate(a, 1):
    if el not in duplicates:
        duplicates[el] = 0
    else:
        d = el
        duplicates[el] += 1
    min_value = i-1
    delta += el - min_value
if sum(duplicates.values()) > 1 or duplicates.get(0, 0) >= 1 or (d is not None and d-1 in duplicates):
    print('cslnb')
elif delta == 0:
    print('cslnb')
elif delta % 2 == 1:
    print('sjfnb')
else:
    print('cslnb')
",O(n)
"n = int(input())
l = []
for i in range(n):
    x, y = map(int, input().split())
    l += [(x + y, x - y)]
l.sort()
r = -2000000000
a = 0
for u in l:
    if u[1] >= r:
        a += 1
        r = u[0]
print(a)
",O(nlogn)
"import collections


class Solution(object):
    def largestUniqueNumber(self, A):
        A.append(-1)
        return max(k for k,v in list(collections.Counter(A).items()) if v == 1)",O(n)
"class Solution(object):
    def threeSumSmaller(self, nums, target):
        nums.sort()
        n = len(nums)

        count, k = 0, 2
        while k < n:
            i, j = 0, k - 1
            while i < j: 
                if nums[i] + nums[j] + nums[k] >= target:
                    j -= 1
                else:
                    count += j - i
                    i += 1
            k += 1

        return count",O(n ^ 2)
"class Solution2(object):
    def minimumEffort(self, tasks):
        tasks.sort(key=lambda x: x[0]-x[1]) 
        result = curr = 0
        for a, m in tasks: 
            result += max(m-curr, 0)
            curr = max(curr, m)-a
        return result",O(nlogn)
"a, b = map(int, input().split())
A = list(map(int, input().split()))
A.append(-1)
B = []
Z = []
AN = []
x, y = A[0], A[1]
for i in range(a - 1):
    Z.append((x, y))
    if x > y:
        B.append(y)
        y = A[i + 2]
    else:
        B.append(x)
        x, y = y, A[i + 2]
for i in range(b):
    w = int(input())
    if w <= len(Z):
        AN.append(Z[w - 1])
    else:
        w = w % len(B)
        AN.append((x, B[w - 1]))
for W in AN:
    print(*W)",O(n)
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush

from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect, insort
from time import perf_counter
from fractions import Fraction
import copy
from copy import deepcopy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:

    sys.stdin = open(""input.txt"", ""r"")

except:
    pass
def pmat(A):
    for ele in A: print(*ele,end=""\n"")

n=L()[0]
A=L()
A.sort()
if A[-1]==1:
    A[-1]=2
else:
    A[-1]=1
    A.sort()
print(*A)",O(nlogn)
"from sys import stdin
def get_ints(): return list(map(int, stdin.readline().strip().split()))

n = int(input())
ar = get_ints()

bus = sorted([ (ar[i], i+1) for i in range(n) ])
pa = [int(x) for x in input()]
seq = []

tail = 0
for p in pa:
	if p == 0:
		print(bus[tail][1], end="" "")
		seq.append(tail)
		tail+=1
	else:
		v = seq.pop()
		print(bus[v][1],end="" "")
",O(nlogn)
"def ints():
 return map(int,input().split())
n,m=ints()
c=ints()
aa=[0]*(n+1)
for cc in c:
 aa[cc]+=1
print(min(aa[1:]))
",O(n ^ 2)
"import sys,os,io
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from sys import stdin

import math

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2

    for i in range(3,int(math.sqrt(n))+1,2):

        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))

def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res

def si():
    return input()

def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r

def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1

def ii():
    return int(input())

def li():
    return list(map(int,input().split()))

def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"")
    sys.stdout = open(""output.txt"",""w"")

t = 1
for _ in range(t):
    s = si()
    s = s*3
    m = 0
    c = 1
    for i in range(1,len(s)):
        if (s[i]!=s[i-1]):
            c+=1
        else:
            m = max(m,c)
            c = 1
    m = max(m,c)

    m = min(m,len(s)//3)
    print(m)",O(n)
"def my_solve(n, m, graph, mask):
	if do_dfs_bool(n,graph,mask.copy()):
		c = get_cyclic(n, graph, mask)
		for u,v in c:
			graph[u].remove(v)
			if not do_dfs_bool(n,graph,mask.copy()):
				return 'YES'
			graph[u].append(v)
		return ""NO""
	return ""YES""

def get_cyclic(n, graph, mask):
	c,v = do_dfs(n,graph,mask)
	path = []
	i = 0
	begin = False
	if c:
		for u in c.keys():
			if c[u] == v:
				begin = True
				path.append((c[u],u))
			elif begin:
				path.append((c[u],u))
		tmp = list(c.keys())
		if len(tmp):
			path.append((tmp[-1],v))
	return path

def do_dfs_bool(n, graph, mask):
	colors = [0]*(n+5)
	for u in graph.keys():
		if not u in mask.keys():
			if dfs_bool(u,graph,mask,colors):
				return True
	return False

def dfs_bool(u, graph, mask,colors):
	colors[u] = 1
	mask[u] = True
	for v in graph[u]:
		if colors[v] == 1:
			return True
		if colors[v] == 0:
			if dfs_bool(v,graph,mask,colors):
				return True
	colors[u] = 2
	return False

def do_dfs(n, graph, mask):
	colors = [0]*(n+5)
	c = {}
	for u in graph.keys():
		if not u in mask.keys():
			c = {}
			p, v = dfs(u,graph,mask,c,colors)
			if p and v:
				return (p,v)

def dfs(u, graph, mask, c, colors):
	colors[u] = 1
	for v in graph[u]:
		if colors[v] == 1:
			return (c, v)
		if colors[v] == 0:
			c[v] = u
			p,w = dfs(v,graph,mask,c,colors)
			if w:
				return (p,w)
	colors[u] = 2
	if len(c) > 0:
		if u in c.keys():
			del c[u]
	return (c, None)

def test(n, m, edges):
	graph = {}
	mask = {}
	for u,v in edges:
		if u not in graph.keys():
			graph[u] = []
		graph[u].append(v)
		if v not in graph.keys():
			graph[v] = []
	return my_solve(n, m, graph, mask)

if __name__ == '__main__':
	n,m = [int(x) for x in input().split()]
	edges = []
	for i in range(0,m):
		u,v = [int(x) for x in input().split()]
		edges.append((u,v))
	print(test(n, m, edges))",O(n ^ 2)
"import sys
import heapq
input = sys.stdin.readline
n = int(input())
w = [int(z) for z in input().split()]; s = input(); idx = []
for i in range(n):
    idx.append((w[i], i+1))

idx.sort()
heapq.heapify(idx)
ones = []
heapq.heapify(ones)
res = []
for i in range(2*n):
    if s[i] == '0':
        l = idx[0]
        heapq.heappop(idx)
        res.append(l[1])
        heapq.heappush(ones, [-l[0], l[1]])
    else:
        l = ones[0]
        heapq.heappop(ones)
        res.append(l[1])
res = ' '.join([str(i) for i in res])
sys.stdout.write(res)",O(nlogn)
"class Solution(object):
    def countKConstraintSubstrings(self, s, k):
        result = cnt = left = 0
        for right in range(len(s)):
            cnt += int(s[right] == '1')
            while not (cnt <= k or (right-left+1)-cnt <= k):
                cnt -= int(s[left] == '1')
                left += 1
            result += right-left+1
        return result",O(n)
"import sys

rd = lambda : sys.stdin.readline().rstrip()

n = int(rd())
c = list(map(int, rd().split()))
a = list(map(lambda x: int(x)-1, rd().split()))

visited = [-1] * (n)
res = 0

for i in range(n):
    trace = []

    t = i
    mn = 1e9
    while visited[t] == -1:
        visited[t] = i
        trace.append(t)
        t = a[t]

    if visited[t] != i:
        continue

    while len(trace) > 0:
        v = trace.pop()
        mn = min(mn, c[v])

        if t == v: break

    res += mn

print(res)
",O(n)
"N, M, K = map(int, input().split())
A = [int(a) for a in input().split()]
S = [0]
for a in A:
    S.append(S[-1]+M*a-K)
MI = [(10**50)] * M
ans = 0
for i in range(N+1):
    MI[i%M] = min(MI[i%M], S[i])
    for j in range(M):
        ans = max(ans, (S[i]-MI[(i-j)%M] - K*((-j)%M))//M)
print(ans)
",O(n ^ 2)
"MOD = 1000000007
def fast_power(base, power):
    result = 1
    while power > 0:
        if power % 2 == 1:
            result = (result * base) % MOD

        power = power // 2
        base = (base * base) % MOD

    return result

x, k = map(int, input().split())

if x == 0 or k == 0:
    print((x * 2) % MOD)
else:
    d = ((x * 4) - 1) - (x * 2)
    print(((x * 2) + (d * (fast_power(2, k) - 1))) % MOD)",O(logn)
"dul = 0
n, k = map(int,input().split())
sum1 = 0
if k == 0:
    for i in range (n-1,-1,-1):
        sum1 = sum1 + 1
        dul = dul + sum1
        if dul == i:
            print(i)
            break

if k != 0:
    for i in range (n-1,-1,-1):
        sum1 = sum1 + 1
        dul = dul + sum1
        if dul - i == k:
            print(i)
            break
",O(logn)
"import sys,os,io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

n,m,k = [int(i) for i in input().split()]
h = []
for i in range (n):
    h.append([int(i) for i in input().split()])
v = []
for i in range (n-1):
    v.append([int(i) for i in input().split()])
if k%2:
    for i in range (n):
        for j in range (m):
            print(-1,end="" "")
        print()
    exit()
dp = [[[float('inf')]*m for i in range (n)] for j in range (k//2+1)]
for i in range (n):
    for j in range (m):
        dp[0][i][j] = 0
for x in range (1,k//2+1):
    for i in range (n):
        for j in range (m):
            if i!=0:
                dp[x][i][j] = min(dp[x][i][j], dp[x-1][i-1][j] + v[i-1][j])
            if i!=n-1:
                dp[x][i][j] = min(dp[x][i][j], dp[x-1][i+1][j] + v[i][j])
            if j!=0:
                dp[x][i][j] = min(dp[x][i][j], dp[x-1][i][j-1] + h[i][j-1])
            if j!=m-1:
                dp[x][i][j] = min(dp[x][i][j], dp[x-1][i][j+1] + h[i][j])

for i in range (n):
    for j in range (m):
        print(2*dp[k//2][i][j],end="" "")
    print()",O(n ^ 3)
"import os
import heapq
import sys
import math
import operator
from collections import defaultdict
from io import BytesIO, IOBase

def inpt():
    return [int(k) for k in input().split()]

def main():
    n1, n2, n3 = map(int, input().split())
    ar = [int(x) for x in input().split()]
    br = [int(x) for x in input().split()]
    cr = [int(x) for x in input().split()]
    ar.sort()
    br.sort()
    cr.sort()
    dp = [[[0 for x in range(201)] for y in range(201)] for z in range(201)]
    for i in range(n1 + 1):
        for j in range(n2 + 1):
            for k in range(n3 + 1):
                if (i and j):
                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + (ar[i - 1] * br[j - 1]))
                if (i and k):
                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + (ar[i - 1] * cr[k - 1]))
                if (k and j):
                    dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + (cr[k - 1] * br[j - 1]))
    print(dp[n1][n2][n3])

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"import collections



class Solution(object):
    def longestEqualSubarray(self, nums, k):
        cnt = collections.Counter()
        result = left = 0
        for right in range(len(nums)):
            cnt[nums[right]] += 1
            result = max(result, cnt[nums[right]])
            if right-left+1 > result+k:
                cnt[nums[left]] -= 1
                left += 1
        return result",O(n)
"class Solution(object):
    def findPrefixScore(self, nums):
        curr = 0
        for i in range(len(nums)):
            curr = max(curr, nums[i])
            nums[i] += (nums[i-1] if i-1 >= 0 else 0)+curr
        return nums",O(n)
"class Solution(object):
    def minimumFuelCost(self, roads, seats):
        def ceil_divide(a, b):
            return (a+b-1)//b
    
        def iter_dfs():
            result = 0
            stk = [(1, (0, -1, 0, [1]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, d, ret = args
                    stk.append((3, (d, ret)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        new_ret = [1]
                        stk.append((2, (new_ret, ret)))
                        stk.append((1, (v, u, d+1, new_ret)))
                elif step == 2:
                    new_ret, ret = args
                    ret[0] += new_ret[0]
                elif step == 3:
                    d, ret = args
                    if d:
                        result += ceil_divide(ret[0], seats)
            return result
    
        adj = [[] for _ in range(len(roads)+1)]
        for u, v in roads:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()",O(n)
"class Combi():

    def __init__(self, N, mod=10**9 + 7):
        self.power = [1 for _ in range(N+1)]
        self.rev = [1 for _ in range(N+1)]
        self.mod = mod
        for i in range(2, N+1):
            self.power[i] = (self.power[i-1]*i) % self.mod
        self.rev[N] = pow(self.power[N], self.mod-2, self.mod)
        for j in range(N, 0, -1):
            self.rev[j-1] = (self.rev[j]*j) % self.mod

    def com(self, K, R):
        if not (0 <= R <= K):
            return 0
        else:
            return ((self.power[K])*(self.rev[K-R])*(self.rev[R])) % self.mod

    def perm(self, K, R):
        if not (0 <= R <= K):
            return 0
        else:
            return (self.power[K])*(self.rev[K-R]) % self.mod

def bitcnt(X):
    res = 0
    v = X
    while v:
        res += v & 1
        v >>= 1
    return res

c = Combi(10000)
NL = list(map(int, list(input())))[::-1]
N = len(NL)
K = int(input())
MOD = 10**9 + 7

dp = [[0]*(1020) for i in range(1020)]

dp[0][0] = 1
for pos, bit in enumerate(NL):
    if bit == 1:
        for bit in range(1010):
            dp[pos + 1][bit] = (dp[pos][bit - 1] + c.com(pos, bit)) % MOD
        continue
    else:
        for bit in range(1010):
            dp[pos + 1][bit] = dp[pos][bit]
        continue

INF = 1 << 60
cnt = [INF]*(1010)

cnt[1] = 0
MOD = 10**9 + 7

for i in range(2, 1010):
    cnt[i] = 1 + cnt[bitcnt(i)]

if K == 0:
    print(dp[N][0])
    exit()
else:
    ans = 0
    for bitcnt in range(1010):
        if cnt[bitcnt] == K - 1:
            ans += dp[N][bitcnt]
    if K == 1:
        ans -= 1
    print(ans % MOD)
    exit()
",O(n)
"a=input()
b=input()
na=len(a)
nb=len(b)
def fs(a,b):
	try:
		for i in range(a+1,len(b)):
			if b[a]>b[i]:
				ans=b[i]
				k=b.copy()
				k.pop(i)
				ans+="""".join(k)
				return ans
		return False
	except:
		return False
if(na<nb):
	print("""".join(sorted(list(a),reverse=True)))
else:
	if(a==b):
		print(a)

	else:
		l=sorted(list(a),reverse=True)
		l2=l.copy()
		ans1=""""
		flag=0
		ans=[]
		for i in b:
			for j in range(len(l)):
				if i==l[j]:
					k=fs(j,l)
					if(k!=False):
						ans.append(ans1+fs(j,l))
					ans1+=l[j]
					l.pop(j)
					break
				if i>l[j]:
					ans1+=l[j]
					l.pop(j)
					flag=1
					break
			if(flag==1):
				break
		ans1+="""".join(l)
		if(int(ans1)<=int(b)):
			print(ans1)
		else:
			for i in sorted([int(i) for i in ans],reverse=True):
				if(i<=int(b)):
					print(i)
					break",O(n ^ 3)
"class Solution2(object):
    def moveSubTree(self, root, p, q):
        def iter_find_parents(node, parent, p, q, lookup):
            stk = [(1, [node, None])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, parent = params
                    if node in (p, q):
                        lookup[node] = parent
                        if len(lookup) == 2:
                            return
                    stk.append((2, [node, reversed(node.children)]))
                else:
                    node, it = params
                    child = next(it, None)
                    if not child:
                        continue
                    stk.append((2, [node, it]))
                    stk.append((1, [child, node]))

        def iter_is_ancestor(node, q):
            stk = [(1, [node])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node = params[0]
                    stk.append((2, [reversed(node.children)]))
                else:
                    it = params[0]
                    child = next(it, None)
                    if not child:
                        continue
                    if child == q:
                        return True
                    stk.append((2, [it]))
                    stk.append((1, [child]))
            return False

        lookup = {}
        iter_find_parents(root, None, p, q, lookup)
        if p in lookup and lookup[p] == q:
            return root
        q.children.append(p)
        if not iter_is_ancestor(p, q):
            lookup[p].children.remove(p)
        else:
            lookup[q].children.remove(q)
            if p == root:
                root = q
            else:
                lookup[p].children[lookup[p].children.index(p)] = q
        return root",O(n)
"import collections


class Solution(object):

    def __init__(self):
        _trie = lambda: collections.defaultdict(_trie)
        self.__root = _trie()


    def insert(self, key, val):
        curr = self.__root
        for c in key:
            curr = curr[c]
        delta = val
        if ""_end"" in curr:
            delta -= curr[""_end""]

        curr = self.__root
        for c in key:
            curr = curr[c]
            if ""_count"" in curr:
                curr[""_count""] += delta
            else:
                curr[""_count""] = delta
        curr[""_end""] = val


    def sum(self, prefix):
        curr = self.__root
        for c in prefix:
            if c not in curr:
                return 0
            curr = curr[c]
        return curr[""_count""]",O(n)
"import sys
input=sys.stdin.readline
def read():return list(map(int,input().split()))
n=int(input())
s=input()
t=input()
if sorted(s)!=sorted(t):
    print(-1)
    quit()
s=list(s)
t=list(t)
ans=[]
for i in range(n):
    for j in range(i,n-1):
        if s[j+1] == t[i]:
            for k in range(j,i-1,-1):
                ans.append(k+1)
                s[k+1], s[k] = s[k], s[k+1]
            break
print(len(ans))
print(*ans)",O(n ^ 2)
"class Solution(object):
    def canCompleteCircuit(self, gas, cost):
        start, total_sum, current_sum = 0, 0, 0
        for i in range(len(gas)):
            diff = gas[i] - cost[i]
            current_sum += diff
            total_sum += diff
            if current_sum < 0:
                start = i + 1
                current_sum = 0
        if total_sum >= 0:
            return start

        return -1",O(n)
"class Solution(object):
    def splitArray(self, nums):
        if len(nums) < 7:
            return False

        accumulated_sum = [0] * len(nums)
        accumulated_sum[0] = nums[0]
        for i in range(1, len(nums)):
            accumulated_sum[i] = accumulated_sum[i-1] + nums[i]
        for j in range(3, len(nums)-3):
            lookup = set()
            for i in range(1, j-1):
                if accumulated_sum[i-1] == accumulated_sum[j-1] - accumulated_sum[i]:
                    lookup.add(accumulated_sum[i-1])
            for k in range(j+2, len(nums)-1):
                if accumulated_sum[-1] - accumulated_sum[k] == accumulated_sum[k-1] - accumulated_sum[j] and \
                   accumulated_sum[k - 1] - accumulated_sum[j] in lookup:
                    return True
        return False",O(n ^ 2)
"parent = [i for i in range(int(1e5 + 2))]
def findSet(u):
    if parent[u] != u:
        parent[u] = findSet(parent[u])
    return parent[u]

def unionSet(u, v):
    up = findSet(u)
    vp = findSet(v)
    parent[up] = vp

if __name__ == '__main__':
    n, a, b = map(int, input().split())
    lst = list(map(int, input().split()))
    temp = {lst[i]: i for i in range(n)}
    for i in range(n):
        if a - lst[i] in temp:
            unionSet(i, temp[a - lst[i]])
        else:
            unionSet(i, n)
        if b - lst[i] in temp:
            unionSet(i, temp[b - lst[i]])
        else:
            unionSet(i, n + 1)

    pa = findSet(n)
    pb = findSet(n + 1)
    if pa == pb:
        print('NO')
    else:
        print('YES')
        lst = [0 if findSet(i) == pb else 1 for i in range(n)]
        print(*lst)",O(n)
"from sys import stdin

def solve(tc):
    k = int(stdin.readline().strip())
    cmp = 9
    ndigit = 1

    while k>(cmp*ndigit):
        k -= cmp*ndigit
        cmp *= 10
        ndigit += 1

    num = (10**(ndigit-1)) + ((k-1) // ndigit)
    pos = (k-1) % ndigit

    print(str(num)[pos])
    pass

LOCAL_TEST = not __debug__
if LOCAL_TEST:
    infile = __file__.split('.')[0] + ""-test.in""
    stdin = open(infile, 'r')

tcs = (int(stdin.readline().strip()) if LOCAL_TEST else 1)
tc = 1
while tc <= tcs:
    solve(tc)
    tc += 1",O(1)
"def palin(s):
    global ans
    if (s[::-1] != s or len(s) == 0):
        return len(s)
    else:
        return palin(s[1:])
s = input()
print(palin(s))",O(n)
"import itertools


class Solution(object):
    def maxCoins(self, piles):
        piles.sort()
        return sum(itertools.islice(piles, len(piles)//3, len(piles), 2))",O(nlogn)
"n, s = map(int, input().rstrip().split())
if n <= s:
    print(0)
    exit()
for i in range(s, n + 2):
    l = 0
    for j in str(i):
        l += int(j)
    if i - l >= s:
        break
print(max(n - i + 1, 0))",O(logn)
"from itertools import combinations
n,l,r,x=map(int,input().split())
arr=list(map(int,input().split()))
ans=0
for i in range(2,n+1):
	brr=list(combinations(arr,i))
	for j in brr:
		s=sum(j)
		if l<=s<=r and max(j)-min(j)>=x:
			ans+=1
print(ans)
",np
"k = int(input())

if k<=9:
    print(k)
else:
    num_arr = [9*(i+1)* 10**i for i in range(11)]

    index = 0

    while True:
        if k<=num_arr[index]:
            break
        else:
            k -= num_arr[index]
            index += 1

    digit = index+1
    k += digit-1

    num = k//digit
    offset = k%digit

    string_num = str(10**(digit-1)+ num-1)

    print(string_num[offset])
",O(logn)
"def flipH(A,N):
    B=[[0 for i in range(N)] for j in range(N)]
    for i in range(N):
        for j in range(N):
            B[i][j]=A[i][N-j-1]
    return B

def flipV(A,N):
    B=[[0 for i in range(N)] for j in range(N)]
    for i in range(N):
        for j in range(N):
            B[i][j]=A[N-i-1][j]
    return B

def rotate90(A):
    ans = zip(*A[::-1])
    ans=list(map(list,ans))
    return ans

def check(A,B,N):
    for i in range(N):
        for j in range(N):
            if A[i][j]!=B[i][j]:
                return False
    return True

N=int(input())
A=[]
X=[]
for i in range(N):
    A.append(list(input()))
for i in range(N):
    X.append(list(input()))
B=flipH(A,N)
C=flipV(A,N)
flag=False
for i in range(4):
    if check(A,X,N) or check(B,X,N) or check(C,X,N):
        flag=True
        break
    else:
        A=rotate90(A)
        B=rotate90(B)
        C=rotate90(C)
if flag:
    print(""Yes"")
else:
    print(""No"")",O(n ^ 2)
"from collections import Counter
n, k = map(int, input().split())
c = Counter(input())
ans = min(c[chr(ord('A') + i)] for i in range(k))
print(k * ans)
",O(n)
"class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        stack = [root]
        while stack:
            node = stack.pop()
            node.left, node.right = node.right, node.left
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
        return root
",O(n)
"from math import ceil
n=int(input())
if n<=9:
    print(n)
else:
    d=2
    ov=9
    while n>d*9*(10**(d-1))+ov:
        ov=d*9*(10**(d-1))+ov
        d+=1
    v=ceil((n-ov)/d)+int('9'*(d-1))
    print(str(v)[(n-ov-1)%d])",O(logn)
"class Solution(object):
    def fullJustify(self, words, maxWidth):
        def addSpaces(i, spaceCnt, maxWidth, is_last):
            if i < spaceCnt:
                return 1 if is_last else (maxWidth // spaceCnt) + int(i < maxWidth % spaceCnt)
            return 0

        def connect(words, maxWidth, begin, end, length, is_last):
            s = [] 
            n = end - begin
            for i in range(n):
                s += words[begin + i],
                s += ' ' * addSpaces(i, n - 1, maxWidth - length, is_last),
            line = """".join(s)
            if len(line) < maxWidth:
                line += ' ' * (maxWidth - len(line))
            return line

        res = []
        begin, length = 0, 0
        for i in range(len(words)):
            if length + len(words[i]) + (i - begin) > maxWidth:
                res += connect(words, maxWidth, begin, i, length, False),
                begin, length = i, 0
            length += len(words[i])

        res += connect(words, maxWidth, begin, len(words), length, True),
        return res",O(n)
"from collections import defaultdict
import sys
input = sys.stdin.readline

n, m = map(int, input().split())
p = list(map(int, input().split()))
x = [0] * (n + 1)
for i in range(n):
    if p[i] < m:
        x[i + 1] = -1
    elif p[i] > m:
        x[i + 1] = 1
    else:
        l = i
for i in range(1, n + 1):
    x[i] += x[i - 1]
cnt = [defaultdict(lambda : 0) for _ in range(2)]
for i in range(l + 1):
    cnt[i % 2][x[i]] += 1
ans = 0
for i in range(l + 1, n + 1):
    xi = x[i]
    ans += cnt[i % 2][xi - 1]
    ans += cnt[i % 2 ^ 1][xi]
print(ans)",O(nlogn)
"n = int(input())
l = list(map(int,input().split()))

l = set(l)
l = list(l)

if len(l)<=1:
    print(""NO"")
    exit()

l.sort()
print(l[1])",O(nlogn)
"from sys import stdin, stdout
input = stdin.readline

n,m,K = map(int,input().split())
edges = []
for i in range(n):
    edges.append([[]])
    lis = list(map(int,input().split()))
    for j in range(m-1):
        edges[i][j].append((1,0,lis[j]))
        edges[i].append([])
        edges[i][j+1].append((-1,0,lis[j]))
for i in range(n-1):
    lis = list(map(int,input().split()))
    for j in range(m):
        edges[i][j].append((0,1,lis[j]))
        edges[i+1][j].append((0,-1,lis[j]))

if K%2==1:
    lis = []
    for i in range(n):
        lis.append([-1]*m)
else:
    lis = []
    for i in range(n):
        lis.append([0]*m)

    for k in range(1,(K//2)+1):
        new_lis = []
        for i in range(n):
            new_lis.append([0]*m)
        for i in range(n):
            for j in range(m):
                dist = []
                for e in edges[i][j]:

                    dist.append(e[2] + lis[i+e[1]][j+e[0]])
                new_lis[i][j] = min(dist)
        lis = new_lis
    for i in range(n):
        for j in range(m):
            lis[i][j] *= 2

for i in lis:
    print(*i)",O(n ^ 3)
"n=int(input())
arr=list(map(int,input().split()))
gap=n//2
count =0
while gap >=1:
    for j in range(gap ,n):
        i= j-gap
        while i >=0:
            if arr[i +gap] >arr[i]:
                break
            else:
                arr[i +gap],arr[i] =arr[i] ,arr[i +gap]
                count +=1
            i-=gap
    gap//=2
if count % 2== 3*n %2:
    print(""Petr"")
else:
    print(""Um_nik"")",O(nlogn)
"ceil1 = lambda a, b: (a + b - 1) // b
n = int(input())
sq = int(n ** .5)
sq2, ans, cur = ceil1(n, sq), [], 0

for i in range(sq2 - 1):
    cur += sq
    ans.extend([x for x in range(cur, cur - sq, -1)])

ans.extend([x for x in range(n, cur, -1)])
print(' '.join(map(str, ans)))
",O(n)
"import sys, string

n, k = map(int, sys.stdin.readline().split())
arr = list(sys.stdin.readline().rstrip())
st = []
ans = []
for i in range(n):
    if k <= 0:
        break
    else:
        if arr[i] == '(':
            st.append((arr[i], i))
        else:
            if st and st[-1][0] == '(':
                k -= 2
                ans.append(st.pop())
                ans.append((arr[i], i))
            else:
                st.append((arr[i], i))

ans.sort(key=lambda x: x[1])
res = []
for i in ans:
    res.append(i[0])
print(''.join(res))",O(n)
"import math

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def calc(st,j):
    ans=9999999999999999999999

    if j>=len(st):
        return 0
    j=len(st)-j
    for i in range(j-1,len(st)):
        ans=min(ans,st[i]-st[i-j+1]+1)
    return ans
n,m,k=map(int,input().split())
s=[]
for i in range(n):
    s.append(input())
inf=99999999999999999999
dp=[[inf for i in range(k+1)]for j in range(n+1)]
for i in range(k+1):
    dp[0][i]=0
for i in range(1,n+1):
    st=[]
    for ik in range(len(s[i-1])):
        if s[i-1][ik]=='1':
            st.append(ik)
    for j in range(k+1):
        no=calc(st,j)

        for t in range(k+1-j):
            dp[i][t+j]=min(dp[i][t+j],no+dp[i-1][t])

print(dp[n][k])
",O(n ^ 3)
"a, b = map(int, input().split())
print((b+a-1)//a)
",O(1)
"class Solution(object):
    def plusOne(self, digits):
        for i in reversed(range(len(digits))):
            if digits[i] == 9:
                digits[i] = 0
            else:
                digits[i] += 1
                return digits
        digits[0] = 1
        digits.append(0)
        return digits",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")
def getint(): return int(input())
def getints(): return list(map(int, input().split()))
def getint1(): return list(map(lambda x: int(x) - 1, input().split()))

def main():
    a,b = getints()
    print(result(a,b))

def result(a,b):
    if a==0 or b==0:
        return 0
    if a>b:
        return a//b+result(a%b,b)
    else:
        return b//a+result(b%a,a)

if __name__ == ""__main__"":
    main()",O(1)
"T = int(input())

while (T != 0):
    T -= 1

    N, K = map(int, input().split())
    cur_usage = 0
    reslog = 0
    cnts = dict()

    while True:
        reslog += 1
        cur_usage +=  (1 << reslog) - 1
        if reslog != N:
            cnts[reslog] = (((1 << reslog)-2)<<1) + 1

        if cur_usage + (1 << (reslog+1))-1 > K or reslog == N:
            break

    K -= cur_usage

    while K > 0:
        if len(cnts) == 0:
            break
        for key in cnts:
            K -= cnts[key]
            if key+1 >= N:
                del cnts[key]
                break
            if (key+1 not in cnts):
                cnts[key+1] = 0
            cnts[key+1] += cnts[key] * 4
            del cnts[key]
            break

    if K <= 0:
        print('YES %d' % (N-reslog))
    else:
        print('NO')
",O(logn)
"n,m=map(int,input().split())
s=input()
t=input()
if n-1>m:
    print('NO')
else:
    try:
        a=s.index('*')
    except:
        a=-1
    if a==-1:
        if s==t:
            print('YES')
        else:
            print('NO')
    else:
        f=True
        for i in range(a):
            if s[i]!=t[i]:
                print('NO')
                exit()
        i=1
        while m-i>=a and n-i>a:
            if s[n-i]!=t[m-i]:
                print('NO')
                exit()
            i+=1
        print('YES')",O(n)
"import bisect


class Solution2(object):
    def smallerNumbersThanCurrent(self, nums):
        sorted_nums = sorted(nums)
        return [bisect.bisect_left(sorted_nums, i) for i in nums]",O(nlogn)
"class Solution2(object):
    def missingNumber(self, nums):
        return sum(range(len(nums)+1)) - sum(nums)",O(n)
"class Solution(object):
    def isPreorder(self, nodes):
        stk = [nodes[0][0]]
        for i in range(1, len(nodes)):
            while stk and stk[-1] != nodes[i][1]:
                stk.pop()                
            if not stk:
                return False            
            stk.append(nodes[i][0])            
        return True",O(n)
"import sys
import os
from io import IOBase, BytesIO

def main():
    n = int(input())
    arr = get_array()
    arr.sort()
    tmp = [-1] * n
    c = 1
    for i in range(n):
        if tmp[i] != -1:
            continue
        x = arr[i]
        for j in range(i, n):
            if arr[j] % x == 0:
                tmp[j] = c
        c += 1

    print(c - 1)

BUFSIZE = 8192

class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        py2 = round(0.5)
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2 == 1:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode(""ascii""))
            self.read = lambda: self.buffer.read().decode(""ascii"")
            self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def get_array():
    return list(map(int, sys.stdin.readline().split()))

def get_ints():
    return map(int, sys.stdin.readline().split())

def input():
    return sys.stdin.readline().strip()

if __name__ == ""__main__"":
    main()
",O(n ^ 2)
"import pandas as pd



def Solution(animals: pd.DataFrame) -> pd.DataFrame:
     return animals[animals['weight'] > 100].sort_values(by=""weight"", ascending=False)[['name']]",O(nlogn)
"import sys
def ask(x,y,rev):
	if (rev==0):
		print(""? %d %d""%(x,y))
	else:
		print(""? %d %d""%(y,x))
	sys.stdout.flush()
	if (rev==1):
		return -int(input())
	else:
		return int(input())

comp=ask(0,0,0)
nowa=0
nowb=0
rev=0
for i in range(29,-1,-1):
	if (comp<0):
		rev^=1
		nowa,nowb=nowb,nowa
		comp=-comp
	if comp>=0:
		comp=ask(nowa|(1<<i),nowb|(1<<i),rev)
		if (comp<0):
			nowa|=1<<i
			comp=ask(nowa,nowb,rev)
		else:
			tmp=ask(nowa|(1<<i),nowb,rev)
			if (tmp<0):
				nowa|=1<<i
				nowb|=1<<i
if (rev==1):
	nowa,nowb=nowb,nowa
print(""! %d %d""%(nowa,nowb))
",O(logn)
"class Solution(object):
    def arrayNesting(self, nums):
        result = 0
        for num in nums:
            if num is not None:
                start, count = num, 0
                while nums[start] is not None:
                    temp = start
                    start = nums[start]
                    nums[temp] = None
                    count += 1
                result = max(result, count)
        return result",O(n)
"import os
import sys

from collections import *

from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M=998244353
EPS=1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]

def ok(here):

    have = defaultdict(lambda : -1)
    for j in range(n):
        b = a[j]
        s = ''
        for i in b:
            if(i>=here): s+='1'
            else: s+='0'
        have[int(s,2)] = j

    for i in range(300):
        for j in range(300):
            if(i|j == 2**m-1 and have[i]!=-1 and have[j]!=-1): return (have[i]+1,have[j]+1)

    return -1

n,m = value()
a = []

for i in range(n): a.append(array())

low = 0
high = 10**9

while(low<=high):

    mid = low + (high - low)//2
    here = ok(mid)

    if(here != -1):
        ans = here
        low = mid+1
    else:
        high = mid - 1

print(*ans)
",np
"class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        l, r = 0, len(matrix) - 1
        while l < r:
            for i in range(r - l):
                top, bottom = l, r

                topLeft = matrix[top][l + i]

                matrix[top][l + i] = matrix[bottom - i][l]

                matrix[bottom - i][l] = matrix[bottom][r - i]

                matrix[bottom][r - i] = matrix[top + i][r]

                matrix[top + i][r] = topLeft
            r -= 1
            l += 1
",O(n ^ 2)
"n, q = map(int, input().split())
nums = list(map(int, input().split()))

m = max(nums)

ab = []
while nums[0] < m:
    ab.append([nums[0], nums[1]])
    nums.append(nums.pop(1)) if nums[0]>nums[1] else nums.append(nums.pop(0))

for i in range(q):
    mj = int(input())
    a, b = map(str, ab[mj-1] if mj <= len(ab) else (m, nums[(mj-len(ab)-1)%(len(nums)-1) +1]))
    print(a + "" "" + b)
",O(n)
"a, b, c, n = [int(j) for j in input().split()]
a -= c
b -= c
if n - a - b - c >= 1 and a >= 0 and b >= 0:
    print(n - a - b - c)
else:
    print(-1)
",O(1)
"n, k = map(int,input().split())

start = 0
cnt = n
cur = 1

while start <= k:
    start += cur
    cnt -= 1
    cur += 1

ans = 0

if start != k:
    while cnt > 0:
        if start == k:
            start += cur
            cur += 1
            cnt -= 1
        ans += (start - k)
        cnt -= (start - k)
        start = k

print(ans)
",O(logn)
"n, pos, l, r = map(int,input().split())
step, dif = 0, lambda a, b : abs(a - b)

if dif(pos, l) < dif(pos, r):
	if l != 1:
		step += dif(pos, l) + 1
		pos = l
	if r != n:
		step += dif(pos, r) + 1
else:
	if r != n:
		step += dif(pos, r) + 1
		pos = r
	if l != 1:
		step += dif(pos, l) + 1
print(step)
",O(1)
"class Solution:
    def findMin(self, nums: List[int]) -> int:
        res = nums[0]
        l, r = 0, len(nums) - 1

        while l <= r:
            if nums[l] < nums[r]:
                res = min(res, nums[l])
                break

            m = (l + r) // 2
            res = min(res, nums[m])
            if nums[m] >= nums[l]:
                l = m + 1
            else:
                r = m - 1
        return res
",O(logn)
"class Solution2(object):

    def __init__(self):
        self.__books = []


    def book(self, start, end):
        i = bisect.bisect_left(self.__books, (start, 1))
        if i < len(self.__books) and self.__books[i][0] == start:
            self.__books[i] = (self.__books[i][0], self.__books[i][1]+1)
        else:
            self.__books.insert(i, (start, 1))

        j = bisect.bisect_left(self.__books, (end, 1))
        if j < len(self.__books) and self.__books[j][0] == end:
            self.__books[j] = (self.__books[j][0], self.__books[j][1]-1)
        else:
            self.__books.insert(j, (end, -1))

        result, cnt = 0, 0
        for book in self.__books:
            cnt += book[1]
            result = max(result, cnt)
        return result",O(n ^ 2)
"class Solution(object):
    def isWinner(self, player1, player2):
        k = 2
        def f(arr):
            result = cnt = 0
            for i in range(len(arr)):
                result += 2*arr[i] if cnt else arr[i]
                cnt += (arr[i] == 10)
                if i-k >= 0:
                    cnt -= (arr[i-k] == 10)
            return result

        a, b = f(player1), f(player2)
        return 1 if a > b else 2 if a < b else 0",O(n)
"import sys
import math
input = sys.stdin.readline
from functools import cmp_to_key;

def pi():
    return(int(input()))
def pl():
    return(int(input(), 16))
def ti():
    return(list(map(int,input().split())))
def ts():
    s = input()
    return(list(s[:len(s) - 1]))
def invr():
    return(map(int,input().split()))
mod = 1000000007;
f = [];
def fact(n,m):
    global f;
    f = [1 for i in range(n+1)];
    f[0] = 1;
    for i in range(1,n+1):
        f[i] = (f[i-1]*i)%m;

def fast_mod_exp(a,b,m):
    res = 1;
    while b > 0:
        if b & 1:
            res = (res*a)%m;
        a = (a*a)%m;
        b = b >> 1;
    return res;

def inverseMod(n,m):
    return fast_mod_exp(n,m-2,m);

def ncr(n,r,m):
    if n < 0 or r < 0 or r > n: return 0;
    if r == 0: return 1;
    return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m;

def main():
    C();

def D():
    [n,m,k] = ti();
    w = [[] for i in range(n)];
    for i in range(n):
        w[i] = ts();

    mn = [[0 for j in range(k+1)] for i in range(n+1)];
    for i in range(1,n+1):
        for j in range(k+1):
            c = 0;
            st,en = -1,-1;
            for x in range(m):
                if w[i-1][x] == '1':
                    if c == j and st == -1: st = x;
                    if c < j: c += 1;
                    if c == j: en = x;
            mn[i][j] = en-st+1 if st != -1 and en != -1 else 0;
            st,en = -1,-1;
            c = 0;
            for x in range(m-1,-1,-1):
                if w[i-1][x] == '1':
                    if c == j and st == -1: st = x;
                    if c < j: c += 1;
                    if c == j: en = x;
            if st != -1 and en != -1 >= 0:
                mn[i][j] = min(mn[i][j], st-en+1);

    dp = [[9999999999999999 for j in range(k+1)] for i in range(n+1)];
    for i in range(k+1):
        dp[0][i] = 0;
    for i in range(1,n+1):
        for j in range(k+1):
            for x in range(k+1):
                if j-x >= 0:
                    dp[i][j] = min(dp[i][j], dp[i-1][j-x]+mn[i][x]);

    print(dp[n][k]);

def C():
    n = pi();
    s = [];
    mxI = 0;
    for i in range(n):
        c = input();
        s.append(c[:len(c)-1]);
        if s[len(s)-1] == 'f': mxI += 1;
    dp = [[0 for j in range(mxI+1)] for i in range(n)];
    dp[0][0] = 1;
    preSum = [1 for i in range(mxI+1)];
    pre = 1;
    for i in range(1,n):
        sm = 0;
        pre = 0;
        for j in range(mxI+1):
            if s[i-1] == 'f':
                dp[i][j] = dp[i-1][j-1]%mod;
            else:
                dp[i][j] = (preSum[mxI]%mod-(pre if j != 0 else 0)%mod)%mod;
            pre = preSum[j];
            preSum[j] = ((preSum[j-1] if j != 0 else 0)%mod+dp[i][j]%mod)%mod;

    print(preSum[mxI]%mod);

main();",O(n ^ 2)
"q=input().split()

x=int(q[0])
k=int(q[1])

def po(a,p,m):
 if p==0:
  return 1
 x=po(a,p//2,m)%m
 x=(x%m*x%m)%m
 if p%2==1:
  x=(x%m*a%m)%m

 return int(x)

m=1000000007
if x==0:
 print(0)
else:
 print(((po(2,k+1,m)%m*x%m)%m-(po(2,k,m)%m-1)%m)%m)",O(logn)
"n = int(input())
flag = True
l , r = list(map(int,input().split())) , list(map(int,input().split()))
ans , check_l , check_r = [n for i in range(n)] , [0 for i in range(n)] , [0 for i in range(n)]
for i in range(n):
    ans[i] -= l[i]+r[i]
for i in range(n):
    cl , cr = 0 , 0
    for j in range(i):
        if ans[j] > ans[i]:
            cl += 1
    for j in range(i+1,n):
        if ans[j] > ans[i]:

            cr += 1

    if cl != l[i] or cr!=r[i]:
        flag = False
        break
mini = min(ans) - 1
for i in range(n):
    ans[i] -= mini

if flag:
    print(""YES"")
    for i in ans:
        print(i,end= ' ')
else:
    print(""NO"")",O(n ^ 2)
"a0 = (1 << 30) - 1

a0 = 3
b0 = 1

def mock_query(c, d):
    res = (a0 ^ c) - (b0 ^ d)
    if res > 0:
        return 1
    elif res < 0:
        return -1
    else:
        return 0

def query2(c, d):
    ans = mock_query(c, d)
    print('? {:08b} {:08b} --> {}'.format(c, d, ans))
    return ans

def query(c, d):
    print('?', c, d)
    return int(input())

def solve():
    a = 0
    b = 0
    last_ans = query(0, 0)

    pos = 29
    while pos >= 0:
        bit = 1 << pos

        ans = query(a + bit, b + bit)
        if (last_ans, ans) == (1, -1):
            a += bit
            last_ans = query(a, b)
        elif (last_ans, ans) == (-1, 1):
            b += bit
            last_ans = query(a, b)

        else:
            last_ans = ans
            ans = query(a + bit, b)
            if ans == -1:
                a += bit
                b += bit

        pos -= 1

    print('!', a, b)

solve()
",O(logn)
"n, v = map(int, input().strip().split())
answer = 0
n -= 1
if n <= v:
    print(n)
else:
    answer =v

    for i in range(1,n-v + 1):

        answer += (i + 1)
    print(answer)",O(n)
"a, b, c, n = map(int, input().split())
t = a+b-c
if c > a or c > b:
    print(-1)
    exit()
if n-t >= 1:
    print(n-t)
else:
    print(-1)
",O(1)
"class Solution2(object):
    def longestPalindrome(self, s):
        def expand(s, left, right):
            while left >= 0 and right < len(s) and s[left] == s[right]:
                left -= 1
                right += 1
            return (right-left+1)-2
        
        left, right = -1, -2
        for i in range(len(s)):
            l = max(expand(s, i, i), expand(s, i, i+1))
            if l > right-left+1:
                right = i+l//2
                left = right-l+1
        return s[left:right+1] if left >= 0 else """"",O(n ^ 2)
"mod = 1000000000+7
def fp(x ,y):
    if y == 1:
        return x
    if y == 0:
        return 1
    t = fp(x,y//2)%mod
    if y%2 == 1:
        return (t*t*x)
    else:
        return (t*t)

def inv(x):
    return fp(x%mod,mod-2)%mod

n,k=list(map(int,input().split()))
if not n:
    print(0)
    exit()
if not k:
    print( (2*n)%mod )
    exit()
numberOfPro =fp(2,k)
last = n*numberOfPro
first = (n-1)*numberOfPro+1
sumOfLast = (last)*(last+1)*inv(2)
sumOfFirst = first*(first-1)*inv(2)
num = 2*(sumOfLast - sumOfFirst)*inv(numberOfPro)
print(num%mod)
",O(logn)
"import sys
import math
input=sys.stdin.readline
a=list(input())
b=list(input())
x=a.count('+')-b.count('+')
y=a.count('-')-b.count('-')
if x<0 or y<0:
    print(0)
else:
    fact=math.factorial(x+y)/(math.factorial(x)*math.factorial(y))
    total=2**(x+y)
    print(fact/total)
",np
"

class Solution(object):
    def constructTransformedArray(self, nums):
        return [nums[(i+nums[i])%len(nums)] for i in range(len(nums))]
",O(n)
"import sys
reader = (s.rstrip() for s in sys.stdin)
inp = reader.__next__

n, m = map(int, inp().split())
arr = tuple(tuple(map(int, inp().split())) for i in range(n))
lower_bound = 0
upper_bound = int(1e9) + 1
mask = (1 << m) - 1

ans = (0, 0)

def can_upper(mid):
	global ans

	d = dict()
	for i in range(n):
		bit = 0
		for j in range(m):
			if arr[i][j] >= mid:
				bit += 1 << j
		d[bit] = i

	keys = tuple(d.keys())
	for i in range(len(keys)):
		a1 = keys[i]
		for j in range(i, len(keys)):
			a2 = keys[j]
			if a1 | a2 == mask:
				ans = (d[a1], d[a2])
				return True
	return False

while upper_bound - lower_bound > 1:
	middle = (upper_bound + lower_bound) >> 1
	if can_upper(middle):
		lower_bound = middle
	else:
		upper_bound = middle

print(ans[0] + 1, ans[1] + 1)",np
"from collections import deque

class Solution(object):

    def __init__(self):
        self.__k = 300
        self.__dq = deque()
        self.__count = 0

    def hit(self, timestamp):
        self.getHits(timestamp)
        if self.__dq and self.__dq[-1][0] == timestamp:
            self.__dq[-1][1] += 1
        else:
            self.__dq.append([timestamp, 1])
        self.__count += 1

    def getHits(self, timestamp):
        while self.__dq and self.__dq[0][0] <= timestamp - self.__k:
            self.__count -= self.__dq.popleft()[1]
        return self.__count",O(1)
"import heapq



class Solution(object):
    def findMaxSum(self, nums1, nums2, k):
        result = [0]*len(nums1)
        min_heap = []
        idxs = list(range(len(nums1)))
        idxs.sort(key=lambda x: nums1[x])
        total = j = 0
        for i in range(len(idxs)):
            while nums1[idxs[j]] < nums1[idxs[i]]:
                total += nums2[idxs[j]]
                heapq.heappush(min_heap, nums2[idxs[j]])
                if len(min_heap) == k+1:
                    total -= heapq.heappop(min_heap)
                j += 1
            result[idxs[i]] = total            
        return result",O(nlogn)
"class Solution5(object):
    def rotate(self, nums, k):
        while k > 0:
            nums.insert(0, nums.pop())
            k -= 1",O(n)
"class Solution2(object):
    def numberOfSubstrings(self, s):
        result, left, count = 0, 0, [0]*3
        for right, c in enumerate(s):
            count[ord(s[right])-ord('a')] += 1
            while all(count):
                count[ord(s[left])-ord('a')] -= 1
                left += 1
            result += left
        return result",O(n)
"n,s=map(int,input().split())
x=s//n
if x*n<s:
    x+=1
print(x)",O(1)
"class Solution(object):
    def mostPoints(self, questions):
        dp = [0]*(len(questions)+1)
        for i in reversed(range(len(dp)-1)):
            dp[i] = max(dp[i+1], questions[i][0] + (dp[i+1+questions[i][1]] if i+1+questions[i][1] < len(dp) else 0))
        return dp[0]",O(n)
"import sys
input = sys.stdin.readline

n = int(input())
a = list(map(int,input().split()))

dp = [[1000]*(n+1) for i in range(n+1)]
val = [[0]*(n+1) for i in range(n+1)]

for i in range(n):
    dp[i][i+1] = 1
    val[i][i+1] = a[i]

for p in range(2,n+1):
    for i in range(n-p+1):
        j = i+p
        for k in range(i+1,j):
            if dp[i][k] == dp[k][j] == 1 and val[i][k] == val[k][j]:
                dp[i][j] = 1
                val[i][j] = val[i][k] + 1
            else:
                dp[i][j] = min(dp[i][j] , dp[i][k]+dp[k][j])
print(dp[0][n])
",O(n ^ 3)
"from sys import setcheckinterval,stdin
setcheckinterval(1000)

iin=lambda :int(stdin.readline())
lin=lambda :list(map(int,stdin.readline().split()))

n,q=lin()
a=lin()
if q==0:
    exit()
Q=[iin() for i in range(q)]
sq=set(Q)
mx=max(Q)
d=dict()
ch=1
for i in range(min(mx,n+1)):
    if ch==n:
        ch=1
    if i+1 in sq:d[i+1]=[a[0],a[ch]]
    if a[0]<a[ch]:
        a[0],a[ch]=a[ch],a[0]
    ch+=1

for i in Q:
    if i>n:
        x=n-1 if i%(n-1)==0 else i%(n-1)
        print(a[0],a[x])
    else:
        print(*d[i])
",O(n)
"class Solution(object):
    def truncateSentence(self, s, k):
        for i in range(len(s)):
            if s[i] == ' ':
                k -= 1
                if not k:
                    return s[:i]
        return s",O(n)
"class Solution(object):
    def makeIntegerBeautiful(self, n, target):
        total, m = 0, n
        while m:
            total += m%10
            m //= 10
        m, l = n, 0
        while total > target:
            while True:
                total -= m%10
                m //= 10
                l += 1
                if m%10 != 9:
                    break
            total += 1
            m += 1
        return m*10**l-n",O(logn)
"from collections import defaultdict

data = defaultdict(list)
position = defaultdict()
nxt = defaultdict()
agg_sum = list()

k = int(input())
trace = defaultdict()
F = [False for x in range(1 << k)]
back = [0 for x in range(1 << k)]
total_sum = 0
res = [(0, 0) for x in range(k)]

def build_mask(trace_mask):
    if trace_mask == 0:
        return

    if trace.get(trace_mask):
        for data in trace.get(trace_mask):
            fr, to, v = data
            res[fr] = (v, to)
        return

    sub_mask = back[trace_mask]
    build_mask(sub_mask)
    build_mask(trace_mask - sub_mask)

if __name__ == '__main__':
    for i in range(k):
        values = list(map(int, input().split(' ')))
        data[i] = values[1:]

        agg_sum.append(sum(data[i]))
        total_sum += agg_sum[i]

        for cnt, v in enumerate(data[i], 0):
            position[v] = (i, cnt)

    if total_sum % k != 0:
        print(""No"")
        exit(0)

    row_sum = total_sum // k

    for i in range(k):
        for cnt, value in enumerate(data.get(i), 0):

            x = i
            y = cnt
            mask = (1 << x)
            could = True
            circle = list()
            while True:
                next_value = row_sum - agg_sum[x] + data.get(x)[y]
                if position.get(next_value) is None:
                    could = False
                    break

                last_x = x
                last_y = y

                x, y = position.get(next_value)
                circle.append((x, last_x, next_value))

                if x == i and y == cnt:
                    break

                if mask & (1 << x):
                    could = False
                    break

                mask |= (1 << x)

            F[mask] |= could
            if could:
                trace[mask] = circle

    for mask in range(1, 1 << k):
        sub = mask
        while sub > 0:
            if F[sub] and F[mask - sub]:
                F[mask] = True
                back[mask] = sub
                break
            sub = mask & (sub - 1)

    if F[(1 << k) - 1]:
        print('Yes')
        build_mask((1 << k) - 1)
        for value in res:
            print(value[0], value[1] + 1)
    else:
        print('No')
",np
"k = int(input())
prev=0
nextt=0
NumofDigits=0

while(True):
    prev = nextt
    nextt = nextt+(9*(10**(NumofDigits-1))*NumofDigits)
    if(k>= prev and k<=nextt):
        break
    NumofDigits=NumofDigits+1
if(NumofDigits==1):
    print(k)
else:
    result = (10**(NumofDigits-1))+int((k-(prev+1))/NumofDigits)
    i=0
    while(True):
        if (k-int(prev+1))%NumofDigits == i:
            break
        i=i+1
    result = str(result)
    print(result[i])",O(1)
"def main():
    n = int(input())
    arr = []

    for i in range(n):
        arr.append(input())

    arr = sorted(arr, key=lambda x : len(x))

    for i in range(n-1):
        if arr[i] not in arr[i+1]:
            print('NO')
            return;

    print('YES')
    for pal in arr:
        print(pal)

main()
",O(nlogn)
"def checksq(n):
    m = int(n**0.5)
    if m * m == n:
        return m
    m += 1
    if m * m == n:
        return m
    return -1

def main():

    n = int(input())

    if n % 2 == 1:
        print(""NO"")
        return
    if checksq(n // 2) != -1:
        print('YES')
        return
    n //= 2
    if n % 2 == 1:
        print('NO')
        return
    if checksq(n // 2) != -1:
        print('YES')
    else:
        print('NO')

for i in range(int(input())):
    main()",O(1)
"class SegmentTree:
    def __init__(self, N, A):
        self.n = N
        while (self.n & (self.n - 1)) != 0:
            self.n += 1
        self.build(N, A)

    def build(self, N, A):
        self.tree = [float('-inf')] * (2 * self.n)
        for i in range(N):
            self.tree[self.n + i] = A[i]
        for i in range(self.n - 1, 0, -1):
            self.tree[i] = max(self.tree[i << 1], self.tree[i << 1 | 1])

    def query(self, l, r):
        res = float('-inf')
        l += self.n
        r += self.n + 1
        while l < r:
            if l & 1:
                res = max(res, self.tree[l])
                l += 1
            if r & 1:
                r -= 1
                res = max(res, self.tree[r])
            l >>= 1
            r >>= 1
        return res

class Solution:
    def maxSlidingWindow(self, nums, k):
        n = len(nums)
        segTree = SegmentTree(n, nums)
        output = []
        for i in range(n - k + 1):
            output.append(segTree.query(i, i + k - 1))
        return output
",O(nlogn)
"class Solution(object):
    def dailyTemperatures(self, temperatures):
        result = [0] * len(temperatures)
        stk = []
        for i in range(len(temperatures)):
            while stk and \
                  temperatures[stk[-1]] < temperatures[i]:
                idx = stk.pop()
                result[idx] = i-idx
            stk.append(i)
        return result",O(n)
"
class Solution(object):
    def reverseWords(self, s):
        return ' '.join(reversed(s.split()))

",O(n)
"n = int(input())

r = []
for _ in range(n):
    a,b,c,d = map(int,input().split())
    r.append(sum([a,b,c,d]))

thomas = r[0]
print(sorted(r, reverse=True).index(thomas)+1)
",O(n)
"import sys
input = sys.stdin.readline

from collections import deque
N, Q = map(int, input().split())
que = deque([int(a) for a in input().split()])
ma = max(que)

X = []
k = -1
c = 0
while c <= k+N+5:
    a = deque.popleft(que)
    b = deque.popleft(que)

    X.append((a, b))
    c += 1
    if a > b:
        a, b = b, a
    if k < 0 and b == ma:
        k = c
    deque.appendleft(que, b)
    deque.append(que, a)

for _ in range(Q):
    i = int(input()) - 1
    if i <= k:
        print(*X[i])
    else:
        i = (i-k)%(N-1)+k
        print(*X[i])
",O(n)
"n,k = [int(s) for s in input().split()]
p = [int(s) for s in input().split()]

map = {}
res = []

for pi in p:
    if map.get(pi) is None:
        key = pi
        for j in range(pi, pi-k, -1):
            if j < 0: break
            if map.get(j) is None:
                key = j
            else:
                if map[j] >= pi-k+1: key = map[j]
                break
        for j in range(pi, key-1, -1):
            if map.get(j):
                break
            map[j] = key
    res.append(map[pi])

print(*res, sep="" "")
",O(n ^ 2)
"rgb = 'RGB' * 1000
for q in range(int(input())):
    n, k = [int(s) for s in input().split()]
    s = input()
    ans = 3000
    for w in range(3):
        for e in range(n - k + 1):
            temp = 0
            for i in range(k):
                if s[e + i] != rgb[w + i]:
                    temp += 1
            ans = min(ans, temp)
    print(ans)",O(n ^ 2)
"import sys,os,io
from sys import stdin
import math
from collections import defaultdict
from heapq import heappush, heappop, heapify
from bisect import bisect_left , bisect_right
from io import BytesIO, IOBase
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

alphabets = list('abcdefghijklmnopqrstuvwxyz')

from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)

    return list(set(l))

def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res

def sieveForSmallestPrimeFactor():
    MAXN = 100001
    spf = [0 for i in range(MAXN)]
    spf[1] = 1
    for i in range(2, MAXN):
        spf[i] = i
    for i in range(4, MAXN, 2):
        spf[i] = 2
    for i in range(3, math.ceil(math.sqrt(MAXN))):
        if (spf[i] == i):
            for j in range(i * i, MAXN, i):
                if (spf[j] == j):
                    spf[j] = i
    return spf
def getPrimeFactorizationLOGN(x):
    spf = sieveForSmallestPrimeFactor()
    ret = list()
    while (x != 1):
        ret.append(spf[x])
        x = x // spf[x]
    return ret

def SieveOfEratosthenes(n):

    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def si():
    return input()
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"")
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
    input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def has(x,bit):
    return x&(1<<bit)

def solve():
    l,r = li()
    bit = 62
    while bit>=0 and has(l,bit)==has(r,bit):
        bit-=1
    print(2**(bit+1)-1)

t = 1

for _ in range(t):
    solve()
",O(logn)
"import sys
input=sys.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
from queue import PriorityQueue as pq
n=int(input())
if n<=5:
    print(-1)
else:
    for i in range(2,5):
        print(1,i)
    for i in range(5,n+1):
        print(2,i)
for i in range(2,n+1):
    print(1,i)",O(n)
"class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        n = len(gas)
        start, end = n - 1, 0
        tank = gas[start] - cost[start]
        while start > end:
            if tank < 0:
                start -= 1
                tank += gas[start] - cost[start]
            else:
                tank += gas[end] - cost[end]
                end += 1
        return start if tank >= 0 else -1
",O(n)
"a=int(input())
z=list(map(int,input().split()))
ans=[]
k=len(z)
for i in range(len(z)):
    if((z[i]-i)%len(z)==0):
        ans.append((z[i]-i)//k)
    else:
        ans.append((z[i]-i)//k)
        ans[-1]+=1
t=min(ans)
print(ans.index(t)+1)
",O(n)
"def prime(n):
    j = 3
    while j * j <= n:
        if n % j == 0:
            return False
        j += 2
    return True
ref = [2]
for j in range(3, 1000, 2):
    if prime(j) == True:
        ref.append(j)
def check(n):
    for j in range(1, len(ref) - 1):
        v = n - ref[j] - 1
        if ref[j - 1] == v or ref[j + 1] == v:
            return True
        if j > n:
            break
    return False
arr = []
for j in range(3, 1001, 2):
    if prime(j) == True and check(j) == True:
        arr.append(j)
n, k = [int(j) for j in input().split()]
count = 0
for j in range(2, n + 1):
    if j in arr:
        count += 1
if count >= k:
    print(""YES"")
else:
    print(""NO"")
",O(n)
"import sys
from math import sqrt, gcd, ceil, log, floor
from bisect import bisect, bisect_left
from collections import defaultdict, Counter, deque
from heapq import heapify, heappush, heappop
input = sys.stdin.readline
read = lambda: list(map(int, input().strip().split()))

MOD = 10**9 + 7

def main():

	r, g, b = read()
	r_ar=sorted(read(), reverse = True); g_ar = sorted(read(), reverse = True); b_ar = sorted(read(), reverse = True)
	N = 201
	dp = [[[-1]*N for i in range(N)]for j in range(N)]

	def f(x, y, z):

		if ((x >= r) + (y >= g) + (z >= b)) >= 2:
			return(0)
		if dp[x][y][z] != -1:
			return(dp[x][y][z])
		maxi = 0
		if x < r and y < g:
			maxi = max(maxi, r_ar[x]*g_ar[y] + f(x+1, y+1, z))
		if z < b and y < g:
			maxi = max(maxi, b_ar[z]*g_ar[y] + f(x, y+1, z+1))
		if x < r and z < b:
			maxi = max(maxi, r_ar[x]*b_ar[z] + f(x+1, y, z+1))
		dp[x][y][z] = maxi
		return(maxi)
	print(f(0, 0, 0))

if __name__ == ""__main__"":
	main()",O(n ^ 3)
"import operator
from functools import reduce


class Solution2(object):
    def xorOperation(self, n, start):
        return reduce(operator.xor, (i for i in range(start, start+2*n, 2)))",O(n)
"class Solution(object):
    def isSumEqual(self, firstWord, secondWord, targetWord):
        def stoi(s):
            result = 0
            for c in s:
                result = result*10 + ord(c)-ord('a')
            return result
        
        return stoi(firstWord) + stoi(secondWord) == stoi(targetWord)",O(n)
"def solve():
    num_pixels, max_group_size = (int(x) for x in input().split())
    pixels = [int(x) for x in input().split()]
    groups = [None for _ in range(256)]

    for pixel in pixels:
        if groups[pixel] is None:
            smallest_of_group = pixel
            while smallest_of_group >= 0 and smallest_of_group > pixel - max_group_size and groups[smallest_of_group] is None:
                smallest_of_group -= 1

            if smallest_of_group >= 0 and groups[smallest_of_group] is not None and pixel - groups[smallest_of_group] + 1 <= max_group_size:
                group_color = groups[smallest_of_group]
            else:
                group_color = smallest_of_group + 1
            smallest_of_group += 1
            for color in range(smallest_of_group, pixel + 1):
                groups[color] = group_color

    print(*(groups[pixel] for pixel in pixels))

solve()
",O(n ^ 2)
"n=int(input())
li=list(map(int,input().split("" "")))
dp1=[]
for i in range(n):
  lis=[-1]*n
  dp1.append(lis)
dp2=[0]*n
for i in range(n):
  dp1[i][i]=li[i]

for i in range(n):
  dp2[i]=i+1
size=2

while size<=n:
  i=0
  while i<n-size+1:
    j=i+size-1
    k=i
    while k<j:
      if dp1[i][k]!=-1:
        if dp1[i][k]==dp1[k+1][j]:
          dp1[i][j]=dp1[i][k]+1
      k+=1
    i+=1
  size+=1

i=0
while i<n:
  k=0
  while k<=i:
    if dp1[k][i]!=-1:
      if k==0:
        dp2[i]=1
      else:
        dp2[i]=min(dp2[i],dp2[k-1]+1)
    k+=1
  i+=1

print(dp2[n-1])
",O(n ^ 3)
"N, K= map(int, input().split())
Rcnt = N * 2
Gcnt = N * 5
Bcnt = N * 8

res = (Rcnt + K - 1) // K + (Gcnt + K - 1) //K + (Bcnt + K -1 ) // K
print(res)
",O(1)
"def number(pos):
    ans = 0
    for i in range(pos + 1):
        ans += 2**(i)
    return ans

l, r = input().split()
l = int(l)
r = int(r)

if(l == r):
    print(0)
else:
    b_pos = 0
    i = 0
    while(l > 0 or r > 0):
        if(l%2 != r%2):
            b_pos = i
        l >>= 1
        r >>= 1
        i += 1
    print(number(b_pos))
",O(logn)
"class Solution(object):
    def findWinningPlayer(self, skills, k):
        result = cnt = 0
        for i in range(1, len(skills)):
            if skills[result] < skills[i]:
                result = i
                cnt = 0
            cnt += 1
            if cnt == k:
                return result
        return result",O(n)
"def iskoutsu(arr):
	return len(set(arr)) == 1

def isshuntsu(arr):
	nos = [int(ele[0]) for ele in arr]
	nos.sort()
	return nos[0]+1 == nos[1] and nos[1]+1 == nos[2] and len(set([ele[1] for ele in arr])) == 1

arr = input().strip().split()
if isshuntsu(arr) or iskoutsu(arr):
	exit(print(0))

total1 = 0
if len(set(arr)) == 3:
	total1 = 2
elif len(set(arr)) == 2:
	total1 = 1

total2 = 2
for ele in arr:
	no, suite = int(ele[0]), ele[1]

	if no+2 <= 9:
		required = [str(no+1)+suite, str(no+2)+suite]
		curr = int(required[0] not in arr) + (required[1] not in arr)
		total2 = min(total2, curr)

	if no+1 <= 9 and no-1 >= 0:
		required = [str(no-1)+suite, str(no+1)+suite]
		curr = int(required[0] not in arr) + (required[1] not in arr)
		total2 = min(total2, curr)

	if no+2 <= 9:
		required = [str(no-1)+suite, str(no-2)+suite]
		curr = int(required[0] not in arr) + (required[1] not in arr)
		total2 = min(total2, curr)

print(min(total1, total2))",O(nlogn)
"n = int(input())
for _ in range(n):
    l, r = map(int, input().split())
    if (l - r) % 2 == 1:
        if l % 2:
            print((r-l+1)//2)
        else:
            print(-((r-l+1)//2))
    else:
        ans = 0
        if l % 2:
            ans = ans + (r-l)//2
        else:
            ans = ans + -(r-l)//2
        if r % 2:
            ans = ans - r
        else:
            ans = ans + r
        print(ans)",O(1)
"t = input().split()

t.sort()

if t.count(t[0]) == 3:
  print('0')
elif t.count(t[0]) == 2 or t.count(t[1]) == 2:
  print('1')
else:
  num = list(map(int, [t[0][0], t[1][0], t[2][0]]))
  suit = [t[0][1], t[1][1], t[2][1]]
  if len(set(suit)) == 3:
    print('2')
  elif len(set(suit)) == 1:
    if num[1] == num[0] + 1 or num[2] == num[1] + 1:
      if num[2] == num[0] + 2:
        print('0')
      else:
        print('1')
    elif num[1] == num[0] + 2 or num[2] == num[1] + 2:
        print('1')
    else:
      print('2')
  else:
    if suit[0] == suit[1]:
      if num[1] - num[0] in [1, 2]:
        print('1')
      else:
        print('2')
    elif suit[1] == suit[2]:
      if num[2] - num[1] in [1, 2]:
        print('1')
      else:
        print('2')
    else:
      if num[2] - num[0] in [1, 2]:
        print('1')
      else:
        print('2')",O(nlogn)
"from sys import stdin, setrecursionlimit, stdout

from collections import deque
from math import sqrt, floor, ceil, log, log2, log10, pi, gcd, sin, cos, asin
from heapq import heapify, heappop, heappush, heapreplace, heappushpop
from bisect import bisect_right, bisect_left
def ii(): return int(stdin.readline())
def fi(): return float(stdin.readline())
def mi(): return map(int, stdin.readline().split())
def fmi(): return map(float, stdin.readline().split())
def li(): return list(mi())
def si(): return stdin.readline().rstrip()
def lsi(): return list(si())
mod=1000000007
res=['NO', 'YES']

aa=[9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, 9999999999]
a=[9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889]

test=1
test_case=1
while test<=test_case:
    test+=1

    n=ii()
    if n in a:
        n=9
    if n<10:
        print(n)
        exit()
    x=1
    while a[x]<n:
        x+=1
    v=n-a[x-1]
    z=v//(x+1)
    z+=aa[x-1]
    v%=x+1

    if not v:
        p=z%10
    else:
        z+=1
        p=int(str(z)[v-1])
    print(p)",O(logn)
"import sys
sys.setrecursionlimit(int(1e7))

def main():
    n = int(input().strip())
    print(2*(n*(n-1))+1)
    return

while 1:
    try: main()
    except EOFError: break",O(1)
"class Solution(object):
    def smallestSubarrays(self, nums):
        result = [0]*len(nums)
        lookup = [-1]*max(max(nums).bit_length(), 1)
        for i in reversed(range(len(nums))):
            for bit in range(len(lookup)):
                if nums[i]&(1<<bit):
                    lookup[bit] = i
            result[i] = max(max(lookup)-i+1, 1)
        return result",O(n)
"import os,sys
from io import BytesIO,IOBase

def count(x):
    ans = 0
    while x:
        x &= x-1
        ans += 1
    return ans

def main():
    n = int(input())
    a = [list(map(float,input().split())) for _ in range(n)]
    y = 1<<n
    dp = [0]*(y-1)+[1]
    powe = [1<<i for i in range(n)]
    for i in range(y-1,0,-1):
        bit = count(i)
        prob = bit*(bit-1)//2
        for j in range(n):
            if not i&powe[j]:
                continue
            for x in range(n):
                if not i&powe[x]:
                    continue
                dp[i-powe[x]] += dp[i]*a[j][x]*prob
                dp[i-powe[j]] += dp[i]*a[x][j]*prob
    z = sum(dp[1<<i] for i in range(n))
    for i in range(n):
        print(dp[1<<i]/z,end=' ')
    print()

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")
sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",np
"if __name__==""__main__"":
    dic={}
    n,m=map(int,input().split())
    li=list(map(int,input().split()))
    c=0
    for i in range(n):
        dic.setdefault(i+1,0)
    for i in li:
        if 0 not in dic.values():
            c=c+1
            for j in range(1,n+1):
                dic[j]=dic[j]-1

        dic[i]=dic[i]+1
    if 0 not in dic.values():
        c=c+1
    print(c)
",O(n ^ 2)
"import os,sys
from io import BytesIO, IOBase

from collections import deque, Counter,defaultdict as dft
from heapq import heappop ,heappush
from math import log,sqrt,factorial,cos,tan,sin,radians,log2,ceil,floor
from bisect import bisect,bisect_left,bisect_right
from decimal import *
import sys,threading
from itertools import permutations, combinations
from copy import deepcopy
input = sys.stdin.readline

ii = lambda: int(input())
si = lambda: input().rstrip()
mp = lambda: map(int, input().split())
ms=  lambda: map(str,input().strip().split("" ""))
ml = lambda: list(mp())
mf = lambda: map(float, input().split())

alphs = ""abcdefghijklmnopqrstuvwxyz""

def solve():

    def seq(nd,i):
        case=0
        vis[nd]=1
        for lnk in d[nd]:

            if not vis[lnk]:
                i,case=seq(lnk,i)
                if case:return i,case
            else:
                if lnk not in seen:

                    case=1
                    break

        order[i]=nd
        seen.add(nd)

        return i-1,case

    def chk(word,dct,i):
        if i==k:
            res.append(dct['
        else:
            if word[i] in dct:
                chk(word,dct[word[i]],i+1)
            if '_' in dct:
                chk(word,dct['_'],i+1)

    n,m,k=map(int,input().split())
    trie={}
    global case
    case=0
    for i in range(n):
        word=input()
        dct=trie
        for w in word:
            if w not in dct:
                dct[w]={}
            dct=dct[w]
        dct['
    d=dft(list)
    for i in range(m):

        word,idx=input().split()
        idx=int(idx)
        res=[]
        chk(word,trie,0)

        temp=0
        for num in res:
            if num!=idx:
                d[idx].append(num)
            else:
                temp=1
        if not temp:
            case=1

    order=[0]*(n+1)
    vis=[0]*(n+1)
    seen=set()
    idx=n

    for i in range(1,n+1):
        if not vis[i]:
            idx,tp=seq(i,idx)
            if tp:
                case=1
                break

    if case:
        print(""NO"")
    else:
        print(""YES"")
        print(*order[1:])

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

def print(*args, **kwargs):

    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()

if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    tc=1

    for i in range(tc):
    	solve()",np
"class Solution(object):
    def minDeletion(self, nums):
        result = 0
        for i in range(len(nums)-1):
            result += int(i%2 == result%2 and nums[i] == nums[i+1])
        return result+(len(nums)-result)%2",O(n)
"import collections



class Solution(object):
    def maxFreq(self, s, maxLetters, minSize, maxSize):
        M, p = 10**9+7, 113
        power, rolling_hash = pow(p, minSize-1, M), 0

        left = 0
        lookup, count = collections.defaultdict(int), collections.defaultdict(int)
        for right in range(len(s)):
            count[s[right]] += 1
            if right-left+1 > minSize:
                count[s[left]] -= 1
                rolling_hash = (rolling_hash - ord(s[left])*power) % M
                if count[s[left]] == 0:
                    count.pop(s[left])
                left += 1
            rolling_hash = (rolling_hash*p + ord(s[right])) % M
            if right-left+1 == minSize and len(count) <= maxLetters:
                lookup[rolling_hash] += 1
        return max(list(lookup.values()) or [0])",O(n)
"import itertools


class Solution(object):
    def knightDialer(self, N):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) % M \
                     for col in ZB] for row in A]
        
        M = 10**9 + 7
        T = [[0, 0, 0, 0, 1, 0, 1, 0, 0, 0],
             [0, 0, 0, 0, 0, 0, 1, 0, 1, 0],
             [0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
             [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],
             [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
             [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
             [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],
             [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
             [0, 1, 0, 1, 0, 0, 0, 0, 0, 0],
             [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]]
        return sum(map(sum, matrix_expo(T, N-1))) % M",O(logn)
"x, k = list(map(int,input().split()))
m = 10**9 + 7
if x==0:
    print(0)
else:
    print((pow(2,k+1,m)*x - pow(2,k,m)+1) % m)",O(logn)
"class BIT:

    __all__ = ['add', 'sumrange', 'lower_left']

    def __init__(self, maxsize=10**7):
        assert (maxsize > 0)

        self._n = maxsize+1
        self._bitdata = [0]*(maxsize+1)

    def add(self, i, x):

        assert(0 <= i < self._n)

        pos = i+1
        while pos < self._n:
            self._bitdata[pos] += x
            pos += pos&(-pos)

    def running_total(self, i):

        assert (-1<= i < self._n)

        if i == -1:
            return 0
        returnval = 0
        pos = i+1
        while pos:
            returnval += self._bitdata[pos]
            pos -= pos & (-pos)
        return returnval

    def sumrange(self, lo=0, hi=None):

        if lo < 0:
            raise ValueError('lo must be non-negative')
        if hi is None:
            hi = self._n

        return self.running_total(hi) - self.running_total(lo-1)

    def lower_left(self, total):

        if total < 0:
            return -1
        pos = 0
        k = 1<<(self._n.bit_length()-1)
        while k > 0:
            if pos+k < self._n and self._bitdata[pos+k] < total:
                total -= self._bitdata[pos+k]
                pos += k
            k //= 2
        return pos
def tentousu(lis):
  bit = BIT()
  ans = 0
  for i in range(len(lis)):
      bit.add(lis[i], 1)
      ans += i + 1 - bit.running_total(lis[i])
  return ans
N=int(input())
L=list(map(int,input().split()))
a=tentousu(L)
a%=2
if N%2==0 and a%2==0:
  print(""Petr"")
if N%2==0 and a%2==1:
  print(""Um_nik"")
if N%2==1 and a%2==0:
  print(""Um_nik"")
if N%2==1 and a%2==1:
  print(""Petr"")
",O(nlogn)
"def min_sub_array(day, k):
    if not day:
        return [0] * (k + 1)
    n = len(day)
    best = [float('inf')] * (n + 1)
    best[0] = 0
    best[1] = 1
    for size in range(2, n + 1):
        for i in range(n + 1 - size):
            best[size] = min(best[size], day[i + size - 1] - day[i] + 1)
    output = [0] * (k + 1)
    for i in range(k + 1):
        if n - i > 0:
            output[i] = best[n - i]
    return output

N, M, K = map(int, input().split())

day = [i for i, val in enumerate(input()) if val == '1']
best = min_sub_array(day, K)

for _ in range(N - 1):
    day = [i for i, val in enumerate(input()) if val == '1']
    new_day_best = min_sub_array(day, K)

    new_best = [float('inf')] * (K + 1)
    for i in range(K + 1):
        for j in range(i + 1):
            new_best[i] = min(new_best[i], new_day_best[j] + best[i - j])
    best = new_best
print(best[K])
",O(n ^ 3)
"n, m = map(int, input().split())
c = list(map(int, input().split()))
a = list(map(int, input().split()))

ans = 0
i = 0
for bill in a:
    try:
        i += next(ind for ind, el in enumerate(c[i:]) if el <= bill) + 1
        ans += 1
    except StopIteration:
        break

print(ans)
",O(n)
"class Solution(object):
    def findLatestTime(self, s):
        result = list(s)
        if result[0] == '?': 
            result[0] = '1' if result[1] == '?' or result[1] <= '1' else '0'
        if result[1] == '?': 
            result[1] = '1' if result[0] == '1' else '9'
        if result[3] == '?':
            result[3] = '5'
        if result[4] == '?':
            result[4] = '9'
        return """".join(result)",O(1)
"n,m = map(int,input().split())
final = []
for i in range(n):
    a,b = map(int,input().split())
    final.append([a,b])
final.sort(key = lambda x: x[0]-x[1])
s1 = 0
s2 = 0
for i in final:
    s2+=i[1]
    s1+=i[0]
if s2>m:
    print(-1)
else:
    if s1<=m:
        print(0)
    else:
        i = n-1
        count = 0
        while s1>m:
            s1 = s1 - (final[i][0]-final[i][1])
            count+=1
            i-=1
        print(count)
",O(nlogn)
"from math import ceil
def test(f):
    for i in range(n):
        if (r1+ f) > f * lift[i]:
            return 0
        f -= (r1 + f) / lift[i]
        if (r1+ f) > f * land[i + 1]:
            return 0
        f -= (r1 + f) / land[i + 1]
    return 1
p=int(input())
total_wgt=int(input());r1=total_wgt
lift=list(map(int,input().split()))
land=list(map(int,input().split()));n=len(land);ans=1e20
lift+=[lift[0]];land+=[land[0]]
l=0.0;r=1e20
for i in range(1000):
  mid=(l+r)/2.0

  if test(mid):r=mid
  else:l=mid
if r<1e19:
    print('%.17f' %r)
else:
    print(-1)
",O(n)
"s=input()
length=len(s)
answer=[ ]
for i in range (0,length):
    for j in range(i+1,length+1):
        k=s[i:j]
        co=0
        for u in range (0,length):
            if(s[u:].startswith(k)):
                co+=1
        if(co>=2):

            answer.append(len(k))
if(len(set(s))==length):
    print('0')
else:
    print(max(answer))
",O(n ^ 3)
"import itertools
n,l,r,x=map(int,input().split())
problems=[int(x) for x in input().split()]
result=0
for i in range(2,n+1):
    for comb in itertools.combinations(problems,i):
        summ = sum(comb)
        mini = min(comb)
        maxx = max(comb)
        if l <= summ <=r and maxx-mini>=x:
            result+=1
print(result)
",np
"f = lambda c: 'mps'.index(c)
l = [[], [], []]
for c in input().split():
    a, b = c
    l[f(b)].append(int(a))
for i in range(3):
    l[i].sort()

res = 3
for x in l:
    if len(x) == 0: continue
    elif len(x) == 1: res = min(res, 2)
    elif len(x) == 3:
        if len(set(x)) == 1:
            res = min(res, 0)
            break
        if x[0] == x[1] - 1 and x[1] == x[2] - 1:
            res = min(res, 0)
            break
    res = min(res, 2)
    for i in range(len(x)):
        for j in range(i + 1, len(x)):
            if abs(x[i] - x[j]) <= 2:
                res = min(res, 1)
print(res)",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase
import math as M
import itertools as ITR
from collections import defaultdict as D
from collections import Counter as C
from collections import deque as Q
import threading
from functools import lru_cache, reduce
from functools import cmp_to_key as CMP
from bisect import bisect_left as BL
from bisect import bisect_right as BR
import random as R
import string
import cmath, time

enum = enumerate
start_time = time.time()

MOD = 1_00_00_00_007
MA = float(""inf"")
MI = float(""-inf"")

di8 = ((1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1))

di4 = ((1, 0), (0, 1), (-1, 0), (0, -1))

def increase_stack():
    sys.setrecursionlimit(2 ** 32 // 2 - 1)
    threading.stack_size(1 << 27)

def binary(n):
    return bin(n)[2:]

def decimal(s):
    return int(s, 2)

def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return p

def maxfactor(n):
    q = []
    for i in range(1, int(n ** 0.5) + 1):
        if n % i == 0:
            q.append(i)
    if q:
        return q[-1]

def factors(n):
    q = []
    for i in range(1, int(n ** 0.5) + 1):
        if n % i == 0:
            q.append(i)
            q.append(n // i)
    return list(sorted(list(set(q))))

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(M.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n = n / i
    if n > 2:
        l.append(int(n))
    l.sort()
    return l

def isPrime(n):
    if n == 1:
        return False
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if n % i == 0:
                return False
        return True

def seive(n):
    a = []
    prime = [True for i in range(n + 1)]
    p = 2
    while p * p <= n:
        if prime[p] == True:
            for i in range(p ** 2, n + 1, p):
                prime[i] = False
        p = p + 1
    for p in range(2, n + 1):
        if prime[p]:
            a.append(p)
    prime[0] = prime[1] = False
    return a, prime

def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(M.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)

def countchar(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if s[i] == ch:
            c += 1
        else:
            break
    return c

def str_counter(a):
    q = [0] * 26
    for i in range(len(a)):
        q[ord(a[i]) - 97] = q[ord(a[i]) - 97] + 1
    return q

def lis(arr):
    n = len(arr)
    lis = [1] * n
    maximum = 0

    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
                maximum = max(maximum, lis[i])
    return maximum

def lcm(arr):
    a = arr[0]
    val = arr[0]

    for i in range(1, len(arr)):

        gcd = gcd(a, arr[i])
        a = arr[i]
        val *= arr[i]

    return val // gcd

def ncr(n, r):
    return M.factorial(n) // (M.factorial(n - r) * M.factorial(r))

def npr(n, r):
    return M.factorial(n) // M.factorial(n - r)

def IF(c, t, f):
    return t if c else f

def YES(c):
    print(IF(c, ""YES"", ""NO""))

def Yes(c):
    print(IF(c, ""Yes"", ""No""))

def yes(c):
    print(IF(c, ""yes"", ""no""))

def JA(a, sep="" ""):
    print(sep.join(map(str, a)))

def JAA(a, s=""\n"", t="" ""):
    return s.join(t.join(map(str, b)) for b in a)

def PS(a, s="" ""):
    print(str(a), end=s)

def I():
    return int(inp())

def F():
    return float(inp())

def LI():
    return list(map(int, inp().split()))

def LF():
    return list(map(float, inp().split()))

def MATI(n):
    return [LI() for i in range(n)]

def MATS(n):
    return [list(inp()) for i in range(n)]

def IV():
    return map(int, inp().split())

def FV():
    return map(float, inp().split())

def LS():
    return list(inp())

def S():
    return inp()

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
inp = lambda: sys.stdin.readline().rstrip(""\r\n"")

TestCases = 0

def solve():
    a, b = IV()

    if b - a + 1 < 3:
        print(""-1"")

    elif a % 2 == 0:
        print(a, a + 1, a + 2)

    elif b - a + 1 > 3:
        print(a + 1, a + 2, a + 3)
    else:
        print(-1)

def main():
    flag = 1

    try:
        sys.stdin = open(
            ""c:/Users/Manoj Chowdary/Documents/python/CodeForces/contest-div-2/input.txt"",
            ""r"",
        )
        sys.stdout = open(
            ""c:/Users/Manoj Chowdary/Documents/python/CodeForces/contest-div-2/output.txt"",
            ""w"",
        )
    except:
        flag = 0

    t = 1
    if TestCases:
        t = I()
    for _ in range(1, t + 1):
        solve()

    if flag:
        print(""Time: %.4f sec"" % (time.time() - start_time))
        localtime = time.asctime(time.localtime(time.time()))
        print(localtime)
        sys.stdout.close()

if __name__ == ""__main__"":

    main()",O(1)
"class Solution(object):
    def checkIfPangram(self, sentence):
        return len(set(sentence)) == 26",O(n)
"import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

INF = 10**9

n, m = [int(item) for item in input().split()]
s = input().rstrip()

count = [[0] * m for _ in range(m)]
ord_a = ord(""a"")
for c1, c2 in zip(s, s[1:]):
    c1 = ord(c1) - ord_a
    c2 = ord(c2) - ord_a
    if c1 != c2:
        count[c1][c2] += 1

sum_of_subset = [[0] * (1 << m) for _ in range(m)]
for i in range(m):
    for j in range(1 << m):
        if j == 0:
            continue
        lsb = j & -j
        sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]

adj_in_subset = [0] * (1 << m)
for i in range(1 << m):
    for j in range(m):
        if i & (1 << j):
            adj_in_subset[i] += sum_of_subset[j][i]

total_adj = adj_in_subset[-1]
dp = [INF] * (1 << m)
dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if i & 1 << j:
            continue
        cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]
        dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + cost)
print(dp[-1])",np
"from sys import stdin,stdout
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):
    n=nmbr()
    l=sorted(zip(lst(),range(n)))
    p=0;ans=[0]*(2*n)
    st=[0]*n;ln=0
    s=input()
    for i in range(2*n):
        ch=s[i]
        if ch=='0':
            st[ln]=p
            ans[i]=l[p][1]+1
            ln+=1
            p+=1
        else:
            ans[i]=l[st[ln-1]][1]+1
            ln-=1
    print(*ans)
",O(nlogn)
"a = list(map(int, input().split()))
b = list(map(int, input().split()))
a1 = min(a[::2])
b1 = max(a[::2])
c1 = min(a[1::2])
d1 = max(a[1::2])
g  = sum(b[::2]) / 4
h  = sum(b[1::2]) / 4
r  = abs(b[0] - g) + abs(b[1] - h)
for i in range(a1, b1+1) :
    for j in range(c1, d1+1) :
        if abs(i-g) + abs(j-h) <= r:
            print(""YES"")
            exit()
print(""NO"")
",O(1)
"a = input()
b = input()

length_of_a = len(a)
length_of_b = len(b)
found_digit = False
chk_finnish = False
appended_digit_count = 0
n = {}
num = []
for i in range(0,10):
	n[i] = 0

for i in range(0,length_of_a):
	c = int(a[i])
	n[c] += 1

if length_of_a < length_of_b:
	num = sorted(a,reverse=True)
	for i in range(0,length_of_a):
		print(num[i],end="""")
else:
	for i in range(0,length_of_b):
		digit = int(b[i])
		if n[digit] > 0:
			num.append(digit)
			n[digit] -= 1

			appended_digit_count += 1
		else:
			j = digit - 1
			while j > -1:
				if n[j] > 0:
					num.append(j)
					appended_digit_count += 1
					n[j] -= 1

					found_digit = True
					chk_finnish = True
					break
				j -= 1

			if found_digit:
				j = 9
				while j > -1:
					if n[j] > 0:
						digit_count = n[j]
						for k in range(0,digit_count):
							num.append(j)
							n[j] -= 1

							appended_digit_count += 1
					j -= 1
				if chk_finnish:
					break
			else:
				found_digit = False
				while found_digit == False:
					pop_up = num[appended_digit_count-1]

					del num[-1]
					j = pop_up - 1
					n[pop_up] += 1

					appended_digit_count -= 1
					while j > -1:
						if n[j] > 0:
							num.append(j)
							appended_digit_count += 1
							n[j] -= 1

							found_digit = True
							break
						j -= 1
				j = 9
				while j > -1:
					if n[j] > 0:

						digit_count = n[j]
						for k in range(0,digit_count):
							num.append(j)
							appended_digit_count += 1
					j -= 1
				break

	for i in range(0,length_of_b):
		print(num[i],end="""")",O(n ^ 3)
"r,g, b = map(int,input().split())
R = sorted([*map(int,input().split())],reverse=True)
G= sorted([*map(int,input().split())],reverse=True)
B = sorted([*map(int,input().split())],reverse=True)
mem = [[[-1 for i in range(201)] for j in range(201)] for j in range(201)]
def dp(i,j,k):
    p = (i==r)+(j==g)+(k==b)
    if(p>1):
        return 0
    if(mem[i][j][k]!=-1):
        return mem[i][j][k]
    ans = 0
    if(i==r):
        ans = dp(i,j+1,k+1)+G[j]*B[k]
        return ans
    elif(j==g):
        ans = dp(i+1,j,k+1)+R[i]*B[k]
    elif(k==b):
        ans = dp(i+1,j+1,k)+R[i]*G[j]
    else:
        ans = max(dp(i+1,j+1,k)+R[i]*G[j],dp(i,j+1,k+1)+G[j]*B[k],dp(i+1,j,k+1)+R[i]*B[k])
    mem[i][j][k] = ans
    return ans
print(dp(0,0,0))",O(n ^ 3)
"t=int(input())
for _ in range(t):
  n,k=map(int,input().split())
  if n==2 and k==3:
    print('NO')
    continue
  if n<=100:
    curr=0
    for j in range(n):
      curr+=pow(4,j)
    if curr<k:
      print('NO')
      continue
  curr=0
  ans=0
  while curr<k and ans<n:
    ans+=1
    curr+=pow(2,ans)-1
  if curr>k:
    ans-=1
  print('YES',n-ans)",O(logn)
"import sys
import math
from math import *
from collections import Counter,defaultdict
from io import BytesIO, IOBase
from collections import deque

def rec(i,j,k):
	if (i == rl and j == bl) or (i == rl and k == gl) or (k == gl and j == bl):
		return 0
	if dp[i][j][k] != -1:
		return dp[i][j][k]
	else:
		x = r[i]*b[j]
		y = b[j]*g[k]
		z = r[i] * g[k]
		if x>0:
			x += rec(i+1,j+1,k)
		if y>0:
			y += rec(i,j+1,k+1)
		if z>0:
			z += rec(i+1,j,k+1)

		dp[i][j][k] = max(x,y,z)
		return dp[i][j][k]

def main():
	global r,g,b,rl,bl,gl,dp

	rl,bl,gl = list(map(int, input().split()))
	r = list(map(int, input().split())) + [0]
	b = list(map(int, input().split())) + [0]
	g = list(map(int, input().split())) + [0]
	cnt =3
	i =j = k = 0
	ans = 0
	dp=[[[-1 for i in range(gl+1)] for j in range(bl+1)]for k in range(rl+1)]
	r.sort(reverse = True)
	b.sort(reverse = True)
	g.sort(reverse = True)

	print(rec(i,j,k))

main()",O(n ^ 3)
"class Solution(object):
    def countOperationsToEmptyArray(self, nums):
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        return len(idxs)+sum(len(idxs)-(i+1) for i in range(len(idxs)-1) if idxs[i] > idxs[i+1])",O(nlogn)
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

INF=999999999999999999999999
alphabets=""abcdefghijklmnopqrstuvwxyz""
class SortedList:
    def __init__(self, iterable=[], _load=200):

        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):

        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):

        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):

        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):

        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):

        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):

        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):

        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):

        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):

        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):

        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):

        return self._len

    def __getitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):

        return (value for _list in self._lists for value in _list)

    def __reversed__(self):

        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):

        return 'SortedList({0})'.format(list(self))

class SegTree:

    def __init__(self, n):
        self.N = 1 << n.bit_length()
        self.tree = [0] * (self.N<<1)

    def update(self, i, j, v):
        i += self.N
        j += self.N
        while i <= j:
            if i%2==1: self.tree[i] += v
            if j%2==0: self.tree[j] += v
            i, j = (i+1) >> 1, (j-1) >> 1

    def query(self, i):
        v = 0
        i += self.N
        while i > 0:
            v += self.tree[i]
            i >>= 1
        return v

def SieveOfEratosthenes(limit):

    isPrime = [True]*(limit+1)
    isPrime[0] = isPrime[1] = False
    primes = []
    for i in range(2, limit+1):
        if not isPrime[i]:continue
        primes += [i]
        for j in range(i*i, limit+1, i):
            isPrime[j] = False
    return primes

def main():

    mod=1000000007

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc = 1
    for _ in range(tc):
        a,b=ria()
        op=0
        while min(a,b):
            if a>b:
                op+=a//b
                a%=b
            else:
                op+=b//a
                b%=a

        wi(op)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(1)
"class Solution4(object):
    def lastMarkedNodes(self, edges):
        def increase(x):
            return (x[0]+1, x[1])

        def iter_dfs1():
            dp = [[(0, u)]*2 for u in range(len(adj))]
            stk = [(1, (0, -1))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p = args
                    stk.append((2, (u, p, 0)))
                elif step == 2:
                    u, p, i = args
                    if i == len(adj[u]):
                        continue
                    stk.append((2, (u, p, i+1)))
                    v = adj[u][i]
                    if v == p:
                        continue
                    stk.append((3, (v, u)))
                    stk.append((1, (v, u)))
                elif step == 3:
                    v, u = args
                    curr = increase(dp[v][0])
                    for i in range(len(dp[u])):
                        if curr > dp[u][i]:
                            curr, dp[u][i] = dp[u][i], curr
            return dp

        def iter_dfs2():
            result = [-1]*len(adj)
            stk = [(0, -1, (0, -1))]
            while stk:
                u, p, curr = stk.pop()
                result[u] = max(dp[u][0], curr)[1]
                for v in reversed(adj[u]):
                    if v == p:
                        continue
                    stk.append((v, u, increase(max(dp[u][dp[u][0][1] == dp[v][0][1]], curr))))
            return result
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = iter_dfs1()
        return iter_dfs2()",O(n)
"class Solution(object):
    def alternatingSubarray(self, nums):
        result = l = -1
        for i in range(len(nums)-1):
            if l != -1 and nums[i-1] == nums[i+1]:
                l += 1
            else:
                l = 2 if nums[i+1]-nums[i] == 1 else -1
            result = max(result, l)
        return result",O(n)
"n = int(input())
a = n * (n + 1) // 2
print(4 * a - 4 * n + 1)",O(1)
"class Solution(object):
    def smallestEvenMultiple(self, n):
        return n<<(n&1)",O(1)
"n, k = map(int, input().split())
a = list(map(int, input().split()))
ans = a[-1] - a[0]
delta = [-a[i] + a[i - 1] for i in range(1, n)]
delta.sort()
ans += sum(delta[:(k-1)])
print(ans)",O(nlogn)
"l = []
a, b = map(int, input().split())
l.append((a,b))
a, b = map(int, input().split())
l.append((a,b))
a, b = map(int, input().split())
l.append((a,b))
l.sort()
path = []
path.append(l[0])
x = l[0][0]
while(x<l[1][0]):
	path.append((x, l[0][1]))
	x = x + 1
up = False
if(l[0][1]<l[1][1]):

	up = True
if(up):
	y = l[0][1]
	while(y<=l[1][1]):
		path.append((l[1][0], y))
		y = y+1
else:
	y = l[0][1]
	while(y>=l[1][1]):
		path.append((l[1][0], y))
		y = y-1
up = False
if(l[1][1]<l[2][1]):
	up = True
if(up):
	y = l[1][1]
	while(y<=l[2][1]):
		path.append((l[1][0], y))
		y = y+1
else:
	y = l[1][1]
	while(y>=l[2][1]):
		path.append((l[1][0], y))
		y = y-1
x = l[1][0]
while(x<l[2][0]):
	path.append((x, l[2][1]))
	x = x + 1
path.append(l[2])
path = list(set(path))
print(len(path))
for i in range(len(path)):
	print(str(path[i][0])+"" ""+str(path[i][1]))
",O(1)
"a = list(input())
a = [int(x) for x in a]

b = list(input())
b = [int(x) for x in b]

n = len(a)
m = len(b)

ans = 0
for i in range(n):
    ans+=a[i]^b[i]
ones = [0 for i in range(m)]
zeros = [0 for i in range(m)]

for i in range(m):
    if b[i]:
        ones[i]=1
    else:
        zeros[i]=1

for i in range(1,m):
    ones[i]+=ones[i-1]
    zeros[i]+=zeros[i-1]

for i in range(n):
    if a[i]==1:
        ans+=zeros[m-n+i]-zeros[i]
    else:
        ans+=ones[m-n+i]-ones[i]
print(ans)
",O(n)
"import collections


class Solution(object):
    def distinctNumbers(self, nums, k):
        result = []
        count = collections.Counter()
        for i, num in enumerate(nums):
            count[num] += 1
            if i >= k:
                count[nums[i-k]] -= 1
                if not count[nums[i-k]]:
                    del count[nums[i-k]]
            if i+1 >= k:
                result.append(len(count))
        return result",O(n)
"class Solution(object):
    def findPeaks(self, mountain):
        return [i for i in range(1, len(mountain)-1) if mountain[i-1] < mountain[i] > mountain[i+1]]",O(n)
"n=int(input())
a=list(map(int,input().split()))
st=[a[0]]
for i in range(1,n):
    if len(st)>0 and st[-1]%2==a[i]%2:
        st.pop()
    else:
        st.append(a[i])
if len(st)<=1:
    print(""YES"")
else:
    print(""NO"")
",O(n)
"class Solution(object):
    def reverseStr(self, s, k):
        s = list(s)
        for i in range(0, len(s), 2*k):
            s[i:i+k] = reversed(s[i:i+k])
        return """".join(s)",O(n)
"class Solution(object):
    def xorOperation(self, n, start):
        def xorNums(n, start):
            def xorNumsBeginEven(n, start):
                assert(start%2 == 0)
                return ((n//2)%2)^((start+n-1) if n%2 else 0)

            return start^xorNumsBeginEven(n-1, start+1) if start%2 else xorNumsBeginEven(n, start)
        
        return int(n%2 and start%2) + 2*xorNums(n, start//2)",O(1)
"x, k = map(int, input().split())
mod = 10**9+7
if x==0:
    print(0)
else:
    p = pow(2, k, mod)
    res = (((2*x)%mod + mod - 1)%mod)
    res = ((res*p)%mod + 1)%mod
    print(res)
",O(logn)
"class Solution(object):
    def checkValid(self, matrix):
        return all(len(set(row)) == len(matrix) for row in matrix) and all(len(set(matrix[i][j] for i in range(len(matrix)))) == len(matrix) for j in range(len(matrix[0])))",O(n ^ 2)
"N = int(input())
A = [int(i) for i in input().split()]
A.sort()
duplicates = 0
i=1
temp = 1
ind = -1
while i<N:
    temp = 1
    while i<N and A[i] == A[i-1]:
        ind = i-1
        temp +=1
        i+=1
    i+=1

    if temp != 1: duplicates +=1
    if temp > 2 :
        break

turns =  sum(A) - N*(N-1)//2

if temp>2 or duplicates>1: print('cslnb')

else:
    output = 'cslnb'
    if duplicates == 0:
        if turns%2 == 1: output = 'sjfnb'
    else:
        if ind-1 >= 0:
            if A[ind-1] == A[ind]-1:
                output = 'cslnb'
            else:
                if turns%2 == 1: output = 'sjfnb'
        else:
            if A[ind] == 0:
                output = 'cslnb'
            else:
                if turns%2 == 1: output = 'sjfnb'
    print(output)
",O(nlogn)
"class Solution3(object):
    def maxIncreasingGroups(self, usageLimits):
        def check(l):
            curr = 0
            for i in range(l):
                curr += usageLimits[~i]-(l-i)
                curr = min(curr, 0)
            for i in range(len(usageLimits)-l):
                curr += usageLimits[i]
            return curr >= 0

        usageLimits.sort()
        left, right = 1, len(usageLimits)
        while left <= right:
            mid = left + (right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right",O(nlogn)
"n = int(input())
a = [int(x) for x in input().split()]
h = [-1]*(n)
b = [(a[i],i) for i in range(n)]
b.sort(reverse=True)
for e in b:

	num,idx = e
	flag = True
	allNeg = True
	foundLosing = False
	foundWin = False
	for i in range(idx%num,n,num):

		if i == idx:
			continue
		if h[i]!= -1:
			allNeg = False
		if h[i] == 0:
			foundLosing = True
			break
		if h[i] == 1:
			foundWin = False
	if allNeg:
		h[idx] = 0
	elif foundLosing:
		h[idx] = 1
	else:
		h[idx] = 0

for i in range(n):
	if h[i]==0:
		print('B',end='')
	else:
		print('A',end='')
",O(n ^ 2)
"n = int(input())
p = [0,0] + [int(w) for w in input().split()]
d = [0] * (n+1)

for i in range(n, 1, -1):
    if d[i] == 0:
        d[i] = 1
    d[p[i]] += d[i]
if n == 1:
    d[1] = 1
d = d[1:]
d.sort()
print(*d)",O(n)
"n=int(input())
a=list(map(int,input().split()))
p=0
while p+1<len(a) and a[p]==a[p+1]:
    p+=2
c=0
while p<len(a):
    if p+1<len(a):
        i=a.index(a[p],p+1)
        c+=i-p-1
        tmp=a.pop(i)
        a.insert(p,tmp)
    while p+1<len(a) and a[p]==a[p+1]:
        p+=2
print(c)",O(n ^ 2)
"class Solution(object):
    def pushDominoes(self, dominoes):
        force = [0]*len(dominoes)

        f = 0
        for i in range(len(dominoes)):
            if dominoes[i] == 'R':
                f = len(dominoes)
            elif dominoes[i] == 'L':
                f = 0
            else:
                f = max(f-1, 0)
            force[i] += f

        f = 0
        for i in reversed(range(len(dominoes))):
            if dominoes[i] == 'L':
                f = len(dominoes)
            elif dominoes[i] == 'R':
                f = 0
            else:
                f = max(f-1, 0)
            force[i] -= f

        return """".join('.' if f == 0 else 'R' if f > 0 else 'L'
                       for f in force)",O(n)
"class Solution(object):
    def minimumLevels(self, possible):
        prefix = [0]*(len(possible)+1)
        for i in range(len(possible)):
            prefix[i+1] = prefix[i]+(+1 if possible[i] else -1)
        return next((i+1 for i in range(len(possible)-1) if prefix[i+1] > prefix[-1]-prefix[i+1]), -1)",O(n)
"n=int(input())
if(n>=0):
    print(n)
else:
    n=abs(n)
    rem=n%10
    n1=n//10
    n2=n1//10
    n2=n2*10+rem
    k=min(n1,n2)
    print(-1*k)
",O(1)
"k1,k2,k3 = map(int, input().strip().split(' '))
l=[k1,k2,k3]
if min(k1,k2,k3)==1:
    print('yes')
elif l.count(2)>=2:
    print('yes')
elif l.count(3)==3:
    print('yes')
elif l.count(4)==2 and l.count(2)==1:
    print('yes')
else:
    print('no')",O(1)
"class Solution(object):
    def maximumInvitations(self, favorite):
        def find_cycles(adj):
            result = []
            lookup = [False]*len(adj)
            for u in range(len(adj)):
                cnt = {}
                while not lookup[u]:
                    lookup[u] = True
                    cnt[u] = len(cnt)
                    u = adj[u]
                if u in cnt:
                    result.append((u, len(cnt)-cnt[u]))
            return result

        def bfs(adj, u, exclude):
            result = 0
            q = [u]
            while q:
                result += 1
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if v == exclude:
                            continue
                        new_q.append(v)
                q = new_q
            return result
            
        inv_adj = [[] for _ in range(len(favorite))]  
        for u, v in enumerate(favorite):
            inv_adj[v].append(u)
        cycles = find_cycles(favorite)
        return max(max([l for _, l in cycles if l > 2] or [0]),
                   sum(bfs(inv_adj, u, favorite[u]) + bfs(inv_adj, favorite[u], u) for u, l in cycles if l == 2))",O(n)
"n = int(input())
a = list(map(int, input().split()))
s = list(map(int, input().split()))
d = []
for q in range(n):
    d.append(a[q]+s[q])
d = [n-q for q in d]
for q in range(n):
    f = 0
    for q1 in range(q):
        if d[q1] > d[q]:
            f += 1
    g = 0
    for q1 in range(q+1, n):
        if d[q1] > d[q]:
            g += 1
    if f != a[q] or g != s[q]:
        print('NO')
        break
else:
    print('YES')
    print(*d)
",O(n ^ 2)
"n,k=map(int,input().split())
a=list(map(int,input().split()))
a.sort(reverse=True)
worst=0
maxi=a[0]
a.append(0)
for i in range(n+1):
    bad=maxi-a[i]-i
    worst=max(worst,bad)
print(sum(a)-n-worst)",O(nlogn)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

n, k = mi()
ans = (n * 2 + k - 1) // k + (n * 5 + k - 1) // k + (n * 8 + k - 1) // k
print(ans)
",O(1)
"N, M = map(int, input().split())

fac = [1] + [0] * N
for i in range(1, N + 1):
    fac[i] = fac[i - 1] * i % M
fac_inv = [0] * N + [pow(fac[N], M - 2, M)]
for i in range(N, 0, -1):
    fac_inv[i - 1] = fac_inv[i] * i % M
pow2 = [1] + [0] * N
for i in range(N):
    pow2[i + 1] = pow2[i] * 2 % M

DP = [[0] * N for _ in range(N + 2)]
DP[0][0] = 1
for i in range(N):
    for j in range(N):
        DP[i][j] %= M
        if DP[i][j]:
            for k in range(i + 2, N + 2):
                DP[k][j + 1] += DP[i][j] * fac_inv[k - i - 1] % M * pow2[k - i - 2] % M
ans = 0
for j in range(N):
    DP[N + 1][j] %= M
    if DP[N + 1][j]:
        ans += DP[N + 1][j] * fac[N - j + 1] % M
print(ans % M)
",O(n ^ 3)
"import sys
def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def minput():   return map(int, sys.stdin.readline().strip().split())
def listinput(): return list(map(int, sys.stdin.readline().strip().split()))
n=iinput()
color=['purple','green','blue','orange','red','yellow']
gem=['Power','Time','Space','Soul','Reality','Mind']
for _ in range(n):
    s=input()
    indexofcolor=color.index(s)
    color.remove(s)
    gem.pop(indexofcolor)
print(len(gem))
for i in gem:
    print(i)",O(1)
"def main():
    n, m, k, l = map(int, input().split())
    d = (l + k) // m
    if (l + k) % m:
        d += 1
    if m * d > n or n - k < l:
        print(-1)
    else:
        print(d)

main()",O(1)
"n=int(input())
a=list(map(int,input().split()))
d=set()
t={}
rep=set()
if a.count(0)>=2:
	print(""cslnb"")
	exit()

for i in a:
	if i in d:
		if t[i]+1==3:
			print(""cslnb"")
			exit()
		else:
			t[i]+=1
			rep.add(i)
			if len(rep)>=2:
				print(""cslnb"")
				exit()
	else:
		t[i]=1
		d.add(i)
if rep:
	for c in rep:
		if c-1 in d:
			print(""cslnb"")
			exit()
s=0
a.sort()
for i in range(n):
	s+=a[i]-i
if s%2==1:print(""sjfnb"")
else:print(""cslnb"")",O(nlogn)
"class Solution(object):
    def timeRequiredToBuy(self, tickets, k):
        return sum(min(x, tickets[k] if i <= k else tickets[k]-1) for i, x in enumerate(tickets))",O(n)
"n = int(input().strip())
a = list(map(int,input().strip().split()))
b = list(map(int,input().strip().split()))
pos_of = [-1 for i in range(2*10**5+1)]

for i,ele in enumerate(a):
    pos_of[ele]=i+1

current_pos = 0
ans=[]
for i in b:
    if(pos_of[i]>current_pos):
        ans.append(pos_of[i]-current_pos)
        current_pos=pos_of[i]
    else:
        ans.append(0)

print(' '.join(list(map(str,ans))))
",O(n)
"_ = int(input())
binary_number = input()

if binary_number == '0':
    print('0')
else:
    count_0 = sum(1 for b in binary_number if b == '0')
    count_1 = sum(1 for b in binary_number if b == '1')
    print('1' + '0' * count_0)
",O(n)
"n=int(input())
l1=list(map(int,input().split()))
if len(list(set(l1)))==1 and l1[0]>0:
    print(1)
else:
    l2=list(set(l1))
    x=l1.count(0)
    if x==0:
        print(len(l2))
    else:
        print(len(l2)-1)
",O(n)
"class Solution2(object):
    def minWindow(self, s, t):
        current_count = [0 for i in range(52)]
        expected_count = [0 for i in range(52)]

        for char in t:
            expected_count[ord(char) - ord('a')] += 1

        i, count, start, min_width, min_start = 0, 0, 0, float(""inf""), 0
        while i < len(s):
            current_count[ord(s[i]) - ord('a')] += 1
            if current_count[ord(s[i]) - ord('a')] <= expected_count[ord(s[i]) - ord('a')]:
                count += 1

            if count == len(t):
                while expected_count[ord(s[start]) - ord('a')] == 0 or \
                      current_count[ord(s[start]) - ord('a')] > expected_count[ord(s[start]) - ord('a')]:
                    current_count[ord(s[start]) - ord('a')] -= 1
                    start += 1

                if min_width > i - start + 1:
                    min_width = i - start + 1
                    min_start = start
            i += 1

        if min_width == float(""inf""):
            return """"

        return s[min_start:min_start + min_width]",O(n)
"n = int(input())
ls1 = [int(i) for i in input().split()]
ls2 = [int(i) for i in input().split()]

ans = float('inf')

for i in range(1, n - 1):
    l = [ls2[j] for j in range(0, i) if ls1[j] < ls1[i]]
    r = [ls2[j] for j in range(i + 1, n) if ls1[j] > ls1[i]]

    if len(l) and len(r):
        ans = min(ans, min(l) + min(r) + ls2[i])

print([-1 , ans][ans != float('inf')])",O(n ^ 2)
"import itertools


class Solution2(object):
    def maxPower(self, s):
        return max(len(list(v)) for _, v in itertools.groupby(s))",O(n)
"class Solution(object):
    def cleanRoom(self, robot):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        def goBack(robot):
            robot.turnLeft()
            robot.turnLeft()
            robot.move()
            robot.turnRight()
            robot.turnRight()

        def dfs(pos, robot, d, lookup):
            robot.clean()
            for _ in directions:
                new_pos = (pos[0]+directions[d][0],
                           pos[1]+directions[d][1])
                if new_pos not in lookup:
                    lookup.add(new_pos)
                    if robot.move():
                        dfs(new_pos, robot, d, lookup)
                        goBack(robot)
                robot.turnRight()
                d = (d+1) % len(directions)
        
        dfs((0, 0), robot, 0, set())",O(n)
"from collections import defaultdict
import os
import sys
from io import BytesIO, IOBase

ii = lambda: int(input())
lmii = lambda: list(map(int, input().split()))
slmii = lambda: sorted(map(int, input().split()))
li = lambda: list(input())
mii = lambda: map(int, input().split())
msi = lambda: map(str, input().split())

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

def lcm(a, b): return (a * b) // gcd(a, b)

def main():

    n = ii()
    d = defaultdict(int)
    ll = defaultdict(list)
    rr = defaultdict(list)
    llst = []
    rlst = []
    lst = []
    for i in range(n):
        l, r = mii()
        lst.append([l,r])
        llst.append(l)
        rlst.append(r)
        ll[l].append(r)
        rr[r].append(l)
    left = max(llst)
    right = min(rlst)
    lleft = min(ll[left])
    lright = max(rr[right])
    lst.remove([left,lleft])
    pl = max(i[0] for i in lst)
    pr = min(i[1] for i in lst)
    mx = max(0,pr-pl)
    lst.append([left,lleft])
    lst.remove([lright,right])
    pl = max(i[0] for i in lst)
    pr = min(i[1] for i in lst)
    print(max(mx, max(0,pr-pl)))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(n)
"from sys import stdin

add = lambda a, b: (a % mod + b % mod) % mod
mod, bits = 998244353, ['00', '01', '10', '11']
pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]

n, k = map(int, stdin.readline().split())
mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(2)]

for i in range(4):
    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)
    if val <= k:
        mem[0][val][i] = 1

for i in range(1, n):
    for j in range(1, k + 1):
        for k1 in range(4):
            for k2 in range(4):
                val = j + pat[k1][k2]
                if val <= k:
                    mem[i & 1][val][k2] = add(mem[(i - 1) & 1][j][k1], mem[i & 1][val][k2])

    for j in range(1, k + 1):
        for k1 in range(4):
            mem[(i - 1) & 1][j][k1] = 0

print(sum(mem[(n - 1) & 1][k]) % mod)
",np
"class Node(object):
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight


class Solution(object):
    def intersect(self, quadTree1, quadTree2):
        if quadTree1.isLeaf:
            return quadTree1 if quadTree1.val else quadTree2
        elif quadTree2.isLeaf:
            return quadTree2 if quadTree2.val else quadTree1
        topLeftNode = self.intersect(quadTree1.topLeft, quadTree2.topLeft)
        topRightNode = self.intersect(quadTree1.topRight, quadTree2.topRight)
        bottomLeftNode = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)
        bottomRightNode = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)
        if topLeftNode.isLeaf and topRightNode.isLeaf and \
           bottomLeftNode.isLeaf and bottomRightNode.isLeaf and \
           topLeftNode.val == topRightNode.val == bottomLeftNode.val == bottomRightNode.val:
            return Node(topLeftNode.val, True, None, None, None, None)
        return Node(True, False, topLeftNode, topRightNode, bottomLeftNode, bottomRightNode)",O(n)
"r,g,b=map(int,input().split())
rs=sorted(list(map(int,input().split())))
gs=sorted(list(map(int,input().split())))
bs=sorted(list(map(int,input().split())))
dp=[[[0 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
ans=0
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i>0 and k>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+rs[i-1]*bs[k-1])
            if i>0 and j>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+rs[i-1]*gs[j-1])
            if j>0 and k>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+gs[j-1]*bs[k-1])
            ans=max(ans,dp[i][j][k])
print(ans)
",O(n ^ 3)
"class Solution(object):
    def sortArray(self, nums):
        def mergeSort(left, right, nums):
            if left == right:
                return
            mid = left + (right-left)//2
            mergeSort(left, mid, nums)
            mergeSort(mid+1, right,  nums)
            r = mid+1
            tmp = []
            for l in range(left, mid+1):
                while r <= right and nums[r] < nums[l]:
                    tmp.append(nums[r])
                    r += 1
                tmp.append(nums[l])
            nums[left:left+len(tmp)] = tmp

        mergeSort(0, len(nums)-1, nums)
        return nums",O(nlogn)
"class Solution:
    def maxSubArray(self, nums):
        dp = [*nums]
        for i in range(1, len(nums)):
            dp[i] = max(nums[i], nums[i] + dp[i - 1])
        return max(dp)
",O(n)
"class Solution(object):
    def minimumMoney(self, transactions):
        return sum(max(a-b, 0) for a, b in transactions)+max(a-max(a-b, 0) for a, b in transactions)",O(n)
"import os
import sys
import math
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

x,k=map(int,input().split())
res=0
mod=1000000007
res=pow(2,k,mod)*(2*x-1)+1
res%=mod
if x==0:
    res=0
print(res)
",O(logn)
"if __name__ == '__main__':
	n = int(input())
	num = n + n//2
	print(num)",O(1)
"n = int(input())
if n <= 4:
    print(""YES"")
    exit()

A = [None]*n

for i in range(n):
    A[i] = list(map(int,input().split()))

def is_colinear(a1,a2,a3):
    if a1 == a2 or a2 == a3 or a1 == a3:
        return True

    x1,y1 = a1
    x2,y2 = a2
    x3,y3 = a3

    if x1 == x2 or x1 == x3 or x2 == x3:
        return x1 == x2 == x3
    if y1 == y2 or y1 == y3 or y2 == y3:
        return y1 == y2 == y3
    return (y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)

X,Y,Z = A[0],A[1],A[2]

def good(X,Y):

    bad = []
    for i in range(n):
        if not is_colinear(X,Y,A[i]):
            bad.append(A[i])

    if len(bad) <= 2:
        return True

    U,V = bad[0],bad[1]
    for i in range(len(bad)):
        if not is_colinear(U,V,bad[i]):
            return False
    return True

if good(X,Y) or good(Y,Z) or good(X,Z):
    print(""YES"")
    exit()

print(""NO"")
exit()
",O(nlogn)
"class Solution:
    def reverseBits(self, n: int) -> int:
        res = 0
        for i in range(32):
            bit = (n >> i) & 1
            res += (bit << (31 - i))
        return res
",O(1)
"import math

def valid(n, k, c1, c2):
    if c1 > n:
        return c2
    elif c2 > n:
        return c1
    ans_one = ((n - c1) * (n - c1 + 1) // 2) - c1
    if ans_one == k:
        return c1
    return c2

def f(n, k):
    b2 = (2 * n + 3)
    delta = int(math.sqrt(8 * n + 8 * k + 9))
    return valid(n, k, (b2 + delta) // 2, (b2 - delta) // 2)

n, k = map(int, input().strip().split(' '))
print(f(n, k))
",O(logn)
"n, s = map(int, input().split(' '))

if(s <= n):
  sol = 1
else:
  sol = s // n
  if(s % n):
    sol += 1

print(sol)
",O(1)
"import math
[l,r]=list(map(int,input().split()))
l=l^r
if l:
    l=int(math.log(l,2))
    l=(1<<(l+1))-1
    print(l)
else:
    print(0)",O(logn)
"from sys import stdin

add = lambda a, b: (a % mod + b % mod) % mod
mod, bits = 998244353, ['00', '01', '10', '11']
pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]

n, k = map(int, stdin.readline().split())
mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]

for i in range(4):
    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)
    if val <= k:
        mem[0][val][i] = 1

for i in range(1, n):
    for j in range(1, k + 1):
        for k1 in range(4):
            for k2 in range(4):
                val = j + pat[k1][k2]
                if val <= k:
                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])

print(sum(mem[-1][k]) % mod)
",np
"class Solution2(object):
    def minOperations(self, nums):
        n = len(nums)
        nums = sorted(set(nums))
        result = right = 0
        for left in range(len(nums)):
            while right < len(nums) and nums[right] <= nums[left]+n-1:
                right += 1
            result = max(result, right-left)
        return n-result",O(nlogn)
"class Solution2(object):
    def maxPathSum(self, root):
        def dfs(node):
            if not node:
                return (float(""-inf""), 0)
            max_left, curr_left = dfs(node.left)
            max_right, curr_right = dfs(node.right)
            return (max(max_left, max_right, node.val+max(curr_left, 0)+max(curr_right, 0)),
                    node.val+max(curr_left, curr_right, 0))
        
        return dfs(root)[0]",O(n)
"n = int(input())
if n == 0:
    print(0)
else:
    if n % 2 == 0:
        print(n+1)
    else:
        print((n+1)//2)",O(1)
"import bisect
xyz=[9,90,900,9000,90000,900000,9000000,90000000,900000000,9000000000,900000000000]
xzy=[10,190,2890,38890,488890,5888890,68888890,788888890,8888888890,98888888890,1088888888890,11888888888890]
count=2
k=int(input())
digits=bisect.bisect_left(xzy,k)

if k==10:
    print(1)
elif k>10:
    apu=k-xzy[digits-1]

    modulo=apu%(digits+1)

    dlj=apu//(digits+1)

    output=10**(digits)+dlj

    list1=[i for i in str(output)]

    print(list1[modulo])
else:
    print(k)
",O(logn)
"import sys
input = sys.stdin.readline

t = int(input())
for _ in range(t):
    s = list(input().rstrip())
    t = input().rstrip()
    ok = False
    for i in range(len(t)):
        t1 = list(t[:i]) + [""
        t2 = list(t[i:]) + [""

        dp = [[-1] * (len(t) + 1) for _ in range(len(s) + 1)]
        dp[0][0] = 0
        for j, ch in enumerate(s):
            for k in range(len(t1)):
                if dp[j][k] == -1:
                    continue
                dp[j+1][k] = max(dp[j+1][k], dp[j][k])
                if ch == t1[k]:
                    dp[j+1][k+1] = max(dp[j+1][k+1], dp[j][k])
                if ch == t2[dp[j][k]]:
                    dp[j+1][k] = max(dp[j+1][k], dp[j][k] + 1)
        for k in range(len(t) + 1):
            if dp[len(s)][k] + k >= len(t):
                ok = True

    if ok:
        print(""YES"")
    else:
        print(""NO"")",O(n ^ 3)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def rotateRight(self, head, k):
        if not head or not head.__next__:
            return head

        n, cur = 1, head
        while cur.__next__:
            cur = cur.__next__
            n += 1
        cur.next = head

        cur, tail = head, cur
        for _ in range(n - k % n):
            tail = cur
            cur = cur.__next__
        tail.next = None

        return cur",O(n)
"from collections import deque as de
import math
from collections import Counter as cnt
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()

def isPrime(n) :

	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):

    prime_factors = []

    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2

    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic

n,k=map(int,input().split())
a=list(map(int,input().split()))
l=sorted(a, reverse=True)
dic={}
totalprofit=0
for i in range(k):
    totalprofit+=l[i]
    if l[i] in dic:
        dic[l[i]]+=1
    else:
        dic[l[i]]=1
ans=[]
count=0
for i in range(n):
    if a[i] in dic:
        count+=1
        if dic[a[i]]==1:
            del dic[a[i]]
        else:
            dic[a[i]]-=1
        if not dic:
            count-=1
            ans.append(count+ n-i)
            break
        else:
            ans.append(count)
        count=0
    else:
        count+=1
print(totalprofit)
print(*ans)
",O(nlogn)
"s1 = input()
s2 = input()

objetivo = s1.count(""+"") - s1.count(""-"")
inicio = s2.count(""+"") - s2.count(""-"")
incognitos = s2.count(""?"")
distancia = objetivo - inicio

def factorial(n):
    total = 1
    for i in range(int(n)):
        total *= (i + 1)
    return total

if abs(distancia) > incognitos or distancia % 2 != incognitos % 2:
    print(0)
else:
    mas = (distancia + incognitos) / 2
    menos = (incognitos - distancia) / 2
    print((factorial(incognitos)/(factorial(mas)*factorial(menos)))/2**incognitos)
",np
"n=int(input())
arr=list(map(int,input().split()))
dp=[[-1 for i in range(5+1)] for j in range(n)]
for i in range(1,6):
    dp[0][i] =1
for i in range(1,n):
    if arr[i] > arr[i - 1]:
        for j in range(1,6):
            for k in range(1,j):
                if dp[i-1][k]==1:
                    dp[i][j] =1
                    break
    elif arr[i] <arr[i-1]:
        for j in range(1,6):
            for k in range(j+1,6):
                if dp[i-1][k] ==1:
                    dp[i][j]=1
                    break
    else:
        for j in range(1,6):
            for k in range(1,6):
                if j ==k:
                    continue
                if dp[i-1][k] ==1:
                    dp[i][j] =1
                    break
ans=[]
for i in range(1,6):
    if dp[n-1][i]==1:
        ans.append(i)
        break
if len(ans) ==0:
    print(-1)
    exit()
for i in range(n-2,-1,-1):
    curr=ans[-1]
    if arr[i] >arr[i+1]:
        for j in range(curr+1,6):
            if dp[i][j] ==1:
                ans.append(j)
                break
    elif arr[i] <arr[i+1]:
        for j in range(1,curr):
            if dp[i][j] ==1:
                ans.append(j)
                break
    else:
        for j in range(1,6):
            if j ==curr:
                continue
            if dp[i][j] ==1:
                ans.append(j)
                break
ans=ans[::-1]
print(*ans)
",O(n)
"n,m=map(int,input().split())
seq=list(map(str,input().split()))
fp=list(map(str,input().split()))
checklist=[]
for number in seq:
    if(number in fp):
        checklist.append(number)
print("" "".join(checklist))",O(n ^ 2)
"n, x, y = int(input())-1, 1, 9
while n > x*y :
	n, x, y = n-x*y, x+1, 10*y
print(str(10**(x-1)+n//x)[n%x])",O(logn)
"import sys
import string
from math import gcd
import getpass
import math
from decimal import Decimal

def ria():
    return [int(i) for i in input().split()]

if getpass.getuser() != 'frohenk':
    filename = 'half'

else:
    sys.stdin = open('input.txt')

n = ria()[0]
x, y = ria()
bx, by = ria()
cx, cy = ria()

x1, y1 = x - bx, y - by
x2, y2 = x - cx, y - cy

if abs(x2) == abs(y2):
    print('NO')
    exit(0)
if math.copysign(x2, x1) != x2:
    print('NO')
    exit(0)
if math.copysign(y2, y1) != y2:
    print('NO')
    exit(0)
print('YES')",O(1)
"n,k = map(int,input().split())
s = input()
c=0
for i in range(len(s)):
	if s[:i]==s[-i:]:
		c=i
print(s+s[c:]*(k-1))",O(n ^ 2)
"n = int(input())
m = int(input())
if(n<=26):
    print(m%(2**n))
else:
    print(m)
",O(1)
"from sys import stdin, stdout
from math import sin, tan, cos

n, m, k, l = map(int, stdin.readline().split())

lb, rb = 0, n // m + 1
while rb - lb > 1:
    mid = (lb + rb) >> 1

    if mid * m - k >= l:
        rb = mid
    else:
        lb = mid

if lb != n // m:
    stdout.write(str(rb))
else:
    stdout.write('-1')",O(logn)
"x1, y1 = map(int, input().split())
x2, y2 = map(int, input().split())
x3, y3 = map(int, input().split())

points = [(x1, y1), (x2, y2), (y3, x3)]

def gen_points(A, B):

	return [(A[0], B[1]), (B[0], A[1])]

points += gen_points([x1, y1], [x2, y2])
points += gen_points([x2, y2], [x3, y3])
points += gen_points([x1, y1], [x3, y3])

points = list(set(points))

ans = 1e9
ans_l = []

def mark_points(A, B):
	A = list(A)
	B = list(B)
	d = set()
	x_s = 1 if A[0] < B[0] else -1
	y_s = 1 if A[1] < B[1] else -1
	d.add((A[0], A[1]))
	while A[0] != B[0]:
		A[0] += x_s
		d.add((A[0], A[1]))
	while A[1] != B[1]:
		A[1] += y_s
		d.add((A[0], A[1]))
	return d

for el in points:
	d = mark_points([x1, y1], el).union(mark_points([x2, y2], el))
	d = d.union(mark_points([x3, y3], el))
	if len(d) < ans:
		ans = len(d)
		ans_l = d

print(ans)
for el in ans_l:
	print(*el)",O(n ^ 2)
"class Solution(object):
    def threeSumClosest(self, nums, target):
        result, min_diff = 0, float(""inf"")
        nums.sort()
        for i in reversed(range(2, len(nums))):
            if i+1 < len(nums) and nums[i] == nums[i+1]:
                continue
            left, right = 0, i-1
            while left < right:
                total = nums[left]+nums[right]+nums[i]
                if total < target:
                    left += 1
                elif total > target:
                    right -= 1
                else:
                    return target
                if abs(total-target) < min_diff:
                    min_diff = abs(total-target)
                    result = total
        return result",O(n ^ 2)
"class Solution:
    def numDecodings(self, s: str) -> int:
        dp = {len(s): 1}
        for i in range(len(s) - 1, -1, -1):
            if s[i] == ""0"":
                dp[i] = 0
            else:
                dp[i] = dp[i + 1]

            if i + 1 < len(s) and (s[i] == ""1"" or
               s[i] == ""2"" and s[i + 1] in ""0123456""
            ):
                dp[i] += dp[i + 2]
        return dp[0]
",O(n)
"class Solution(object):
    def memLeak(self, memory1, memory2):
        def s(a, d, n):
            return (2*a + (n-1)*d)*n//2

        def f(a, d, x):
            r = int((-(2*a-d)+((2*a-d)**2+8*d*x)**0.5)/(2*d))
            if s(a, d, r) > x: 
                r -= 1
            return r

        is_swapped = False
        if memory1 < memory2:
            memory1, memory2 = memory2, memory1
            is_swapped = True
        n = f(1, 1, memory1-memory2)
        memory1 -= s(1, 1, n)
        if memory1 == memory2:
            is_swapped = False
        l = f(n+1, 2, memory1)
        r = f(n+2, 2, memory2)
        memory1 -= s(n+1, 2, l)
        memory2 -= s(n+2, 2, r)
        if is_swapped:
            memory1, memory2 = memory2, memory1
        return [n+l+r+1, memory1, memory2]",O(1)
"from __future__ import division
from sys import stdin, stdout
from collections import Counter

def write(x):
    stdout.write(str(x) + ""\n"")

n, c = map(int, stdin.readline().split())
a = map(int, stdin.readline().split())
assert len(a) == n

tel = Counter()
target_count_last = Counter()
targets = 0
best = 0

for num in a:
    if num == c:
        targets += 1
    else:
        since_last = targets - target_count_last[num]
        target_count_last[num] = targets
        tel[num] = max(0, tel[num] - since_last)
        tel[num] += 1
        best = max(best, tel[num])

write(targets + best)
",O(n)
"from itertools import combinations

n,l,r,x = map(int,input().split())
a=list(map(int,input().split()))

c=[]
for i in range(2,n+1):
	c+=list(combinations(a,i))

cnt=0

for t in c:
	m=min(t)
	M=max(t)
	s=sum(t)
	if M-m >=x and (s>=l and s<=r):
		cnt+=1

print(cnt)",np
"class Solution3(object):
    def rotate(self, nums, k):
        count = 0
        start = 0
        while count < len(nums):
            curr = start
            prev = nums[curr]
            while True:
                idx = (curr + k) % len(nums)
                nums[idx], prev = prev, nums[idx]
                curr = idx
                count += 1
                if start == curr:
                    break
            start += 1",O(n)
"import sys
from math import sqrt,log2
from collections import Counter

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n=input()
ct=0
i=0
s=[]
while i <len(n):
    if not int(n[i])%3:
        ct+=1
        s.clear()
    else:
        t=int(n[i])%3
        if 3-t in s:
            ct+=1
            s.clear()
        else:
            s.append(t)
    if len(s)==3:
        ct+=1
        s.clear()
    i+=1

print(ct)",O(n)
"def check(mid):
    added = n - mid
    total = ((added)*(added+1))//2
    return total - mid >= k

n,k = map(int,input().split())
low = 0
high = n-1
while low < high:
    mid = (low+high+1)//2

    if check(mid):
        low = mid
    else:
        high = mid - 1
print(low)",O(logn)
"class Solution2(object):
    def timeTaken(self, edges):
        def dfs1(u, p):
            for v in adj[u]:
                if v == p:
                    continue
                dfs1(v, u)
                curr = [(1+int(v%2 == 0))+dp[v][0][0], v]
                for i in range(len(dp[u])):
                    if curr > dp[u][i]:
                        curr, dp[u][i] = dp[u][i], curr

        def dfs2(u, p, curr):
            result[u] = max(dp[u][0][0], curr)
            for v in adj[u]:
                if v == p:
                    continue
                dfs2(v, u, (1+int(u%2 == 0))+max((dp[u][0][0] if dp[u][0][1] != v else dp[u][1][0]), curr))

        adj = [[] for _ in range(len(edges)+1)]
        for u, v, in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = [[[0, -1] for _ in range(2)] for _ in range(len(edges)+1)]
        dfs1(0, -1)
        result = [0]*(len(edges)+1)
        dfs2(0, -1, 0)
        return result",O(n)
"import math
n,t=map(int,input().split())
l=[]
for _ in range(n):
    a,b=map(int,input().split())
    x=a-b/2
    y=a+b/2
    l.append([x,y])
l.sort()
c=0

for i in range(n-1):
    if(l[i+1][0]-l[i][1]>t):
        c+=2
    elif(l[i+1][0]-l[i][1]==t):
        c+=1
print(c+2)
",O(nlogn)
"class Solution:
    def checkValidString(self, s: str) -> bool:
        leftMin, leftMax = 0, 0

        for c in s:
            if c == ""("":
                leftMin, leftMax = leftMin + 1, leftMax + 1
            elif c == "")"":
                leftMin, leftMax = leftMin - 1, leftMax - 1
            else:
                leftMin, leftMax = leftMin - 1, leftMax + 1
            if leftMax < 0:
                return False
            if leftMin < 0:
                leftMin = 0
        return leftMin == 0
",O(n)
"n = int(input())
w = list(map(int, input().split()))
intro = [[v, i] for i, v in enumerate(w, 1)]
intro.sort(key=lambda x: x[0])
s = input()
i = -1
li = []
ans = []
for j in s:
    if j == ""0"":
        i += 1
        ans.append(intro[i][1])
        li.append(intro[i][1])
    else:
        ans.append(li.pop(-1))
print("" "".join(map(str, ans)))
",O(nlogn)
"def check(x, y):
    return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y])

re = int(input())
a = [list(input()) for i in range(re)]
b = [list(input()) for i in range(re)]
for i in range(4):
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = b[::-1]
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = [s[::-1] for s in b]
    c = [['' for t in range(re)] for u in range(re)]
    for t in range(re):
        for u in range(re):
            c[t][u] = b[u][re - t - 1]
    b = c[:]
    if check(a, b):
        print('Yes')
        exit(0)
print('No')",O(n ^ 2)
"from math import inf

n, m, k = map(int, input().split())
horizontal_costs = []
vertical_costs = []
for _ in range(n):
    horizontal_costs.append(list(map(int, input().split())))
for _ in range(n-1):
    vertical_costs.append(list(map(int, input().split())))

dp = [[[inf] * (k // 2 + 1) for _ in range(m)] for _ in range(n)]

def find_cost(a, b, c):
    global dp
    if a < 0 or a > n-1 or b < 0 or b > m-1:
        return inf

    if c == 0:
        return 0

    if dp[a][b][c] != inf:
        return dp[a][b][c]

    if a < n-1:
        dp[a][b][c] = find_cost(a+1, b, c-1) + vertical_costs[a][b]
    if b < m-1:
        dp[a][b][c] = min(dp[a][b][c], find_cost(a, b+1, c-1) + horizontal_costs[a][b])
    if b > 0:
        dp[a][b][c] = min(dp[a][b][c], find_cost(a, b-1, c-1) + horizontal_costs[a][b-1])
    if a > 0:
        dp[a][b][c] = min(dp[a][b][c], find_cost(a-1, b, c-1) + vertical_costs[a-1][b])

    return dp[a][b][c]

ans = [[inf] * m for _ in range(n)]
if k % 2 == 1:
    for i in range(n):
        for j in range(m):
            ans[i][j] = -1
else:
    for i in range(n):
        for j in range(m):
            ans[i][j] = min(ans[i][j], 2 * find_cost(i, j, k//2))

for row in ans:
    print(*row)",O(n ^ 3)
"a,b = map(int,input().split())

x,y,z=map(int,input().split())

r = 0

yellow = 2*x
blue = 3*z
green = y

if a > yellow:
    a -= yellow
else:
    r += abs(a-yellow)
    a=0

if b > blue:
    b -= blue
else:
    r += abs(b-blue)
    b=0

if a > green:
    a-= green
else:
    r += abs(a-green)

if b > green:
    b-=green
else:
    r += abs(b-green)

print(r)",O(1)
"tot, choc = [int(i) for i in input().split()]

bg = 1
end = tot

while True:
    mid = (bg + end) / 2
    add = (mid * (mid + 1)) / 2
    sub = tot - mid
    if add - sub == choc:
        print(int(sub))
        break
    if add - sub < choc:
        bg = mid + 1
    else:
        end = mid - 1
",O(logn)
"import itertools



class Solution(object):
    def minCost(self, nums, cost):
        def f(x):
            return sum(abs(y-x)*c for y, c in zip(nums, cost))

        def check(x, t):
            return sum(c for y, c in zip(nums, cost) if y <= x) >= t
    
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        left, right = 0, len(idxs)-1
        total = sum(cost)
        median = (total+1)//2
        while left <= right:
            mid = left+(right-left)//2
            if check(nums[idxs[mid]], median):
                right = mid-1
            else:
                left = mid+1
        return f(nums[idxs[left]])",O(nlogn)
"class Solution2(object):
    def minimumOperations(self, nums):
        return sum(min(x%3, 3-x%3) for x in nums)",O(n)
"class Solution(object):
    def canEat(self, candiesCount, queries):
        prefix = [0]*(len(candiesCount)+1)
        for i, c in enumerate(candiesCount):
            prefix[i+1] = prefix[i]+c
        return [prefix[t]//c < d+1 <= prefix[t+1]//1 for t, d, c in queries]",O(n)
"class Solution(object):
    def twoEggDrop(self, n):
        return int(math.ceil((-1+(1+8*n)**0.5)/2))",O(1)
"class Solution2(object):
    def longestPath(self, parent, s):
        def iter_dfs(s, adj):
            result = 0
            stk = [(1, (0, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, ret = args
                    top2 = [0]*2
                    stk.append((4, (top2, ret)))
                    stk.append((2, (u, 0, top2, ret)))
                elif step == 2:
                    u, i, top2, ret = args
                    if i == len(adj[u]):
                        continue
                    ret2 = [0]
                    stk.append((3, (u, i, top2, ret2)))
                    stk.append((1, (adj[u][i], ret2))) 
                elif step == 3:
                    u, i, top2, ret2 = args
                    if s[adj[u][i]] != s[u]:
                        if ret2[0] > top2[0]:
                            top2[0], top2[1] = ret2[0], top2[0]
                        elif ret2[0] > top2[1]:
                            top2[1] = ret2[0]
                    stk.append((2, (u, i+1, top2, ret)))
                elif step == 4:
                    top2, ret = args
                    result = max(result, top2[0]+top2[1]+1)
                    ret[0] = top2[0]+1
            return result
    
        
        adj = [[] for _ in range(len(s))]
        for i in range(1, len(parent)):
            adj[parent[i]].append(i)
        return iter_dfs(s, adj)",O(n)
"n = int(input())
s = input()
count = 0
temp_count = 0
for c in s:
    if c == 'x':
        temp_count += 1
    else:
        temp_count = 0
    if temp_count == 3:
        count += 1
        temp_count -= 1

print(count)
",O(n)
"n = int(input())
a = [int(i) for i in input().split()]
a.sort()
flag = 0
for i in range(n-1):
	if(a[i] == a[i+1]):
		if(flag == 1):
			flag = 2
			break
		flag = 1
		index = i
		if(i+2<n and a[i+1] == a[i+2]):
			flag = 2
			break
		elif(i>0 and a[i-1] == a[i]-1):
			flag = 2
			break
if(flag == 2):
	print(""cslnb"")
elif(flag ==1 and a[index] ==0):
	print(""cslnb"")
else:
	moves=0
	for i in range(n):
		if(a[i] == i):
			continue
		elif(a[i]<i):
			continue
		else:
			moves += (a[i] - i)
	if(moves%2 == 0):
		print(""cslnb"")
	else:
		print(""sjfnb"")",O(nlogn)
"def black_count(x, y):
	total = x * y
	return total // 2

def black_count2(a, b, c, d):
	return black_count(c, d) - black_count(a-1, d) - black_count(c, b-1) + black_count(a-1, b-1)

def white_count2(a, b, c, d):
	total = (c - a + 1) * (d - b + 1)
	return total - black_count2(a, b, c, d)

def intersection(a, b, c, d, x, y):
	if x < a or y < b:
		return None
	x = min(x, c)
	y = min(y, d)
	return (a, b, x, y)

def intersection2(a1, b1, c1, d1, a2, b2, c2, d2):
	if b1 > d2 or a1 > c2:
		return None
	if b2 > d1 or a2 > c1:
		return None

	a = max(a1, a2)
	b = max(b1, b2)
	c = min(c1, c2)
	d = min(d1, d2)
	return (a, b, c, d)

def solve(n, m, W, B):
	total = n * m
	whites = total - black_count(n, m)
	whites += black_count2(*W)
	whites -= white_count2(*B)
	I = intersection2(*W, *B)
	if I:
		whites -= black_count2(*I)
	blacks = n * m - whites
	return whites, blacks

def main():
	t = int(input())
	for _ in range(t):
		n, m = map(int, input().split())
		W = list(int(i) for i in input().split())
		B = list(int(i) for i in input().split())
		w, b = solve(n, m, W, B)
		print(w, b)

if __name__ == '__main__':
	main()
",O(1)
"n,k=map(int, input().split())
a = list(map(int, input().split()))

c = a[-1] - a[0]

d = [a[i]-a[i-1] for i in range(1, n)]
d = sorted(d)[::-1]
c -= sum(d[:k-1])
print(c)
",O(nlogn)
"n=int(input())
if n==1:
    exit(print(1))
y=n
i=1
while n!=0:
    j=n//2+n%2
    if i*2>y and n==1:
        i=i>>1
        x=y//i
        print(i*x)
    else:
        print((str(i)+' ')*j,end='')
    i=i<<1
    n=n//2",O(nlogn)
"from itertools import combinations
n, l, r, x = map(int,input().split())
c = [*map(int, input().split())]
print(sum([sum([1 if max(j) - min(j) >= x and l <= sum(j) <= r else 0 for j in combinations(c, i)]) for i in range(1, n + 1)]))
",np
"from sys import stdin
readline = stdin.readline
def readInt():
    return int(readline())
def readInts():
    return list(map(int,readline().split()))

U, D, L, R = 0, 1, 2, 3
DIR = [(-1,0), (1,0), (0,-1), (0,1)]

n, m, k = readInts()

moves = [[[-1 for _ in range(4)] for _ in range(m)] for _ in range(n)]

right = []
down = []

for i in range(n):
    row = readInts()
    right.append(row)

for i in range(n-1):
    row = readInts()
    down.append(row)

if k % 2 == 1:
    for _ in range(n):
        for _ in range(m):
            print(-1, end="" "")
        print()
    exit()

k //= 2

dp = [[[0 for _ in range(k+1)] for _ in range(m)] for _ in range(n)]

for l in range(k):
    for i in range(n):
        for j in range(m):
            dp[i][j][l+1] = float(""inf"")
            if i > 0:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i-1][j][l] + down[i-1][j])
            if j > 0:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i][j-1][l] + right[i][j-1])
            if i < n - 1:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i+1][j][l] + down[i][j])
            if j < m - 1:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i][j+1][l] + right[i][j])

for i in range(n):
    for j in range(m):
        print(2*dp[i][j][k], end="" "")
    print()
",O(n ^ 3)
"class Solution(object):
    def findDifference(self, nums1, nums2):
        lookup = [set(nums1), set(nums2)]
        return [list(lookup[0]-lookup[1]), list(lookup[1]-lookup[0])]",O(n)
"import math
n = int(input())

if n>0:
    print(n)
else:
    l = list(str(n))

    last = l[0:len(l)-1]
    second = l[0:len(l)-2]
    second+=l[-1]
    lR = """".join(last)
    sR = """".join(second)

    print(max(eval(lR),eval(sR)))
",O(1)
"import itertools


class Solution(object):
    def numTilings(self, N):
        M = int(1e9+7)

        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) % M \
                     for col in ZB] for row in A]

        T = [[1, 0, 0, 1], 
             [1, 0, 1, 0], 
             [1, 1, 0, 0], 
             [1, 1, 1, 0]] 

        return matrix_mult([[1, 0, 0, 0]], matrix_expo(T, N))[0][0]",O(logn)
"class Solution(object):
    def removeTrailingZeros(self, num):
        return num[:next(i for i in reversed(range(len(num))) if num[i] != '0')+1]",O(n)
"class Solution(object):
    def minOperations(self, nums):
        def popcount(n):
            result = 0
            while n:
                n &= n-1
                result += 1
            return result

        result, max_len = 0, 1
        for num in nums:
            result += popcount(num)
            max_len = max(max_len, num.bit_length())
        return result + (max_len-1)",O(nlogn)
"class Solution(object):
    def myAtoi(self, str):
        INT_MAX =  2147483647
        INT_MIN = -2147483648
        result = 0

        if not str:
            return result

        i = 0
        while i < len(str) and str[i].isspace():
            i += 1

        if len(str) == i:
            return result

        sign = 1
        if str[i] == ""+"":
            i += 1
        elif str[i] == ""-"":
            sign = -1
            i += 1

        while i < len(str) and '0' <= str[i] <= '9':
            if result > (INT_MAX - int(str[i])) / 10:
                return INT_MAX if sign > 0 else INT_MIN
            result = result * 10 + int(str[i])
            i += 1

        return sign * result",O(n)
"q = int(input())
for _ in range(q):
    n, k = map(int, input().split())
    s = input()
    ans = k
    sample = ""RGB""
    for i in range(n - k + 1):
        cnt = 0
        x = 0
        for j in range(i, i + k):
            if s[j] != sample[x]:
                cnt += 1
            x = (x + 1) % 3

        ans = min(ans, cnt)
        cnt = 0
        x = 1
        for j in range(i, i + k):
            if s[j] != sample[x]:
                cnt += 1
            x = (x + 1) % 3
        ans = min(ans, cnt)

        cnt = 0
        x = 2
        for j in range(i, i + k):
            if s[j] != sample[x]:
                cnt += 1
            x = (x + 1) % 3
        ans = min(ans, cnt)

    print(ans)",O(n ^ 2)
"import math
import sys

DEBUG = False

def inp():
    return sys.stdin.readline().rstrip()

def dprint(*value, sep=' ', end='\n'):
    if DEBUG:
        print(*value, sep=sep, end=end)

def solve(H, W, A):
    visited = [bytearray(W) for _ in range(H)]

    for y in range(H):
        for x in range(W):
            if A[y][x] == '.' or visited[y][x]:
                continue

            dprint(x, y)
            for dx, dy in [(0, 0), (-1, 0), (-2, 0),
                           (0, -1), (-2, -1),
                           (0, -2), (-1, -2), (-2, -2)]:
                tx = x + dx
                ty = y + dy
                dprint('  ', tx, ty)
                if tx < 0 or ty < 0 or tx + 2 >= W or ty + 2 >= H:
                    continue
                bad = False
                for ex, ey in [(0, 0), (1, 0), (2, 0),
                               (0, 1), (2, 1),
                               (0, 2), (1, 2), (2, 2)]:
                    nx = tx + ex
                    ny = ty + ey
                    if A[ny][nx] == '.':
                        bad = True
                        break
                if bad:
                    continue

                for ex, ey in [(0, 0), (1, 0), (2, 0),
                               (0, 1), (2, 1),
                               (0, 2), (1, 2), (2, 2)]:
                    nx = tx + ex
                    ny = ty + ey
                    visited[ny][nx] = 1

                assert visited[ny][nx] == 1
                break

            if visited[y][x] == 0:
                return False

    return True

def main():
    H, W = [int(e) for e in inp().split()]
    A = [inp() for _ in range(H)]

    print('YES' if solve(H, W, A) else 'NO')

if __name__ == '__main__':
    main()
",O(n ^ 2)
"import math
a=input()
b=input()
c=int(0)
d=int(0)
q=int(0)
for i in range(len(a)):
    if a[i]==""+"":
        c+=1
    elif a[i]==""-"":
        c-=1
for i in range(len(b)):
    if b[i]==""+"":
        d+=1
    elif b[i]==""-"":
        d-=1
    else:
        q+=1
if c == d:
    print((math.factorial(q)/(math.factorial(q/2)*math.factorial(q/2)))/(2**q))
else:
    mx=d+q
    mn=d-q
    if c>mx or c<mn:
        print(0.0)
    else:
        ans=c-d
        if ans > 0:
            print((math.factorial(q)/(math.factorial(((q-ans)/2)+ans)*math.factorial((q-ans)/2)))/(2**q))
        else:
            print((math.factorial(q)/(math.factorial((q-ans)/2)*math.factorial(((q-ans)/2)+ans)))/(2**q))
",np
"class Solution2(object):
    def scoreOfParentheses(self, S):
        stack = [0]
        for c in S:
            if c == '(':
                stack.append(0)
            else:
                last = stack.pop()
                stack[-1] += max(1, 2*last)
        return stack[0]",O(n)
"def solve(n, k):

	if n >= 60:
		return ""YES "" + str(n - 1)

	mxxx = (4 ** n - 1) // 3

	if k > mxxx:
		return 'NO'

	mn, mx = 0, 0

	for i in range(n):
		mn += 2 ** (i + 1) - 1
		mx += 4 ** i
		if mn <= k and mx >= k:
			return ""YES "" + str(n - i - 1)

	if k >= 22 and k <= 25:
		return 'YES ' + str(n - 3)

	if k == 2:
		if n >= 2:
			return 'YES ' + str(n - 1)
		return 'NO'

	if k == 3:
		if n <= 2:
			return 'NO'
		return 'YES ' + str(n - 1)

	if k >= 6 and k <= 10:
		return 'YES ' + str(n - 2)

t = int(input())

for i in range(t):
	n, k = map(int, input().split())
	print(solve(n, k))
",O(logn)
"from itertools import *
n, s = map(int, input().split())
times = []
for i in range(n):
    h, m = map(int, input().split())
    times.append((h * 60 + m))

times.sort()
for t in count():
    if all(abs(u - t) > s for u in times):
        print(*divmod(t, 60))
        break
",O(n)
"from sys import stdin,stdout
from math import ceil,log
def main():
	d={}
	n=int(stdin.readline())
	a=list(map(int,stdin.readline().split( )))
	m=-1;mm=10**10
	for v in a:
		if v not in d:
			d[v]=1
		else:
			d[v]+=1
		m=max(m,v)
		mm=min(mm,v)
	ans=0

	for v in a:

		exponent=ceil(log(v,2))
		power=2**exponent
		find=0
		while power-v>=0:
			if power-v>mm and power-v>m:
				break

			element=power-v
			if element in d and element==v and d[element]>1:
				find=1
				break
			elif element in d and element!=v:
				find=1
				break
			power=power*2
		if find==0:
			ans+=1
	stdout.write(""%d\n""%(ans))

main()",O(nlogn)
"n, l, r, x = map(int, input().split())
tasks = list(map(int, input().split()))
mask = 3
ans = 0

while (mask < (1 << n)):
    sum_dif = 0
    min_diff = float(""inf"")
    max_diff = -float(""inf"")

    if (mask & (mask-1)):
        for i in range(n):
            if (mask & (1 << i)):
                sum_dif += tasks[i]
                min_diff = min(min_diff, tasks[i])
                max_diff = max(max_diff, tasks[i])
        if (x <= (max_diff - min_diff)) and (l <= sum_dif <= r):
            ans += 1

    mask += 1

print(ans)",np
"class Solution(object):
    def clumsy(self, N):
        if N <= 2:
            return N
        if N <= 4:
            return N+3
        
        if N % 4 == 0:
            return N+1
        elif N % 4 <= 2:
            return N+2
        return N-1",O(1)
"class Solution(object):
    def shortestPalindrome(self, s):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        if not s:
            return s

        A = s + 
        return s[getPrefix(A)[-1]+1:][::-1] + s",O(n)
"import collections


class Solution(object):
    def numEquivDominoPairs(self, dominoes):
        counter = collections.Counter((min(x), max(x)) for x in dominoes)
        return sum(v*(v-1)//2 for v in counter.values())",O(n)
"from sys import stdin,stdout
stdout.flush()
def qu(a,b):
    print(""?"",a,b)
    return int(input())
a=0
b=0
big=qu(a,b)
for i in range(29,-1,-1):
    x=2**i
    f=qu(a+x,b)
    l=qu(a,b+x)
    if l==f:
        if big==1:
            a+=x
        else:
            b+=x
        big=f
    elif f==-1:
        a+=x
        b+=x
print(""!"",a,b)
",O(1)
"class Solution(object):
    def __init__(self):
        def dayOfMonth(M):
            return (28 if (M == 2) else 31-(M-1)%7%2)

        self.__lookup = [0]*12
        for M in range(1, len(self.__lookup)):
            self.__lookup[M] += self.__lookup[M-1]+dayOfMonth(M)
            
    def dayOfYear(self, date):
        Y, M, D = list(map(int, date.split(""-"")))
        leap = 1 if M > 2 and (((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0)) else 0
        return self.__lookup[M-1]+D+leap",O(1)
"n, a, b = map(int, input().split())
if a > 1 < b or a * b == 1 and 1 < n < 4:
    print('NO')
else:
    z, o = ('01', '10')[a < b]
    l = [[z] * n for _ in range(n)]
    for i in range(n):
        l[i][i] = '0'
    for i in range(n - a * b):
        l[i][i + 1] = l[i + 1][i] = o
    print('YES')
    print('\n'.join(map(''.join, l)))",O(n ^ 2)
"import collections


class Solution(object):
    def minTime(self, n, edges, hasApple):
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        result = [0, 0]
        s = [(1, (-1, 0, result))]
        while s:
            step, params = s.pop()
            if step == 1:
                par, node, ret = params
                ret[:] = [0, int(hasApple[node])]
                for nei in reversed(graph[node]):
                    if nei == par:
                        continue
                    new_ret = [0, 0]
                    s.append((2, (new_ret, ret)))
                    s.append((1, (node, nei, new_ret)))
            else:
                new_ret, ret = params
                ret[0] += new_ret[0]+new_ret[1]
                ret[1] |= bool(new_ret[0]+new_ret[1])
        return 2*result[0]",O(n)
"n = int(input())
d = {}
for _ in range(n):
  a, x = map(int, input().split())
  d[a] = x
m = int(input())
for _ in range(m):
  b, y = map(int, input().split())
  d[b] = max(d.get(b, 0), y)
print(sum(d.values()))",O(nlogn)
"import collections



class Solution(object):
    def equalFrequency(self, word):
        cnt = collections.Counter(iter(collections.Counter(word).values()))
        if len(cnt) > 2:
            return False
        if len(cnt) == 1:
            a = list(cnt.keys())[0]
            return a == 1 or cnt[a] == 1
        a, b = list(cnt.keys())
        if a > b:
            a, b = b, a
        return (a == 1 and cnt[a] == 1) or (a+1 == b and cnt[b] == 1)",O(n)
"import collections



class Solution(object):
    def isReflected(self, points):
        if not points:
            return True
        groups_by_y = collections.defaultdict(set)
        left, right = float(""inf""), float(""-inf"")
        for p in points:
            groups_by_y[p[1]].add(p[0])
            left, right = min(left, p[0]), max(right, p[0])
        mid = left + right
        for group in list(groups_by_y.values()):
            for x in group:
                if mid - x not in group:
                    return False
        return True",O(n)
"class Solution(object):
    def findLengthOfLCIS(self, nums):
        result, count = 0, 0
        for i in range(len(nums)):
            if i == 0 or nums[i-1] < nums[i]:
                count += 1
                result = max(result, count)
            else:
                count = 1
        return result",O(n)
"def steps(start, target):

    ans = 0
    for i, v in enumerate(start):
        u = target[i]
        if v != u:
            for j in range(i+1, len(start)):
                a, b = start[j], target[j]
                if a != b and a == u:
                    start[i], start[j] = start[j], start[i]
                    break
            ans += 1

    return ans

def solve(seq):
    hc = seq.count('H')
    tc = len(seq) - hc
    ans = float('inf')
    for i in range(tc+1):
        s = ['T'] * i + ['H'] * hc + ['T'] * (tc-i)
        ans = min(steps(seq.copy(), s), ans)
    for i in range(hc+1):
        s = ['H'] * i + ['T'] * tc + ['H'] * (hc-i)
        ans = min(steps(seq.copy(), s), ans)
    return ans

N = int(input())
line = list(input())
print(solve(line))",O(n)
"class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        if not digits:
            return [1]

        if digits[-1] < 9:
            digits[-1] += 1
            return digits
        else:
            return self.plusOne(digits[:-1]) + [0]
",O(n)
"import sys

n, m = [int(w) for w in input().split()]
x = [int(w) for w in input().split()]
t = [int(w) for w in input().split()]

if m == 1:
    print(n)
    sys.exit(0)

p = []
tx = []
for i in range(n+m):
    (tx if t[i] == 1 else p).append(x[i])

a = [0] * m
i = 0
for pi in p:
    while i < m-1 and pi > (tx[i]+tx[i+1])/2:
        i += 1
    a[i] += 1

print("" "".join(str(ai) for ai in a))
",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase
from collections import Counter

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)

def lcm(a, b):
    return (a * b) / gcd(a, b)

def main():
    n=int(input())
    if n<6:
        print(-1)
    else:
        for i in range(2, n-2+1):
            print(1, i)
        print(2, n-1)
        print(2, n)
    for i in range(1,n):
        print(i, i+1)

    return

if __name__ == ""__main__"":
    main()",O(n)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def inorderTraversal(self, root):
        result, curr = [], root
        while curr:
            if curr.left is None:
                result.append(curr.val)
                curr = curr.right
            else:
                node = curr.left
                while node.right and node.right != curr:
                    node = node.right

                if node.right is None:
                    node.right = curr
                    curr = curr.left
                else:
                    result.append(curr.val)
                    node.right = None
                    curr = curr.right

        return result


",O(n)
"import random



class Solution(object):
    def largestEvenSum(self, nums, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        nth_element(nums, k-1, compare=lambda a, b: a > b)
        total = sum(nums[i] for i in range(k))
        if total%2 == 0:
            return total
        min_k = [float(""inf"")]*2
        for i in range(k):
            min_k[nums[i]%2] = min(min_k[nums[i]%2], nums[i])
        result = -1
        for i in range(k, len(nums)):
            result = max(result, total-min_k[not (nums[i]%2)]+nums[i])
        return result",O(n)
"import threading


class Solution(object):
    def __init__(self, n):
        self.__n = n
        self.__curr = 0
        self.__cv = threading.Condition()

    def fizz(self, printFizz):
        for i in range(1, self.__n+1):
            with self.__cv:
                while self.__curr % 4 != 0:
                    self.__cv.wait()
                self.__curr += 1
                if i % 3 == 0 and i % 5 != 0:
                    printFizz()
                self.__cv.notify_all()

    def buzz(self, printBuzz):
        for i in range(1, self.__n+1):
            with self.__cv:
                while self.__curr % 4 != 1:
                    self.__cv.wait()
                self.__curr += 1
                if i % 3 != 0 and i % 5 == 0:
                    printBuzz()
                self.__cv.notify_all()

    def fizzbuzz(self, printFizzBuzz):
        for i in range(1, self.__n+1):
            with self.__cv:
                while self.__curr % 4 != 2:
                    self.__cv.wait()
                self.__curr += 1
                if i % 3 == 0 and i % 5 == 0:
                    printFizzBuzz()
                self.__cv.notify_all()

    def number(self, printNumber):
        for i in range(1, self.__n+1):
            with self.__cv:
                while self.__curr % 4 != 3:
                    self.__cv.wait()
                self.__curr += 1
                if i % 3 != 0 and i % 5 != 0:
                    printNumber(i)
                self.__cv.notify_all()",O(n)
"class Solution(object):
    def beautifulSplits(self, nums):
        def z_function(s): 
            z = [0]*len(s)
            l, r = 0, 0
            for i in range(1, len(z)):
                if i <= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 > r:
                    l, r = i, i+z[i]-1
            return z

        result = 0
        z0 = z_function(nums)
        for i in range(1, len(nums)-1):
            zi = z_function(nums[i:])
            for j in range(i+1, len(nums)):
                if (z0[i] >= i and j-i >= i) or zi[j-i] >= j-i:
                    result += 1
        return result",O(n ^ 2)
"import math
n=int(input())
columns=list(map(int, input().rstrip().split()))

modcolumns=[i%2 for i in columns]

test=0

previouslist=[]

for i in range(0,n):
    if len(previouslist)==0:
        previouslist.append(modcolumns[i])

    elif modcolumns[i]==previouslist[-1]:
        previouslist.pop()

    else:
        previouslist.append(modcolumns[i])

if len(previouslist)<=1:
    print(""YES"")
else:
    print(""NO"")
",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

        
class Solution(object):
    def flipMatchVoyage(self, root, voyage):
        def dfs(root, voyage, i, result):
            if not root:
                return True
            if root.val != voyage[i[0]]:
                return False
            i[0] += 1
            if root.left and root.left.val != voyage[i[0]]:
                result.append(root.val)
                return dfs(root.right, voyage, i, result) and \
                       dfs(root.left, voyage, i, result)
            return dfs(root.left, voyage, i, result) and \
                   dfs(root.right, voyage, i, result)
        
        result = []
        return result if dfs(root, voyage, [0], result) else [-1]",O(n)
"class Solution2(object):
    def findBuildings(self, heights):
        result = []
        for i in reversed(range(len(heights))):
            if not result or heights[result[-1]] < heights[i]:
                result.append(i)
        result.reverse()
        return result",O(n)
"import collections


class Solution(object):
    def subarraysWithKDistinct(self, A, K):
        def atMostK(A, K):
            count = collections.defaultdict(int)
            result, left = 0, 0
            for right in range(len(A)):
                count[A[right]] += 1
                while len(count) > K:
                    count[A[left]] -= 1
                    if count[A[left]] == 0:
                        count.pop(A[left])
                    left += 1
                result += right-left+1
            return result
        
        return atMostK(A, K) - atMostK(A, K-1)",O(n)
"class Solution(object):
    def maxScoreIndices(self, nums):
        result = []
        mx = zeros = 0
        total = sum(nums)
        for i in range(len(nums)+1):
            zeros += ((nums[i-1] if i else 0) == 0)
            if zeros+(total-(i-zeros)) > mx:
                mx = zeros+(total-(i-zeros))
                result = []
            if zeros+(total-(i-zeros)) == mx:
                result.append(i)
        return result",O(n)
"import sys,atexit
from io import BytesIO
inp = BytesIO(sys.stdin.buffer.read())
input = lambda:inp.readline().decode('ascii')
buf = BytesIO()
sys.stdout.write = lambda s: buf.write(s.encode('ascii'))
atexit.register(lambda:sys.__stdout__.buffer.write(buf.getvalue()))

n,m = map(int,input().split())
if m%2 == 0:
    steps = []
    for j in range(m//2):
        for i in range(n):
            steps.append((j,i))
            steps.append((m-j-1,n-i-1))
else:
    steps = []
    for j in range(m//2):
        for i in range(n):
            steps.append((j,i))
            steps.append((m-j-1,n-i-1))
    l = 0
    r = n-1
    mid = m//2
    while l<=r:
        steps.append((mid,l))
        if l != r:
            steps.append((mid,r))
        l += 1
        r -= 1

for x,y in steps:
    print(y+1,x+1)
",O(n ^ 2)
"n = int(input())
a = list(map(int,input().split()))
rev = [-1] * (n + 1)
for i, j in enumerate(a):
    rev[j] = i

mx = max(a)

l = a.index(mx)
r = l

for i in range(n - 1, 0, -1):
    idx = rev[i]
    if idx == l - 1:
        l -= 1
    elif idx == r + 1:
        r += 1
    else:
        print('NO')
        exit()
print('YES')",O(n)
"from sys import stdin, stdout

def binary_exp(x,n,prime):
	if n==0:
		return 1
	elif n==1:
		return x%prime
	else:
		temp=binary_exp(x,n//2,prime)
		temp=(temp*temp)%prime
		if n%2==0:
			return temp
		else:
			return ((x%prime)*temp)%prime

x,k = map(int, stdin.readline().rstrip().split())
if x==0:
	print(0)
else:
	val1=binary_exp(2,k+1,1000000007)
	val2=binary_exp(2,k,1000000007)
	val1=val1%1000000007
	val2=val2%1000000007

	ans=((val1*(x%1000000007))%1000000007 -(val2-1)%1000000007)%1000000007
	print(ans)",O(logn)
"def area(rect):
    if rect is None:
        return 0
    x1, y1, x2, y2 = rect
    return (x2-x1+1) * (y2-y1+1)

def get_w(rect):
    if rect is None:
        return 0

    x1, y1, x2, y2 = rect

    ra = area(rect)
    more, less = (ra + 1) // 2, ra // 2

    if (x1 + y1) % 2 == 0:
        return more
    else:
        return less

def intersect_rects(r1, r2):
    out = []
    for i, a, b in zip(range(4), r1, r2):
        out.append(max(a,b) if i < 2 else min(a,b))

    if out[0] > out[2] or out[1] > out[3]:
        return None
    return out

def main():
    n, m = list(map(int, input().split()))
    rect1 = list(map(int, input().split()))
    rect2 = list(map(int, input().split()))
    rect12 = intersect_rects(rect1, rect2)

    w_start = get_w([1,1,n,m])
    w1 = get_w(rect1)
    w2 = get_w(rect2)
    w12 = get_w(rect12)

    w = w_start - w1 - w2 + w12 + area(rect1) - area(rect12)
    print(w, n*m-w)

q = int(input())
for i in range(q):
    main()
",O(1)
"class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        stack = [root]
        mp = {None: (0, 0)}

        while stack:
            node = stack[-1]

            if node.left and node.left not in mp:
                stack.append(node.left)
            elif node.right and node.right not in mp:
                stack.append(node.right)
            else:
                node = stack.pop()

                leftHeight, leftDiameter = mp[node.left]
                rightHeight, rightDiameter = mp[node.right]

                mp[node] = (1 + max(leftHeight, rightHeight),
                           max(leftHeight + rightHeight, leftDiameter, rightDiameter))

        return mp[root][1]
",O(n)
"def main():
    n = int(input())
    a = list(map(int, input().split()))
    r = 0
    while a:
        c = a[0]
        del a[0]
        for i in range(len(a)):
            if c == a[i]:
                break
        del a[i]
        r += i
    print(r)

if __name__ == ""__main__"":
    main()
",O(n ^ 2)
"import math
def f(n,s):
    d=[-n,-n];d[s]=0
    for i in range(y//g):
	    d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
    return d[s]
n,x,y=map(int,input().split());
g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));
y+=x;
print(n%g*h(n//g+1)+(g-n%g)*h(n//g))
",np
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

n = ii()
ans = 0
for i in range(2, n):
    for j in range(2 * i, n + 1, i):
        ans += j // i
print(ans * 4)",O(nlogn)
"class Solution3(object):
    def lengthOfLIS(self, nums):
        class BIT(object): 
            def __init__(self, n, default=0, fn=lambda x, y: x+y):
                self.__bit = [default]*(n+1) 
                self.__default = default
                self.__fn = fn

            def update(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = self.__fn(self.__bit[i], val)
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = self.__default
                while i > 0:
                    ret = self.__fn(ret, self.__bit[i])
                    i -= (i & -i)
                return ret
    
        lookup = {x:i for i, x in enumerate(sorted(set(nums)))}
        bit = BIT(len(lookup), fn=max)
        for x in nums:
            bit.update(lookup[x], bit.query(lookup[x]-1)+1)
        return bit.query(len(lookup)-1)



class SegmentTree(object): 
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=lambda x, y: y if x is None else max(x, y), 
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h): 
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1: 
                self.__apply(L, h) 
                L += 1
            if R & 1 == 0: 
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R): 
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = None
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1: 
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0: 
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return "","".join(map(str, showList))",O(nlogn)
"n = int(input())
a = [int(i) for i in input().split()]
a.sort()
count = 0
for i in range(n):
    cur_c = a[i]
    if not cur_c:
        continue
    count += 1
    for j in range(i+1,n):
        if a[j]%cur_c == 0:
            a[j] = 0
print(count)",O(n ^ 2)
"import atexit
import io
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER

@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())

def main():
    n, a, b = [int(x) for x in input().split()]
    dc = {}
    for i in range(n):
        x, vx, vy = [int(x) for x in input().split()]
        nx = x + vx
        ny = a*x+b + vy
        dd = a*nx - ny + b
        if dd not in dc:
            dc[dd] = {}
        if (vx,vy) not in dc[dd]:
            dc[dd][(vx,vy)] = 0
        dc[dd][(vx,vy)] += 1

    tot = 0
    for v,k in dc.items():
        tt = 0
        pp =0
        for _,cc in k.items():
            tt -= cc * (cc+1) // 2
            pp += cc
        tt += pp * (pp+1) // 2
        tot += tt*2
    print(tot)

if __name__ == '__main__':
    main()
",O(n)
"import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

sys.setrecursionlimit(200000)
r, g, b = map(int, input().split())
R = list(map(int, input().split()))
G = list(map(int, input().split()))
B = list(map(int, input().split()))
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)

dp = [[[0 for i in range(b+5)] for j in range(g+5)] for k in range(r+5)]

def solve(i, j, k):
    x, y, z = 0, 0, 0
    if dp[i][j][k]:
        return dp[i][j][k]
    if i < r and j < g:
        x = (R[i] * G[j]) + solve(i+1, j+1, k)
    if i < r and k < b:
        y = (R[i] * B[k]) + solve(i+1, j, k+1)
    if j < g and k < b:
        z = (G[j] * B[k]) + solve(i, j+1, k+1)
    mx = max([x, y, z])
    dp[i][j][k] = mx
    return mx

print(solve(0, 0, 0))
",O(n ^ 3)
"import math

def gaosi(x):
    if (x==1):
        return 1
    else:
        return ((1+x)*x)/2

def calc(mid, total, left):
    return gaosi(mid) - (total - mid) - left

def main():
    x, left = map(int, input().split())
    if (x == 1 and left == 1):
        print(0)
    else:
        l = 1
        r = x
        while (True):
            mid = math.floor((l + r) / 2)
            result = calc(mid, x, left)
            if (result == 0):
                print(x - mid)
                break
            elif (result > 0):
                r = mid
            elif (result  < left):
                l = mid

if __name__ == ""__main__"":
    main()",O(logn)
"N, K = input().split()
N, K = int(N), int(K)
P = [int(x) for x in input().split()]
A = [None]*256
A[0] = 0
for i in range(N):
    pn = P[i]
    if A[pn] is None:
        for j in range(K-1, -1, -1):
            if pn < j: continue
            if A[pn-j] is None:
                A[pn-j] = pn-j
                break
            else:
                if A[pn-j] + K - 1 >= pn:
                    break
        for jj in range(j, -1, -1):
            A[pn-jj] = A[pn-j]
print(*[A[P[i]] for i in range(N)])
",O(n ^ 2)
"class Solution(object):
    def maxAbsoluteSum(self, nums):
        curr = mx = mn = 0
        for num in nums:
            curr += num
            mx = max(mx, curr)
            mn = min(mn, curr)
        return mx-mn",O(n)
"import collections


class Solution(object):
    def minReorder(self, n, connections):
        lookup, graph = set(), collections.defaultdict(list)
        for u, v in connections:
            lookup.add(u*n+v)
            graph[v].append(u)
            graph[u].append(v) 
        result = 0
        stk = [(-1, 0)]
        while stk:
            parent, u = stk.pop()
            result += (parent*n+u in lookup)
            for v in reversed(graph[u]):
                if v == parent:
                    continue
                stk.append((u, v))
        return result",O(n)
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math

alphabets = list('abcdefghijklmnopqrstuvwxyz')

def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))
def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def fastPrintNextLines(a):

    print('\n'.join(map(str,a)))

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"")
else:
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
t = 1

for _ in range(t):
    n = ii()
    a = li()
    s = sum(a)
    cur = 0
    for i in range(n):
        cur+=a[i]
        if cur>=s/2:
            print(i+1)
            break
",O(n)
"def AP_Term(n):
    return (n*(1+n))//2

act, cleft = map(int, input().split())
if cleft != AP_Term(act):
    low = 1
    high = act
    ans = 0
    while low <= high:
        mid = low + (high-low)//2
        candy_in = AP_Term(mid)
        moves_left = (act - mid)
        if cleft == (candy_in - moves_left):
            ans = (moves_left)
            break
        elif cleft > (candy_in - moves_left):
            low = mid+1
        else:
            high = mid-1
    print(ans)
else:
    print(0)",O(logn)
"class Solution2(object):
    def minTime(self, n, edges, hasApple):
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        result = [0]
        s = [(1, (-1, 0, result))]
        while s:
            step, params = s.pop()
            if step == 1:
                par, node, ret = params
                tmp = [int(hasApple[node])]
                s.append((3, (tmp, ret)))
                for nei in reversed(graph[node]):
                    if nei == par:
                        continue
                    new_ret = [0]
                    s.append((2, (new_ret, tmp, ret)))
                    s.append((1, (node, nei, new_ret)))
            elif step == 2:
                new_ret, tmp, ret = params
                ret[0] += new_ret[0]
                tmp[0] |= bool(new_ret[0])
            else:
                tmp, ret = params
                ret[0] += tmp[0]
        return 2*max(result[0]-1, 0)",O(n)
"n = int(input())
ans = [(0, 0)]
for i in range(1, n):
    ans.append((0, i))
    ans.append((i, 0))
    ans.append((0, -i))
    ans.append((-i, 0))
for i in range(n):
    print(str(ans[i][0]) + ' ' + str(ans[i][1]))
",O(n)
"n,k = map(int,input().split())
s= input()
s1=s
c=0
for i in range(len(s)-1):
    if(s[:i+1]==s[n-i-1:]):
        c=i+1
for i in range(k-1):
    s1+=s[c:]
print(s1)",O(n ^ 2)
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop, heapify
from bisect import bisect_left , bisect_right
import math

alphabets = list('abcdefghijklmnopqrstuvwxyz')

from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    c = dict(Counter(l))
    return list(set(l))

def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res

def sieveForSmallestPrimeFactor():
    MAXN = 100001
    spf = [0 for i in range(MAXN)]
    spf[1] = 1
    for i in range(2, MAXN):
        spf[i] = i
    for i in range(4, MAXN, 2):
        spf[i] = 2
    for i in range(3, math.ceil(math.sqrt(MAXN))):
        if (spf[i] == i):
            for j in range(i * i, MAXN, i):
                if (spf[j] == j):
                    spf[j] = i
    return spf
def getPrimeFactorizationLOGN(x):
    spf = sieveForSmallestPrimeFactor()
    ret = list()
    while (x != 1):
        ret.append(spf[x])
        x = x // spf[x]
    return ret

def SieveOfEratosthenes(n):

    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def si():
    return input()
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"")
else:
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

def solve():
    n,a,b,c,t = li()
    ti = li()
    if b>c:
        print(n*a)
    else:
        ans = 0
        ti.sort()
        for i in ti:
            ans+=(t-i)*(c-b)+a
        print(ans)

t = 1

for _ in range(t):
    solve()
",O(n)
"n, m = map(int, input().split())
c = []
for j in range(n):
    d = []
    s = input()
    for i in s:
        d.append(i)
    c.append(d)
a = []
b = []
e=[]
g=[]

for j in range(n):
    k=[0]*(m)
    e.append(k)
for j in range(n):
    k=[0]*(m)
    g.append(k)

dpu = []
for j in range(n):
    k=[0]*(m)
    dpu.append(k)
dpd = []
for j in range(n):
    k=[0]*(m)
    dpd.append(k)
dpl = []
for j in range(n):
    k=[0]*(m)
    dpl.append(k)
dpr = []
for j in range(n):
    k=[0]*(m)
    dpr.append(k)
for i in range(n):
    for j in range(m):
        if c[i][j] == ""*"":
            if i>0:
                dpu[i][j]+=dpu[i-1][j]+1
            else:
                dpu[i][j]=1
            if j>0:
                dpl[i][j]=dpl[i][j-1]+1
            else:
                dpl[i][j]=1
i=n-1
while(i>=0):
    j=m-1
    while(j>=0):
        if c[i][j] == ""*"":
            if i<(n-1):
                dpd[i][j] += dpd[i + 1][j] + 1
            else:
                dpd[i][j] = 1
            if j<(m-1):
                dpr[i][j] = dpr[i][j + 1] + 1
            else:
                dpr[i][j] = 1
        j+=-1
    i+=-1
for i in range(1,n-1):
    for j in range(1,m-1):
        if c[i][j] == ""*"":
            k=min(dpd[i][j]-1,dpu[i][j]-1,dpr[i][j]-1,dpl[i][j]-1)
            if k==0:
                pass
            elif k>0:
                a.append([i+1,j+1,k])
                e[i-k][j]+=1
                if (i+k)<(n-1):
                    e[i+k+1][j]+=-1
                g[i][j-k] += 1
                if (j + k) < (m - 1):
                    g[i][j+k+1] += -1
for i in range(m):
    for j in range(1,n):
        if c[j-1][i]==""*"":
            e[j][i]+=e[j-1][i]
for i in range(n):
    for j in range(1,m):
        if c[i][j-1]==""*"":
            g[i][j]+=g[i][j-1]
f=0
for i in range(n):
    for j in range(m):
        if c[i][j]==""*"" and e[i][j]<=0 and g[i][j]<=0:
            f=1
            break
if f==1:
    print(-1)
else:
    print(len(a))
    for j in a:
        print(*j)
",O(n ^ 2)
"from sys import stdin
from collections import deque
n=int(stdin.readline())
g=dict()
for i in range(n-1):
    a,b=map(int,stdin.readline().split())
    g.setdefault(a, set()).add(b)
    g.setdefault(b, set()).add(a)
a=[int(x) for x in stdin.readline().split()]
ans = True
if n > 1 and a[0] == 1:
    q=deque()
    m=[0]*(n+1)
    q.append(1)
    m[1]=1
    right=1
    while len(q) > 0 and ans:
        first = q.popleft()
        cnt = 0
        for v in g[first]:
            if m[v] == 0:
                cnt += 1
        for i in range(right, right+cnt):
            if m[a[i]] == 0 and a[i] in g[first]:
                m[a[i]] = 1
                q.append(a[i])
            else:
                ans = False
                break
        right += cnt
else:
    ans = a[0] == 1
if ans:
    print(""Yes"")
else:
    print(""No"")
",O(n)
"import collections
from functools import cmp_to_key

import sys
def getIntList():
    return list(map(int, input().split()))

import bisect

base = 10**9  + 7
def get2k(k) :
    f = 2
    b = 1
    r = 1
    while k>=b:
        if k &b >0:
            r = r*f % base
        b*=2
        f = f*f % base
    return r

x, k = getIntList()
if x ==0:
    print(0)
    sys.exit()
t2k = get2k(k)

r = x *   t2k *2 - t2k + 1
r = r% base
print(r)
",O(logn)
"import sys
input = sys.stdin.readline

def main():
    n,m = map(int,input().split())
    a = []
    for _ in [0]*n:
        a.append(list(map(int,input().split())))

    ok = 0
    ng = 10**9+1
    judge = pow(2,m)-1
    dg = 1000

    while ng-ok > 1:
        mid = (ng+ok)//2
        tank = set()
        for i in range(n):
            r = 0
            for j in range(m):
                r *= 2
                if a[i][j] >= mid:
                    r += 1
            tank.add(r)

        for p in tank:
            for q in tank:
                if p|q == judge:
                    ok = mid
                    break
        if ok != mid:
            ng = mid

    tank = set()
    res = []
    for i in range(n):
        r = 0
        for j in range(m):
            r *= 2
            if a[i][j] >= ok:
                r += 1
        if not r in tank:
            res.append(i*dg+r)
        tank.add(r)

    for p in res:
        for q in res:
            if (p%dg)|(q%dg) == judge:
                print(p//dg+1,q//dg+1)
                return

if __name__ == '__main__':
    main()",np
"n = int(input())
game = list(map(int, input().split()))
game.append(-1)
game.sort()
bitSum = game[1] % 2
rep = False
for i in range(1, n):
    bitSum += game[i + 1] % 2
    if game[i] == game[i + 1]:
        if rep:
            print('cslnb')
            exit(0)
        else:
            if game[i - 1] == game[i] - 1:
                print('cslnb')
                exit(0)
            rep = True
Goal = ((n * (n - 1)) / 2) % 2
if (bitSum + Goal) % 2 == 0:
    print('cslnb')
else:
    print('sjfnb')",O(nlogn)
"n=int(input())
l=list(map(int,input().split()))
r=list(map(int,input().split()))
if l[0]!=0 or r[n-1]!=0:
    print(""NO"")
    exit(0)
s=[(l[i]+r[i]) for i in range(n)]
m=max(s)+1
k=[]
for i in s:
    k.append(m-i)
l1=[]
r1=[]

for i in range(n):
    c=0
    d=0
    for j in range(0,i):
        if k[j]>k[i]:
            c+=1
    l1.append(c)
    for j in range(i+1,n):
        if k[j]>k[i]:
            d+=1
    r1.append(d)
if l1!=l or r1!=r:
    print(""NO"")
else:
    print(""YES"")
    print(*k)
",O(n ^ 2)
"from math import *
k,n=map(int,input().split())
print(ceil(n/k))",O(1)
"n,k=[int(x) for x in input().split()]
lst1=[int(x) for x in input().split()]
lst2=[int(x) for x in input().split()]
lst3={}
ans=[]
for i in lst2:
    if(i in lst1):

        lst3[i]=lst1.index(i)
for i in sorted(lst3,key=lst3.get):
    ans.append(i)

print(*ans,sep="" "")
",O(n ^ 2)
"n = int(input())
a = list(map(int, input().split()))
d = set(a)
if (0 in a):
    print(len(d)-1)
else:
    print(len(d))",O(n)
"class Solution(object):
    def findLongestChain(self, pairs):
        pairs.sort(key=lambda x: x[1])
        cnt, i = 0, 0
        for j in range(len(pairs)):
            if j == 0 or pairs[i][1] < pairs[j][0]:
                cnt += 1
                i = j
        return cnt",O(nlogn)
"n = int(input())

if n == 3:
    print('1 1 3')
    exit()
if n == 1:
    print('1')
    exit()
if n == 2:
    print('1 2')
    exit()
d = 2
ans = []
lfn = n
while d <= n:
    k = n // d
    for j in range(lfn - k):
        ans.append(d//2)
    lfn = n - len(ans)
    d *=2
d //= 2
k = n/d
if k < 1.5:
    ans.append(d)
else:
    ans.append(d + d//2)
print(' '.join([str(i) for i in ans]))",O(nlogn)
"from itertools import permutations

n = int(input())
a = []
for i in range(4):
    a.append([list(map(int, list(input()))) for j in range(n)])
    if i < 3:
        input()

ans = 10 ** 10
for i in permutations(a, 4):
    cnt = 0
    total = 0
    for j in i:
        if cnt < 2:
            cnt2 = 0
            for p in j:
                for q in p:
                    if q != cnt2 % 2:
                        total += 1
                    cnt2 += 1
        else:
            cnt2 = 1
            for p in j:
                for q in p:
                    if q != cnt2 % 2:
                        total += 1
                    cnt2 += 1
        cnt += 1

    ans = min(ans, total)

print(ans)",O(n ^ 2)
"n, p=map(int, input().split())
arr=list(map(int, input().split()))
su=0
for i in range(n):
	su+=arr[i]
maxi, f=0, 0
for i in range(n-1):
	f+=arr[i]
	maxi=max(maxi, f%p+(su-f)%p)
print(maxi)",O(n)
"class Solution(object):
    def eliminateMaximum(self, dist, speed):
        for i in range(len(dist)):
            dist[i] = (dist[i]-1)//speed[i]
        dist.sort()
        result = 0
        for i in range(len(dist)):
            if result > dist[i]:
                break
            result += 1
        return result",O(nlogn)
"print(""?"",0,0)
e=int(input())
astr=""000000000000000000000000000000""
bstr=""000000000000000000000000000000""
abig=e
for i in range(30):
    if abig==0:
        print(""?"",int(astr,2)+2**(29-i),int(bstr,2))
        e=int(input())
        if e==1:
            continue
        else:
            if i<29:
                astr=astr[:i]+""1""+astr[i+1:]
                bstr=bstr[:i]+""1""+bstr[i+1:]
            else:
                astr=astr[:i]+""1""
                bstr=bstr[:i]+""1""
    else:
        print(""?"",int(astr,2)+2**(29-i),int(bstr,2)+2**(29-i))
        e=int(input())
        if e==-abig:
            if abig==1:
                if i<29:
                    astr=astr[:i]+""1""+astr[i+1:]
                else:
                    astr=astr[:i]+""1""
            else:
                if i<29:
                    bstr=bstr[:i]+""1""+bstr[i+1:]
                else:
                    bstr=bstr[:i]+""1""
            print(""?"",int(astr,2),int(bstr,2))
            abig=int(input())
        else:
            print(""?"",int(astr,2)+2**(29-i),int(bstr,2))
            e=int(input())
            if e==-1:
                if i<29:
                    astr=astr[:i]+""1""+astr[i+1:]
                    bstr=bstr[:i]+""1""+bstr[i+1:]
                else:
                    astr=astr[:i]+""1""
                    bstr=bstr[:i]+""1""
print(""!"",int(astr,2),int(bstr,2))",O(1)
"class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [[0] * 2 for _ in range(n)]
        dp[n - 1][1] = dp[n - 1][0] = nums[n - 1]
        for i in range(n - 2, -1, -1):
            dp[i][1] = max(nums[i], nums[i] + dp[i + 1][1])
            dp[i][0] = max(dp[i + 1][0], dp[i][1])

        return dp[0][0]
",O(n)
"class Solution(object):
    def maxSum(self, nums):
        mx = max(nums)
        return mx if mx < 0 else sum(x for x in set(nums) if x >= 0)",O(n)
"class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:

        matrix.reverse()

        for i in range(len(matrix)):
            for j in range(i + 1, len(matrix)):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
",O(n ^ 2)
"class Solution(object):
    def thirdMax(self, nums):
        count = 0
        top = [float(""-inf"")] * 3
        for num in nums:
            if num > top[0]:
                top[0], top[1], top[2] = num, top[0], top[1]
                count += 1
            elif num != top[0] and num > top[1]:
                top[1], top[2] = num, top[1]
                count += 1
            elif num != top[0] and num != top[1] and num >= top[2]:
                top[2] = num
                count += 1

        if count < 3:
            return top[0]

        return top[2]",O(n)
"import sys
import string

def ria():
    return [int(i) for i in input().split()]

n = ria()[0]
ar = ria()

if n == 1:
    print(ar[0])
    exit(0)

onlyNegs = True
onlyPos = True

if max(ar) >= 0:
    onlyNegs = False
if min(ar) <= 0:
    onlyPos = False

if onlyNegs:
    print(abs(sum(ar)) + max(ar) * 2)
    exit(0)

if onlyPos:
    print(abs(sum(ar)) - min(ar) * 2)
    exit(0)

print(sum([abs(i) for i in ar]))
",O(n)
"class Solution:
    def minMeetingRooms(self, intervals: List[Interval]) -> int:
        start = sorted([i.start for i in intervals])
        end = sorted([i.end for i in intervals])

        res = count = 0
        s = e = 0
        while s < len(intervals):
            if start[s] < end[e]:
                s += 1
                count += 1
            else:
                e += 1
                count -= 1
            res = max(res, count)
        return res
",O(nlogn)
"n=int(input())
a=list(map(int,input().split()))
a.sort()
lose=False
pair=False
for i in range(n-1):
  if a[i]==a[i+1]==0:
    lose=True
  if a[i]==a[i+1]:
    if pair:
      lose=True
    pair=True
    if i>=1:
      if a[i]==a[i-1]+1:
        lose=True
if lose:
  print(""cslnb"")
else:
  eventual=n*(n-1)//2
  curr=sum(a)
  if (curr-eventual)%2==0:
    print(""cslnb"")
  else:
    print(""sjfnb"")
",O(nlogn)
"n,k=map(int,input().split())

ar=[-1 for i in range(256)]
ls=list(map(int,input().split()))

for e in ls:
    if ar[e]==-1:
        tmp=max(0,e-k+1)
        for i in range(tmp,e+1):
            if ar[i]!=-1 and ar[i]!=i:
                tmp+=1
                continue
            else:
                while i<=e:
                    ar[i]=tmp
                    i+=1
    print(ar[e],end="" "")
",O(n ^ 2)
"class Solution2(object):
    def postorder(self, root):
        def dfs(root, result):
            for child in root.children:
                if child:
                    dfs(child, result)
            result.append(root.val)
        
        result = []
        if root:
            dfs(root, result)
        return result",O(n)
"import bisect


class Solution(object):
    def findSpecialInteger(self, arr):
        for x in [arr[len(arr)//4], arr[len(arr)//2], arr[len(arr)*3//4]]:
            if (bisect.bisect_right(arr, x) - bisect.bisect_left(arr, x)) * 4 > len(arr):
                return x
        return -1",O(logn)
"class Solution(object):
    def countSubarrays(self, nums, k):
        result = total = left = 0
        for right in range(len(nums)):
            total += nums[right]
            while total*(right-left+1) >= k:
                total -= nums[left]
                left += 1
            result += right-left+1
        return result",O(n)
"turns, candies = map(int, input().split())
summ = 0
turn = 0
while candies != summ - (turns - turn):
    turn += 1
    summ += turn
print(turns - turn)",O(n)
"n, k = map(int, input().split())
same = [0] * (k + 1)
diff = [0] * (k + 1)
mod = 998244353
same[1] = 2
if k > 1 : diff[2] = 2
for i in range (n - 1) :
    newsame = [0] * (k + 1)
    newdiff = [0] * (k + 1)
    for i in range (1, k + 1) : newsame[i] = (same[i] + same[i - 1] + 2 * diff[i]) % mod
    for i in range (2, k + 1) : newdiff[i] = (2 * same[i - 1] + diff[i] + diff[i - 2]) % mod
    same = newsame ; diff = newdiff
print((same[-1] + diff[-1]) % mod)
",np
"l = list(sorted(list(map(int,input().split()))))
if min(l) == 1 or (l[0]==3 and l[1]==3 and l[2]==3) or (l[0]==2 and l[1]==4 and l[2]==4) or(l[0]==2 and l[1] == 2):
    print(""Yes"")
else:
    print(""No"")",O(1)
"n = int(input().strip())
print(n**2+(n-1)**2)",O(1)
"import sys
from math import floor, ceil

r = lambda: sys.stdin.readline().strip()

a = [[0] * 2 for i in range(3)]

def abs(x):
    if x < 0:
        x = -x
    return x

def calcLen(x1, y1, x2, y2):
    return abs(x1 - x2) + abs(y1 - y2) + 1

def main():
    a[0][0], a[0][1] = map(int, r().split())
    a[1][0], a[1][1] = map(int, r().split())
    a[2][0], a[2][1] = map(int, r().split())
    xMax = max(a[0][0], a[1][0], a[2][0])
    xMin = min(a[0][0], a[1][0], a[2][0])
    yMax = max(a[0][1], a[1][1], a[2][1])
    yMin = min(a[0][1], a[1][1], a[2][1])

    pathLen = xMax - xMin + yMax - yMin + 1
    for i in range(3):
        for j in range(3):
            px = a[i][0]
            py = a[j][1]
            sum = 0
            for k in range(3):
                sum += (calcLen(a[k][0], a[k][1], px, py))
            sum -= 2
            if sum == pathLen:
                break
        if sum == pathLen:
            break
    sq = [[0]*(yMax+1) for i in range(xMax+1)]
    for i in range(3):
        if px == a[i][0]:
            c = -1
            if py > a[i][1]:
                c = 1
            for j in range(a[i][1], py, c):
                sq[px][j]=1
        elif py== a[i][1]:
            c = -1
            if px > a[i][0]:
                c= 1
            for j in range(a[i][0], px, c):
                sq[j][py] = 1
        else:
            c = -1
            if py > a[i][1]:
                c = 1
            for j in range(a[i][1], py + c, c):
                sq[a[i][0]][j] = 1

            c = -1
            if px > a[i][0]:
                c= 1
            for j in range(a[i][0], px, c):
                sq[j][py] = 1
    sq[px][py] = 1
    ans = []
    for i in range(xMax + 1):
        for j in range(yMax + 1):
            if sq[i][j] == 1:
                ans.append((i, j))
    print(len(ans))
    for i in ans:
        print(i[0], i[1])

main()
",O(1)
"n, a, b = map(int, input().split())
if min(a, b) > 1 or ((n, a, b,) in ((2, 1, 1), (3, 1, 1))):
    print(""NO"")
    exit()
res = [[0] * n for _ in range(n)]
for i in range(0, n - max(a, b)):
    res[i][i + 1] = res[i + 1][i] = 1
if a == 1:
    res = [[e ^ 1 for e in l] for l in res ]

print(""YES"")
for i in range(n):
    res[i][i] = 0
    print(*res[i], sep='')",O(n ^ 2)
"xa, ya = map(int, input().split())
xb, yb = map(int, input().split())
xc, yc = map(int, input().split())
if (xb, yb) < (xa, ya):
    xa, ya, xb, yb = xb, yb, xa, ya
if (xc, yc) < (xa, ya):
    xa, ya, xc, yc = xc, yc, xa, ya
if xb > xc:
    xb, yb, xc, yc = xc, yc, xb, yb
d = 1 if ya <= yc else -1
if ya <= yb <= yc or ya >= yb >= yc:
    print(xc - xa + abs(yc - ya) + 1)
    for x in range(xa, xb):
        print(x, ya)
    for y in range(ya, yc, d):
        print(xb, y)
    for x in range(xb, xc + 1):
        print(x, yc)
elif yb < min(ya, yc):
    print(xc - xa + max(ya, yc) - yb + 1)
    for x in range(xa, xc + 1):
        print(x, min(ya, yc))
    for y in range(yb, min(ya, yc)):
        print(xb, y)
    if ya < yc:
        for y in range(ya + 1, yc + 1):
            print(xc, y)
    else:
        for y in range(yc + 1, ya + 1):
            print(xa, y)
else:
    print(xc - xa + yb - min(ya, yc) + 1)
    for x in range(xa, xc + 1):
        print(x, max(ya, yc))
    for y in range(max(ya, yc) + 1, yb + 1):
        print(xb, y)
    if ya < yc:
        for y in range(ya, yc):
            print(xa, y)
    else:
        for y in range(yc, ya):
            print(xc, y)
",O(1)
"class Solution(object):
    def canReach(self, s, minJump, maxJump):
        dp = [False]*len(s)
        dp[0] = True
        cnt = 0
        for i in range(1, len(s)):
            if i >= minJump:
                cnt += dp[i-minJump]
            if i > maxJump:
                cnt -= dp[i-maxJump-1]
            dp[i] = cnt > 0 and s[i] == '0'
        return dp[-1]",O(n)
"class Solution_TLE(object):
    def countPrimes(self, n):
        def linear_sieve_of_eratosthenes(n):
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return primes
    
        return len(linear_sieve_of_eratosthenes(n-1))",O(n)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

prime = [True for i in range(200001)]
pp=[0]*200001
def SieveOfEratosthenes(n=200000):

    p = 2
    while (p * p <= n):

        if (prime[p] == True):

            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1

def mergeSort(arr, n):

    temp_arr = [0]*n
    return _mergeSort(arr, temp_arr, 0, n-1)

def _mergeSort(arr, temp_arr, left, right):

    inv_count = 0

    if left < right:

        mid = (left + right)//2

        inv_count += _mergeSort(arr, temp_arr,
                                    left, mid)

        inv_count += _mergeSort(arr, temp_arr,
                                  mid + 1, right)

        inv_count += merge(arr, temp_arr, left, mid, right)
    return inv_count

def merge(arr, temp_arr, left, mid, right):
    i = left
    j = mid + 1
    k = left
    inv_count = 0

    while i <= mid and j <= right:

        if arr[i] <= arr[j]:
            temp_arr[k] = arr[i]
            k += 1
            i += 1
        else:

            temp_arr[k] = arr[j]
            inv_count += (mid-i + 1)
            k += 1
            j += 1

    while i <= mid:
        temp_arr[k] = arr[i]
        k += 1
        i += 1

    while j <= right:
        temp_arr[k] = arr[j]
        k += 1
        j += 1

    for loop_var in range(left, right + 1):
        arr[loop_var] = temp_arr[loop_var]

    return inv_count

n=int(input())
a=list(map(int,input().split()))
r=mergeSort(a, n)
if r%2==(3*n)%2:
    print(""Petr"")
else:
    print(""Um_nik"")",O(nlogn)
"n, s = map(int, input().split())
if not 2*n - 1 <= s <= n * (n+1) // 2:
    print('No')
    exit()
print('Yes')

def ok(d):
    dep, cur, sum, m = 2, 1, 1, 0
    while cur + m < n:
        m += cur
        cur = min(n - m, cur * d)
        sum += cur * dep
        dep += 1
    return sum <= s

l, r = 1, n
while l < r:
    mid = (l+r) // 2
    if ok(mid):
        r = mid
    else:
        l = mid + 1

a, me = [l-1] * (n+1), [_ for _ in range(n+1)]
sum, low = n * (n+1) // 2, 2
while n > low and sum > s:
    dest = min(sum-s, n-low)
    sum -= dest
    me[n] -= dest
    a[me[n]+1] += l
    a[me[n]] -= 1
    if not a[low]: low += 1
    n -= 1
me, l, dg = sorted(me[1:]), 0, 0
for i in me[1:]:
    while me[l] < i-1 or dg == r:
        dg = 0
        l += 1
    print(l+1, end=' ')
    dg += 1
",O(n)
"
import collections



class Solution(object):
    def maxFrequencyElements(self, nums):
        cnt = collections.Counter(nums)
        mx = max(cnt.values())
        return sum(v for v in cnt.values() if v == mx)
",O(n)
"def f(n):
    if n==1:return[1]
    if n==2:return[1,2]
    if n==3:return[1,1,3]
    if n>3:
        L=f(n//2)
        for i in range(len(L)):L[i]*=2
        return [1]*(n-n//2)+L
L=f(int(input()))
s=''
for i in L:s+=(str(i)+' ')
print(s)",O(nlogn)
"from collections import defaultdict

ans = defaultdict(int)
n = int(input())

beg, end = [0] * n, [0] * n

for i in range(n):
    a, b = map(int, input().split())
    beg[i] = a
    end[i] = b + 1
beg.sort()
end.sort()

pa, pb = 0, 0

cur = 0
lst = -1

while pb < n:
    pos = end[pb]
    if pa < n:
        pos = min(pos, beg[pa])

    ans[cur] += pos - lst

    ad = 0
    mn = 0
    while (pa < n and beg[pa] == pos):
        ad += 1
        pa += 1
    while (pb < n and end[pb] == pos):
        pb += 1
        mn -= 1

    lst = pos
    cur += ad + mn

for i in range(1, n + 1):
    print(ans[i], end = ' ')",O(nlogn)
"import collections




class Solution(object):
    def countTriplets(self, A):
        def FWT(A, v):
            B = A[:]
            d = 1
            while d < len(B):
                for i in range(0, len(B), d << 1):
                    for j in range(d):
                        B[i+j] += B[i+j+d] * v
                d <<= 1
            return B

        k = 3
        n, max_A = 1, max(A)
        while n <= max_A:
            n *= 2
        count = collections.Counter(A)
        B = [count[i] for i in range(n)]
        C = FWT([x**k for x in FWT(B, 1)], -1)
        return C[0]",O(nlogn)
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()
def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

n,m=map(int,input().split())
l=[list(map(int,input())) for i in range(n)]
dic={}
discarded={}
for i in range(n):
    for j in range(m):
        if l[i][j]==1 :
            if j+1 not in discarded:
                if j+1 not in dic:
                    dic[j+1]=i+1
                else:
                    del dic[j+1]
                    discarded[j+1]=1

if len(dic)==0:
    print(""YES"")
else:
    kk=list(dic.values())
    temp=list(set(kk))
    if len(temp)==n:
        print(""NO"")
    else:
        print(""YES"")
",O(n ^ 2)
"class Solution(object):
    def findMaximalUncoveredRanges(self, n, ranges):
        ranges.sort()
        covered = [[-1, -1]]
        for left, right in ranges:
            if covered[-1][1] < left:
                covered.append([left, right])
                continue
            covered[-1][1] = max(covered[-1][1], right)    
        covered.append([n, n])        
        return [[covered[i-1][1]+1, covered[i][0]-1] for i in range(1, len(covered)) if covered[i-1][1]+1 <= covered[i][0]-1]",O(nlogn)
"from bisect import bisect_right as br
from bisect import bisect_left as bl
from collections import defaultdict
from itertools import combinations
import sys
import math
MAX = sys.maxsize
MAXN = 10**5+10
MOD = 10**9+7
def isprime(n):
    n = abs(int(n))
    if n < 2:
        return False
    if n == 2:
        return True
    if not n & 1:
        return False
    for x in range(3, int(n**0.5) + 1, 2):
        if n % x == 0:
            return False
    return True

def mhd(a,b,x,y):
    return abs(a-x)+abs(b-y)

def numIN():
    return(map(int,sys.stdin.readline().strip().split()))

def charIN():
    return(sys.stdin.readline().strip().split())

def bfs(g,d):
	global n

	for i in range(n,0,-1):
		while g[i]:
			x = g[i].pop()
			d[i]+=d[x]
	return d

n = int(input())
l = list(numIN())
if n==1:
	print(1)
	exit(0)
if n==2:
	print(1,1)
	exit(0)
d = [0]*(n+1)
l = [0,0]+l
g = defaultdict(list)
for i in range(2,n+1):
	g[l[i]].append(i)
	d[i]+=1
	d[l[i]]+=1
for i in range(1,n+1):
	if g[i]:
		d[i] = 0
x = bfs(g,d)
x.sort()
for i in range(1,n+1):
	print(x[i],end= ' ')
",O(nlogn)
"q = int(input())
for rquer in range(q):
	c, r = map(int, input().split())
	matt = [list(map(int,input().split())) for i in range(c)]
	mat = [[matt[i][j] for i in range(c)] for j in range(r)]
	for i in range(r):
		mat[i].append(max(mat[i]))
		mat[i].reverse()
	mat.sort()
	mat.reverse()
	work = mat[:min(4, r)]
	for t in work:
		t.pop(0)
	r = min(4, r)
	wyn = 0
	for num in range(c**r):
		shif = [(num//(c**i))%c for i in range(r)]
		new = 0
		for i in range(c):
			kol = [work[j][(i + shif[j])%c] for j in range(r)]
			new += max(kol)
		wyn = max(wyn, new)
	print(wyn)
",np
"left = -1
right = 10e9 - 1
nn = [int(i) for i in input().split()]
n = nn[0]
k = nn[1]
f = True
while right - left > 1:
    mid = (left + right) // 2
    if ((n - mid + 1) * abs((n - mid)) // 2 - mid > k):
        left = mid
    else:
        if((n - mid + 1) * abs((n - mid)) // 2 - mid == k):
            print(round(mid))
            f = False
            break
        else:
            right = mid
if f:
    print(round(left))
",O(logn)
"class Solution(object):
    def countLetters(self, S):
        result = len(S)
        left = 0
        for right in range(1, len(S)):
            if S[right] == S[left]:
                result += right-left
            else:
                left = right
        return result",O(n)
"class Solution(object):
    def maxKDivisibleComponents(self, n, edges, values, k):
        def bfs():
            result = 0
            dp = [x%k for x in values]
            cnt = [len(adj[u]) for u in range(len(adj))]
            q = [u for u in range(n) if cnt[u] == 1]
            while q:
                new_q = []
                for u in q:
                    if not dp[u]:
                        result += 1
                    for v in adj[u]:
                        dp[v] = (dp[v]+dp[u])%k
                        cnt[v] -= 1
                        if cnt[v] == 1:
                            new_q.append(v)
                q = new_q
            return max(result, 1)

        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return bfs()",O(n)
"import collections



class Solution(object):
    def isPossibleToSplit(self, nums):
        return all(v <= 2 for v in collections.Counter(nums).values())",O(n)
"def sum_1 (n):
    s=n*(n+1)//2
    return s

def sum_2(s,e):
    if s<=1:
        return sum_1(e)
    return sum_1(e)-sum_1(s-1)

def mini_splitter(k,n):
    st=1
    end=k
    while st<end:
        mid=(st+end)//2
        s=sum_2(mid,k)
        if s==n:
            return k-mid+1
        elif s>n:
            st=mid+1
        else:
            end=mid
    return k-st+2

n,k=map(int,input().split())
if(n==1):
    print(""0"")
elif n<=k:
    print(""1"")
else:
    k-=1
    n-=1
    if sum_1(k)<n:
        print(""-1"")
    else:
        print(mini_splitter(k,n))
",O(logn)
"class Solution(object):
    def isPathCrossing(self, path):
        x = y = 0
        lookup = {(0, 0)}
        for c in path:
            if c == 'E':
                x += 1
            elif c == 'W':
                x -= 1
            elif c == 'N':
                y += 1
            elif c == 'S':
                y -= 1
            if (x, y) in lookup:
                return True
            lookup.add((x, y))
        return False",O(n)
"n = int(input())

L = [int(x) for x in input().split()]
D = {}
J = []
S = []
T = [0]*(n+1)
for i in range(n):
    if L[i] > 0:
        D[L[i]] = i
        J.append(L[i])
        T[i+1] = T[i]
    else:
        T[i+1] = T[i]+1

def I(J):
    if len(J) <= 1:
        return J, 0
    else:
        a = J[:len(J)//2]
        b = J[len(J)//2:]
        a, ai = I(a)
        b, bi = I(b)
        c = []
        i = 0
        j = 0
        inversions = ai + bi
    while i < len(a) and j < len(b):
        if a[i] <= b[j]:
            c.append(a[i])
            i += 1
        else:
            c.append(b[j])
            j += 1
            inversions += (len(a)-i)
    c += a[i:]
    c += b[j:]
    return c, inversions

for i in range(1,n+1):
    if not i in D:
        S.append(i)

total = len(S)
num = 1
denom = 1
if total > 0:
    themostimportantsum = 0
    for i in J:
        low = 0
        high = total-1
        while high-low > 1:
            guess = (high+low)//2
            if S[guess] > i:
                high = guess
            else:
                low = guess
        if S[low] > i:
            smaller = low
        elif S[high] > i:
            smaller = high
        else:
            smaller = high+1

        themostimportantsum += T[D[i]]*(total-smaller)+(total-T[D[i]])*(smaller)
        num = themostimportantsum+total
        denom = total

num =(denom*(((total)*(total-1))//2)+2*num)%998244353
denom *= 2
if num == denom:
    if I(J)[1] == 0:
        print(0)
    else:
        print(I(J)[1]%998244353)
else:
    num += denom*I(J)[1]
    print(((num-denom)*pow(denom%998244353,998244351,998244353))%998244353)
",O(nlogn)
"a,b=map(int,input().split())
if max(a,b)-min(a,b) +1<=2:
    print(-1)
elif max(a,b)-min(a,b) +1==3:
    if a % 2==1 and b %2==1:
        print(-1)
    else:
        print(min(a,b),min(a,b)+1,min(a,b)+2)
else:
    ans=0
    for i in range(a,b+1):
        if i%2==0:
            ans=i
            break
    print(ans,ans+1,ans+2)",O(1)
"for TT in range(1, int(input()) + 1):
    n = int(input())
    l = sorted(map(int, input().split()))
    k = max(0, min(n - 2, l[-2] - 1))
    print(k)",O(nlogn)
"import sys
input = sys.stdin.readline

n=int(input())
A=list(map(int,input().split()))

DP=[[-1]*(n+1) for i in range(n+1)]
for i in range(n):
    DP[i][i]=A[i]

for mid in range(1,n):
    for i in range(n):
        j=i+mid
        if j==n:
            break
        for k in range(i,j+1):
            if DP[i][k]==DP[k+1][j] and DP[i][k]!=-1:
                DP[i][j]=DP[i][k]+1

ANS=[2000]*(n+1)
ANS.append(0)
for i in range(n):
    ANS[i]=min(ANS[i],ANS[i-1]+1)
    for j in range(i,n):
        if DP[i][j]!=-1:
            ANS[j]=min(ANS[j],ANS[i-1]+1)

print(ANS[n-1])
",O(n ^ 3)
"def color(x, y):

	return 'white' if (x + y) % 2 == 0 else 'black'

def white(x1, y1, x2, y2):

	if x1 > x2 or y1 > y2:
		return 0

	if color(x1, y1) != color(x2, y2):
		return (x2 - x1 + 1) * (y2 - y1 + 1) // 2
	else:
		if color(x1, y1) == color(x1, y2) == color(x2, y1) == 'white':
			return ((x2 - x1 + 1) * (y2 - y1 + 1) + 1) // 2
		elif color(x1, y1) == color(x1, y2) == color(x2, y1) == 'black':
			return ((x2 - x1 + 1) * (y2 - y1 + 1) - 1) // 2
		else:
			return (x2 - x1 + 1) * (y2 - y1 + 1) // 2

def black(x1, y1, x2, y2):

	if x1 > x2 or y1 > y2:
		return 0

	return (x2 - x1 + 1) * (y2 - y1 + 1) - white(x1, y1, x2, y2)

def intersect_1D(x1, x2, x3, x4):

	return max(x1, x3), min(x2, x4)

def intersect_2D(x1, y1, x2, y2, x3, y3, x4, y4):

	xl, xr = intersect_1D(x1, x2, x3, x4)
	yl, yr = intersect_1D(y1, y2, y3, y4)
	return xl, yl, xr, yr

for i in range(int(input())):
	n, m = map(int, input().split())

	x1, y1, x2, y2 = map(int, input().split())

	x3, y3, x4, y4 = map(int, input().split())

	w0, b0 = white(1, 1, m, n), black(1, 1, m, n)

	_b0 = black(x1, y1, x2, y2)

	w1, b1 = w0 + _b0, b0 - _b0

	_w1 = white(x3, y3, x4, y4)

	w2, b2 = w1 - _w1, b1 + _w1

	xl, yl, xr, yr = intersect_2D(x1, y1, x2, y2, x3, y3, x4, y4)

	_b2 = black(xl, yl, xr, yr)

	w3, b3 = w2 - _b2, b2 + _b2

	print(w3, b3)
",O(1)
"class Solution(object):
    def sortArrayByParityII(self, A):
        j = 1
        for i in range(0, len(A), 2):
            if A[i] % 2:
                while A[j] % 2:
                    j += 2
                A[i], A[j] = A[j], A[i]
        return A",O(n)
"s = input()

mc = -1

for i in range(len(s)):
	for j in range(i+1, len(s)):
		cu = 0
		for cu in range(len(s)-max(i, j)):
			if s[i+cu] == s[j+cu]:
				mc = max(mc, cu)
			else:
				break

print(mc + 1)
",O(n ^ 3)
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))
r.sort()
g.sort()
b.sort()
dp = [[[0]*202 for i in range(202)] for j in range(202)]
for i in range(R+1):
       for j in range(G+1):
              for k in range(B+1):
                     if i and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])
                     if i and k:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])
                     if k and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])
print(dp[R][G][B])
",O(n ^ 3)
"m,n=[int(ele) for ele in input().split()]
a=[]
for i in range(m):
    a.append(list(map(int, input().split())))

ina,mo=0,10**9+1
pos1,pos2=0,0
mask=(1<<n)-1
def check(tang):
    key=set()
    dic=dict()
    for i in range(m):
        temp=0
        for j in range(n):
            if a[i][j]>=tang:

                temp+=(1<<j)

        if temp in key:
            continue
        key.add(temp)
        tempk=temp
        while tempk>=0:
            tempk &= temp
            dic[tempk]=i
            tempk-=1

        tocheck = mask ^ temp

        if tocheck in dic:
            return dic[tocheck],i,True

    return -1,-1,False

while ina<mo-1:

    tang=(ina+mo)//2

    temppos1,temppos2,status=check(tang)

    if status:
        pos1,pos2=temppos1,temppos2
        ina=tang
    else:
        mo=tang
print(pos1+1,pos2+1)
",np
"import math
n, k = map(int, input().split())

q = int(-3 + math.sqrt(9 + 8*(n+k)))//2

r = n-q

print(r)",O(1)
"class Solution2(object):
    def maxScore(self, nums):
        dp = [0]*len(nums)
        for i in range(1, len(nums)):
            for j in range(i):
                dp[i] = max(dp[i], dp[j]+(i-j)*nums[i])
        return dp[-1]",O(n ^ 2)
"import sys

IS_LOCAL = False

def readMultiple(f):
    return f(map(int, input().split()))

def main():
    n = 3
    a = [1, 2, -4]

    if not IS_LOCAL:
        n = int(input())
        a = readMultiple(list)

    for i, x in enumerate(a):
        if x >= 0:
            a[i] = -x - 1

    cnt_neg = 0
    for x in a:
        if x < 0:
            cnt_neg += 1

    b = sorted([(abs(x), i) for i, x in enumerate(a)])
    if cnt_neg % 2 == 1:
        ind = b[n-1][1]
        a[ind] = -a[ind] - 1

    print(' '.join(map(str, a)))

if __name__ == ""__main__"":
    if len(sys.argv) > 1 and sys.argv[1] == 'True':
        IS_LOCAL = True
    main()
",O(nlogn)
"from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]
n, A, B, C, T = rints()
a, ans = rints(), 0
for i in range(n):
    su, cur = A, A
    for j in range(a[i], T):
        cur -= B
        su = max(su, (j - a[i] + 1) * C + cur)

    ans += su
print(ans)
",O(n)
"import heapq
class Solution(object):
    def jobScheduling(self, startTime, endTime, profit):
        min_heap = list(zip(startTime, endTime, profit))
        heapq.heapify(min_heap)
        result = 0
        while min_heap:
            s, e, p = heapq.heappop(min_heap)
            if s < e:
                heapq.heappush(min_heap, (e, s, result+p))
            else:
                result = max(result, p)
        return result",O(nlogn)
"n,k=map(int,input().split())
d=(n-k)//2
s=0
while s!=n:
    if (s+1)%(d+1)==0:
        print(""1"",end="""")
    else :
        print(""0"",end="""")
    s+=1
",O(n)
"mod = 998244353
N,K = map(int, input().split())

dp = [[[0]*(K+2) for i in range(2)] for i in range(N)]
dp[0][0][0] = 1
dp[0][1][1] = 1

for i in range(1,N):
    for b in range(K):
        dp[i][0][b]   += dp[i-1][0][b]
        dp[i][0][b]   += dp[i-1][1][b]
        dp[i][0][b]   += dp[i-1][1][b]
        dp[i][0][b+1] += dp[i-1][0][b]
        dp[i][0][b]   %= mod

        dp[i][1][b+1] += dp[i-1][0][b]
        dp[i][1][b]   += dp[i-1][1][b]
        dp[i][1][b+2] += dp[i-1][1][b]
        dp[i][1][b+1] += dp[i-1][0][b]
        dp[i][1][b] %= mod

ans = 0
for x in range(2):
    ans += dp[N-1][x][K-1]

print(ans*2%mod)
",np
"class MinIdx_Segtree:
    def __init__(self, N, A):
        self.n = N
        self.INF = int(1e9)
        self.A = A
        while (self.n & (self.n - 1)) != 0:
            self.A.append(self.INF)
            self.n += 1
        self.tree = [0] * (2 * self.n)
        self.build()

    def build(self):
        for i in range(self.n):
            self.tree[self.n + i] = i
        for j in range(self.n - 1, 0, -1):
            a = self.tree[j << 1]
            b = self.tree[(j << 1) + 1]
            if self.A[a] <= self.A[b]:
                self.tree[j] = a
            else:
                self.tree[j] = b

    def update(self, i, val):
        self.A[i] = val
        j = (self.n + i) >> 1
        while j >= 1:
            a = self.tree[j << 1]
            b = self.tree[(j << 1) + 1]
            if self.A[a] <= self.A[b]:
                self.tree[j] = a
            else:
                self.tree[j] = b
            j >>= 1

    def query(self, ql, qh):
        return self._query(1, 0, self.n - 1, ql, qh)

    def _query(self, node, l, h, ql, qh):
        if ql > h or qh < l:
            return self.INF
        if l >= ql and h <= qh:
            return self.tree[node]
        a = self._query(node << 1, l, (l + h) >> 1, ql, qh)
        b = self._query((node << 1) + 1, ((l + h) >> 1) + 1, h, ql, qh)
        if a == self.INF:
            return b
        if b == self.INF:
            return a
        return a if self.A[a] <= self.A[b] else b

class Solution:
    def getMaxArea(self, heights, l, r, st):
        if l > r:
            return 0
        if l == r:
            return heights[l]
        minIdx = st.query(l, r)
        return max(max(self.getMaxArea(heights, l, minIdx - 1, st),
                       self.getMaxArea(heights, minIdx + 1, r, st)),
                   (r - l + 1) * heights[minIdx])

    def largestRectangleArea(self, heights):
        n = len(heights)
        st = MinIdx_Segtree(n, heights)
        return self.getMaxArea(heights, 0, n - 1, st)
",O(nlogn)
"class Solution(object):
    def countSpecialSubsequences(self, nums):
        MOD = 10**9+7
        dp = [0]*3
        for x in nums:
            dp[x] = ((dp[x]+dp[x])%MOD+(dp[x-1] if x-1 >= 0 else 1))%MOD
        return dp[-1]",O(n)
"class Solution2(object):
    def dayOfYear(self, date):
        def numberOfDays(Y, M):
            leap = 1 if ((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0) else 0
            return (28+leap if (M == 2) else 31-(M-1)%7%2)

        Y, M, result = list(map(int, date.split(""-"")))
        for i in range(1, M):
            result += numberOfDays(Y, i)
        return result",O(1)
"def req(a, b, c, d):

    print(f""? {a} {b} {c} {d}"")
    return int(input())

def bin(l, r, down, left, up, right, tp, tar):
    while r - l > 1:
        m = (r + l) // 2

        if tp == 0:
            down = m
        if tp == 1:
            left = m
        if tp == 2:
            up = m
        if tp == 3:
            right = m

        if req(down, left, up, right) == tar:
            l = m
        else:
            r = m
    return [l, r]

def find_rec(x1, y1, x2, y2) -> list:
    up_ = bin(x1 - 1, x2 + 1, x1, y1, -2, y2, 2, 0)[1]
    down_ = bin(x1 - 1, x2 + 1, -2, y1, x2, y2, 0, 1)[0]
    left_ = bin(y1 - 1, y2 + 1, x1, -2, x2, y2, 1, 1)[0]
    right_ = bin(left_ - 1, y2 + 1, x1, y1, x2, -2, 3, 0)[1]
    return [down_, left_, up_, right_]

n = int(input())

l = 0
r = n + 1
while r - l > 1:
    m = (l + r) // 2
    if req(1, 1, m, n) == 0:
        l = m
    else:
        r = m

rec = []

if r != n and req(r + 1, 1, n, n) == 1:
    rec.append(find_rec(1, 1, r, n))
    rec.append(find_rec(r + 1, 1, n, n))
else:
    l = 0
    r = n + 1
    while r - l > 1:
        m = (l + r) // 2
        if req(1, 1, n, m) == 0:
            l = m
        else:
            r = m
    rec.append(find_rec(1, 1, n, r))
    rec.append(find_rec(1, r + 1, n, n))
print('!', *rec[0], *rec[1])
",O(logn)
"from sys import stdin
from bisect import *

rints = lambda: [int(x) for x in stdin.readline().split()]
rints_2d = lambda n: [rints() for _ in range(n)]
n, mem, pos, power = int(input()), [1], [], []
a = sorted(rints_2d(n))

for x, y in a:
    pos.append(x)
    power.append(y)

for i in range(1, n):
    ix = bisect_left(pos, pos[i] - power[i]) - 1
    if ix == -1:
        mem.append(1)
    else:
        mem.append(mem[ix] + 1)

print(n - max(mem))
",O(n)
"n,k=[int(i) for i in input().split()]
a = pow(1+2*k+2*n,0.5) - 1
print(n-int(a))
",O(1)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def zigzagLevelOrder(self, root):
        if root is None:
            return []
        result, current = [], [root]
        while current:
            next_level, vals = [], []
            for node in current:
                vals.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            result.append(vals[::-1] if len(result) % 2 else vals)
            current = next_level
        return result",O(n)
"class Solution(object):
    def getSum(self, a, b):
        bit_length = 32
        neg_bit, mask = (1 << bit_length) >> 1, ~(~0 << bit_length)

        a = (a | ~mask) if (a & neg_bit) else (a & mask)
        b = (b | ~mask) if (b & neg_bit) else (b & mask)

        while b:
            carry = a & b
            a ^= b
            a = (a | ~mask) if (a & neg_bit) else (a & mask)
            b = carry << 1
            b = (b | ~mask) if (b & neg_bit) else (b & mask)

        return a

    def getSum2(self, a, b):
        MAX = 0x7FFFFFFF
        MIN = 0x80000000
        mask = 0xFFFFFFFF
        while b:
            a, b = (a ^ b) & mask, ((a & b) << 1) & mask
        return a if a <= MAX else ~(a ^ mask)

    def minus(self, a, b):
        b = self.getSum(~b, 1)
        return self.getSum(a, b)

    def multiply(self, a, b):
        isNeg = (a > 0) ^ (b > 0)
        x = a if a > 0 else self.getSum(~a, 1)
        y = b if b > 0 else self.getSum(~b, 1)
        ans = 0
        while y & 0x01:
            ans = self.getSum(ans, x)
            y >>= 1
            x <<= 1
        return self.getSum(~ans, 1) if isNeg else ans

    def divide(self, a, b):
        isNeg = (a > 0) ^ (b > 0)
        x = a if a > 0 else self.getSum(~a, 1)
        y = b if b > 0 else self.getSum(~b, 1)
        ans = 0
        for i in range(31, -1, -1):
            if (x >> i) >= y:
                x = self.minus(x, y << i)
                ans = self.getSum(ans, 1 << i)
        return self.getSum(~ans, 1) if isNeg else ans",O(1)
"class Solution:
    def rob(self, nums: List[int]) -> int:
        rob1, rob2 = 0, 0

        for num in nums:
            temp = max(num + rob1, rob2)
            rob1 = rob2
            rob2 = temp
        return rob2
",O(n)
"M=10**9+7
def pw(x,y):
	r=1
	x=x%M
	while y:
		if y&1:
			r=(r*x)%M
		y=y>>1
		x=(x*x)%M
	return r
x,k=map(int,input().split())
ans=pw(2,k+1)*x-pw(2,k)+1+M
if x==0:
	ans=0
print(ans%M)
",O(logn)
"class Solution(object):
    def maximumPoints(self, enemyEnergies, currentEnergy):
        mn = min(enemyEnergies)
        return ((currentEnergy-mn)+sum(enemyEnergies))//mn if currentEnergy >= mn else 0",O(n)
"from math import ceil

k, n, s, p = map(int, input().split())
n_sheets = ceil(n / s)* k
n_p = ceil(n_sheets / p)
print(n_p)",O(1)
"N = int(input())
m1 = []
m2 = []
ms = []
for n in range(N):
    m1.append(input())
for n in range(N):
    m2.append(input())

ms = [
    m2,
    [x[::-1] for x in m2],
    [x for x in reversed(m2)],
]

a = []
for m in ms:
    a.append(m)
    a.append([x[::-1] for x in reversed(m)])
    a.append([''.join(m[j][i] for j in range(N - 1, -1, -1)) for i in range(N)])
    a.append([''.join(m[j][i] for j in range(N)) for i in range(N - 1, -1, -1)])

ms = a
print(['NO', 'YES'][m1 in ms])
",O(n ^ 2)
"class Solution(object):
    def findTheString(self, lcp):
        result = [-1]*len(lcp)
        curr = 0
        for i in range(len(lcp)):
            if result[i] != -1:
                continue
            if curr == 26:
                return """"
            for j in range(i, len(lcp[0])):
                if lcp[i][j]:
                    result[j] = curr
            curr += 1
        for i in reversed(range(len(lcp))):
            for j in reversed(range(len(lcp[0]))):
                if lcp[i][j] != ((lcp[i+1][j+1]+1 if i+1 < len(lcp) and j+1 < len(lcp[0]) else 1) if result[i] == result[j] else 0):
                    return ''
        return """".join([chr(ord('a')+x) for x in result])",O(n ^ 2)
"n,m=[int(x) for x in input().split()]
a=[int(x) for x in input().split()]
s=sum(a)
need=0
a.sort()
j=1
flag=0
k=max(a)
if n==1:
    print(0)
else:
    for i in range(n):
        if a[i]<j:
            flag=1
        else:
            flag=0
        if a[i]==1:
            need+=1
        elif a[i]>=j and i!=n-1:
            need+=1
        elif a[i]>=j and i==n-1 and j<=k:
            need+=k-j+1
        else:
            need+=1
        if flag!=1:
            j+=1
    print(s-need)
",O(nlogn)
"n = int(input())
fst, nxt, lst, des = [0 for i in range(2 * n + 1)], [0 for i in range(2 * n + 1)], [0 for i in range(2 * n + 1)], [0 for i in range(2 * n + 1)]
cnt = 0

def add(u, v) :
	global cnt
	cnt += 1
	if fst[u] == 0 :
		fst[u] = cnt
	else :
		nxt[lst[u]] = cnt
	lst[u], des[cnt] = cnt, v

for i in range(1, n) :
	u, v = map(int, input().split())

	add(u, v)
	add(v, u)

a = list(map(int, input().split()))
deep = [0 for i in range(n + 1)]
deep[1] = 1
now, res = 1, 1
Ans = 0

for i in range(0, n) :
	if deep[a[i]] == 0 :
		Ans = 1
		break
	elif deep[a[i]] < now :
		Ans = 1
		break
	else :
		b = fst[a[i]]
		res += 1
		while b > 0 :
			if deep[des[b]] == 0 :
				deep[des[b]] = res
			b = nxt[b]
		now = deep[a[i]]

if Ans == 0 :
	print(""Yes"")
else :
	print(""No"")
",O(nlogn)
"n,m,k=[int(x) for x in input().split()]
left=[];right=[]
for i in range(n):
    temp=[int(x) for x in input().split()]
    left.append(temp)
for i in range(n-1):
    temp=[int(x) for x in input().split()]
    right.append(temp)
dp_old=[[0 for x in range(m)] for x in range(n)]
if k%2!=0:
    for i in range(n):
        print(*[-1 for x in range(m)])
else:
    k//=2
    for k1 in range(k):
        dp=[[0 for x in range(m)] for x in range(n)]
        for row in range(n):
            for col in range(m):
                t=float(""inf"")
                if 0<col:
                    t=min(t,dp_old[row][col-1]+2*left[row][col-1])
                if m-1>col:
                    t=min(t,dp_old[row][col+1]+2*left[row][col])
                if 0<row:
                    t=min(t,dp_old[row-1][col]+2*right[row-1][col])
                if n-1>row:
                    t=min(t,dp_old[row+1][col]+2*right[row][col])
                dp[row][col]=t
        for row in range(n):
            for col in range(m):
                dp_old[row][col]=dp[row][col]
    for i in range(n):
        print(*dp_old[i])",O(n ^ 3)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from heapq import heapify,heappush as hp,heappop as hpop
def check(x,y):
    if 0<=x<=n-1 and 0<=y<=m-1:
        return True
    return False
n,m,k=map(int,input().split())
l1=[]
l2=[]
for i in range(n):
    l1.append(list(map(int,input().split())))
for  i in range(n-1):
    l2.append(list(map(int,input().split())))
inf=10**18
dp=[[[inf]*21 for i in range(m)] for j in range(n)]
for i in range(n):
    for j in range(m):
        if check(i,j+1):
            dp[i][j][1]=min(l1[i][j],dp[i][j][1])
        if check(i,j-1):
            dp[i][j][1]=min(l1[i][j-1],dp[i][j][1])
        if check(i+1,j):
            dp[i][j][1]=min(l2[i][j],dp[i][j][1])
        if check(i-1,j):
            dp[i][j][1]=min(l2[i-1][j],dp[i][j][1])
for x in range(2,k//2+1):
    for i in range(n):
        for j in range(m):
            if check(i,j+1):
                dp[i][j][x]=min(l1[i][j]+dp[i][j+1][x-1],dp[i][j][x])
            if check(i,j-1):
                dp[i][j][x]=min(l1[i][j-1]+dp[i][j-1][x-1],dp[i][j][x])
            if check(i+1,j):
                dp[i][j][x]=min(l2[i][j]+dp[i+1][j][x-1],dp[i][j][x])
            if check(i-1,j):
                dp[i][j][x]=min(l2[i-1][j]+dp[i-1][j][x-1],dp[i][j][x])

ans=[[inf]*m for i in range(n)]
for i in range(n):
    for j in range(m):
        if k%2:
            ans[i][j]=-1
            continue
        ans[i][j]=2*dp[i][j][k//2]
for i in ans:
    print(*i)
",O(n ^ 3)
"import math

sent = input()
received = input()

sp = sent.count('+')
sm = sent.count('-')
rp = received.count('+')
rm = received.count('-')
quest = received.count('?')

dist = sp - rp

if dist < 0 or dist > quest:
    print(0)
elif dist == 0 and quest == 0:
    print(1)
else:
    total = 2 ** quest
    possible = math.factorial(quest) / math.factorial(dist) / math.factorial(quest-dist)
    print(possible/total)
",np
"import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

INF = 10**9

n, m = [int(item) for item in input().split()]
s = input().rstrip()

count = [[0] * m for _ in range(m)]
ord_a = ord(""a"")
for c1, c2 in zip(s, s[1:]):
    c1 = ord(c1) - ord_a
    c2 = ord(c2) - ord_a
    if c1 != c2:
        count[c1][c2] += 1

sum_of_subset = [[0] * (1 << m) for _ in range(m)]
for i in range(m):
    for j in range(1 << m):
        if j == 0:
            continue
        lsb = j & -j
        sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]

adj_in_subset = [0] * (1 << m)
for i in range(1 << m):
    for j in range(m):
        if i & (1 << j):
            adj_in_subset[i] += sum_of_subset[j][i]

total_adj = adj_in_subset[-1]
dp = [INF] * (1 << m)
dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if i & 1 << j:
            continue
        not_i = ((1 << m) - 1) ^ i
        val = dp[i] + (total_adj - adj_in_subset[i] - adj_in_subset[not_i])
        dp[i | (1 << j)] = min(dp[i | (1 << j)], val)
print(dp[-1])",np
"import collections


class Solution(object):
    def findClosestLeaf(self, root, k):
        def traverse(node, neighbors, leaves):
            if not node:
                return
            if not node.left and not node.right:
                leaves.add(node.val)
                return
            if node.left:
                neighbors[node.val].append(node.left.val)
                neighbors[node.left.val].append(node.val)
                traverse(node.left, neighbors, leaves)
            if node.right:
                neighbors[node.val].append(node.right.val)
                neighbors[node.right.val].append(node.val)
                traverse(node.right, neighbors, leaves)

        neighbors, leaves = collections.defaultdict(list), set()
        traverse(root, neighbors, leaves)
        q, lookup = [k], set([k])
        while q:
            next_q = []
            for u in q:
                if u in leaves:
                    return u
                for v in neighbors[u]:
                    if v in lookup:
                        continue
                    lookup.add(v)
                    next_q.append(v)
            q = next_q
        return 0",O(n)
"from collections import defaultdict

n,a,b = map(int,input().split())

hash = defaultdict(list)

if a == 1 and b == 1:
    if n == 2 or n == 3:
        print('NO')
        exit()

if a == 1 or b == 1:

    bool = [False]*(n+1)

    if a>n or b>n:
        print('NO')
        exit()
    print('YES')

    l = []
    for i in range(n):
        z = ['0']*(n)
        l.append(z)
    ans = []

    for i in range(n):
        z = ['0']*(n)
        ans.append(z)

    if b == 1:

        for i in range(a-1,n-1):

            l[i][i+1] = '1'
            l[i+1][i] = '1'

        for i in l:
            print(''.join(i))
    else:

        ans = []

        for i in range(n):
           z = ['0']*(n)
           ans.append(z)

        for i in range(b-1,n-1):

            l[i][i+1] = '1'
            l[i+1][i] = '1'

        for i in range(n):
            for j in range(n):
                if i!=j:
                    if l[i][j] == '1':
                        ans[i][j] = '0'
                    if l[i][j] == '0':
                        ans[i][j] = '1'

        for i in ans:
            print(''.join(i))

else:
    print('NO')
",O(n ^ 2)
"class Solution(object):
    def maxA(self, N):
        if N < 7:
            return N
        if N == 10:
            return 20 

        n = N // 5 + 1 
        n3 = 5*n - N - 1
        n4 = n - n3
        return 3**n3 * 4**n4",O(1)
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __str__(self):
        if self:
            return ""{}"".format(self.val)
        else:
            return None

class Solution(object):
    def detectCycle(self, head):
        fast, slow = head, head
        while fast and fast.__next__:
            fast, slow = fast.next.__next__, slow.__next__
            if fast is slow:
                fast = head
                while fast is not slow:
                    fast, slow = fast.__next__, slow.__next__
                return fast
        return None

",O(n)
"n = int(input())
l = list(map(int, input().split("" "")))
l2 = list(map(int, input().split("" "")))
dp_1 = l2.copy()
dp_2 = [9999999999]*n
dp_3 = [9999999999]*n
for i in range(1, n):
    for j in range(i):
        if l[i] > l[j]:
            dp_2[i] = min(dp_2[i], dp_1[j]+l2[i])

for i in range(1,n):
    for j in range(i):
        if l[i] > l[j]:
            dp_3[i] = min(dp_3[i], dp_2[j]+l2[i])

x = min(dp_3)
if x == 9999999999:
    print(-1)
else:
    print(x)",O(n ^ 2)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def isEvenOddTree(self, root):
        q = [root]
        is_odd = False
        while q:
            new_q = []
            prev = None
            for node in q:
                if is_odd:
                    if node.val%2 or (prev and prev.val <= node.val):
                        return False
                else:
                    if not node.val%2 or (prev and prev.val >= node.val):
                        return False
                if node.left:
                    new_q.append(node.left)
                if node.right:
                    new_q.append(node.right)
                prev = node
            q = new_q
            is_odd = not is_odd
        return True",O(n)
"def sum(n):
    return (n * (n + 1)) // 2

def range_sum(left, right):
    return sum(right) - sum(left - 1)

def binary_search(k, n):
    low, high, mid = 1, k, 0

    while low <= high:
        mid = (low + high) // 2
        s = range_sum(mid, k)

        if s == n:
            return k - mid + 1
        elif s > n:
            low = mid + 1
        else:
            high = mid - 1

    return k - low + 2

n, k = map(int, input().split(' '))
if n == 1:
    print(0)
elif n <= k:
    print(1)
else:
    n -= 1
    k -= 1

    if n > sum(k):
        print(-1)
    else:
        print(binary_search(k, n))
",O(logn)
"import collections


class Solution(object):
    def minJumps(self, arr):
        groups = collections.defaultdict(list)
        for i, x in enumerate(arr):
            groups[x].append(i)
        q = collections.deque([(0, 0)])
        lookup = set([0])
        while q:
            pos, step = q.popleft()
            if pos == len(arr)-1:
                break
            neighbors = set(groups[arr[pos]] + [pos-1, pos+1])
            groups[arr[pos]] = []
            for p in neighbors:
                if p in lookup or not 0 <= p < len(arr):
                    continue
                lookup.add(p)
                q.append((p, step+1)) 
        return step",O(n)
"class Solution(object):
    def categorizeBox(self, length, width, height, mass):
        bulky = any(x >= 10**4 for x in (length, width, height)) or length*width*height >= 10**9
        heavy = mass >= 100
        if bulky and heavy:
            return ""Both""
        if bulky:
            return ""Bulky""
        if heavy:
            return ""Heavy""
        return ""Neither""",O(1)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def isValidBST(self, root):
        prev, cur = None, root
        while cur:
            if cur.left is None:
                if prev and prev.val >= cur.val:
                    return False
                prev = cur
                cur = cur.right
            else:
                node = cur.left
                while node.right and node.right != cur:
                    node = node.right

                if node.right is None:
                    node.right = cur
                    cur = cur.left
                else:
                    if prev and prev.val >= cur.val:
                        return False
                    node.right = None
                    prev = cur
                    cur = cur.right

        return True


",O(n)
"def main():
	n, pos, l, r=tuple(map(int,input().split()))
	time=0
	if l!=1 and r!=n:
		if abs(pos-l)<abs(pos-r):
			time+=abs(pos-l)+abs(l-r)+2
		else:
			time+=abs(pos-r)+abs(l-r)+2
	elif l==1 and r!=n:
		time+=abs(pos-r)+1
	elif r==n and l!=1:
		time+=abs(pos-l)+1
	else:
		time+=0
	print(time)
if __name__=='__main__':
	main()",O(1)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import ceil

def prod(a, mod=10 ** 9 + 7):
    ans = 1
    for each in a:
        ans = (ans * each) % mod
    return ans

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def lcm(a, b): return a * b // gcd(a, b)

def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

from math import inf

for _ in range(int(input()) if not True else 1):

    n, m = map(int, input().split())

    a = []
    for i in range(n):
        a += [list(map(int, input().split()))]

    alpha, omega = 0, 10**9
    def solve(mid):
        index = [-1] * (1 << m)
        for i in range(n):
            val = 0
            for j in range(m):
                if a[i][j] >= mid:
                    val += (1 << j)
            index[val] = i + 1
        pos = False
        for mask in range(1 << m):
            for mask2 in range(1 << m):
                if mask | mask2 != (1 << m) - 1: continue
                if min(index[mask], index[mask2]) != -1:
                    pos = (index[mask], index[mask2])
                    break
        return pos
    while alpha < omega:
        mid = (alpha + omega + 1) // 2
        if solve(mid):
            alpha = mid
        else:
            omega = mid - 1
    print(*solve(alpha))",np
"class Solution(object):
    def maximumSubarraySum(self, nums, k):
        result = left = total = 0
        lookup = set()
        for right in range(len(nums)):
            while nums[right] in lookup or len(lookup) == k:
                lookup.remove(nums[left])
                total -= nums[left]
                left += 1
            lookup.add(nums[right])
            total += nums[right]
            if len(lookup) == k:
                result = max(result, total)
        return result",O(n)
"n,m=map(int,input().split())
listi=[]
for i in range(0,n):
    string=input()
    listi.append(string)
rownum=0
flag=False
for row in listi:

    for letter in row:
            if(""B"" in row):
                p=row.index(""B"")

                s=row[::-1]
                q=abs(m-s.index(""B"")-1)

                if(p==q):
                    print(rownum+1,row.index(row[p])+1)
                    flag=True
                    break
                mr=(q+p)/2

                length=abs(q-p+1)

                rn= rownum + length//2

                print(rn+1,int(mr+1))
                flag=True
                break

    if(flag==True):
        break

    rownum+=1
",O(n ^ 2)
"class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        numSet = set(nums)
        longest = 0

        for num in numSet:
            if (num - 1) not in numSet:
                length = 1
                while (num + length) in numSet:
                    length += 1
                longest = max(length, longest)
        return longest
",O(n)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def reverseEvenLengthGroups(self, head):
        prev, l = head, 2
        while prev.__next__:
            curr, cnt = prev, 0
            for _ in range(l):
                if not curr.__next__:
                    break
                cnt += 1
                curr = curr.__next__
            l += 1
            if cnt%2:
                prev = curr
                continue
            curr, last = prev.__next__, None
            for _ in range(cnt):
                curr.next, curr, last = last, curr.next, curr
            prev.next.next, prev.next, prev = curr, last, prev.next
        return head",O(n)
"class Solution(object):
    def maximumJumps(self, nums, target):
        dp = [-1]*len(nums)
        dp[0] = 0
        for i in range(1, len(nums)):
            for j in range(i):
                if abs(nums[i]-nums[j]) <= target:
                    if dp[j] != -1:
                        dp[i] = max(dp[i], dp[j]+1)
        return dp[-1]",O(n ^ 2)
"class Solution2(object):
    def findGameWinner(self, n):
        grundy = [0, 1] 
        for i in range(2, n):
            grundy[i%2] = (grundy[(i-1)%2]+1)^(grundy[(i-2)%2]+1) 
        return grundy[(n-1)%2] > 0",O(n)
"import itertools



class Solution2(object):
    def minCost(self, nums, cost):
        def f(x):
            return sum(abs(y-x)*c for y, c in zip(nums, cost))
    
        def check(x):
            return x+1 == len(idxs) or f(nums[idxs[x]]) < f(nums[idxs[x+1]])

        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        left, right = 0, len(idxs)-1
        while left <= right:
            mid = left+(right-left)//2
            if check(mid):
                right = mid-1
            else:
                left = mid+1
        return f(nums[idxs[left]])",O(nlogn)
"n,m = map(int,input().split())
xi = list(map(int,input().split()))
ti = list(map(int,input().split()))
ai = [0] * (m+2)
ar = [0] * (m+2)
ar[-1] = 10**11
ar[0] = -100000000000
j = 1
n2 = n + m
for i in range(n2):
    if ti[i] == 1:
        ar[j] = xi[i]
        j += 1
i1 = 0
i2 = 1
for i in range(n2):
        if ti[i] == 1:
            i2 += 1
            i1 += 1
            continue
        num = xi[i] - ar[i1]
        num2 = ar[i2] - xi[i]
        if num <= num2:
            ai[i1] += 1
        else:
            ai[i2] += 1
for i in range(1,m+1):
    print(ai[i],end="" "")
",O(n)
"import math

n,k = map(int,input().split())
l=[]
c=0
for j in range(2,n):
    p=0

    for i in range(2,int(math.sqrt(j))+1):

        if j%i==0:

            p=1
            break
        else:
            pass

    if p==0:
        l.append(j)

l+=[n]

for i in range(len(l)-1):

    if (l[i]+l[i+1]+1) in l:

        c+=1
if c>=k:
    print(""YES"")
else:
    print(""NO"")
",O(n)
"def solve(a, b):
    m = len(a)
    n = len(b)
    p_b = [0]
    for x in b[:]:
        p_b.append(p_b[-1] + int(x))
    s = 0
    for i in range(m):
        if a[i] == '0':
            s += p_b[n - m + 1 + i] - p_b[i]
        else:
            s += (n - m + 1) - (p_b[n - m + 1 + i] - p_b[i])
    return s

a = input()
b = input()
print(solve(a, b))
",O(n)
"def main():
    pieces_Dimension = int(input())
    piece1 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece2 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece3 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece4 = ''.join(input() for _ in range(pieces_Dimension))

    brokenPieces = (piece1, piece2, piece3, piece4)
    nSquares = pieces_Dimension*pieces_Dimension
    squares = '01'*-(-nSquares//2)

    return nSquaresToRecolorIn(brokenPieces, nSquares, squares)

def nSquaresToRecolorIn(brokenPieces, nSquares, squares):
    possible_nSquares = [(sum(1 for i in range(nSquares) if piece[i] != squares[:-1][i]),
                          sum(1 for i in range(nSquares) if piece[i] != squares[1:][i]))
                         for piece in brokenPieces]
    possible_nSquares.sort(key=lambda x: x[0])

    return possible_nSquares[0][0] + possible_nSquares[1][0] + possible_nSquares[2][1] + possible_nSquares[3][1]

if __name__ == '__main__':
    print(main())
",O(n ^ 2)
"a = input()
b = input()
la = [int(x) for x in a]
res = []
la.sort()
la = la[::-1]
lb = [int(x) for x in b]
cnt = [0] * 20

def check():
    tres = 0
    for x in range(len(res)):
        tres *= 10
        tres += int(res[x])
    return tres <= int(b)
if len(a) < len(b):
    for i in range(len(la)):
        print(la[i], end = '')
    print()
else:
    for i in range(len(la)):
        cnt[la[i]] += 1
    flag = 0
    for i in range(len(lb)):
        if flag == 0 and cnt[lb[i]]:
            res.append(lb[i])
            cnt[lb[i]] -= 1
        else:
            flag = i - 1
            for j in range(lb[i] - 1, -1, -1):
                if cnt[j]:
                    res.append(j)
                    cnt[j] -= 1
                    break
            for j in range(9, -1, -1):
                while cnt[j]:
                    res.append(j)
                    cnt[j] -= 1
            break
    while not check():
        temp = []
        cnt = [0] * 20
        for x in range(flag):
            temp.append(res[x])
            cnt[res[x]] -= 1
        for i in la:
            cnt[i] += 1

        res = temp

        for v in range(lb[flag] - 1, -1, -1):
            if cnt[v]:
                res.append(v)
                cnt[v] -= 1
                break
        for v in range(9, -1, -1):
            while cnt[v]:
                res.append(v)
                cnt[v] -= 1

        flag -= 1
    for i in range(len(res)):
        print(res[i], end = '')
    print()
",O(n ^ 3)
"class Solution(object):
    def numberOfLines(self, widths, S):
        result = [1, 0]
        for c in S:
            w = widths[ord(c)-ord('a')]
            result[1] += w
            if result[1] > 100:
                result[0] += 1
                result[1] = w
        return result",O(n)
"class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = set()
        nums.sort()
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                for k in range(j + 1, len(nums)):
                    if nums[i] + nums[j] + nums[k] == 0:
                        tmp = [nums[i], nums[j], nums[k]]
                        res.add(tuple(tmp))
        return [list(i) for i in res]
",O(n ^ 3)
"def bina(bi):
    binary1 = bi
    decimal, i, n = 0, 0, 0
    while(bi != 0):
        dec = bi % 10
        decimal = decimal + dec * pow(2, i)
        bi = bi//10
        i += 1
    return decimal
def con(n):
   return bin(n).replace(""0b"", """")
l,r=map(int,input().split())
k=con(l)
m=con(r)
k=list(str(k))
m=list(str(m))
j=len(m)-len(k)
k=['0']*j + k

c=0
for i in range(len(m)):
    if k[i]!=m[i]:
        c=1
    if k[i]==m[i] and k[i]=='1' and c==1:
        k[i]='0'
    elif k[i]==m[i] and k[i]=='0' and c==1:
        k[i]='1'
k=int(''.join(k))
m=int(''.join(m))
print(bina(k)^bina(m))",O(logn)
"import sys
import bisect
from bisect import bisect_left as lb
from bisect import bisect_right as rb
input_=lambda: sys.stdin.readline().strip(""\r\n"")
from math import log
from math import gcd
from math import atan2,acos
from random import randint
sa=lambda :input_()
sb=lambda:int(input_())
sc=lambda:input_().split()
sd=lambda:list(map(int,input_().split()))
sflo=lambda:list(map(float,input_().split()))
se=lambda:float(input_())
sf=lambda:list(input_())
flsh=lambda: sys.stdout.flush()

mod=10**9+7
mod1=998244353
gp=[]
cost=[]
dp=[]
mx=[]
ans1=[]
ans2=[]
special=[]
specnode=[]
a=0
kthpar=[]
def dfs2(root,par):
    if par!=-1:
        dp[root]=dp[par]+1
    for i in range(1,20):
        if kthpar[root][i-1]!=-1:
            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]
    for child in gp[root]:
        if child==par:continue
        kthpar[child][0]=root
        dfs(child,root)

ans=0
b=[]
vis=[]
tot=0
def dfs(root):
    global tot,vis,gp
    for child in gp[root]:
        if vis[child]==0:
            tot+=1
            vis[child]=1
            dfs(child)
pre=[[] for i in range(3)]
def hnbhai(tc):
    n=sb()
    d,num=0,1
    while num<=n:
        num+=9*(d+1)*(10**d)
        d+=1
    num-=9*(d)*(10**(d-1))
    ans=str(10**(d-1)+(n-num)//d)
    print(ans[(n-num)%d])
for _ in range(1):
    hnbhai(_+1)
",O(logn)
"import sys
input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))

dp = [[-1]*(N+1) for _ in range(N+1)]
for l in range(N):
    dp[l][l+1] = A[l]

for d in range(2, N+1):
    for l in range(N-d+1):
        for t in range(1, d):
            if dp[l][l+t] == dp[l+t][l+d] and dp[l][l+t] != -1:
                dp[l][l+d] = dp[l][l+t] + 1
                break

dp2 = [i for i in range(N+1)]
for r in range(1,N+1):
    if dp[0][r] != -1:
        dp2[r] = 1
for l in range(N):
    for r in range(l+2, N+1):
        if dp[l+1][r] != -1:
            dp2[r] = min(dp2[l+1]+1, dp2[r])
        else:
            dp2[r] = min(dp2[l+1]+(r-l-1), dp2[r])

print(dp2[N])",O(n ^ 3)
"import math

def Maxxor(l,r):
	if(l==r):
		return 0
	else:
		reflog=math.floor(math.log2(r))
		ref=2**reflog
		if(l<ref):
			return (2*ref)-1
		else:
			return Maxxor(l-ref,r-ref)

l,r = map(int, input().split())
ans=Maxxor(l,r)
print(ans)",O(logn)
"import sys
n = int(input().strip())
sizes = list(map(int, input().strip().split()))
cost = list(map(int, input().strip().split()))
tot = []
for i in range(n):
    tot.append([sizes[i], cost[i]])
ret = False
lcomp = []
for j in range(len(tot)):
    if j > 0 and j < len(tot)-1:
        temp1 = tot[:j]
        temp2 = tot[j+1:]
        mi_1 = sys.maxsize
        ret1 = False
        for i in range(len(temp1)):
            if temp1[i][0] < tot[j][0]:
                mi_1 = min(mi_1, temp1[i][1])
                ret1 = True
        mi_2 = sys.maxsize
        ret2 = False
        for k in range(len(temp2)):
            if temp2[k][0] > tot[j][0]:
                mi_2 = min(mi_2, temp2[k][1])
                ret2 = True
        if ret1 and ret2:
            ret = True
            lcomp.append(mi_1+tot[j][1]+mi_2)

if ret:
    print(min(lcomp))
else:
    print(-1)
",O(n ^ 2)
"class Solution2(object):
    def minOperationsToFlip(self, expression):
        stk = [[None]*3]
        for c in expression:                                
            if c == '(':                                            
                stk.append([None]*3)
            elif c in {')', '0', '1'}:
                if c == ')':
                    dp0, dp1, _ = stk.pop()
                else:
                    dp0, dp1 = int(c != '0'), int(c != '1')
                if stk[-1][2] == '&':
                    stk[-1] = [min(stk[-1][0], dp0),
                               min(stk[-1][1]+dp1, min(stk[-1][1], dp1)+1),
                               None]
                elif stk[-1][2] == '|':
                    stk[-1] = [min(stk[-1][0]+dp0, min(stk[-1][0], dp0)+1),
                               min(stk[-1][1], dp1),
                               None]
                else: 
                    stk[-1] = [dp0, dp1, None]
            else:
                stk[-1][2] = c
        return max(stk[0][0], stk[0][1])",O(n)
"class Solution(object):
    def minOperationsToFlip(self, expression):
        def compute(operands, operators):
            right, left = operands.pop(), operands.pop()
            operands.append(ops[operators.pop()](left, right))

        ops = {'&':lambda x, y: [min(x[0], y[0]), min(x[1]+y[1], min(x[1], y[1])+1)],
               '|':lambda x, y: [min(x[0]+y[0], min(x[0], y[0])+1), min(x[1], y[1])]}
        precedence = {'&':0, '|':0}
        operands, operators = [], []
        for c in expression:
            if c.isdigit():
                operands.append([int(c != '0'), int(c != '1')])
            elif c == '(':
                operators.append(c)
            elif c == ')':
                while operators[-1] != '(':
                    compute(operands, operators)
                operators.pop()
            elif c in precedence:
                while operators and operators[-1] in precedence and \
                      precedence[operators[-1]] >= precedence[c]:
                    compute(operands, operators)
                operators.append(c)
        while operators:
            compute(operands, operators)
        return max(operands[-1])",O(n)
"n, m = map(int, input().split())
xs = [int(k) for k in input().split()]
ts = [int(k) for k in input().split()]
pos = [-1 for i in range(n + m)]
if ts[0]:
    pos[0] = 0
for i in range(1, n + m):
    pos[i] = pos[i - 1]
    if ts[i]:
        pos[i] += 1
result = [0 for i in range(m)]
left = 0
leftC = 0
right = 0
rightC = 0
for i in range(n + m):
    if ts[i] == 0:
        right = max(i, right)
        while right + 1 < n + m and not ts[right]:
            right += 1
        mP, mD = 0, 20000000
        if ts[left]:
            mP = pos[left]
            mD = xs[i] - xs[left]
        if ts[right] and xs[right] - xs[i] < mD:
            mD = xs[right] - xs[i]
            mP = pos[right]
        result[mP] += 1
    else:
        left = i
print(*result)
",O(n)
"N=int(input())
A=[int(x) for x in input().split()]
bit=[]
nax=200010
for i in range(nax*4+1):
    bit.append([0,0])

def up(k,val):
    while k< (nax*4):
        bit[k][0]+=val
        bit[k][1]+=1
        k+=(k&-k)

def go(k):
    ans=0;r=0
    while k>0:
        ans+=bit[k][0]
        r+=bit[k][1]
        k-=(k&-k)
    return ans,r

index={}
B=[x for x in A]
B.sort()
idx=1
index[B[0]]=idx;
for i in range(1,N):
    if B[i]!=B[i-1]:
        if B[i]==(B[i-1]+1):
            idx+=1
            index[B[i]]=idx
        else:
            idx+=2
            index[B[i]]=idx

have=0
for i in range(0,N):
    a1,a2=go(index[A[i]]-2)
    a3,a4=go(3*N)
    a5,a6=go(index[A[i]]+1)
    s1=(a2*A[i])-(a1)
    s2=((a4-a6)*A[i])-(a3-a5)
    have+=s1
    have+=s2
    up(index[A[i]],A[i])

print(have)
",O(nlogn)
"a, b  = map(int, input().split())

k = 2**(a^b).bit_length()
print(k-1)",O(logn)
"n,useless=list(map(int,input().split()))
arr=list(map(int,input().split()))
for x in range(1,n+1):
    if x not in arr:
        print(0)
        break
else:
    print(arr.count(min(arr,key=lambda x:arr.count(x))))",O(n ^ 2)
"class Solution(object):
    def maximumBinaryString(self, binary):
        result = list(binary)
        zeros = ones = 0
        for i, c in enumerate(result):
            if c == '0':
                zeros += 1
            elif zeros == 0:
                ones += 1
            result[i] = '1'
        if ones != len(result):
            result[zeros+ones-1] = '0'
        return """".join(result)",O(n)
"x, y, z, t1, t2, t3 = map(int, input().split())
lift = abs(z - x) * t2 + t3 + t3 + abs(x - y) * t2 + t3
stairs = t1 * abs(x - y)
if lift <= stairs:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"class Solution(object):
    def minimumOperations(self, nums):
        return sum(x%3 != 0 for x in nums)",O(n)
"n = int(input())
l = list(map(int, input().split()))
ansl = ['sjfnb', 'cslnb']
ans = -1
d = dict()
val = 0
if n == 1:
    ans = (l[0] + 1) % 2
else:
    l.sort()
    for elem in l:
        d[elem] = d.get(elem, 0) + 1
    hm = 0
    which = -1
    i = 0
    for elem in d.values():
        if elem >= 2:
            hm += 1
            which = i
        i += 1
    which = list(d.keys())[which]
    if max(d.values()) >= 3 or d.get(0, 0) >= 2 or hm > 1:
        ans = 1
    elif hm == 1 and d.get(which - 1, 0) > 0:
        ans = 1
    else:
        for i in range(n):
            val += l[i] - i
        ans = (val + 1) % 2
print(ansl[ans])",O(nlogn)
"x, y, z, t1, t2, t3 = list(map(int, input().split()))
print(""YES"" if 3 * t3 + abs(x - z) * t2 + abs(x - y) * t2 <= abs(x - y) * t1 else ""NO"")",O(1)
"n = int(input())
l = list(map(int,input().split()))
i = 0
p = []
while 2**i <= 10**18:
    p.append(2**i)
    i = i+1

d = {}
s = set()
for i in l:
    s.add(i)
    if i in d:
        d[i] += 1

    else:
        d[i] = 1

z = set()
for i in s:
    f = 1
    for j in p:
        e = j-i
        if e in s:
            if e == i and d[e] == 1:
                continue

            f = 0
            break

    if f:
        z.add(i)

ans = 0
for i in z:
    ans += d[i]

print(ans)",O(nlogn)
"n,m,k = [int(y) for y in input().split()]
a = [int(y) for y in input().split()]
a.sort(reverse=True)
no = 0
while k < m and no < n:
    k += a[no]-1
    no += 1
if k < m:
    print(-1)
else:
    print(no)",O(nlogn)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def nodesBetweenCriticalPoints(self, head):
        first = last = -1
        result = float(""inf"")
        i, prev, head = 0, head.val, head.__next__
        while head.__next__:
            if max(prev, head.next.val) < head.val or min(prev, head.next.val) > head.val:
                if first == -1:
                    first = i
                if last != -1:
                    result = min(result, i-last)
                last = i
            i += 1
            prev = head.val
            head = head.__next__
        return [result, last-first] if last != first else [-1, -1]",O(n)
"class Solution(object):
    def longestContinuousSubstring(self, s):
        result = l = 0
        for i in range(len(s)):
            l += 1
            if i+1 == len(s) or ord(s[i])+1 != ord(s[i+1]):
                result = max(result, l)
                l = 0
        return result",O(n)
"class Solution:
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0
        n = len(height)
        res = 0

        for i in range(n):
            leftMax = rightMax = height[i]

            for j in range(i):
                leftMax = max(leftMax, height[j])
            for j in range(i + 1, n):
                rightMax = max(rightMax, height[j])

            res += min(leftMax, rightMax) - height[i]
        return res
",O(n ^ 2)
"class Solution2(object):
    list_head = None
    def flatten(self, root):
        if root:
            self.flatten(root.right)
            self.flatten(root.left)
            root.right = self.list_head
            root.left = None
            self.list_head = root",O(n)
"class Solution2(object):
    def triangleNumber(self, nums):
        result = 0
        nums.sort()
        for i in range(len(nums)-2):
            if nums[i] == 0:
                continue
            k = i+2
            for j in range(i+1, len(nums)-1):
                while k < len(nums) and nums[i] + nums[j] > nums[k]:
                    k += 1
                result += k-j-1
        return result",O(n ^ 2)
"import collections


class Solution(object):
    def largestValsFromLabels(self, values, labels, num_wanted, use_limit):
        counts = collections.defaultdict(int)
        val_labs = list(zip(values,labels))
        val_labs.sort(reverse=True)
        result = 0
        for val, lab in val_labs:
            if counts[lab] >= use_limit:
                continue
            result += val
            counts[lab] += 1
            num_wanted -= 1
            if num_wanted == 0:
                break
        return result",O(nlogn)
"class Solution(object):
    def shiftingLetters(self, s, shifts):
        events = [0]*(len(s)+1)
        for b, e, d in shifts:
            events[b] += 1 if d else -1
            events[e+1] -= 1 if d else -1
        result = []
        curr = 0
        for i in range(len(s)):
            curr += events[i]
            result.append(chr(ord('a')+(ord(s[i])-ord('a')+curr)%26))
        return """".join(result)",O(n)
"import sys
def contain(a, b):
    ax1, ay1, ax2, ay2 = a
    bx1, by1, bx2, by2 = b
    return bx1 <= ax1 and ax2 <= bx2 and by1 <= ay1 and ay2 <= by2
def ask(x1, y1, x2, y2, known=(), memo={}):
    if x2 < x1+1 or y2 < y1+1:
        return 0
    ofs = len(list(filter(lambda rect: contain(rect, (x1, y1, x2, y2)), known)))
    key = (x1+1, y1+1, x2, y2)
    if key in memo:
        return memo[key] - ofs
    print('?', *key)
    sys.stdout.flush()
    memo[key] = int(input())
    return memo[key] - ofs
def binsearch(l, r, p):
    assert l < r
    while l+1 != r:
        m = (l + r) // 2
        if p(m):
            r = m
        else:
            l = m
    return r
def shrink(x1, y1, x2, y2, cnt, known=()):
    assert ask(x1, y1, x2, y2, known=known) == cnt
    x1 = binsearch(x1, x2, lambda x: ask(x, y1, x2, y2, known=known) != cnt) - 1
    y1 = binsearch(y1, y2, lambda y: ask(x1, y, x2, y2, known=known) != cnt) - 1
    x2 = binsearch(x1, x2, lambda x: ask(x1, y1, x, y2, known=known) == cnt)
    y2 = binsearch(y1, y2, lambda y: ask(x1, y1, x2, y, known=known) == cnt)
    assert ask(x1, y1, x2, y2, known=known) == cnt
    assert ask(x1, y1, x2, y2, known=known) == cnt
    return x1, y1, x2, y2
def go(x1, y1, x2, y2):
    assert ask(x1, y1, x2, y2) == 2
    x1, y1, x2, y2 = shrink(x1, y1, x2, y2, 2)
    a = None
    if not a and x1 < x2:
        if ask(x1+1, y1, x2, y2) == 1:
            a = shrink(x1+1, y1, x2, y2, 1)
        elif ask(x1, y1, x2-1, y2) == 1:
            a = shrink(x1, y1, x2-1, y2, 1)
    if not a and y1 < y2:
        if ask(x1, y1+1, x2, y2) == 1:
            a = shrink(x1, y1+1, x2, y2, 1)
        elif ask(x1, y1, x2, y2-1) == 1:
            a = shrink(x1, y1, x2, y2-1, 1)
    if not a:
        a = x1, y1, x2, y2
        return a, a
    else:
        b = shrink(x1, y1, x2, y2, 1, known=[ a ])
        return a, b
n = int(input())
a, b = go(0, 0, n, n)
ax1, ay1, ax2, ay2 = a
bx1, by1, bx2, by2 = b
print('!', ax1+1, ay1+1, ax2, ay2, bx1+1, by1+1, bx2, by2)
",O(logn)
"def solve(x,y,z):
    global r,g,b,ans
    if (x > r - 1 and y > g - 1) or (x > r - 1 and z > b - 1) or (y > g - 1 and z > b - 1):
        return 0
    if memo[x][y][z] != -1:
        return memo[x][y][z]
    mx = 0
    if x < r and y < g:
        mx = max(mx,ra[x]*ga[y] + solve(x+1,y+1,z))
    if x < r and z < b:
        mx = max(mx,ra[x]*ba[z] + solve(x+1,y,z+1))
    if y < g and z < b:
        mx = max(mx,ga[y]*ba[z] + solve(x,y+1,z+1))
    ans = max(ans,mx)
    memo[x][y][z] = mx
    return mx

r,g,b = map(int,input().split())
ra = sorted(list(map(int,input().split())),reverse = True)
ga = sorted(list(map(int,input().split())),reverse = True)
ba = sorted(list(map(int,input().split())),reverse = True)

memo = [[[-1 for k in range(205)] for i in range(205)] for j in range(205)]

ans = 0

solve(0,0,0)
print(ans)
",O(n ^ 3)
"from math import factorial
f=lambda:input()
a=f()
b=f()
s=0
s1=0
c=0
for i in a:
    if i=='+':
       s+=1
    else:
       s-=1
for i in b:
    if i=='+':
       s1+=1
    elif i=='-':
       s1-=1
    else:
       c+=1
if c==0:
    if s==s1:
        print(c+1)
    else:
        print(c)
else:
    l=[]
    k=c
    i=c
    j=0
    while i>=0:
        l.append(k)
        i-=1
        j+=1
        k=0
        k+=i
        k-=j
    if s1!=0:
        for i in range(len(l)):
            l[i]+=s1
    try:
        c1=l.index(s)
        k=factorial(c)/(factorial(c-c1)*factorial(c1))
        print(k/pow(2,c))
    except:
        print(0.0)",np
"d={}
n=int(input())
for _ in range(n):
    a,b=map(int,input().split())
    d[a]=b
m=int(input())
for _ in range(m):
    a,b=map(int,input().split())
    if(a in d and b>d[a]):
        d[a]=b
    elif(a not in d):
        d[a]=b
s=0
for i in d:
    s+=d[i]
print(s)
",O(nlogn)
"

class Solution(object):
    def minimizedStringLength(self, s):
        return len(set(s))
",O(n)
"from sys import stdin

add = lambda a, b: (a + b) % mod
mod, bits = 998244353, ['00', '01', '10', '11']
pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]

n, k = map(int, stdin.readline().split())
mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]

for i in range(4):
    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)
    if val <= k:
        mem[0][val][i] = 1

for i in range(1, n):
    for j in range(1, k + 1):
        for k1 in range(4):
            for k2 in range(4):
                val = j + pat[k1][k2]
                if val <= k:
                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])

print(sum(mem[-1][k]) % mod)
",np
"n=int(input())
if n >= 0:

    print(n)

else:

    a = int(n / 10)
    b=int(n/100)*10 - abs(n)%10

    print(max(a,b))",O(1)
"class Solution2(object):
    def countPairsOfConnectableServers(self, edges, signalSpeed):
        def dfs(u, p, dist):
            cnt = 1 if dist%signalSpeed == 0 else 0
            for v, w in adj[u]:
                if v == p:
                    continue
                cnt += dfs(v, u, dist+w)
            return cnt
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        result = [0]*(len(edges)+1)
        for u in range(len(result)):
            curr = 0
            for v, w in adj[u]:
                cnt = dfs(v, u, w)
                result[u] += curr*cnt
                curr += cnt
        return result",O(n ^ 2)
"n,k = [int(x) for x in input().split()]
a = []
for _ in range(n):
    a.append([int(x) for x in input().split()])

a.sort(key = lambda x: x[1])
a.sort(reverse=True,key=lambda x: x[0])
b=a[k-1]
print(a.count(b))",O(nlogn)
"n = int(input())
print((n//2)+1)",O(1)
"class Solution(object):
    def convertTime(self, current, correct):
        OPS = (60, 15, 5, 1)
        diff = (int(correct[:2])*60+int(correct[3:]))-(int(current[:2])*60+int(current[3:]))
        result = 0
        for x in OPS:
            q, diff = divmod(diff, x)
            result += q
        return result",O(1)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

prime = [True for i in range(200001)]
pp=[0]*200001
def SieveOfEratosthenes(n=200000):

    p = 2
    while (p * p <= n):

        if (prime[p] == True):

            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1

n,m=map(int, input().split())
a=list(map(int, input().split()))
t=n//m
remain=[[] for i in range(m)]
for i in range(n):
    x=a[i]%m
    remain[x].append(i)
ans=0
f=[]
for i in range(2*m):
    cur=i%m
    while len(remain[cur])>t:
        elm=remain[cur].pop()
        f.append([elm,i])
    while len(remain[cur])<t and len(f)!=0:
        elm,j=f.pop()
        remain[cur].append(elm)
        a[elm]+=abs(i-j)
        ans+=abs(i-j)
print(ans)
print(*a)
",O(n)
"n = int(input())-1
x, y = 1, 9
while n > x * y: n,x,y = n-x*y,x+1,y*10
a = str(10 ** (x - 1) + n // x)[n%x]
print(a)",O(logn)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

from collections import Counter

n, s = mi()
d = Counter()
for i in range(n - 1):
    u, v = mi()
    d[u] += 1
    d[v] += 1

l = sum(v == 1 for v in d.values())
ans = s / l * 2
print('%.10f' % (ans,))",O(n)
"class Solution(object):
    def checkArray(self, nums, k):
        curr = 0
        for i, x in enumerate(nums):
            if x-curr < 0:
                return False
            nums[i] -= curr
            curr += nums[i]
            if i-(k-1) >= 0:
                curr -= nums[i-(k-1)]
        return curr == 0",O(n)
"n=int(input())
print((n+2)//2)",O(1)
"from sys import stdin, stdout

N = 55

f = [0]
for i in range(1, N):
    f.append(f[-1]*4 + 1)
    if f[-1] > 1e18:
        break

t = int(stdin.readline().strip().split()[0])

for ca in range(0, t):
    n, m = [int(x) for x in stdin.readline().strip().split()]
    if n > 31:
        stdout.write(""YES {}\n"".format(n-1))
    else:

        start = 0
        found = False
        res = -1
        for i in range(1, n+1):
            start += 2**i -1
            end = start
            for k in range(1, i+1):
                end += f[n-k] * (2**(k+1) - 3)
            if m >= start and m <= end:
                found = True
                res = i
                break
        if found:
            stdout.write(""YES {}\n"".format(n-res))
        else:
            stdout.write(""NO\n"")
",O(n ^ 2)
"
class Solution(object):
    def minDiffInBST(self, root):
        def dfs(node):
            if not node:
                return
            dfs(node.left)
            self.result = min(self.result, node.val-self.prev)
            self.prev = node.val
            dfs(node.right)

        self.prev = float('-inf')
        self.result = float('inf')
        dfs(root)
        return self.result


",O(n)
"n=int(input())
st_a=input()
st_b=input()
st_c=input()
a=[0 for i in range(125)]
b=[0 for i in range(125)]
c=[0 for i in range(125)]
l=len(st_c)
for i in range(l):
    a[ord(st_a[i])] +=1
    b[ord(st_b[i])] +=1
    c[ord(st_c[i])] +=1
maxi_a=0
maxi_b=0
maxi_c=0
if n==1:
    maxi_a =max(a) +1
    maxi_b=max(b) +1
    maxi_c=max(c) +1
    if maxi_a >l:
        maxi_a-=2
    if maxi_b >l:
        maxi_b -=2
    if maxi_c >l:
        maxi_c-=2
else:
    for i in range(123):
        if (i>=65 and i <=90) or (i>=97 and i<=122):
            if a[i] +n >=l:
                    maxi_a=max(maxi_a,l)
            else:
                maxi_a =max(maxi_a ,a[i] +n)
            if b[i] +n >=l:
                    maxi_b=max(maxi_b,l)
            else:
                maxi_b =max(maxi_b ,b[i] +n)
            if c[i] +n >=l:
                    maxi_c=max(maxi_c,l)
            else:
                maxi_c =max(maxi_c ,c[i] +n)
s=[maxi_a,maxi_b,maxi_c]
s.sort()
if s[1] ==s[2]:
    print(""Draw"")
if maxi_a >max(maxi_b,maxi_c):
    print(""Kuro"")
if maxi_b >max(maxi_c,maxi_a):
    print(""Shiro"")
if maxi_c >max(maxi_b,maxi_a):
    print(""Katie"")
",O(n)
"import math as ma
import sys
from sys import exit
from decimal import Decimal as dec
from itertools import permutations

def li():
	return list(map(int , input().split()))

def num():
	return map(int , input().split())

def nu():
	return int(input())

n,m=num()
a=li()
ind=-1
z=0
ll=sorted(a)
mx=ll[n-1]-1
cc=0
for i in range(n-2,-1,-1):
	if (ll[i] == 0):
		continue
	if(mx==0):
		cc += ll[i] - 1
		continue

	if(ll[i]>=mx):
		cc+=1
		mx-=1
		cc+=ll[i]-1
		ll[i]=1
	else:
		mx=ll[i]
		cc+=1
		mx-=1
		cc += ll[i] - 1
		ll[i] = 1

print(cc)",O(nlogn)
"n = int(input())
a = list(map(int, input().split()))
a.sort()
k = 0
for i in range(n) :
    if a[i] :
        k += 1
        for j in range(i + 1, n) :
            if a[j] and a[j] % a[i] == 0 :
                a[j] = 0
print(k)",O(n ^ 2)
"class Read:
    @staticmethod
    def int():
        return int(input())

    @staticmethod
    def list(sep=' '):
        return input().split(sep)

    @staticmethod
    def list_int(sep=' '):
        return list(map(int, input().split(sep)))
    @staticmethod
    def calc(sep = '', k = ''):
        count = 0
        for i in range(sep):
            j = sep - i
            sum = ((i + 1)* i) / 2
            if (sum - j == k):
                return j
        return count

def main():
    n, k = Read.list_int()
    print(Read.calc(n, k))

main()",O(logn)
"n, a, b = map(int, input().split())
if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:
    print('NO')
    exit()
print('YES')
f = int(a == 1)
g = [a, b][f]
r = [[f] * n for i in range(n)]
for i in range(n):
    r[i][i] = 0
for i in range(n - g):
    r[i][i + 1] ^= 1
    r[i + 1][i] ^= 1
print('\n'.join(map(lambda x: ''.join(map(str, x)), r)))
",O(n ^ 2)
"class Solution(object):
    def minFlips(self, s):
        result = float(""inf"")
        cnt1 = cnt2 = 0
        for i in range(2*len(s)-1 if len(s)%2 else len(s)):
            if i >= len(s):
                cnt1 -= int(s[i%len(s)])^((i-len(s))%2)^0
                cnt2 -= int(s[i%len(s)])^((i-len(s))%2)^1
            cnt1 += int(s[i%len(s)])^(i%2)^0
            cnt2 += int(s[i%len(s)])^(i%2)^1
            if i >= len(s)-1:
                result = min(result, cnt1, cnt2)
        return result",O(n)
"import collections



class Solution2(object):
    def minimumLength(self, s):
        return sum(2-x%2 for x in collections.Counter(s).values())",O(n)
"p = int(input())
arr = list(map(int, input().split()))
arr.sort(reverse=True)
d = 0
for x in arr:
    d += x
c = 0
num = 0
while c <= d/2:
    c += arr[num]
    num += 1
print(num)
",O(nlogn)
"n, m, k = list(map(int, input().split()))
f = list(map(int, input().split()))
f.sort()

fs = 0
ptr = len(f) - 1
while ptr >= 0:
    if m <= k:
        print(fs)
        exit()
    k -= 1
    k += f[ptr]
    fs += 1
    ptr -= 1

if m <= k:
    print(fs)
else:
    print(-1)",O(nlogn)
"def solve():
    n, l, r, x = map(int, input().split(' '))
    c = list(map(int, input().split(' ')))
    ans = 0
    for bitmask in range(2 ** n):
        if bin(bitmask).count('1') > 1:
            res, _min, _max = 0, float('+inf'), float('-inf')
            for c_i, bit_i in zip(c, (1 & int(bitmask) >> i for i in range(n))):
                if bit_i:
                    res += c_i * bit_i
                    if c_i < _min:
                        _min = c_i
                    if c_i > _max:
                        _max = c_i
            if l <= res <= r and (_max - _min) >= x:
                ans += 1
    print(ans)

if __name__ == '__main__':
    solve()",np
"import collections
import itertools
from sortedcontainers import SortedList



class Solution2(object):
    def mostFrequentIDs(self, nums, freq):
        result = []
        cnt = collections.Counter()
        cnt2 = collections.Counter()
        sl = SortedList()
        for x, f in zip(nums, freq):
            sl.discard((cnt[x], cnt2[cnt[x]]))
            cnt2[cnt[x]] -= 1
            if cnt2[cnt[x]]:
                sl.add((cnt[x], cnt2[cnt[x]]))
            cnt[x] += f
            sl.discard((cnt[x], cnt2[cnt[x]]))
            cnt2[cnt[x]] += 1
            sl.add((cnt[x], cnt2[cnt[x]]))
            result.append(sl[-1][0])
        return result",O(nlogn)
"n=int(input())
l=[]
for i in range(n):
    s=str(input())
    l.append(s)
print(6-n)
if ""purple"" not in l:
    print(""Power"")
if ""green"" not in l:
    print(""Time"")
if ""red"" not in l:
    print(""Reality"")
if ""blue"" not in l:
    print(""Space"")
if ""orange"" not in l:
    print(""Soul"")
if ""yellow"" not in l:
    print(""Mind"")
",O(1)
"r, g, b = map(int, input().split())
a = [[], [], []]
dp = [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)]
for x in range(3):
    a[x] = sorted([int(x) for x in input().split()])
odp = 0
for i in range(r + 1):
    for j in range(g + 1):
        for k in range(b + 1):
            if i < r and j < g:
                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])
            if i < r and k < b:
                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])
            if j < g and k < b:
                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])
            odp = max(odp, dp[i][j][k])
print(odp)",O(n ^ 3)
"class Solution(object):
    def longestAlternatingSubarray(self, nums, threshold):
        result = l = 0
        for x in nums:
            if x > threshold:
                l = 0
                continue
            if l%2 == x%2:
                l += 1
            else:
                l = int(x%2 == 0)
            result = max(result, l)
        return result",O(n)
"n, A, C = list(map(int, input().split()))

def Ro(x, y):
    return A * x - y + C

huh = []

for i in range(n):
    z, x, y = list(map(int, input().split()))
    huh.append((Ro(x + z, z * A + y), x))
huh = sorted(huh)
anss = 0
c1 = 0
c2 = 0
prev = (-9999999999999, -999999999999999)
g = []

huh.append((-9999999999999, -999999999999999))

for huhh in huh:
    if huhh[0] != prev[0]:
        g.append(c1)

        for j in g:
            anss += (c2 - j) * j
        g = []
        c1 = 1
        c2 = 1
        prev = (huhh[0], huhh[1])
        continue
    c2 += 1
    if huhh[1] != prev[1]:
        g.append(c1)
        c1 = 0
        prev = (huhh[0], huhh[1])
    c1 += 1
print(anss)
",O(n)
"xs = [int(x) for x in input().split()]

res = 0
for i in range(14):
    newxs = xs[:]
    newxs[i] = 0
    for j in range(14):
        newxs[j] += xs[i] // 14

    for j in range(xs[i] % 14):
        newxs[(i + 1 + j) % 14] += 1

    res = max(res, sum(val for val in newxs if val % 2 == 0))

print(res)
",O(1)
"import collections


class Solution(object):
    def checkEqualTree(self, root):
        def getSumHelper(node, lookup):
            if not node:
                return 0
            total = node.val + \
                    getSumHelper(node.left, lookup) + \
                    getSumHelper(node.right, lookup)
            lookup[total] += 1
            return total

        lookup = collections.defaultdict(int)
        total = getSumHelper(root, lookup)
        if total == 0:
            return lookup[total] > 1
        return total%2 == 0 and (total/2) in lookup",O(n)
"class Solution(object):
    def checkOnesSegment(self, s):
        return ""01"" not in s",O(n)
"class Solution2(object):
    def pseudoPalindromicPaths (self, root):
        def dfs(node, count):
            if not root:
                return 0
            count ^= 1 << (node.val-1)
            return int(node.left == node.right and count&(count-1) == 0) + \
                   dfs(node.left, count) + dfs(node.right, count)
        return dfs(root, 0)",O(n)
"n = int(input())
x, y = map(int, input().split())

def d(a, b):
    return a + b

if d(x-1, y-1) <= d(n-x, n-y):
    print(""White"")
else:
    print(""Black"")",O(1)
"n,k=map(int,input().split())
l=[]
for i in range(n):
   manan,surbhi=map(int,input().split())
   l.append((manan,surbhi))

l.sort(key=lambda x:(x[0], -x[1]),reverse=True)
ans=1
ps=l[k-1][0]
tp=l[k-1][1]
for i in range(k,n):
    if l[i][0]==ps and l[i][1]==tp:
        ans+=1
    else:
        break
for i in range(k-2,-1,-1):
    if l[i][0]==ps and l[i][1]==tp:
        ans+=1
    else:
        break

print(ans)
",O(nlogn)
"class Solution(object):
    def maxArea(self, height):
        max_area, i, j = 0, 0, len(height) - 1
        while i < j:
            max_area = max(max_area, min(height[i], height[j]) * (j - i))
            if height[i] < height[j]:
                i += 1
            else:
                j -= 1
        return max_area",O(n)
print(25),O(1)
"def isValid(arr, l, r, x):
	return l <= sum(arr) <= r and max(arr)-min(arr) >= x

n, l, r, x = map(int, input().strip().split())
arr = list(map(int, input().strip().split()))
valid = 0

for i in range(1, 1<<n):
	s = str(bin(i))[2:].rjust(n, '0')
	temp = []
	for j in range(n):
		if s[j] == '1':
			temp.append(arr[j])
	if isValid(temp, l, r, x):
		valid += 1
print(valid)",np
"class Solution(object):
    def isArraySpecial(self, nums):
        return all(nums[i]&1 != nums[i+1]&1 for i in range(len(nums)-1))",O(n)
"n = int(input())
a = list(map(int, input().split()))

if sum(a) < (2 * n) - 2:
    print(""NO"")
else:
    one = []
    rst = []
    for i in range(0, n):
        if a[i] > 1:
            rst.append(i)
        else:
            one.append(i)
    ans = []
    for i in range(1, len(rst)):
        ans.append((rst[i], rst[i - 1]))
        a[rst[i]] -= 1
        a[rst[i - 1]] -= 1
    for i in range(1, len(one)):
        for j in range(0, len(rst)):
            if a[rst[j]] > 0:
                a[rst[j]] -= 1
                ans.append((rst[j], one[i]))
                break
    if len(one):
        for i in range(len(rst) - 1, -1, -1):
            if a[rst[i]] > 0:
                ans.append((rst[i], one[0]))
                break
    siz = min(len(one) + len(rst), 2 + len(rst)) - 1
    print(""YES "", siz)

    print(len(ans))
    for u,v in ans:
        print(u + 1,v + 1)
",O(n ^ 2)
"n = int(input())
a = list(map(int, input().split()))
s = 0

for j, i in enumerate(a):
    if i > s:
        print(j + 1)
        exit()
    if i == s:
        s += 1

print(-1)
",O(n)
"class Solution(object):
    def lexicographicallySmallestArray(self, nums, limit):
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        groups = []
        for i in range(len(nums)):
            if i-1 < 0 or nums[idxs[i]]-nums[idxs[i-1]] > limit:
                groups.append([])
            groups[-1].append(idxs[i])
        result = [-1]*len(nums)
        for g in groups:
            for i, j in enumerate(sorted(g)):
                result[j] = nums[g[i]]
        return result",O(nlogn)
"n, k = map(int, input().split())
a = list(map(int, input().split()))
c = [-1]*256

ans = [0]*n
for i in range(n):
    if c[a[i]] == -1:
        for j in range(a[i], max(-1, a[i]-k), -1):
            if c[j] != -1:
                if (c[j] +k) > a[i]:
                    c[a[i]] = c[j]
                else:
                    c[a[i]] = j+1
                break
        if c[a[i]] == -1:
            c[a[i]] = max(0, a[i]-k+1)
        for xx in range(c[a[i]], a[i]):
            c[xx] = c[a[i]]
    ans[i] = str(c[a[i]])

print(' '.join(ans))
",O(n ^ 2)
"class Solution(object):
    def readBinaryWatch(self, num):
        def bit_count(bits):
            count = 0
            while bits:
                bits &= bits-1
                count += 1
            return count

        return ['%d:%02d' % (h, m) for h in range(12) for m in range(60)
                if bit_count(h) + bit_count(m) == num]

    def readBinaryWatch2(self, num):
        return ['{0}:{1}'.format(str(h), str(m).zfill(2))
                for h in range(12) for m in range(60)
                if (bin(h) + bin(m)).count('1') == num]",O(1)
"from itertools import chain
from time import time

def main():

    BITS = [1 << sh for sh in range(24)]
    B2N = {v: u for u, v in enumerate(BITS)}

    def getPt():
        return tuple(map(int, input().split()))

    def dist(ptA, ptB):
        return sum(((u-v)**2 for u, v in zip(ptA, ptB)))

    def getBits(val):
        return tuple(filter(lambda x: x&val, BITS))

    def chooseTwo(pool):
        n = len(pool)
        for i in range(n):
            for j in range(i+1, n):
                yield (pool[i], pool[j])

    ori = getPt()
    pts = []
    N = int(input())

    for _ in range(N):
        pts.append(getPt())

    vis = set([0])
    mint = [0]+[1e8]*(1<<N)
    pres = [None]*(1<<N)
    allb = (1 << N)-1
    B2P = {BITS[u]: v for u, v in enumerate(pts)}
    B2P[0] = ori
    alld = {u: {v: dist(B2P[u], B2P[v]) for v in B2P} for u in B2P}

    getDP = lambda x: mint[x]
    newDist = lambda stt, p: mint[stt] + alld[p[0]][p[1]] \
                                + alld[p[0]][0] \
                                + alld[p[1]][0]

    for stt in range(1<<N):
        if stt not in vis:
            continue

        bits = getBits(~stt&allb)

        sb = bits[0] if bits else None

        for bit in bits:

            newstt = stt | sb | bit
            nd = newDist(stt, (sb, bit))
            if getDP(newstt) > nd:
                mint[newstt] = nd
                pres[newstt] = sb | bit
                vis.add(newstt)

    print(mint[allb])
    path = ['0']
    stt = allb

    while stt:

        bits = getBits(pres[stt])
        for bit in bits:
            path.append(str(B2N[bit]+1))
        path.append('0')

        stt ^= pres[stt]

    print(' '.join(path))

if __name__ == '__main__':
    import sys
    st = time()
    main()
    print('Run {:.6f} seconds.'.format(time()-st), file=sys.stderr)",np
"n=int(input())
r=list(map(int,input().split()))
dp=[0]*(10**5+1)
cnt=[0]*(10**5+1)
tmp=[0]*(10**5+1)
mod=10**9+7
for i in range(n):
	cnt[r[i]]+=1
for i in range(1,10**5+1):
	for j in range(2*i,10**5+1,i):
		cnt[i]+=cnt[j]
	tmp[i]=pow(2,cnt[i],mod)-1
for i in range(10**5,0,-1):
	for j in range(2*i,10**5+1,i):
		tmp[i]=(tmp[i]-tmp[j])%mod
print(tmp[1]%mod)",np
"n = int(input())
limit_int = limit = decimal = 9
count = 0
while True:
    count += 1
    if n <= limit:
        difference = limit - n
        position = difference % count
        difference = difference // count
        difference = decimal - difference
        print(''.join(list(reversed(str(difference))))[position])
        break
    else:
        decimal = int(str(limit_int) * (count + 1))
        limit += int(str(limit_int) + '0' * count) * (count + 1)
",O(1)
"class Solution(object):
    def deleteAndEarn(self, nums):
        vals = [0] * 10001
        for num in nums:
            vals[num] += num
        val_i, val_i_1 = vals[0], 0
        for i in range(1, len(vals)):
            val_i_1, val_i_2 = val_i, val_i_1
            val_i = max(vals[i] + val_i_2, val_i_1)
        return val_i",O(n)
"from sys import stdin

sys_input = stdin.readline

def si(): return sys_input().rstrip()

def ii(): return int(si())

def sti(): return si().split()

def iti(): return map(int, sti())

def sli(): return list(si())

def ili(): return list(iti())

def main():
    B.sort(reverse=True)
    G.sort(reverse=True)

    if B[0] > G[-1]:
        print(-1)
        return

    boy_capacities = [M - 1] * N
    current_capable_boy_index = 0

    result = sum(B) * M

    for j, g in enumerate(G):
        yet = True
        while yet:
            if B[current_capable_boy_index] < g and boy_capacities[current_capable_boy_index] > 0:
                result += g - B[current_capable_boy_index]

                boy_capacities[current_capable_boy_index] -= 1
                yet = False
            elif B[current_capable_boy_index] == g:
                result += g - B[current_capable_boy_index]

                yet = False
            else:
                current_capable_boy_index += 1
                if current_capable_boy_index > N - 1:
                    print(-1)
                    return

    print(result)

    return

if __name__ == '__main__':
    N, M = iti()
    B = ili()
    G = ili()

    main()
",O(nlogn)
"class Solution(object):
    def minimumHealth(self, damage, armor):
        return sum(damage)-min(max(damage), armor)+1",O(n)
"n,a,b=map(int,input().split())
if a>n:
    print('NO')
    exit()
if b>n:
    print(""NO"")
    exit()
if a==1  and b==1:
    if n==2 or n==3:
        print('NO')
        exit()
if n==1 and a>1 or n==1 and b>1:
    print('NO')
    exit()
if min(a,b)>1:
    print('NO')
    exit()

def check(mat):
    vis=[0]*n
    cnt=0
    for i in range(n):
        if vis[i]==0:
            q=[i]
            cnt+=1
            vis[i]=1
            while q:
                t=q.pop(0)
                for j in range(n):
                    if mat[t][j]==1 and vis[j]==0:
                        vis[j]=1
                        q.append(j)
        return cnt
mat=[[0 for i in range(n)] for j in range(n)]
m=max(a,b)
j=1
for i in range(n):
    if j<n:
        mat[i][j]=1
        mat[j][i]=1
    j+=1
for i in range(m-1):
    curr=n-i-1
    for j in range(n):
        if mat[curr][j]==1:
            mat[curr][j]=0
            mat[j][curr]=0
if b==1:
    print('YES')
    for i in range(n):
        print(*mat[i],sep='')

else:
    print('YES')
    for i in range(n):
        for j in range(n):
            mat[i][j]=1-mat[i][j]
    for i in range(n):
        mat[i][i]=0
    for i in range(n):
        print(*mat[i],sep='')",O(n ^ 2)
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def isCompleteTree(self, root):
        end = False
        current = [root]
        while current:
            next_level = []
            for node in current:
                if not node:
                    end = True
                    continue
                if end:
                    return False
                next_level.append(node.left)
                next_level.append(node.right)
            current = next_level
        return  True


",O(n)
"a=input()
n=len(a)
b=[]
c=0
d=0
for i in range(1,n):
    if a[i]==a[i-1]:
        b.append(['bw'.find(a[c]),i-c])
        d=max(d,i-c)
        c=i
b.append(['bw'.find(a[c]),n-c])
d=max(d,n-c)
if d<n and b[0][0]==(b[-1][0]+b[-1][1])%2:
    d=max(d,b[-1][1]+b[0][1])
print(d)",O(n)
"n = int(input())
a = list(map(int, input().split()))
b = []
for i in range(n):
    a[i] %= 2
    if len(b) != 0:
        if b[-1] == a[i]:
            b.pop()
        else:
            b.append(a[i])
    else:
        b.append(a[i])
if len(b) > 1:
    print(""NO"")
else:
    print(""YES"")
",O(n)
"class Solution2(object):
    def sortedArrayToBST(self, nums):
        self.iterator = iter(nums)
        return self.helper(0, len(nums))
    
    def helper(self, start, end):
        if start == end:
            return None
        
        mid = (start + end) // 2
        left = self.helper(start, mid)
        current = TreeNode(next(self.iterator))
        current.left = left
        current.right = self.helper(mid+1, end)
        return current",O(n)
"class Solution2(object):
    def distinctSubarraysWithAtMostKOddIntegers(self, A, K):
        def countDistinct(A, left, right, trie): 
            result = 0
            for i in range(left, right+1):
                if A[i] not in trie:
                    result += 1
                trie = trie[A[i]]
            return result

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        result = 0
        for left in range(len(A)):
            count = 0
            for right in range(left, len(A)):
                count += A[right]%2
                if count > K:
                    right -= 1
                    break
            result += countDistinct(A, left, right, trie)
        return result",O(n ^ 2)
"from sys import stdout
a, b = 0, 0

mp = 29

c, d = 0,0

powers = [1]
for i in range(32):
    powers.append(powers[-1]*2)

qqq = 0

def get_ans(c, d):
    global qqq
    qqq += 1
    a, b = 1073741823, 1073741821
    a, b = 3, 1

    print(c, d)

    if (a^c) > (b^d):
        print(1)
        return -1
    elif (a^c) < (b^d):
        print(-1)
        return 1
    print(0)
    return 0

def get_ans(c, d):
    print('? {} {}'.format(c, d))
    stdout.flush()
    return -int(input())

q = get_ans(0, 0)

for i in range(mp+1):
    cp = mp - i
    c += powers[cp]
    d += powers[cp]

    if q == 0:
        continue
    t = get_ans(c, d)

    if t != q:

        if t == 1:
            a += powers[cp]
            c -= powers[cp]
        elif t == -1:
            b += powers[cp]
            d -= powers[cp]
        q = get_ans(c, d)

for i in range(mp+1):
    cp = mp - i

    if c & powers[cp] > 0 and d & powers[cp] > 0:
        c -= powers[cp]
        t = get_ans(c, d)

        if t < 0:
            a += powers[cp]
            b += powers[cp]

        c += powers[cp]

print('!', a, b)
",O(1)
"import sys

def is_winning_state(nims, n):
    keys = set(nims)
    counts = dict.fromkeys(keys, 0)
    for nim in nims:
        counts[nim] += 1
    if 0 in keys and counts[0] > 1:
        return True
    lose_count = 0
    for k in keys:
        if counts[k] > 2:
            return True
        if counts[k] > 1 and (k - 1) in keys and counts[k - 1] > 0:
            return True
        if counts[k] > 1:
            lose_count += 1
    if lose_count > 1:
        return True
    return False

def main():
    n = int(input())
    nims = list(map(int, input().split()))
    if is_winning_state(nims, n):
        print('cslnb')
    else:
        x = sum(nims) - (n * (n - 1)) // 2
        if x % 2 == 0:
            print('cslnb')
        else:
            print('sjfnb')

main()
",O(n)
"class Solution(object):
    def findFinalValue(self, nums, original):
        lookup = set(nums)
        while original in lookup:
            original *= 2
        return original",O(n)
"import sys
import os.path
from collections import *
import math
import bisect

if (os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")

n, m, k1 = [int(x) for x in input().split()]

arr = [0 for i in range(n)]
for i in range(n):
    arr[i] = [int(x) for x in input().split()]

brr = [0 for i in range(n - 1)]
for i in range(n - 1):
    brr[i] = [int(x) for x in input().split()]

dp = [[[0 for k in range(11)] for j in range(m)] for i in range(n)]

for k in range(1, 11):
    for i in range(n):
        for j in range(m):
                dp[i][j][k] = 10 ** 9
                if i > 0:
                    dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1] + brr[i - 1][j] * 2)
                if i < n - 1:
                    dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 1] + brr[i][j] * 2)
                if j > 0:
                    dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 1] + arr[i][j - 1] * 2)
                if j < m - 1:
                    dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 1] + arr[i][j] * 2)

for i in range(n):
    for j in range(m):
        if(k1 % 2):
            print(-1,end="" "")
        else:
            print(dp[i][j][k1 // 2],end="" "")
    print()
",O(n ^ 3)
"class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        q = deque([root])

        while q:
            rightSide = None
            qLen = len(q)

            for i in range(qLen):
                node = q.popleft()
                if node:
                    rightSide = node
                    q.append(node.left)
                    q.append(node.right)
            if rightSide:
                res.append(rightSide.val)
        return res
",O(n)
"a=[int(x) for x in input().split()]
n=a[0]^a[1]
x=bin(n)[2:]

f=0
for i in range(len(x)):
    if x[i]=='1':
        f=1
        break
l=len(x)-i
sum=0
for i in range(l):
   sum+=2**i
if f==0:
    sum=0
print(sum)",O(logn)
"import bisect



class Solution3(object):
    def maximumBeauty(self, flowers, newFlowers, target, full, partial):
        def check(prefix, total, x):
            return x and (total+prefix[x])//x <= prefix[x+1]-prefix[x]

        def binary_search(prefix, total, left, right):
            while left <= right:
                mid = left+(right-left)//2
                if check(prefix, total, mid):
                    right = mid-1
                else:
                    left = mid+1
            return left
    
        flowers.sort()
        n = bisect.bisect_left(flowers, target)
        prefix = [0]*(n+1)
        for i in range(n):
            prefix[i+1] = prefix[i]+flowers[i]
        suffix = sum(flowers[i] for i in range(n))
        result = left = 0
        for right in range(n+1):
            if right:
                suffix -= flowers[right-1]
            total = newFlowers-((n-right)*target-suffix)
            if total < 0:
                continue
            left = binary_search(prefix, total, 0, right-1)
            mn = min((total+prefix[left])//left if left else 0, target-1)
            result = max(result, mn*partial+(len(flowers)-right)*full)
        return result",O(nlogn)
"s=input()
ans=0
m=set()
for i in range(len(s)):
    for j in range(i,-1,-1):
        if(s[j:i+1] in m):
            ans=max(ans,i-j+1)
        else:
            m.add(s[j:i+1])
print(ans)
",O(n ^ 3)
"class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if t == """":
            return """"

        countT = {}
        for c in t:
            countT[c] = 1 + countT.get(c, 0)

        res, resLen = [-1, -1], float(""infinity"")
        for i in range(len(s)):
            countS = {}
            for j in range(i, len(s)):
                countS[s[j]] = 1 + countS.get(s[j], 0)

                flag = True
                for c in countT:
                    if countT[c] > countS.get(c, 0):
                        flag = False
                        break

                if flag and (j - i + 1) < resLen:
                    resLen = j - i + 1
                    res = [i, j]

        l, r = res
        return s[l : r + 1] if resLen != float(""infinity"") else """"
",O(n ^ 2)
"import math

def main():
    buf = input()
    n = int(buf)
    buf = input()
    buflist = buf.split()
    a = []
    for i, item in enumerate(buflist):
        a.append([i+1, int(item)])
    a = list(reversed(list(sorted(a, key = lambda x:x[1]))))
    one_deg_count = 0
    for i in a:
        if i[1] == 1:
            one_deg_count += 1
    if one_deg_count == len(a):
        if one_deg_count == 2:
            print(""YES"", 1)
            print(1)
            print(1, 2)
        else:
            print(""NO"")
        return
    elif one_deg_count == len(a) - 1:
        if one_deg_count <= a[0][1]:
            print(""YES"", 2)
            print(one_deg_count)
            for i in range(one_deg_count):
                print(a[0][0], a[-i-1][0])
        else:
            print(""NO"")
        return
    else:
        spare_edges = 2
        for i in range(len(a) - one_deg_count):
            spare_edges += a[i][1] - 2
        if spare_edges >= one_deg_count:
            diameter = len(a) - 1 - one_deg_count + min(one_deg_count, 2)
            edge_count = 0
            edge_list = []
            for i in range(len(a) - one_deg_count - 1):
                edge_list.append((a[i][0], a[i+1][0]))
            for i in range(len(a) - one_deg_count):
                a[i][1] -= 2
            if one_deg_count > 0:
                edge_list.append((a[0][0], a[-1][0]))
                one_deg_count -= 1
            if one_deg_count > 0:
                edge_list.append((a[-one_deg_count-2][0], a[-2][0]))
                one_deg_count -= 1
            idx = 0
            for i in range(one_deg_count):
                edge_list.append((a[idx][0], a[-i-3][0]))
                a[idx][1] -= 1
                if a[idx][1] <= 0:
                    idx += 1
            print(""YES"", diameter)
            print(len(edge_list))
            for i in edge_list:
                print(i[0], i[1])
        else:
            print(""NO"")

if __name__ == '__main__':
    main()
",O(nlogn)
"x0, y0 = map(int, input().split())
n = int(input())
arr = [[x0, y0]]
for i in range(0, n):
    x, y = map(int, input().split())
    arr.append([x, y])
dist = [[0 for j in range(0, n+1)] for i in range(0, n+1)]
for i in range(0, n+1):
    for j in range(0, n+1):
        dist[i][j] = (arr[i][0] - arr[j][0])**2 + (arr[i][1] - arr[j][1])**2

def dfs(status, memo, pp):

    if memo[status] != None:
        return memo[status]
    if status < 0:
        return 1e8
    res = 1e8
    prev = []
    for i in range(1, n+1):
        if (status & (1 << (i - 1))) == 0:
            continue
        t1 = status ^ (1 << (i - 1))

        temp = dfs(t1, memo, pp) + dist[0][i]*2
        if temp < res:
            res = temp
            prev = [i, 0]
        for j in range(i+1, n+1):
            if j == i:
                continue
            if (t1 & (1 << (j - 1))) == 0:
                continue
            next = t1 ^ (1 << (j - 1))
            temp = dfs(next, memo, pp) + dist[0][j] + dist[j][i] + dist[i][0]
            if temp < res:
                res = temp
                prev = [i, j, 0]
        break
    memo[status] = res
    pp[status] = prev

    return res

memo = [None for i in range(0, 1 << n)]
pp = [None for i in range(0, 1 << n)]
memo[0] = 0
pp[0] = []
start = 0
end = 0
for i in range(0, n):
    end += (1 << i)
res = dfs(end, memo, pp)
path = [0]
cur = end

while cur > 0:
    prev = pp[cur]

    path.extend(prev)
    for i in range(len(prev) - 1):
        cur -= (1 << (prev[i] - 1))

print(res)
print(' '.join(map(str, path)))
",np
"class Solution(object):
    def visibleMountains(self, peaks):
        peaks.sort(key=lambda x: (x[0]-x[1], -(x[0]+x[1]))) 
        result = mx = 0
        for i in range(len(peaks)):
            if peaks[i][0]+peaks[i][1] <= mx:
                continue
            mx = peaks[i][0]+peaks[i][1]
            if i+1 == len(peaks) or peaks[i+1] != peaks[i]:
                result += 1
        return result",O(nlogn)
"import math
n=int(input())
if(n==3):
    print('1 1 3')

else:
    t=1
    while(t<=n):
        ct=math.ceil((n//t)/2)
        for i in range(0,ct):
            print(t,end="" "")

        if(ct==2 and (n//t)%2!=0):
            t=t*3
        else:
            t=t*2
    print("" "")
",O(nlogn)
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)

graph, mod, szzz =  {}, 10**9 + 7, lambda: sorted(zzz())
def getStr(): return input()
def getInt(): return int(input())
def listStr(): return list(input())
def getStrs(): return input().split()
def isInt(s): return '0' <= s[0] <= '9'
def input(): return stdin.readline().strip()
def zzz(): return [int(i) for i in input().split()]
def output(answer, end='\n'): stdout.write(str(answer) + end)
def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def lcm(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]
daysInMounth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

n = getInt()

arr = listStr()

for i in range(n):
    arr[i]=int(arr[i])

okk=0
s=0
for i in range(n-1):
    s+=arr[i]
    cnt=0
    ok=1
    sss=0
    for j in range(i+1,n):
        cnt+=arr[j]
        if cnt==s:
            cnt=0
            sss+=1
        if cnt>s:
            ok=0

    if cnt==0 and sss :
        okk=1
        break
print(""YES"" if okk else ""NO"")",O(n ^ 2)
"import sys
input = sys.stdin.readline

def readPair():
  return tuple(map(int, input().split()))

(n, m) = readPair()
entries = [readPair() for _ in range(0, n)]
entries.sort(key=lambda x: x[1] - x[0])

size = sum(x[0] for x in entries)
count = 0

while (size > m and count < n):
  size -= entries[count][0] - entries[count][1]
  count += 1

print(-1 if size > m else count)",O(nlogn)
"class Solution(object):
    def minIncrements(self, n, cost):
        result = 0
        for i in reversed(range(n//2)):
            result += abs(cost[2*i+1]-cost[2*i+2])
            cost[i] += max(cost[2*i+1], cost[2*i+2])
        return result",O(n)
"class Solution(object):
    def findNumber(self):
        return reduce(lambda accu, x: accu|x, (1<<i for i in range(30) if commonSetBits(1<<i)))",O(logn)
"from math import *
n,m,k = map(int,input().split())
l = list(map(int,input().split()))
a = [0 for i in range(n+1)]
ans = 0
for M in range(m):
    min1 = 0
    for i in range(1,n+1):
        a[i] = a[i-1] + l[i-1]
        if(i % m == M):
            a[i] -= k
            ans = max(ans,a[i]-min1)
        min1 = min(min1,a[i])

print(ans)
",O(n ^ 2)
"class Solution2(object):
    def makePalindrome(self, s):
        cnt = 0
        left, right = 0, len(s)-1
        while left < right:
            if s[left] != s[right]:
                cnt += 1
                if cnt > 2:
                    return False
            left += 1
            right -= 1
        return True",O(n)
"class Solution2(object):
    def findNonMinOrMax(self, nums):
        mx, mn = max(nums), min(nums)
        return next((x for x in nums if x not in (mx, mn)), -1)",O(n)
"class Solution2(object):
    def distributeCandies(self, n, limit):
        return sum(min(limit, n-i)-max((n-i)-limit, 0)+1 for i in range(max(n-2*limit, 0), min(limit, n)+1))",O(n)
"n = int(input())
a = [0] * (n+1) ; b = [0] * (n+1) ; c = [0] * (n+1)
for i in range(2, n+1):
    a[i] = int(input())
    b[a[i]] += 1
for i in range(1, n+1):
    if b[i] == 0:
        c[a[i]] += 1
for i in range(1, n+1):
    if b[i] != 0 and c[i] < 3:
        print(""NO"")
        exit()
print(""YES"")",O(n)
"l,r=[int(i) for i in input().split()]
LXR=l^r
msbPos = 0
while(LXR):
	msbPos+=1
	LXR>>=1
maxXOR, two = 0, 1
while (msbPos):
	maxXOR += two
	two <<= 1
	msbPos -= 1
print(maxXOR)
",O(logn)
"n, k = map(int, input().split())
A = list(map(int, input().split()))
B = []
for i in range(n - 1):
    B.append([A[i + 1] - A[i], i])
B.sort(reverse=True)
C = []
for i in range(k - 1):
    C.append(B[i][1])
C.sort()
ans = 0
mi = 10 ** 9
ma = -10 ** 9
u = 0
for i in range(n):
    mi = min(mi, A[i])
    ma = max(ma, A[i])
    if u < len(C) and i == C[u]:
        ans += ma - mi
        mi = 10 ** 9
        ma = -10 ** 9
        u += 1
print(ans + ma - mi)",O(nlogn)
"class Solution2(object):
    def findBestValue(self, arr, target):
        arr.sort(reverse=True)
        max_arr = arr[0]
        while arr and arr[-1]*len(arr) <= target:
            target -= arr.pop()
        if not arr:
            return max_arr
        x = (target-1)//len(arr)
        return x if target-x*len(arr) <= (x+1)*len(arr)-target else x+1",O(nlogn)
"class Solution(object):
    def countBinarySubstrings(self, s):
        result, prev, curr = 0, 0, 1
        for i in range(1, len(s)):
            if s[i-1] != s[i]:
                result += min(prev, curr)
                prev, curr = curr, 1
            else:
                curr += 1
        result += min(prev, curr)
        return result",O(n)
"k = int(input())
prev=0
nextt=0
NumofDigits=0

while(True):
    prev = nextt
    nextt = nextt+(9*(10**(NumofDigits-1))*NumofDigits)
    if(k>= prev and k<=nextt):
        break
    NumofDigits=NumofDigits+1
if(NumofDigits==1):
    print(k)
else:
    result = (10**(NumofDigits-1))+int((k-(prev+1))/NumofDigits)
    i=0
    while(True):
        if (k-int(prev+1))%NumofDigits == i:
            break
        i=i+1
    result = str(result)
    print(result[i])",O(logn)
"R,G,B=[int(c) for c in input().split()]
ra=[int(c) for c in input().split()]
ga=[int(c) for c in input().split()]
ba=[int(c) for c in input().split()]

ra.sort(reverse=True)
ga.sort(reverse=True)
ba.sort(reverse=True)

dp = [[[-1 for i in range(201)]for j in range(201)]for k in range(201)]
def solve(dp,r,g,b):
    if dp[r][g][b] !=-1:
        return dp[r][g][b]
    count= 0
    for i,j in zip((r,g,b),(R,G,B)):
        if i == j:
            count+=1
    if count >= 2:
        return 0

    res = -999
    if r != R and b!=B:

        res = max(res,ra[r]*ba[b] + solve(dp,r+1,g,b+1))

    if r!=R and g != G:
        res = max(res,ra[r]*ga[g] + solve(dp,r+1,g+1,b))

    if b!=B and g != G:
        res = max(res,ba[b]*ga[g] + solve(dp,r,g+1,b+1))

    dp[r][g][b] = res

    return res

print(solve(dp,0,0,0))",O(n ^ 3)
"import sys
input = sys.stdin.readlines()
n = int(input[0].strip())
m = 10**9 + 7
curr = [0] * (n+20)
last = [0] * (n+20)
curr[0] = 1
for s in range(1,n):
    last, curr = curr, last
    if input[s]=='f\n':
        curr[0] = 0
        for i in range(len(last)-1):
            curr[i+1] = last[i]
    elif input[s]=='s\n':
        curr[-1] = 0
        for i in range(len(last)-2, -1, -1):
            curr[i] = (curr[i+1] + last[i]) % m
s = 0
for x in curr:
    s = (s + x) % m
print(s)",O(n ^ 2)
"import os
from io import BytesIO, IOBase
import sys
from collections import defaultdict, deque, Counter
from math import sqrt, pi, ceil, log, inf, gcd, floor
from itertools import combinations, permutations
from bisect import *
from fractions import Fraction
from heapq import *
from random import randint

def main():
    n, s = map(int, input().split())
    lo, hi = s, n
    ans = n + 1
    while lo <= hi:
        mid = (lo + hi) // 2
        z = sum(map(int, str(mid)))
        if mid >= s + z:
            ans = mid
            hi = mid - 1
        else:
            lo = mid + 1
    print(n - ans + 1)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(logn)
"class Solution(object):
    def maxCoins(self, lane1, lane2):
        result = dp1 = dp12 = dp121 = float(""-inf"")
        for i in range(len(lane1)):
            dp1 = max(dp1, 0)+lane1[i]
            dp12 = max(max(dp12, 0)+lane2[i], dp1)
            dp121 = max(max(dp121, 0)+lane1[i], dp12)
            result = max(result, dp1, dp121)
        return result",O(n)
"from bisect import bisect_left as bl
from bisect import bisect_right as br
import heapq
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
input = sys.stdin.readline

def factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))

def li():return [int(i) for i in input().rstrip('\n').split(' ')]
def st():return input().rstrip('\n')
def val():return int(input().rstrip('\n'))
def li2():return [i for i in input().rstrip('\n').split(' ')]
def li3():return [int(i) for i in input().rstrip('\n')]

n,L = li()
l = []
for i in range(n):
    l.append(li())

index = defaultdict(list)
for ind,i in enumerate(l):
    index[tuple(i)].append(ind + 1)

l.sort(key = lambda x:x[1])
d = defaultdict(list)

ans = i = tot = currpoints = 0
anspattern = []
he = []

while i < n:

    if l[i][1] + tot <= L:
        tot += l[i][1]
        heapq.heappush(d[l[i][0]],l[i][1])
        currpoints += 1

        if len(d[l[i][0]]) == 1:
            heapq.heappush(he,l[i][0])

    while len(he) and currpoints > he[0]:
        temp = heapq.heappop(he)
        tot -= heapq.heappop(d[temp])
        currpoints -= 1
        if len(d[temp]):heapq.heappush(he,temp)

    if currpoints > ans:
        ans = currpoints

    i += 1
i = tot = currpoints = 0
he = []
d = defaultdict(list)

while i < n:

    if l[i][1] + tot <= L:
        tot += l[i][1]
        heapq.heappush(d[l[i][0]],l[i][1])
        currpoints += 1

        if len(d[l[i][0]]) == 1:
            heapq.heappush(he,l[i][0])

    while len(he) and currpoints > he[0]:
        temp = heapq.heappop(he)
        tot -= heapq.heappop(d[temp])
        currpoints -= 1
        if len(d[temp]):heapq.heappush(he,temp)

    if currpoints == ans:
        anspattern = []
        for i in he:
            for j in d[i]:
                anspattern.append(index[tuple([i,j])][-1])
                index[tuple([i,j])].pop()
        print(ans)
        print(len(anspattern))
        print(*sorted(anspattern))
        exit()
    i += 1",O(nlogn)
"class Solution(object):
    def maxTurbulenceSize(self, A):
        result = 1
        start = 0
        for i in range(1, len(A)):
            if i == len(A)-1 or \
               cmp(A[i-1], A[i]) * cmp(A[i], A[i+1]) != -1:
                result = max(result, i-start+1)
                start = i
        return result",O(n)
"n,m=map(int,input().split())
a=0
while m:a+=n//m;n,m=m,n%m
print(a)",O(1)
"for _ in range(int(input())):
    s = input()
    ro=co=0
    for c in s:
        if '0'<= c <= '9': ro = 10*ro+int(c)
        elif ro:
            ro, co = s[1:].split('C'); co=int(co)
            v = ''
            while co:
                co-=1
                r = co%26
                co = co//26
                v += chr(65+r)
            print(v[::-1]+ro)
            break
        else: co = co*26 + ord(c) - 64
    else:
        print(""R{}C{}"".format(ro, co))
",O(n)
"import math

l, r = (map(int, input().split()))
a = l
if a % 2:
    a += 1

if a + 2 > r:
    print(-1)
else:
    print(a, a + 1, a + 2)",O(1)
"import sys

n = int(input())
prob = [list(map(float, input().split())) for _ in range(n)]
dp = [[0.0]*n for _ in range(1 << n)]
dp[1][0] = 1.0

for mask in range(3, 1 << n):
    for i in range(n):
        if not (mask & (1 << i)):
            continue
        for j in range(n):
            if i != j and mask & (1 << j):
                dp[mask][i] = max(
                    dp[mask][i],
                    dp[mask - (1 << j)][i] * prob[i][j]
                    + dp[mask - (1 << i)][j] * prob[j][i]
                )

print(max(dp[-1]))
",np
"class UnionFind(object): 
    def __init__(self, nums):
        self.set = list(range(len(nums)))
        self.rank = [0]*len(nums)
        self.size = nums[:]

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        self.size[y] += self.size[x]
        return True

    def total(self, x):
        return self.size[self.find_set(x)]



class Solution(object):
    def maximumSegmentSum(self, nums, removeQueries):
        result = [0]*len(removeQueries)
        lookup = [0]*len(nums)
        uf = UnionFind(nums)
        for i in reversed(range(1, len(removeQueries))): 
            q = removeQueries[i]
            lookup[q] = 1
            if q-1 >= 0 and lookup[q-1]:
                uf.union_set(q-1, q)
            if q+1 < len(nums) and lookup[q+1]:
                uf.union_set(q, q+1)
            result[i-1] = max(result[i], uf.total(q))   
        return result",O(n)
"class Solution(object):
    def partitionLabels(self, S):
        lookup = {c: i for i, c in enumerate(S)}
        first, last = 0, 0
        result = []
        for i, c in enumerate(S):
            last = max(last, lookup[c])
            if i == last:
                result.append(i-first+1)
                first = i+1
        return result",O(n)
"class Solution(object):
    def maxCollectedFruits(self, fruits):
        n = len(fruits)
        for i in range(n):
            for j in range(i+1, n-(i+1)):
                fruits[i][j] = 0
        for i in range(1, n-1):
            for j in range(i+1, n):
                fruits[i][j] += max(fruits[i-1][j-1], fruits[i-1][j], fruits[i-1][j+1] if j+1 < n else 0)
        for j in range(n):
            for i in range(j+1, n-(j+1)):
                fruits[i][j] = 0
        for j in range(1, n-1):
            for i in range(j+1, n):
                fruits[i][j] += max(fruits[i-1][j-1], fruits[i][j-1], fruits[i+1][j-1] if i+1 < n else 0)
        return sum(fruits[i][i] for i in range(n))+fruits[-2][-1]+fruits[-1][-2]",O(n ^ 2)
"from collections import defaultdict as di

n = int(input())
a = list(map(int, input().split()))
d = di(int)
res, sum = 0, 0
for i in range(n):
	res += a[i] * i - sum - d[a[i]-1] + d[a[i]+1]
	sum += a[i]
	d[a[i]] += 1
print(res)",O(nlogn)
"class Solution(object):
    def findGameWinner(self, n):
        return n%6 != 1",O(1)
"n,k = map(int, input().split())
d = (n-k)//2+1
ans = ['1' if (i+1)%d==0 else '0' for i in range(n)]
print(''.join(ans))
",O(n)
"from itertools import accumulate
n,m,k = map(int,input().split())
a = list(map(int,input().split()))
als = []
for i in range(m):
  ls = a[:]
  for j in range(n):
    if j%m == i:
      ls[j] -= k
  als.append(list(accumulate(ls)))
ans = 0
for i in range(m):
  ls = als[i]
  mn = 0
  anstmp = 0
  for j in range(n):
    if mn > ls[j]:
      mn = ls[j]
    if j%m == i:
      anstmp = max(anstmp,ls[j]-mn)
  ans = max(ans,anstmp)
print(ans)",O(n ^ 2)
"def replace(arr):
    if arr==[1]*len(arr):
        arr[-1]=2
        print(*sorted(arr))
        return """"
    arr[arr.index(max(arr))]=1
    print(*sorted(arr))
    return """"
a=input()
lst=list(map(int,input().strip().split()))
print(replace(lst))",O(nlogn)
"def next(A,n, x):
    l = 0
    r = n-1
    p = -1
    while l <= r:
        m = (l+r)//2

        if A[m] <= x:
            l = m+1
        else:
            p = m
            r = m-1
    return p

N, Q = map(int, input().split())

A = list(map(int, input().split()))
B = list(map(int, input().split()))

P = []
P.append(A[0])

for i in range(1, N):
    P.append(P[i-1] + A[i])

soldiers = P[-1]
arrows = 0

for q in range(Q):

    arrows += B[q]
    if arrows >= soldiers:
        arrows = 0
        print(N)
    else:
        ind = next(P, N, arrows)
        print(N- ind)
",O(nlogn)
"import sys
import math

fileoperation=0
if(fileoperation):
    orig_stdout = sys.stdout
    orig_stdin = sys.stdin
    inputfile = open('W:/Competitive Programming/input.txt', 'r')
    outputfile = open('W:/Competitive Programming/output.txt', 'w')
    sys.stdin = inputfile
    sys.stdout = outputfile

mod=1000000007

def nospace(l):
    ans=''.join(str(i) for i in l)
    return ans

t=1
for tt in range(t):
    n=int(input())

    a=list(map(int,sys.stdin.readline().split(' ')))
    a.sort()

    i=0
    ans=0
    while i<len(a):
        if a[i]:
            ans+=1
            j=i+1
            while j<n:
                if(a[j]%a[i]==0):
                    a[j]=0
                j+=1
        i+=1
    print(ans)

if(fileoperation):
    sys.stdout = orig_stdout
    sys.stdin = orig_stdin
    inputfile.close()
    outputfile.close()",O(n ^ 2)
"import sys
def fi():
	return sys.stdin.readline()
if __name__ == '__main__':
	n,k = map(int, fi().split())

	l = list(map(int, fi().split()))
	d = dict()
	c = set()
	l.sort()
	for i in range (n):
		if not d.get(l[i]):
			c.add(l[i])
			d.setdefault(l[i]*k,1)
	print(len(c))",O(nlogn)
"import math

a, b = [int(x) for x in input().split()]
while a != 0 and b != 0:
    x = int(math.log(a, 2))
    y = int(math.log(b, 2))
    if x != y:
        break
    a = a & (~(1 << x))
    b = b & (~(1 << y))

if a == 0 and b == 0:
    print(0)
else:
    if b > a:
        a, b = b, a
    x = int(math.log(a, 2)) + 1
    b = (1 << x) - 1
    a = a | b
    print(a)
",O(logn)
"class Solution:
    def longestPalindrome(self, s: str) -> str:
        resIdx, resLen = 0, 0
        n = len(s)

        dp = [[False] * n for _ in range(n)]

        for i in range(n - 1, -1, -1):
            for j in range(i, n):
                if s[i] == s[j] and (j - i <= 2 or dp[i + 1][j - 1]):
                    dp[i][j] = True
                    if resLen < (j - i + 1):
                        resIdx = i
                        resLen = j - i + 1

        return s[resIdx : resIdx + resLen]
",O(n ^ 2)
"class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        charSet = set()
        l = 0
        res = 0

        for r in range(len(s)):
            while s[r] in charSet:
                charSet.remove(s[l])
                l += 1
            charSet.add(s[r])
            res = max(res, r - l + 1)
        return res
",O(n)
"n = int(input())
x,y = map(int,input().split())
if max(x-1,y-1) > max(n-x,n-y):
    print(""Black"")
else:
    print(""White"")
",O(1)
"line = input().split()
n, k = int(line[0]), int(line[1])
line = input()
if n == k:
    print(line)

else:
    ans = []
    arr = []
    for i in line:
        arr.append(i)

    for i in range(n):
        if len(ans) == k//2:
            break
        if arr[i] == '(':
            ans.append(i)
    for i in range(n-1, -1, -1):
        if len(ans) == k:
            break
        if arr[i] == ')':
            ans.append(i)
    ans.sort()
    for i in ans:
        print(arr[i], end="""")",O(n)
"import collections


class Solution(object):
    def maxResult(self, nums, k):
        score = 0
        dq = collections.deque()
        for i, num in enumerate(nums):
            if dq and dq[0][0] == i-k-1:
                dq.popleft()
            score = num if not dq else dq[0][1]+num
            while dq and dq[-1][1] <= score:
                dq.pop()
            dq.append((i, score))
        return score",O(n)
"lis = []
for _ in range(int(input())):
    lis.append(input())
lis = sorted(lis, key=len)

for i in range(len(lis) - 1):
    if(lis[i] not in lis[i + 1]):
        print(""NO"")
        exit(0)

print(""YES"")
for i in lis:
    print(i)
",O(nlogn)
"x, y, z, t1, t2, t3 = map(int, input().split())

tp = abs(x - y) * t1
pt = (abs(x - y) + abs(x - z)) * t2 + t3 + t3 + t3
if tp >= pt:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"n, m = map(int, input().split())
a = list(map(int, input().split()))
t = list(map(int, input().split()))
ans = [0] * m
p = []
for i in range(n + m):
    if t[i] == 1:
        p.append(i)
ans[0] = p[0]
for i in range(m):
    if i == m - 1:
        ans[i] += n + m - p[i] - 1
    else:
        for j in range(p[i] + 1, p[i + 1]):
            if a[j] - a[p[i]] <= a[p[i + 1]] - a[j]:
                ans[i] += 1
            else:
                ans[i + 1] += 1
print(' '.join(map(str, ans)))
",O(n ^ 2)
"import sys

R, G, B = list(map(int, input().split()))
r = sorted([int(x) for x in input().split()], reverse = True)
g = sorted([int(x) for x in input().split()], reverse = True)
b = sorted([int(x) for x in input().split()], reverse = True)

ans = 0

dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]

for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
            if  j<G and k<B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])
            if i<R and k<B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + b[k]*r[i])
            ans = max(ans, dp[i][j][k])
print(ans)",O(n ^ 3)
"class Solution2(object):
    def minimumScore(self, nums, edges):
        def is_ancestor(a, b):
            return left[a] <= left[b] and right[b] <= right[a]

        def dfs(u, p):
            left[u] = cnt[0]
            cnt[0] += 1
            for v in adj[u]:
                if v == p:
                    continue
                dfs(v, u)
                nums[u] ^= nums[v]
            right[u] = cnt[0]
                
        adj = [[] for _ in range(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        cnt = [0]
        left = [0]*len(nums)
        right = [0]*len(nums)
        dfs(0, -1)
        result = float(""inf"")
        for i in range(1, len(nums)):
            for j in range(i+1, len(nums)):
                if is_ancestor(i, j):
                    a, b, c = nums[0]^nums[i], nums[i]^nums[j], nums[j]
                elif is_ancestor(j, i):
                    a, b, c = nums[0]^nums[j], nums[j]^nums[i], nums[i]
                else:
                    a, b, c = nums[0]^nums[i]^nums[j], nums[i], nums[j]
                result = min(result, max(a, b, c)-min(a, b, c))
        return result",O(n ^ 2)
"k = int(input()) - 1

l = 1
c = 9
while k >= c*l:
    k -= c * l
    l += 1
    c *= 10

c = 10**(l-1) + k // l
print(str(c)[k % l])
",O(logn)
"from sys import stdin, gettrace

if gettrace():
    def inputi():
        return input()
else:
    def input():
        return next(stdin)[:-1]

    def inputi():
        return stdin.buffer.readline()

def bitcount(m):
    return bin(m).count('1')

def main():
    n,x,y = map(int, input().split())
    if x > y:
        x,y = y, x
    assert x <= y
    mm1 = range(1, 1 << y, 2)
    vbases = [((~(m1 >> (y - x)) & ~m1 & ((1 << x) - 1)) << y) | m1 for m1 in mm1 if m1 & m1 >> x == 0]
    def btail(m):
        return bitcount(m & ((1 << n % (x + y)) - 1))
    res = max(bitcount(m)*(n//(x+y)) + btail(m) for m in vbases)
    print(res)

if __name__ == ""__main__"":
    main()
",np
"class Solution(object):
    def countElements(self, arr):
        arr.sort()
        result, l = 0, 1
        for i in range(len(arr)-1):
            if arr[i] == arr[i+1]:
                l += 1
                continue
            if arr[i]+1 == arr[i+1]:
                result += l
            l = 1
        return result",O(nlogn)
"x, k = map(int, input().split())
MOD = 1000000007
pw = pow(2, k + 1, MOD)
n = pow(2, k, MOD)
a = (pw * x) - n
a = (a + 1) % MOD
if x == 0:
    a = 0
print(int(a))
",O(logn)
"class Solution(object):
    def jump(self, A):
        jump_count = 0
        reachable = 0
        curr_reachable = 0
        for i, length in enumerate(A):
            if i > reachable:
                return -1
            if i > curr_reachable:
                curr_reachable = reachable
                jump_count += 1
            reachable = max(reachable, i + length)
        return jump_count",O(n)
"n=int(input())+1
if n==1:
    print(0)
elif n%2:
    print(n)
else:
    print(n//2)",O(1)
"n = int(input())
p = [(-(10**6), 0)] + sorted([tuple(map(int, input().split())) for i in range(n)])
dp = [0] * (n + 1)
for i in range(1, n + 1):
    l, r = 0, i
    while r - l > 1:
        mid = (l + r) >> 1
        if p[i][0] - p[i][1] <= p[mid][0]: r = mid
        else: l = mid
    dp[i] = i - r + dp[r - 1]
ans = min(dp[i] + (n - i) for i in range(1, n + 1))
print(ans)",O(n)
"class Solution(object):
    def validateBinaryTreeNodes(self, n, leftChild, rightChild):
        roots = set(range(n)) - set(leftChild) - set(rightChild)
        if len(roots) != 1:
            return False
        root, = roots
        stk = [root]
        lookup = set([root])
        while stk:
            node = stk.pop()
            for c in (leftChild[node], rightChild[node]):
                if c < 0:
                    continue
                if c in lookup:
                    return False
                lookup.add(c)
                stk.append(c)
        return len(lookup) == n",O(n)
"class Solution:
    def countBits(self, n: int) -> List[int]:
        res = [0] * (n + 1)
        for i in range(1, n + 1):
            num = i
            while num != 0:
                res[i] += 1
                num &= (num - 1)
        return res
",O(n)
"n = int(input())
graph = [set() for tr in range(n+2)]
i = 1
while i < n:
	x, y = map(int, input().split())
	graph[x].add(y)
	graph[y].add(x)
	i += 1
a = iter(map(int, input().split()))
try:
	assert next(a) == 1
	q = [1]
	for v in q:
		gv = graph[v]
		gv1 = tuple(gv)
		for tr2 in gv1:
			u = next(a)
			assert u in gv
			gv.remove(u)
			graph[u].remove(v)
			q.append(u)
	print(""Yes"")
except AssertionError:
	print(""No"")
",O(n)
"

class Solution(object):
    def removeStars(self, s):
        result = []
        for c in s:
            if c == '*':
                result.pop()
            else:
                result.append(c)
        return """".join(result)
",O(n)
"l, r = list(map(int, input().strip().split()))

if l == r:
    print(0)
    exit()

l, r = bin(l)[2:].zfill(64), bin(r)[2:].zfill(64)
i = 0
while i < len(r):
    if l[i] == r[i]:
        i += 1
    else:
        break
rslt = len(r[:i])*'0' + len(r[i:])*'1'
print(int(rslt, 2))
",O(logn)
"n,m = map(int, input().split())
tL0 = list(map(int, input().split()))
tL = [0] * n
score = 0

for i in range(m):
    tL[tL0[i] - 1] += 1
    if(0 not in tL):
        score += 1
        for i in range(n):
            tL[i] = tL[i] - 1

print(score)",O(n ^ 2)
"from collections import defaultdict as dd
import math
import sys
import heapq
import copy
input=sys.stdin.readline
def nn():
	return int(input())

def li():
	return list(input())

def mi():
	return map(int, input().split())

def lm():
	return list(map(int, input().split()))

def solve():

	r,g,b = mi()

	rs = lm()
	gs = lm()
	bs = lm()
	rs.sort()
	gs.sort()
	bs.sort()

	ans = [[[0 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]

	for i in range(1,r+1):
		for j in range(1,g+1):
			ans[i][j][0]= ans[i-1][j-1][0]+rs[i-1]*gs[j-1]

	for i in range(r+1):
		for j in range(g+1):
			for k in range(1,b+1):
				new_len = bs[k-1]
				if i==0:
					i_len = 0
				else:
					i_len = ans[i-1][j][k-1] + rs[i-1]*new_len
				if j==0:
					j_len = 0
				else:
					j_len = ans[i][j-1][k-1] + gs[j-1]*new_len
				if i>0 and j>0:
					i_j_len = ans[i-1][j-1][k]+rs[i-1]*gs[j-1]
				else:
					i_j_len = 0
				ans[i][j][k] = max(i_len,
									j_len,
									ans[i][j][k-1],
									i_j_len)

	print(ans[r][g][b])

solve()
",O(n ^ 3)
"n, l, r, x = map(int, input().split())
arr = list(map(int, input().split()))
res = 0
for j in range(1, 2**n):
    a = [arr[i] for i in range(n) if (((j >> i) & 1) == 1)]
    s = sum(a)
    res += (max(a) - min(a) >= x and s >= l and s <= r)
print(res)
",np
"def main():
    n = int(input())
    a = list(map(int, input().split(' ')))
    array = []
    array.append(a)

    for i in range(n - 1):
        aux = []
        for j in range(1, len(array[-1])):
            xor = array[-1][j-1] ^ array[-1][j]
            aux.append(xor)
        array.append(aux)

    for j in range(1, len(array)):
        for k in range(len(array[j])):
            maximo = max(array[j][k], array[j-1][k], array[j - 1][k + 1])
            array[j][k] = maximo

    q = int(input())
    for i in range(q):
        l, r = map(int, input().split(' '))
        print(str(array[r - l][l - 1]))

main()
",O(n ^ 2)
"class Solution(object):
    def minMaxGame(self, nums):
        n = len(nums)
        while n != 1:
            new_q = []
            for i in range(n//2):
                nums[i] = min(nums[2*i], nums[2*i+1]) if i%2 == 0 else max(nums[2*i], nums[2*i+1])
            n //= 2
        return nums[0]",O(n)
"n,m=map(int,raw_input().split())

l=[]
for i in range(n):
	s=raw_input()
	l.append([])
	for j in range(m):
		l[-1].append(s[j])

ans=[]
for i in range(n):

	ans.append([])
	for j in range(m):
		ans[-1].append(""."")

for i in range(n-2):
	for j in range(m-2):
		if l[i][j]==""
			if l[i][j]==l[i][j+1] and l[i][j]==l[i][j+2] and l[i][j]==l[i+1][j] and l[i][j]==l[i+1][j+2] and l[i][j]==l[i+2][j] and l[i][j]==l[i+2][j+1] and l[i][j]==l[i+2][j+2]:
				ans[i][j]=""
				ans[i][j+1]=""
				ans[i][j+2]=""
				ans[i+1][j]=""
				ans[i+1][j+2]=""
				ans[i+2][j]=""
				ans[i+2][j+1]=""
				ans[i+2][j+2]=""

flag = True
for i in range(n):
	for j in range(m):
		if l[i][j]!=ans[i][j]:
			flag = False
			break
	if flag==False:
		break

if flag==True:
	print(""YES"")
else:
	print(""NO"")
",O(n ^ 2)
"class Solution(object):
    def numberOfMatches(self, n):
        return n-1",O(1)
"q=int(input())

for e in range(q):
    x,y,k=map(int,input().split())
    x,y=abs(x),abs(y)
    x,y=max(x,y),min(x,y)

    if(x%2!=k%2):
        k-=1
        y-=1

    if(x>k):
        print(-1)
        continue
    if((x-y)%2):
        k-=1
        x-=1
    print(k)
",O(1)
"class Solution(object):
    def similarRGB(self, color):
        def rounding(color):
            q, r = divmod(int(color, 16), 17)
            if r > 8: q += 1
            return '{:02x}'.format(17*q)

        return 
                rounding(color[1:3]) + \
                rounding(color[3:5]) + \
                rounding(color[5:7])",O(1)
"def check(x, y):
    return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y])

n = int(input())
a = [list(input()) for i in range(n)]
b = [list(input()) for i in range(n)]
for i in range(4):
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = b[::-1]
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = [s[::-1] for s in b]
    c = [['' for t in range(n)] for u in range(n)]
    for t in range(n):
        for u in range(n):
            c[t][u] = b[u][n - t - 1]
    b = c[:]
    if check(a, b):
        print('Yes')
        exit(0)
print('No')
",O(n ^ 2)
"M = 0x3b800001
wa = 0;
n = int(input())
a = list(map(int, input().split()))
now = 1
wa += a[-1]
for i in range(n - 1)[::-1]:
    wa += (now * (n - i - 1) + now * 2) * a[i]
    wa %= M
    now *= 2
    now %= M
print(wa % M)
",O(n)
"def read_int(): return int(input())
def read_ints(): return list(map(int, input().split()))

n = read_int()
a = read_ints()
dp = [[0] * n for _ in range(n)]
f = [[0] * n for _ in range(n)]
for i in range(n - 1, -1, -1):
	f[i][i] = dp[i][i] = a[i]
	for j in range(i + 1, n):
		f[i][j] = f[i][j - 1] ^ f[i + 1][j]
		dp[i][j] = max(f[i][j], dp[i][j - 1], dp[i + 1][j])
q = read_int()
for _ in range(q):
	l, r = read_ints()
	print(dp[l - 1][r - 1])
",O(n ^ 2)
"import math
def f(n,k):
    if k==1:
        return (n*(n+1))//2
    a=math.floor(math.log(n,k))
    b=sum(k**i for i in range(a+1))
    c=sum((i+1)*k**i for i in range(a+1))
    if n<b:
        return c-(b-n)*(a+1)
    else:
        return c+(n-b)*(a+2)
n,s=map(int,input().split())
if s==(n*(n+1))//2:
    print(""Yes"")
    a=[str(i+1) for i in range(n-1)]
    print("" "".join(a))
elif s>(n*(n+1))//2:
    print(""No"")
elif s<2*n-1:
    print(""No"")
else:
    mini=1
    maxi=n-1
    curr=1
    while True:
        a,b=f(n,curr),f(n,curr+1)
        if b>s:
            mini=curr+1
            curr=math.ceil((curr+maxi)/2)
        elif a<=s:
            maxi=curr-1
            curr=(curr+mini)//2
        else:
            opt=curr+1
            break
    depths=[0,1]+[0]*(n-1)
    ins=1
    ind=2
    while True:
        a=min(opt**(ind-1),n-ins)
        depths[ind]=a
        ind+=1
        ins+=a
        if ins==n:
            break
    left=s-b
    far=ind-1
    bulk=ind-1
    if depths[bulk]==1:
        bulk-=1
    while left>0:
        if far+1-bulk<=left:
            far+=1
            left-=far-bulk
            depths[far]+=1
            depths[bulk]-=1
            if depths[bulk]==1:
                bulk-=1
        else:
            depths[bulk]-=1
            depths[bulk+left]+=1
            left=0
    verts=[None]*far
    sumi=0
    for i in range(far):
        verts[i]=list(range(sumi+1,sumi+1+depths[i+1]))
        sumi+=depths[i+1]
    out=""""
    for i in range(1,far):
        for j in range(len(verts[i])):
            out+=str(verts[i-1][j//opt])+"" ""
    print(""Yes"")
    print(out)",O(n)
"yellow,blue = map(int,input().split())
x,y,z = map(int,input().split())
ry = x*2+y
rb =z*3+y
r1,r2 = 0,0
if ry-yellow < 0:
    r1 = 0
else:
    r1 = ry-yellow
if rb - blue < 0:
    r2 = 0
else:
    r2 = rb-blue
print(r1+r2)
",O(1)
"class Solution(object):
    def maxAlternatingSum(self, nums):
        result = nums[0]
        for i in range(len(nums)-1):
            result += max(nums[i+1]-nums[i], 0)
        return result",O(n)
"import os,sys
from io import BytesIO,IOBase

def main():
    n,k = map(int,input().split())
    card = list(map(int,input().split()))
    fav = list(map(int,input().split()))
    joy = [0]+list(map(int,input().split()))
    dp = [[0]*(n*k+1) for _ in range(n+1)]
    for i in range(len(joy)):
        dp[1][i] = joy[i]
    for i in range(len(joy),n*k+1):
        dp[1][i] = joy[-1]
    for i in range(2,n+1):
        for j in range(1,n*k+1):
            for kk in range(min(k+1,j+1)):
                dp[i][j] = max(dp[i][j],dp[i-1][j-kk]+dp[1][kk])
    tot = [0]*(10**5+1)
    for i in card:
        tot[i] += 1
    tot1 = [0]*(10**5+1)
    for i in fav:
        tot1[i] += 1
    ans = 0
    for i in range(10**5+1):
        ans += dp[tot1[i]][tot[i]]
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(n ^ 3)
"import sys
input = sys.stdin.readline
n, m = map(int, input().split())

MOD = m
MAX_N = 10**3

fac = [1] + [0] * MAX_N
for i in range(1, MAX_N+1):
    fac[i] = fac[i-1] * (i) % MOD

fac_inv = [1] + [0] * MAX_N

fac_inv[MAX_N] = pow(fac[MAX_N], MOD-2, MOD)
for i in range(MAX_N, 1, -1):
    fac_inv[i-1] = fac_inv[i] * i % MOD

def mod_nCr(n, r):
    if n < r or n < 0 or r < 0:
        return 0
    tmp = fac_inv[n-r] * fac_inv[r] % MOD
    return tmp * fac[n] % MOD

pow2 = [0] * (n+1)
pow2[0] = 1
for i in range(1, n+1):
    pow2[i] = pow2[i-1] * 2 % MOD

table = [[0] * 500 for _ in range(500)]
for i in range(500):
    for j in range(i+1):
        table[i][j] = mod_nCr(i, j)

dp = [[0] * (n+1) for _ in range(n)]
for i in range(n):
    dp[i][i+1] = pow2[i]
for i in range(n-1):
    for j in range(i // 2 + 1, n-1):
        if dp[i][j] == 0:
            continue
        dp[i][j] %= MOD
        for k in range(1, n-j):
            if i + k + 1 >= n:
                break

            dp[i+k+1][j+k] += dp[i][j] * pow2[k-1] * table[k + j][k]

ans = sum(dp[-1]) % MOD
print(ans)",O(n ^ 3)
"a = list(input())
b = list(input())
n = len(a)
a.sort()

def listtostring(li:list):
    return ''.join(li)

for i in range(0,n):
    for j in range(0,n):
        t = a.copy()
        t[i],t[j] = t[j],t[i]
        if((int(listtostring(t)) >= int(listtostring(a))) and (int(listtostring(t))<= int(listtostring(b)))):

            a[i],a[j] = a[j],a[i]

print(listtostring(a))",O(n ^ 3)
"from collections import deque

class Solution(object):

    def __init__(self, size):
        self.__size = size
        self.__sum = 0
        self.__q = deque()

    def next(self, val):
        if len(self.__q) == self.__size:
            self.__sum -= self.__q.popleft()
        self.__sum += val
        self.__q.append(val)
        return 1.0 * self.__sum / len(self.__q)",O(1)
"class Solution(object):
    def smallestRangeI(self, A, K):
        return max(0, max(A) - min(A) - 2*K)",O(n)
"n = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]
k = n[2]
ans = 0
dele = 1
i = 0
while(i<n[1]):
	count = 1
	while(((i+count)<n[1]) and (a[(i+count)]-dele)//k == (a[i]-dele)//k):
		count += 1

	ans += 1
	dele += count
	i += count
print(ans)",O(n)
"class Solution(object):
    def totalMoney(self, n):
        def arithmetic_sequence_sum(a, d, n):
            return (2*a + (n-1)*d) * n //2

        cost, day = 1, 7
        first_week_cost = arithmetic_sequence_sum(cost, cost, day)
        week, remain_day = divmod(n, day)
        return arithmetic_sequence_sum(first_week_cost, cost*day, week) + \
               arithmetic_sequence_sum(cost*(week+1), cost, remain_day)",O(1)
"class Solution(object):
    def smallestString(self, s):
        result = list(s)
        i = next((i for i in range(len(s)) if s[i] != 'a'), len(s))
        if i == len(s):
            result[-1] = 'z'
        else:
            for i in range(i, len(s)):
                if result[i] == 'a':
                    break
                result[i] = chr(ord(result[i])-1)
        return """".join(result)",O(n)
"import bisect

b = []
a = []
b.append(0)

for i in range(1, 15):
	b.append(9 * i * (10 ** (i - 1)))

a.append(b[0])
for i in range(1, 15):
	a.append(a[i - 1] + b[i])

k = int(input())

th = bisect.bisect_left(a, k)
th -= 1;
k = k - a[th];
start = 10 ** th;
now = th + 1;
rem = k % now;
iss = k / now;
end = start + (k / now);
temp = str(end - 1);
s = """";
s += temp[now - 1] + str(end) + str(end + 1);

print(s[0 + rem])
",O(logn)
"n = int(input())
print((n*3)//2)",O(1)
"import collections


class Solution2(object):
    def findAllPeople(self, n, meetings, firstPerson):
        meetings.sort(key=lambda x: x[2])
        result = {0, firstPerson}
        adj = collections.defaultdict(list)
        for i, (x, y, _) in enumerate(meetings):
            adj[x].append(y)
            adj[y].append(x)
            if i+1 != len(meetings) and meetings[i+1][2] == meetings[i][2]:
                continue
            stk = [i for i in adj.keys() if i in result]
            while stk:
                u = stk.pop()
                for v in adj[u]:
                    if v in result:
                        continue
                    result.add(v)
                    stk.append(v)
            adj = collections.defaultdict(list)
        return list(result)",O(nlogn)
"a1, a2, b1, b2, c1, c2 = map(int, input().split())
l = max([a1, a2, b1, b2, c1, c2])

if (a1*a2 + b1*b2 + c1*c2 != l**2):
    print(-1)
else:
    if a1 > a2:
        a1, a2 = a2, a1
    if b1 > b2:
        b1, b2 = b2, b1
    if c1 > c2:
        c1, c2 = c2, c1

    if a2 == b2 and b2 == c2:
        print(l)
        for i in range(a1):
            print('A'*a2)
        for i in range(b1):
            print('B'*b2)
        for i in range(c1):
            print('C'*c2)
    else:
        ls = [[a1, a2, 'A'], [b1, b2, 'B'], [c1, c2, 'C']]

        if b2 == l:
            ls[0], ls[1] = ls[1], ls[0]
        if c2 == l:
            ls[0], ls[2] = ls[2], ls[0]

        valid = True
        if ls[1][0] == ls[2][0]:
            pass
        elif ls[1][1] == ls[2][1]:
            ls[1][0], ls[1][1] = ls[1][1], ls[1][0]
            ls[2][0], ls[2][1] = ls[2][1], ls[2][0]
        elif ls[1][0] == ls[2][1]:
            ls[2][0], ls[2][1] = ls[2][1], ls[2][0]
        elif ls[1][1] == ls[2][0]:
            ls[1][0], ls[1][1] = ls[1][1], ls[1][0]
        else:
            valid = False

        if (ls[1][0] + ls[0][0] != l) or (ls[1][1] + ls[2][1] != l):
            valid = False

        if not valid:
            print(-1)
        else:
            print(l)

            for i in range(ls[0][0]):
                print(ls[0][2] * l)
            for i in range(ls[1][0]):
                print(ls[1][2] * ls[1][1] + ls[2][2] * ls[2][1])
",np
"n = int(input())
print([""YES"", ""NO""][all(n % i for i in [4, 7, 47, 744, 477])])",O(1)
"def comp(a,b):
    x=len(a)
    s1=''
    s2=''
    for i in range(x):
        s1+=str(a[i])
        s2+=str(b[i])
    if s1>s2:
        return 1
    else:
        return 0

a=list(input(''))
b=list(input(''))
cnt=[0]*10
n=len(a)
m=len(b)
sol=''
for i in range(n):
    a[i]=int(a[i])
    cnt[a[i]]+=1

if n!=m:
    a.sort(reverse=True)
    for i in a:
        sol+=str(i)
    print(sol)
else:
    a.sort()

    for i in range(n):
        b[i]=int(b[i])
    for i in range(n-1):
        for j in range(i,n):
            if a[i]<a[j]:
                temp=a[i]
                a[i]=a[j]
                a[j]=temp
                if comp(a,b):
                    temp=a[i]
                    a[i]=a[j]
                    a[j]=temp

    for i in a:
        sol+=str(i)
    print(sol)",O(n ^ 3)
"a,b,c,n=map(int, input().split())
p=n-(a+b-c)
if c>a or c>b or p<=0:
    print(-1)
    exit()
if p<1:
    print(-1)
else:
    print(p)",O(1)
"import sys
input=lambda: sys.stdin.readline().rstrip()
import copy
n=int(input())
A=[int(i) for i in input().split()]
inf=float(""inf"")
DP=[[inf]*(n+1) for _ in range(n+1)]

for j in range(1,n+1):
  for i in range(n):
    if i+j>n:
      continue
    else:
      if j==1:
        DP[i][i+1]=A[i]
      else:
        for k in range(i+1,i+j):
          if DP[i][k]<10000 and DP[k][i+j]<10000:
            if DP[i][k]==DP[k][i+j]:
              DP[i][i+j]=DP[i][k]+1
            else:
              DP[i][i+j]=20000
          else:
            if DP[i][k]<10000:
              DP[i][i+j]=min(DP[i][i+j],10000+DP[k][i+j])
            elif DP[k][i+j]<10000:
              DP[i][i+j]=min(DP[i][i+j],DP[i][k]+10000)
            else:
              DP[i][i+j]=min(DP[i][i+j],DP[i][k]+DP[k][i+j])
print(DP[0][n]//10000 if DP[0][n]>=10000 else 1)",O(n ^ 3)
"class Solution2(object):
    def isPowerOfTwo(self, n):
        return n > 0 and (n & ~-n) == 0",O(1)
"a = int(input())

print(a**2+(a-1)**2)
",O(1)
"from sys import stdin, stdout
import math,sys,heapq
from itertools import permutations, combinations
from collections import defaultdict,deque,OrderedDict
from os import path
import random
import bisect as bi
def yes():print('YES')
def no():print('NO')
if (path.exists('input.txt')):

    sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');
    def I():return (int(input()))
    def In():return(map(int,input().split()))
else:

    def I():return (int(stdin.readline()))
    def In():return(map(int,stdin.readline().split()))

def dict(a):
    d={}
    for x in a:
        if d.get(x,-1)!=-1:
            d[x]+=1
        else:
            d[x]=1
    return d
def find_gt(a, x):
    'Find leftmost value greater than x'
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:
        return -1

def cal(r,g,b,dp,R,G,B,nr,ng,nb):
    if dp[r][g][b]!=-1:
        return dp[r][g][b]
    best=0
    if r<nr and g<ng:
        best=max(best,cal(r+1,g+1,b,dp,R,G,B,nr,ng,nb)+R[r]*G[g])
    if r<nr and b<nb:
        best=max(best,cal(r+1,g,b+1,dp,R,G,B,nr,ng,nb)+R[r]*B[b])
    if g<ng and b<nb:
        best=max(best,cal(r,g+1,b+1,dp,R,G,B,nr,ng,nb)+B[b]*G[g])
    dp[r][g][b]=best
    return dp[r][g][b]
def main():
    try:
        nr,ng,nb=In()
        dp=[[[-1 for x in range(201)]for y in range(201)] for z in range(201)]
        R=list(In())
        G=list(In())
        B=list(In())
        R.sort(reverse=True)
        G.sort(reverse=True)
        B.sort(reverse=True)
        print(cal(0,0,0,dp,R,G,B,nr,ng,nb))
    except:
        pass

M = 998244353
P = 1000000007

if __name__ == '__main__':

    for _ in range(1):main()",O(n ^ 3)
"from bisect import *
from collections import *
from math import gcd,ceil,sqrt,floor,inf
from heapq import *
from itertools import *
from operator import add,mul,sub,xor,truediv,floordiv
from functools import *

import os
import sys

from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())

from types import GeneratorType

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

mod=10**9+7
farr=[1]
ifa=[]

def fact(x,mod=0):
    if mod:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr)%mod)
    else:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr))
    return farr[x]

def ifact(x,mod):
    global ifa
    fact(x,mod)
    ifa.append(pow(farr[-1],mod-2,mod))
    for i in range(x,0,-1):
        ifa.append(ifa[-1]*i%mod)
    ifa.reverse()

def per(i,j,mod=0):
    if i<j: return 0
    if not mod:
        return fact(i)//fact(i-j)
    return farr[i]*ifa[i-j]%mod

def com(i,j,mod=0):
    if i<j: return 0
    if not mod:
        return per(i,j)//fact(j)
    return per(i,j,mod)*ifa[j]%mod

def catalan(n):
    return com(2*n,n)//(n+1)

def isprime(n):
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return False
    return True

def floorsum(a,b,c,n):
    if a==0:return b//c*(n+1)
    if a>=c or b>=c: return floorsum(a%c,b%c,c,n)+b//c*(n+1)+a//c*n*(n+1)//2
    m=(a*n+b)//c
    return n*m-floorsum(c,c-b-1,a,m-1)

def inverse(a,m):
    a%=m
    if a<=1: return a
    return ((1-inverse(m,a)*m)//a)%m

def lowbit(n):
    return n&-n

class BIT:
    def __init__(self,arr):
        self.arr=arr
        self.n=len(arr)-1

    def update(self,x,v):
        while x<=self.n:
            self.arr[x]+=v
            x+=x&-x

    def query(self,x):
        ans=0
        while x:
            ans+=self.arr[x]
            x&=x-1
        return ans

class DSU:
    def __init__(self,n):
        self.c=[-1]*n

    def same(self,x,y):
        return self.find(x)==self.find(y)

    def find(self,x):
        if self.c[x]<0:
            return x
        self.c[x]=self.find(self.c[x])
        return self.c[x]

    def union(self,u,v):
        u,v=self.find(u),self.find(v)
        if u==v:
            return False
        if self.c[u]>self.c[v]:
            u,v=v,u
        self.c[u]+=self.c[v]
        self.c[v]=u
        return True

    def size(self,x): return -self.c[self.find(x)]

class UFS:
    def __init__(self,n):
        self.parent=[i for i in range(n)]
        self.ranks=[0]*n

    def find(self,x):
        if x!=self.parent[x]:
            self.parent[x]=self.find(self.parent[x])
        return self.parent[x]

    def union(self,u,v):
        pu,pv=self.find(u),self.find(v)
        if pu==pv:
            return False
        if self.ranks[pu]>=self.ranks[pv]:
            self.parent[pv]=pu
            if self.ranks[pv]==self.ranks[pu]:
                self.ranks[pu]+=1
        else:
            self.parent[pu]=pv

def Prime(n):
    c=0
    prime=[]
    flag=[0]*(n+1)

    for i in range(2,n+1):
        if not flag[i]:
            prime.append(i)
            c+=1
        for j in range(c):
            if i*prime[j]>n: break
            flag[i*prime[j]]=prime[j]
            if i%prime[j]==0: break
    return prime

def dij(s,graph):
    d={}
    d[s]=0
    heap=[(0,s)]
    seen=set()
    while heap:
        dis,u=heappop(heap)
        if u in seen:
            continue
        seen.add(u)
        for v,w in graph[u]:
            if v not in d or d[v]>d[u]+w:
                d[v]=d[u]+w
                heappush(heap,(d[v],v))
    return d

def GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]
def lcm(a,b): return a*b//gcd(a,b)
def lis(nums):
    res=[]
    for k in nums:
        i=bisect.bisect_left(res,k)
        if i==len(res):
            res.append(k)
        else:
            res[i]=k
    return len(res)

class DLN:
    def __init__(self,val):
        self.val=val
        self.pre=None
        self.next=None

def nb(i,j):
    for ni,nj in [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]:
        if 0<=ni<n and 0<=nj<m:
            yield ni,nj

def topo(n):
    q=deque()
    res=[]
    for i in range(n):
        if ind[i]==0:
            q.append(i)
            res.append(i+1)
    while q:
        u=q.popleft()
        for v in g[u]:
            ind[v]-=1
            if ind[v]==0:
                q.append(v)
                res.append(v+1)
    return res

@bootstrap
def gdfs(r,p):
    if len(g[r])==1 and p!=-1:
        yield None
    for ch in g[r]:
        if ch!=p:
            yield gdfs(ch,r)
    yield None

def match(pat,cur):
    for i in range(k):
        if pat[i]!='_' and pat[i]!=cur[i]:

            return False
    return True

def pos(cur):
    res=list(cur)

    pa=[]
    dfs(0,pa,res)
    return pa

def dfs(i,pa,res):

    global k
    if i==k:

        pa.append(''.join(res))
        return
    dfs(i+1,pa,res)

    tmp=res[i]
    res[i]='_'
    dfs(i+1,pa,res)
    res[i]=tmp

t=1
for i in range(t):
    n,m,k=RLL()
    p=[]
    d={}
    for i in range(n):
        cur=input()
        p.append(cur)
        d[cur]=i
    res=[]
    ans=True
    ind=[0]*n

    g=[[] for i in range(n)]
    for i in range(m):
        cur,x=input().split()
        x=int(x)
        if ans:

            if not match(p[x-1],cur):
                ans=False
            else:

                for al in pos(cur):
                    if al in d and d[al]!=x-1:
                        g[x-1].append(d[al])
                        ind[d[al]]+=1
    if not ans:
        print(""NO"")
    else:

        ans=topo(n)
        if len(ans)!=n:
            print(""NO"")
        else:
            print(""YES"")
            print(*ans)
",np
"n=int(input())
print(n**2+(n-1)**2)",O(1)
"n=int(input())
b=[]
for i in range(n):
    b.append(list(map(float,input().split())))

ma=1<<n
dp=[0 for j in range(ma)]
dp[0]=1
for mask in range(1,ma):
    l=n-bin(mask).count(""1"")+1
    res=l*(l-1)//2
    for i in range(n):
        if mask&(1<<i):
            for j in range(n):
                if not mask&(1<<j):

                    dp[mask]+=((dp[mask^(1<<i)]*b[j][i])/res)

ans=[]
for i in range(n):
    ans.append(dp[ma-1-(1<<i)])
print(*ans)
",np
"n = int(input())

dt = input()
s = dt.split()
a = [int(x) for x in s]
sortm = [int(x) for x in s]

sortm.sort()

cnt = 0

for i in range(n):
	if a[i] != sortm[i]:
		cnt += 1

if cnt <= 2:
	print(""YES"")
else:
	print(""NO"")
",O(nlogn)
"n, k = map(int, input().split(' '))
s = input()
m = 10 ** 10
for i in range(k):
    c = chr(ord('A') + i)
    m = min(m, s.count(c))
print(m * k)",O(n)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, = getIntList()

re = 0
for i in range(2,N):

    t = N // i -1
    re += t * i

print(re *4)
",O(n)
"import sys
import math
import collections
import bisect
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n=int(input())
    starting=[]
    ending=[]
    points=[]
    for i in range(n):
        x,y=get_ints()
        starting.append(x)
        ending.append(y)
    ans=0
    start_count=collections.Counter(starting)
    end_count=collections.Counter(ending)
    s=starting.copy()
    s.sort()
    e=ending.copy()
    e.sort()
    maxim=max(starting)
    minim=min(ending)

    for i in range(n):
        if starting[i]==maxim:
            if start_count[maxim]>1:
                loc_max=maxim
            else:
                pos=bisect.bisect_left(s,maxim)
                loc_max=s[pos-1]
        else:
            loc_max=maxim
        if ending[i]==minim:
            if end_count[minim]>1:
                loc_min=minim
            else:
                pos=bisect.bisect_right(e,minim)
                loc_min=e[pos]
        else:
            loc_min=minim
        ans=max(ans,loc_min-loc_max)

    print(ans)",O(n)
"import sys

rd = lambda : sys.stdin.readline().rstrip()

t = int(rd())
for _ in range(t):
    n = int(rd())
    a = list(map(int, rd().split()))
    b = []
    res_a, res_b = 1, 1e18

    a = sorted(a)
    i = 0
    while i < n-1:
        if a[i] == a[i+1]:
            b.append(a[i])
            i += 1

        i += 1

    p2s = lambda x, y : (x+y)**2/(x*y)

    for i in range(len(b)-1):
        if p2s(res_a, res_b) > p2s(b[i], b[i+1]):
            res_a, res_b = b[i], b[i+1]

    print(res_a, res_a, res_b, res_b)
",O(nlogn)
"import math

t = int(input())

def eval_(n, k):
    level = 0.5*math.log2(3*k+1)
    if n > 30:
        cond = (level - n) > 0
    else:
        cond = (3*k+1) > 4**n
    if cond:
        return ""NO""
    elif n == 2 and k == 3:
        return ""NO""
    else:
        level = math.floor(level)

        if n > 5:

            temp = 1 + 0.5*math.log2(3*(k-1) + 1)
            if n > temp:
                return ""YES "" + str(n - 1)
            else:
                return ""YES  0""
        else:
            delta = 2**(n-level)*(2**level-1)*(4**(n-level)-1)//3
            start = (4**(level)-1)//3
            if k <=(start+delta):
                return ""YES "" + str(n - level)
            else:
                return ""YES "" + str(n - level-1)

for i in range(t):
    (n, k) = [int(i) for i in input().split()]
    print(eval_(n, k))",O(logn)
"q = int(input())

for i in range(q):
    (x, y, k) = map(int, input().split())

    if max(x, y) > k:
        print(-1)
    elif x == y and k == x + 1:
        print(k - 2)
        continue
    elif x % 2 == 1 and y % 2 == 1 and k % 2 == 0:
        print(k - 2)
        continue
    elif x % 2 == 0 and y % 2 == 0 and k % 2 == 1:
        print(k - 2)
        continue
    elif (x + y) % 2 == 0:
        print(k)
    else:
        print(k - 1)
",O(1)
"import sys
k=int(input())
if type(k)!=int or k<=0 or k>pow(10,12) :
        print(""wrong input. try again"")
        sys.exit()
lim_init=lim=decimal=9
c=0
while True:
        c+=1
        if k<=lim:
                diff=lim-k
                pos=diff%c
                diff=int(diff/c)
                diff=decimal-diff
                print(''.join(list(reversed(str(diff))))[pos])
                break
        else:
                decimal = int(str(lim_init)*(c+1))
                lim+=int(str(lim_init)+'0'*c)*(c+1)
",O(logn)
"n = int(input())

from collections import defaultdict

first = defaultdict(int)
second = defaultdict(int)
for _ in range(n):
    s = input().strip()
    count = 0
    min_count = 0
    for c in s:
        if c == '(': count += 1
        else: count -= 1
        min_count = min(count, min_count)
    if min_count >= 0: first[count] += 1
    if count == min_count: second[count] += 1

res = 0
for k, v in first.items():
    res += v * second[-k]

print(res)
",O(n)
"n = int(input())
a = list(map(int, input().split()))
a.sort()
ans = 0
u = [0] * (n+1)
for i in range(n):
    if u[i] == 0:
        ans+=1
    for j in range(i, n):
        if a[j] % a[i] == 0:
            u[j] = 1
print(ans)",O(n ^ 2)
"from operator import xor
from functools import reduce


class Solution(object):
    def xorGame(self, nums):
        return reduce(xor, nums) == 0 or \
            len(nums) % 2 == 0",O(n)
"class Solution(object):
    def bitwiseComplement(self, N):
        mask = 1
        while N > mask:
            mask = mask*2+1
        return mask-N",O(logn)
"import sys
N, M = map(int, input().split())

Ans = [(0, 0) for  _ in range(N*M)]
for i in range(1, N*M+1):
    if i % 2:
        a, b = divmod(i//2, M)
    else:
        a, b = divmod(N*M - i//2, M)
    Ans[i-1] = ' '.join((str(a+1), str(b+1)))

for a in Ans:
    sys.stdout.write(f'{a}\n')
",O(n ^ 2)
"MOD = 10**9+7

class Solution(object):

    def __init__(self):
        self.__arr = []
        self.__ops = [[1, 0]]

    def append(self, val):
        self.__arr.append(val)
        self.__ops.append(self.__ops[-1][:])

    def addAll(self, inc):
        self.__ops[-1][1] = (self.__ops[-1][1]+inc) % MOD

    def multAll(self, m):
        self.__ops[-1] = [(self.__ops[-1][0]*m) % MOD, (self.__ops[-1][1]*m) % MOD]

    def getIndex(self, idx):
        if idx >= len(self.__arr):
            return -1
        a1, b1 = self.__ops[idx]
        a2, b2 = self.__ops[-1]
        a = a2*pow(a1, MOD-2, MOD)%MOD 
        b = (b2 - b1*a) % MOD
        return (self.__arr[idx]*a + b) % MOD",O(1)
"class Solution2(object):
    def maximumSetSize(self, nums1, nums2):
        lookup1, lookup2 = set(nums1), set(nums2)
        n, c = len(nums1), len(lookup1&lookup2)
        d1, d2 = min(len(lookup1)-c, n//2), min(len(lookup2)-c, n//2)
        r1, r2 = n//2-d1, n//2-d2
        return d1+d2+min(r1+r2, c)",O(n)
"class Solution3(object):
    def maxProfit(self, prices):
        min_price, max_profit_from_left, max_profits_from_left = \
            float(""inf""), 0, []
        for price in prices:
            min_price = min(min_price, price)
            max_profit_from_left = max(max_profit_from_left, price - min_price)
            max_profits_from_left.append(max_profit_from_left)

        max_price, max_profit_from_right, max_profits_from_right = 0, 0, []
        for i in reversed(list(range(len(prices)))):
            max_price = max(max_price, prices[i])
            max_profit_from_right = max(max_profit_from_right,
                                        max_price - prices[i])
            max_profits_from_right.insert(0, max_profit_from_right)

        max_profit = 0
        for i in range(len(prices)):
            max_profit = max(max_profit,
                             max_profits_from_left[i] +
                             max_profits_from_right[i])

        return max_profit",O(n)
"from math import log2
n = int(input())
if n == 1:
    print(1)
    exit()
elif n == 3:
    print(1, 1, 3)
    exit()
l = [1] * (n // 2)
if n % 2 == 1:
    l.append(1)

xn = int(log2(n))
tmp = n - len(l)
for i in range(2, xn+1):
    fn = tmp // 2
    if tmp % 2 == 1:
        fn += 1
    tmp -= fn
    l += ([pow(2, i-1)] * fn)
l.append((n // pow(2, xn - 1)) * pow(2, xn - 1))
print(' '.join(str(i) for i in l))",O(n)
"class Solution(object):
    def minimumAverageDifference(self, nums):
        total = sum(nums)
        mn, idx = float(""inf""), -1
        prefix = 0
        for i, x in enumerate(nums):
            prefix += x
            a = prefix//(i+1)
            b = (total-prefix)//(len(nums)-(i+1)) if i+1 < len(nums) else 0
            diff = abs(a-b)
            if diff < mn:
                mn, idx = diff, i
        return idx",O(n)
"n, m = map(int, input().split())
b = list(map(int, input().split()))
g = list(map(int, input().split()))

if max(b) > min(g):
    print(-1)
else:
    total = m*sum(b)
    b.sort()
    g.sort()
    while len(g) > 0:
        current = 0
        count = 1
        if len(b) > 0:
            current = b.pop()
        while len(g) > 0 and g[-1] > current and count < m:
            total += g[-1] - current
            g.pop()
            count += 1
        while len(g) > 0 and g[-1] == current:
            g.pop()
    print(total)
",O(nlogn)
"i = int(input())
s = input().split()

l = []
for j in s:
    if not l or  int(j)%2 != l[-1]:
        l.append(int(j)%2)
    else:
        l.pop()

if len(l) < 2:
    print('YES')
else:
    print('NO')
",O(n)
"input()
p = list(map(int, input().split()))
x = max(p)
if p[p.index(x)] == 1:
    p[p.index(x)] = 2
else:
    p[p.index(x)] = 1
p.sort()
print(' '.join(str(i) for i in p))",O(nlogn)
"class Solution3(object):
    def isDecomposable(self, s):
        found, l = False, 0
        for i, c in enumerate(s):
            if not l or c != s[i-1]:
                if l:
                    return False
                l = 1
                continue
            l += 1
            if l == 2:
                if i == len(s)-1 or s[i] != s[i+1]:
                    if found:
                        return False
                    found, l = True, 0
            elif l == 3:
                 l =  0
        return found",O(n)
"class Solution2(object):
    def balanceBST(self, root):
        def inorderTraversalHelper(node, arr):
            if not node:
                return
            inorderTraversalHelper(node.left, arr)
            arr.append(node.val)
            inorderTraversalHelper(node.right, arr)
        
        def sortedArrayToBstHelper(arr, i, j):
            if i >= j:
                return None
            mid = i + (j-i)//2
            node = TreeNode(arr[mid])
            node.left = sortedArrayToBstHelper(arr, i, mid)
            node.right = sortedArrayToBstHelper(arr, mid+1, j)
            return node
        
        arr = []
        inorderTraversalHelper(root, arr)
        return sortedArrayToBstHelper(arr, 0, len(arr))",O(n)
"k = int(input())
prev=0
next=0
NumofDigits=0

while(True):
    prev = next
    next = next+(9*(10**(NumofDigits-1))*NumofDigits)
    if(k>= prev and k<=next):
        break
    NumofDigits=NumofDigits+1
if(NumofDigits==1):
    print(k)
else:
    result = (10**(NumofDigits-1))+int((k-(prev+1))/NumofDigits)
    i=0
    while(True):
        if (k-int(prev+1))%NumofDigits == i:
            break
        i=i+1
    result = str(result)
    print(result[i])",O(logn)
"class Solution(object):
    def printLinkedListInReverse(self, head):
        def print_nodes(head, count):
            nodes = []
            while head and len(nodes) != count:
                nodes.append(head)
                head = head.getNext()
            for node in reversed(nodes):
                node.printValue()
                   
        count = 0
        curr = head
        while curr:
            curr = curr.getNext()
            count += 1
        bucket_count = int(math.ceil(count**0.5))
        
        buckets = []
        count = 0
        curr = head
        while curr:
            if count % bucket_count == 0:
                buckets.append(curr)
            curr = curr.getNext()
            count += 1
        for node in reversed(buckets):
            print_nodes(node, bucket_count)",O(n)
"N = int(input())
X = list(map(int, input().split()))
from collections import defaultdict
dp = defaultdict(lambda :-1)
M=1000
for i in range(N):
    dp[i+M] = X[i]
for i in range(2, N+1):
    for j in range(N-i+1):
        for k in range(1, i):
            u, v = dp[j+M*k], dp[j+k+M*(i-k)]
            if u == -1 or v == -1 or u != v:
                continue
            dp[j+M*i] = u+1;break

dp2 = [0]*(N+1)
for i in range(N):
    dp2[i+1] = dp2[i]+1
    for j in range(i+1):
        if dp[j+(i+1-j)*M] == -1:
            continue
        dp2[i+1] = min(dp2[i+1], dp2[j]+1)
print(dp2[-1])
",O(n ^ 3)
"list1=input()
l=list1.split()
l=[int(item) for item in l]

n,m,k=l

a=input()
a1=map(int,a.split())

a1=list(sorted(a1))

count=0
for i in range(len(a1)):
    if k>=m:
        break
    else:
        k+=a1.pop()-1
        count+=1

if k>=m:
    print(count)
else:
    print(""-1"")",O(nlogn)
"class Solution(object):
    def maxScore(self, nums):
        nums.sort(reverse=True)
        curr = 0
        for i, x in enumerate(nums):
            curr += x
            if curr <= 0:
                return i
        return len(nums)",O(nlogn)
"import sys

sys.setrecursionlimit(10**5)
int1 = lambda x: int(x)-1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def MI(): return map(int, sys.stdin.buffer.readline().split())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
inf = 10**16
md = 10**9+7

trie = [{}]

def push(s, val):
    now = 0
    for c in s:
        if c not in trie[now]:
            trie[now][c] = len(trie)
            trie.append({})
        now = trie[now][c]
    trie[now][""end""] = val

def match(s):
    res = []
    stack = [(0, 0)]
    while stack:
        u, i = stack.pop()
        if i == k:
            res.append(trie[u][""end""])
            continue
        if s[i] in trie[u]:
            stack.append((trie[u][s[i]], i+1))
        if ""_"" in trie[u]:
            stack.append((trie[u][""_""], i+1))
    return res

n, m, k = MI()
for i in range(n):
    push(SI(), i)

to = [[] for _ in range(n)]
for _ in range(m):
    s, u = SI().split()
    u = int(u)-1
    vv = match(s)

    notmatch = True
    for v in vv:
        if u == v: notmatch = False
        else: to[u].append(v)
    if notmatch:
        print(""NO"")
        exit()

vis=[-1]*n
topo=[]
for u in range(n):
    if vis[u]==1:continue
    stack=[u]
    while stack:
        u=stack.pop()
        if vis[u]==-1:
            vis[u]=0
            stack.append(u)
            for v in to[u]:
                if vis[v]==0:
                    print(""NO"")
                    exit()
                if vis[v]==-1:
                    stack.append(v)
        elif vis[u]==0:
            topo.append(u+1)
            vis[u]=1

print(""YES"")
print(*topo[::-1])
",np
"import heapq
from heapq import heappush as push_
from heapq import heappop  as pop_

class heapT():
    def __init__(self, T):
        self.Q     = []
        self.curT  = 0
        self.maxT  = T
        self.his   = []

    def push(self, t, index):
        push_(self.Q, (-t, index))
        self.his.append(index)
        self.curT += t

        while self.curT > self.maxT:
            self.pop()

    def pop(self):
        t, ind     = pop_(self.Q)
        self.his.append(ind)
        self.curT -= t * -1

    def normalize(self, length):
        while len(self.Q) > length:
            self.pop()

def solve(a, n, T):
    a    =  sorted(a, key=lambda x:x[0], reverse=True)
    H    =  heapT(T)

    max_ = -1
    pos  = None

    for ak, t, ind in a:
        H.push(t, ind)
        H.normalize(ak)

        if len(H.Q) >  max_:
            max_ = len(H.Q)
            pos  = len(H.his)

    d = {}
    if pos is not None:
        for x in H.his[:pos]:
            if x not in d:
                d[x] = 1
            else:
                del d[x]

    if len(d) > 0:
        print(len(d))
        print(len(d))
        print(' '.join([str(x+1) for x in d]))
    else:
        print('0'+'\n'+'0')

n, T =  map(int, input().split())
a    =  [list(map(int, input().split())) + [_] for _ in range(n)]
solve(a, n, T)
",O(nlogn)
"def gen(n):
    if n == 1:
        yield '0'
        yield '1'
    else:
        for s in gen(n - 1):
            yield s+'0'
            yield s +'1'

n, l, r, x = map(int, input().split())
cnt = 0
C = list(map(int, input().split()))
for pos in gen(n):
    A = []
    for i in range(n):
        if pos[i] == '1':
            A.append(C[i])
    A.sort()
    if len(A):
        if l <= sum(A) <= r and A[-1] - A[0] >= x:
            cnt += 1
print(cnt)
",np
"n = int(input())

a = map(int, input().split())
mp = {}
s = 0
ans = 0
i = 0
for x in a:
    i += 1
    s += x

    if x not in mp:
        mp[x] = 0

    if x+1 not in mp:
        mp[x+1] = 0

    if x-1 not in mp:
        mp[x-1] = 0
    mp[x] += 1

    adj = mp[x] + mp[x+1] + mp[x-1];
    c = s;
    c -= mp[x]*x;
    c -= mp[x+1] * (x+1);
    c -= mp[x-1] * (x-1);

    valid = i-adj

    ans += (valid*x)-c

print(ans)",O(nlogn)
"def dig(d):
    return ord(d) - ord('0')

def biggest_left(counts):
    res = ''
    for i in range(9, -1, -1):
        res += str(i) * counts[i]
    return res

def ok(d, _counts, rest):
    if rest == '':
        return True

    counts = _counts.copy()
    counts[d] -= 1

    r = ''
    for i in range(10):
        r += str(i) * counts[i]

    return int(r) <= int(rest)

def main():
    a, b = input(), input()

    counts = [0] * 10
    for d in a:
        counts[dig(d)] += 1

    ans = ''
    if len(a) < len(b):
        print(biggest_left(counts))
        return

    n = len(a)
    for i in range(n):
        d = dig(b[i])

        if counts[d] and ok(d, counts, b[i+1:]):
            ans += b[i]
            counts[d] -= 1
        else:
            for s in range(d-1, -1, -1):
                if counts[s] > 0:
                    ans += str(s)
                    counts[s] -= 1
                    ans += biggest_left(counts)
                    print(ans)
                    return
    print(ans)

if __name__ == '__main__':
    main()
",O(n ^ 3)
"def getsum(a, b):
    if a % 2 == 0:
        return (a + b) * ((b - a) // 2 + 1) // 2
    else:
        return -(a + b) * ((b - a) // 2 + 1) // 2

q = int(input())
for i in range(q):
    l, r = map(int, input().split())
    if l == r:
        print(l if l % 2 == 0 else -l)
    else:
        print(
            getsum(l if l % 2 == 1 else l + 1, r if r % 2 == 1 else r - 1) +
            getsum(l if l % 2 == 0 else l + 1, r if r % 2 == 0 else r - 1)
        )",O(1)
"q = int(input())
otvet = []
for i in range(q):
    g = input().split()
    n = int(g[0])
    m = int(g[1])
    k = int(g[2])
    if n < 0:
        n = -n
    if m < 0:
        m = -m
    if m > k or n > k:
        otvet.append(-1)
    elif m % 2 == k % 2 and n % 2 == k % 2:
        otvet.append(k)
    elif m % 2 == k % 2 or n % 2 == k % 2:
        otvet.append(k - 1)
    else:
        otvet.append(k - 2)
for i in otvet:
    print(i)
",O(1)
"def digit(a):
    s=0
    while a:
        s+=a%10
        a//=10
    return s

def big(n,s):

    lo=1
    hi=n
    while lo<=hi:
        mid=(lo+hi)//2
        if mid-digit(mid)<s:

            lo=mid+1
        else:
            hi=mid-1

    return n-lo+1

a,b=map(int,input().strip().split())
print(big(a,b))",O(logn)
"n=int(input())
if n>=6:
	for i in range(2, n-1):
		print(1, i)
	for i in range(n-1, n+1):
		print(2, i)
else:
	print(-1)
for i in range(2, n+1):
	print(1, i)",O(n)
"def main():

    n = int(input())
    a = list(map(int, input().split()))
    cnt = 0
    for i in range(n):
        for j in range(i+1, n):
            if a[i] > a[j]:
                cnt += 1
    even = cnt % 2 == 0
    q = int(input())
    ans = []
    for _ in range(q):
        l, r = map(int, input().split())
        len = r - l + 1
        pairs = len * (len-1) // 2
        if pairs % 2 == 1:
            even = not even
        if even:
            ans.append('even')
        else:
            ans.append('odd')
    print('\n'.join(ans))

main()",O(n ^ 2)
"import json
import os

def convert_files_to_json():
    answer = dict()
    for file in os.listdir(""bad/""):
        if '_' in file:

            answer[file] = [list(map(int, line.split())) for line in open(""bad/"" + file).read().split('\n')[:2]]

    return json.dumps(answer)

def extract_list(compressed_list, start_val=1):
    answer = []
    for num in compressed_list:
        answer += [start_val] * num
        start_val += 1
    return answer

answer = json.loads('{""1_12"": [[], [2, 2, 2, 2, 2, 3]], ""6_11"": [[1, 1, 1, 1, 1, 7], [2, 3, 1, 2, 2, 2, 2, 3]], '
                    '""3_10"": [[], [1, 1, 4, 1, 1, 5]], ""3_17"": [[1, 1, 4, 1, 1, 4, 1, 1, 4], [2]], ""6_9"": [[], [1, 1, '
                    '1, 1, 1, 10]], ""9_18"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 19]], ""18_21"": [[], [1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 22]], ""10_20"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 21]], ""15_18"": [['
                    '], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19]], ""1_10"": [[], [2, 2, 2, 2, 3]], ""6_19"": [[], '
                    '[1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 8]], ""3_13"": [[1, 1, 4, 1, 1, 4], [2]], ""2_22"": [[], [1, 3]], '
                    '""3_6"": [[], [1, 1, 7]], ""10_14"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 1, 3, 1, 3, 1, 1, 1, 1, 1, 7], '
                    '[1, 3]], ""9_17"": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [2]], ""6_15"": [[], [1, 1, 1, 1, 1, 7, 1, 1, 7]], '
                    '""7_22"": [[], [1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 9]], ""1_15"": [[], [2]], ""10_15"": [[], [1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 16]], ""3_15"": [[], [1, 1, 4]], ""11_20"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '12], [1, 3, 1, 4, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 4]], ""15_21"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 16, 1, 1, 4, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 10], [1, 1, 4]], ""18_19"": [[], [1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20]], ""11_21"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12], '
                    '[2]], ""2_2"": [[], [1, 3]], ""16_19"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 3, 1, 2, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 3, 3, '
                    '3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 8, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 5], [3, '
                    '3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 2, 3]], ""3_12"": [[], [1, 1, 4, 1, 1, 7]], ""18_22"": [['
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 15, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 1, 3, 1, 3, 1, 3, 1, 3, 1, '
                    '3, 1, 3, 1, 1, 1, 1, 1, 7], [1, 3]], ""21_22"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 23]], ""8_19"": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 1, 4, 1, 4, 1, 1, 3, 1, 1, 4, 1, '
                    '4]], ""13_22"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14], [1, 1, 1, 6, 1, 1, 1, 1, 5, 1, 1, 1, 5, '
                    '1, 1, 1, 6]], ""5_18"": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [3, 1, 2, 1, 3, 3, 1, 2, 1, 3, 3]], '
                    '""8_16"": [[], [1, 1, 1, 1, 1, 1, 1, 17]], ""18_18"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 19]], ""1_19"": [[], [2]], ""5_15"": [[], [1, 1, 1, 1, 6]], ""1_6"": [[], [2, 2, 3]], '
                    '""11_22"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 23]], ""17_18"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 19]], ""7_16"": [[1, 1, 1, 1, 1, 1, 8], [1, 3, 1, 4, 1, 1, 3, 1, 3, 1, 4]], '
                    '""3_3"": [[], [1, 1, 4]], ""15_16"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], '
                    '""5_11"": [[1, 1, 1, 1, 6], [2]], ""1_2"": [[], [3]], ""1_17"": [[], [2]], ""14_17"": [[1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 15, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 3, 3, 1, 2, 1, 2, 1, 1, '
                    '1, 1, 1, 1, 1, 9, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 6], [3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, '
                    '2, 1, 3, 3]], ""13_17"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6], [2]], ""1_8"": [[], [2, 2, 2, 3]], ""9_20"": [[1, '
                    '1, 1, 1, 1, 1, 1, 1, 10], [1, 3, 1, 3, 3, 1, 2, 1, 3, 1, 3, 1, 3, 3]], ""8_22"": [[], [1, 1, 1, 1, '
                    '1, 1, 1, 9, 1, 1, 1, 1, 1, 9]], ""7_17"": [[1, 1, 1, 1, 1, 1, 8, 1, 1, 4, 2, 2, 2, 2, 1, 1, 4], '
                    '[2]], ""17_22"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 1, 4, 1, 1, 3, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 13, 1, 4, 1, 4, 1, 1, 3, 1, 1, 3, 1, 1, 1, 1, 1, 1, 8], [1, 4, 1, 4, 1, 4, '
                    '1, 1, 3, 1, 1, 3, 1, 1, 3, 1, 3, 1, 4]], ""12_21"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13], [1, 1, '
                    '7, 1, 1, 1, 1, 1, 4, 1, 1, 4, 1, 1, 7]], ""5_19"": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [2]], '
                    '""14_19"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15, 2, 3, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, '
                    '2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 1, 1, 1, 5], [2, 3, 2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 1, 2, 2, 3]], '
                    '""6_6"": [[], [1, 1, 1, 1, 1, 7]], ""7_11"": [[1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 1, 1, 4], [2]], '
                    '""2_10"": [[], [1, 3]], ""5_7"": [[1, 1, 1, 1, 6, 2, 2, 1, 1, 4], [2]], ""2_7"": [[], [1, 3, 1, 4]], '
                    '""10_13"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 3, 1, 2, 1, 1, 1, 1, 1, 1, 8, 3, 3, 1, 2, 1, 2, 1, 1, '
                    '1, 5], [3, 3, 3, 1, 2, 1, 2, 1, 2, 2, 3]], ""12_12"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13]], '
                    '""4_15"": [[1, 1, 1, 5, 1, 1, 1, 5], [3, 1, 2, 2, 3, 1, 2, 2, 3]], ""9_14"": [[1, 1, 1, 1, 1, 1, 1, '
                    '1, 10, 2, 3, 1, 2, 2, 1, 1, 1, 5], [2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 3]], ""11_15"": [[1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], '
                    '""15_20"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 21]], ""3_14"": [[], [1, 1, 4, 1, 1, 4, '
                    '1, 4]], ""7_18"": [[1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 5, 3, 1, 2, 1, 1, 1, 5], [3, 1, 2, 2, 3, 3, 1, '
                    '2, 1, 2, 2, 3]], ""2_13"": [[], [1, 3, 1, 3, 1, 3, 3]], ""10_22"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], '
                    '[1, 3]], ""9_16"": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [1, 3, 3, 1, 2, 1, 3, 1, 3, 1, 3, 3]], '
                    '""8_18"": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 3, 1, 5, 1, 1, 1, 3, 1, 3, 1, 5]], ""6_10"": [[1, 1, 1, 1, '
                    '1, 7], [1, 3]], ""16_21"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 2, 3, 1, 2, 2, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 1, 1, 1, 1, 1, 7], [2, 3, 2, 3, 2, 3, '
                    '1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 3]], ""21_21"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 22]], ""12_16"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], ""10_19"": [[1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 11], [2, 2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3]], ""2_9"": [[], [1, 3, 1, 3, '
                    '3]], ""1_18"": [[], [2, 2, 2, 2, 2, 2, 2, 2, 3]], ""8_9"": [[], [1, 1, 1, 1, 1, 1, 1, 10]], '
                    '""5_13"": [[1, 1, 1, 1, 6, 1, 1, 4, 2, 2, 1, 1, 4], [2]], ""4_10"": [[], [1, 1, 1, 5, 1, 5]], '
                    '""1_5"": [[], [2]], ""18_20"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 21]], '
                    '""3_8"": [[], [1, 1, 4, 1, 4]], ""2_12"": [[], [1, 3, 1, 3, 1, 5]], ""2_21"": [[], [1, 3, 1, 3, 1, 3, '
                    '1, 3, 1, 3, 3]], ""6_13"": [[1, 1, 1, 1, 1, 7], [2, 2, 3, 1, 2, 2, 2, 2, 3]], ""4_6"": [[], [1, 1, '
                    '1, 7]], ""2_8"": [[], [1, 3, 1, 5]], ""12_13"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14]], '
                    '""5_10"": [[], [1, 1, 1, 1, 11]], ""3_4"": [[], [1, 1, 5]], ""10_11"": [[], [1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 12]], ""16_22"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 1, 5, 1, 1, 1, 3, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 11], [1, 5, 1, 5, 1, 1, 1, 3, 1, 1, 1, 3, 1, 1, 1, 5, 1, 5]], ""4_12"": [[], [1, '
                    '1, 1, 5]], ""11_14"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 9, 3, 3, '
                    '1, 2, 1, 2, 1, 1, 1, 1, 6], [3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 3, 3]], ""4_16"": [[], [1, 1, 1, 5, 1, '
                    '1, 1, 9]], ""5_16"": [[], [1, 1, 1, 1, 6, 1, 1, 1, 1, 7]], ""5_17"": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6, '
                    '2, 2, 1, 1, 4, 2, 2, 1, 1, 4], [2]], ""10_18"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [1, 3]], '
                    '""4_18"": [[], [1, 1, 1, 5, 1, 1, 1, 5, 1, 5]], ""4_19"": [[], [1, 1, 1, 5, 1, 1, 1, 5, 1, 1, 5]], '
                    '""8_8"": [[], [1, 1, 1, 1, 1, 1, 1, 9]], ""19_20"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 21]], ""3_20"": [[], [1, 1, 4, 1, 1, 4, 1, 1, 4, 1, 4]], ""5_14"": [[], [1, 1, 1, 1, 6, '
                    '1, 1, 1, 6]], ""13_15"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 12, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, '
                    '2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], ""1_3"": [[], [2]], '
                    '""5_21"": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [2]], ""1_20"": [[], [2, 2, 2, 2, 2, 2, 2, 2, 2, 3]], '
                    '""15_19"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 12, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, '
                    '4], [2]], ""14_21"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 22]], ""4_5"": [[], [1, 1, 1, 6]], '
                    '""3_21"": [[], [1, 1, 4]], ""4_9"": [[1, 1, 1, 5], [2, 3, 1, 2, 2, 3]], ""7_7"": [[], [1, 1, 1, 1, 1, '
                    '1, 8]], ""11_18"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12], [1, 1, 5, 1, 1, 1, 4, 1, 1, 1, 5, 1, 1, '
                    '5]], ""15_22"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 1, '
                    '1, 1, 1, 9], [2, 2, 3, 2, 2, 3, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 3]], ""14_14"": [[], [1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 15]], ""4_17"": [[1, 1, 1, 5, 1, 1, 1, 5], [2, 3, 1, 2, 2, 3, 1, 2, 2, '
                    '3]], ""6_12"": [[], [1, 1, 1, 1, 1, 13]], ""1_1"": [[], [2]], ""19_21"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 20, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 2, 2, '
                    '2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 14, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 2, 2, '
                    '2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, '
                    '2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, '
                    '2, 1, 1, 4], [2]], ""9_21"": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [1, 1, 4]], ""17_21"": [[1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, '
                    '2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, '
                    '6], [2]], ""16_17"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18]], ""4_21"": [[], [1, 1, '
                    '1, 5, 1, 1, 1, 5, 1, 1, 1, 6]], ""5_6"": [[], [1, 1, 1, 1, 7]], ""10_10"": [[], [1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 11]], ""8_15"": [[1, 1, 1, 1, 1, 1, 1, 9], [2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 3]], '
                    '""13_18"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 1, 4, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 9], [1, '
                    '4, 1, 4, 1, 1, 3, 1, 1, 3, 1, 1, 4, 1, 4]], ""20_22"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 23]], ""9_10"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 11]], ""2_19"": [[], [1, 3, 1, 3, '
                    '1, 3, 1, 3, 1, 4]], ""6_22"": [[1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 7], [1, 3]], ""13_13"": [[], [1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14]], ""17_20"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '18, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 12, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 9, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, '
                    '2, 1, 1, 1, 1, 6], [3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 3, 3]], ""6_18"": [[], [1, 1, '
                    '1, 1, 1, 7]], ""5_12"": [[1, 1, 1, 1, 6], [1, 3, 3, 1, 2, 1, 3, 3]], ""17_17"": [[], [1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18]], ""8_20"": [[], [1, 1, 1, 1, 1, 1, 1, 9, 1, 1, 1, 9]], '
                    '""11_17"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6], [2]], ""1_4"": [[], '
                    '[2, 3]], ""3_11"": [[1, 1, 4, 1, 1, 4], [2]], ""3_9"": [[], [1, 1, 4]], ""7_14"": [[], [1, 1, 1, 1, 1, '
                    '1, 15]], ""13_20"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 1, 1, '
                    '7], [2, 2, 3, 2, 2, 3, 1, 2, 2, 2, 1, 2, 2, 2, 2, 3]], ""8_13"": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 4, '
                    '1, 1, 3, 1, 1, 4, 1, 4]], ""9_13"": [[1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 1, 1, 1, 1, 6], '
                    '[2]], ""11_13"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, '
                    '1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], '
                    '""9_22"": [[1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 5, 2, 3, 1, 2, 2, 1, 1, 1, 5], [2, 3, 1, 2, 2, 3, '
                    '2, 3, 1, 2, 2, 1, 2, 2, 3]], ""6_21"": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 10]], ""12_14"": [[], '
                    '[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15]], ""3_7"": [[1, 1, 4], [2]], ""14_20"": [[1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 15, 1, 5, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 9], [1, 5, 1, 5, 1, 1, 1, 3, 1, 1, '
                    '1, 3, 1, 3, 1, 5]], ""9_11"": [[1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, '
                    '1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], ""12_22"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '13], [1, 3, 1, 5, 1, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 5]], ""5_20"": [[], [1, 1, 1, 1, 6, 1, 1, 1, 1, '
                    '11]], ""1_16"": [[], [2, 2, 2, 2, 2, 2, 2, 3]], ""7_12"": [[1, 1, 1, 1, 1, 1, 8], [1, 4, 1, 1, 3, 1, '
                    '3, 1, 4]], ""12_15"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16]], ""7_9"": [[1, 1, 1, 1, 1, 1, 8, '
                    '2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 1, 1, 4], [2]], ""15_15"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 16]], ""5_5"": [[], [1, 1, 1, 1, 6]], ""9_19"": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [2]], '
                    '""8_11"": [[1, 1, 1, 1, 1, 1, 1, 9, 3, 1, 2, 1, 1, 1, 1, 6], [3, 3, 1, 2, 1, 2, 1, 3, 3]], '
                    '""2_3"": [[], [1, 4]], ""7_10"": [[1, 1, 1, 1, 1, 1, 8, 3, 1, 2, 1, 1, 1, 5], [3, 3, 1, 2, 1, 2, 2, '
                    '3]], ""8_14"": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 5, 1, 1, 1, 3, 1, 3, 1, 5]], ""11_11"": [[], [1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 12]], ""2_11"": [[], [1, 3, 1, 3, 1, 4]], ""2_15"": [[], [1, 3, 1, 3, 1, 3, 1, '
                    '4]], ""10_21"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [2, 2, 2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3]], '
                    '""10_12"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 13]], ""13_21"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '14, 1, 1, 4, 2, 2, 1, 1, 4, 1, 1, 1, 1, 6, 1, 1, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], '
                    '[2]], ""12_19"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 1, 3, 3, 1, 2, 1, 3, 1, 1, 1, 1, 6], [1, '
                    '3, 3, 1, 3, 3, 1, 2, 1, 3, 1, 2, 1, 3, 3]], ""9_9"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 10]], '
                    '""3_18"": [[], [1, 1, 4, 1, 1, 4, 1, 1, 7]], ""14_15"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '16]], ""14_22"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, '
                    '1, 7], [1, 3]], ""13_16"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 11, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 8, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 5], [3, 3, '
                    '3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 2, 3]], ""6_8"": [[], [1, 1, 1, 1, 1, 9]], ""3_16"": [[], [1, 1, 4, 1, '
                    '1, 4, 1, 1, 5]], ""2_6"": [[], [1, 3]], ""20_21"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 22]], ""6_7"": [[], [1, 1, 1, 1, 1, 8]], ""2_4"": [[], [1, 5]], ""9_12"": [[], [1, 1, '
                    '1, 1, 1, 1, 1, 1, 13]], ""8_12"": [[], [1, 1, 1, 1, 1, 1, 1, 13]], ""8_10"": [[], [1, 1, 1, 1, 1, 1, '
                    '1, 11]], ""15_17"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 14, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, '
                    '1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], ""2_17"": [[], [1, 3, 1, 3, 1, 3, 1, 3, '
                    '3]], ""16_16"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], ""1_22"": [[], [2, 2, 2, 2, '
                    '2, 2, 2, 2, 2, 2, 3]], ""4_11"": [[], [1, 1, 1, 5, 1, 1, 5]], ""4_4"": [[], [1, 1, 1, 5]], '
                    '""11_16"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 3, 1, 2, 2, 1, 1, 1, 1, 1, 7], [2, 3, 2, 3, 1, '
                    '2, 2, 1, 2, 2, 2, 2, 3]], ""2_18"": [[], [1, 3]], ""6_16"": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 7]], '
                    '""2_14"": [[], [1, 3]], ""7_13"": [[1, 1, 1, 1, 1, 1, 8], [2]], ""3_22"": [[], [1, 1, 4, 1, 1, 4, 1, '
                    '1, 4, 1, 1, 5]], ""19_19"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20]], '
                    '""8_17"": [[1, 1, 1, 1, 1, 1, 1, 9], [2, 2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 3]], ""2_5"": [[], [1, 3, '
                    '3]], ""19_22"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20, 3, 1, 2, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, '
                    '3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, '
                    '1, 1, 1, 1, 1, 8, 3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 5], [3, 3, 3, 3, 3, 3, '
                    '1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 2, 3]], ""10_16"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [1, 5, 1, '
                    '1, 1, 3, 1, 1, 1, 5, 1, 5]], ""22_22"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 23]], ""4_13"": [[], [1, 1, 1, 5, 1, 1, 1, 6]], ""7_20"": [[], [1, 1, 1, 1, 1, 1, 8, 1, '
                    '1, 1, 1, 1, 8]], ""5_22"": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [1, 3, 3, 1, 2, 1, 3, 3, 1, 2, 1, 3, '
                    '3]], ""16_18"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19]], ""13_14"": [[], [1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 15]], ""5_8"": [[1, 1, 1, 1, 6], [3, 1, 2, 1, 3, 3]], ""1_11"": [[], '
                    '[2]], ""7_21"": [[], [1, 1, 1, 1, 1, 1, 8]], ""11_12"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13]], '
                    '""12_18"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19]], ""7_19"": [[1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, '
                    '6, 2, 2, 1, 1, 1, 1, 6, 2, 2, 1, 1, 4, 2, 2, 2, 2, 1, 1, 4], [2]], ""7_8"": [[], [1, 1, 1, 1, 1, '
                    '1, 9]], ""10_17"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [1, 1, 5, 1, 1, 1, 4, 1, 1, 4, 1, 1, 5]], '
                    '""6_20"": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 9]], ""3_19"": [[1, 1, 4, 1, 1, 4, 1, 1, 4], [2]], '
                    '""11_19"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 1, 1, 4, 2, 2, 1, 1, 4, 1, 1, 4, 1, 1, 4], [2]], '
                    '""6_17"": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 7]], ""20_20"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 21]], ""4_8"": [[], [1, 1, 1, 9]], ""8_21"": [[1, 1, 1, 1, 1, 1, 1, 9, 1, 1, '
                    '1, 1, 6, 3, 1, 2, 1, 1, 1, 1, 6], [3, 1, 2, 1, 3, 3, 3, 1, 2, 1, 2, 1, 3, 3]], ""12_17"": [[1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 1, 4, 1, 1, 3, 1, 1, 1, 1, 1, 1, 8], [1, 4, 1, 4, 1, 1, 3, 1, 1, '
                    '3, 1, 3, 1, 4]], ""2_20"": [[], [1, 3, 1, 3, 1, 3, 1, 3, 1, 5]], ""1_9"": [[], [2]], ""14_16"": [[], '
                    '[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], ""4_20"": [[], [1, 1, 1, 5]], ""2_16"": [[], [1, 3, 1, '
                    '3, 1, 3, 1, 5]], ""1_14"": [[], [2, 2, 2, 2, 2, 2, 3]], ""1_21"": [[], [2]], ""13_19"": [[1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8], [2]], ""7_15"": [[1, 1, 1, 1, '
                    '1, 1, 8], [2]], ""5_9"": [[1, 1, 1, 1, 6], [2]], ""4_7"": [[1, 1, 1, 5], [3, 1, 2, 2, 3]], '
                    '""4_14"": [[], [1, 1, 1, 5, 1, 1, 1, 7]], ""3_5"": [[1, 1, 4], [2]], ""9_15"": [[1, 1, 1, 1, 1, 1, 1, '
                    '1, 10], [1, 1, 4]], ""6_14"": [[1, 1, 1, 1, 1, 7], [1, 3]], ""14_18"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 15, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, '
                    '1, 7], [1, 3]], ""12_20"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13], [1, 1, 1, 5]], ""1_13"": [[], '
                    '[2]], ""4_22"": [[], [1, 1, 1, 5, 1, 1, 1, 5, 1, 1, 1, 7]], ""16_20"": [[], [1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 21]], ""1_7"": [[], [2]], ""17_19"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 18, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 14, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 2, '
                    '2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, '
                    '2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]]}')

n, x, y = map(int, input().split())
n -= 1
if x > y:
    x, y = y, x
prefix = extract_list(answer[str(x) + '_' + str(y)][0])
pattern = extract_list(answer[str(x) + '_' + str(y)][1], prefix[-1] + 1 if prefix else 1)
if n < len(prefix):
    print(prefix[n])
else:
    n -= len(prefix)
    print(n // len(pattern) * (pattern[-1] - pattern[0] + 1) + pattern[n % len(pattern)])
",np
"import os
import sys
from math import *
from collections import *

from bisect import *
from io import BytesIO, IOBase

def vsInput():
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA = ""abcdefghijklmnopqrstuvwxyz/""
M = 1000000007
EPS = 1e-6

def Ceil(a, b):
    return a // b + int(a % b > 0)

def value():
    return tuple(map(int, input().split()))

def array():
    return [int(i) for i in input().split()]

def Int():
    return int(input())

def Str():
    return input()

def arrayS():
    return [i for i in input().split()]

n = int(input())
if n == 0:
    print(0)
else:
    print(n // 2 + 1 if n % 2 != 0 else n + 1)
",O(1)
"n, l, r, x = list(map(int, input().split()))
s = list(map(int, input().split()))
olmps = []
c = []
v = 0
for i in range(1<<n):
    olmps.append([])
    for j in range(n):
        if i & (1<<j):
            olmps[-1].append(s[j])
for o in olmps:
    if l <= sum(o) <= r:
        c.append(o)
for z in c:
    if max(z) - min(z) >= x:
        v+=1
print(v)
",np
"import os
import sys
from io import BytesIO, IOBase

def main():
    n=int(input())
    prob=[]
    for _ in range(n):
        prob.append(list(map(float,input().split())))

    dp=[-1 for _ in range(1<<n)]

    ans=[0 for _ in range(n)]

    def move(mask,die):

        total=bin(mask).count('1')

        z=0

        for i in range(n):
            if mask & (1<<i):
                z+=prob[i][die]

        return z/((total*(total-1))>>1)

    def solve(mask):

        if mask==(1<<n)-1:
            return 1

        if dp[mask]!=-1:
            return dp[mask]

        ans=0
        for i in range(n):
            if not (mask & (1<<i)):
                prev=solve(mask ^ (1<<i))

                ans+=prev*move(mask ^ (1<<i),i)

        dp[mask]=ans
        return ans

    for i in range(n):
        ans[i]='%.6f'%solve(1<<i)

    print(*ans)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda: self.buffer.read().decode('ascii')
        self.readline = lambda: self.buffer.readline().decode('ascii')

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')

if __name__ == '__main__':
    main()",np
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque

n, k = map(int,input().split())
s = input()

maxconseq = [[0 for j in range(k)] for i in range(n+1)]
for i in range(n):
    if s[i]==ord('?'):
        for j in range(k):
            maxconseq[i][j] = maxconseq[i-1][j] + 1
    else:
        j = s[i]-97
        maxconseq[i][j] = maxconseq[i-1][j] + 1

def judge(needed):

    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0

    effect = [[inf]*(n+1) for j in range(k)]

    for j in range(k):
        for i in range(n)[::-1]:
            if maxconseq[i][j]>=needed:
                effect[j][i-needed+1] = i+1
            effect[j][i] = min(effect[j][i], effect[j][i+1])

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index])

        minstate[state] = minimum

    if minstate[-1]<=n:  return True
    return False

front = 0
rear = n//k+1

while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)

    if flag:
        front = mid + 1
    else:
        rear = mid

print(front-1)
",np
"n,m = [int(i) for i in input().split()]
b=[]
a=[]
for i in range(n):
    b.append([i for i in input()])
    a.append([0 for i in range(m)])

def check(e,r,q):
    if e>=0 and r>=0 and e+2<n and r+2<m:
        if b[e][r]=='
            a[e][r]==1
            a[e+1][r]==1
            a[e+2][r]==1
            a[e+2][r+1]==1
            a[e+2][r+2]==1
            a[e+1][r+2]==1
            a[e][r+2]==1
            a[e][r+1]==1
            return True
    if q ==1:
        return False
    return check(e,r-1,1) or check(e,r-2,1) or check(e-1,r-2,1) or check(e-2,r-2,1) or check(e-2,r-1,1) or check(e-2,r,1) or check(e-1,r,1)
for i in range(n):
    for j in range(m):
        if b[i][j]=='
            if (not check(i,j,0)) and a[i][j]==0:
                print(""NO"")
                exit()
print(""YES"")",O(n ^ 2)
"n, k = map(int, input().split())
a, b, c = 2 * n, 5 * n, 8 * n
ceil = lambda x, y: (x + y - 1) // y
print(ceil(a, k) + ceil(b, k) + ceil(c, k))
",O(1)
"n,k=map(int,input().split())
s=[["".""]*n for i in range(4)]
if k%2==0:
  for j in range(1,n-1):
    if k==0:
      break
    s[1][j]=""
    s[2][j]=""
    k-=2
else:
  cen=n//2
  s[1][cen]=""
  k-=1
  for i in range(1,3):
    for j in range(1,cen):
      if k>0:
        k-=2
        s[i][j]=s[i][-j-1]=""
if k==0:
  print(""YES"")
  for i in range(4):
    print("""".join(s[i]))
else:
  print(""NO"")",O(n)
"for _ in range(int(input())):
    s = input()
    t = input()
    if len(t) == 1:
        print(""YES"" if t in s else ""NO"")
        continue
    nxt = [[-1] * 26 for _ in range(len(s) + 1)]
    nxt[-2][ord(s[-1]) - ord('a')] = len(s) - 1
    for i in range(len(s) - 2, -1, -1):
        for c in range(26):
            nxt[i][c] = nxt[i + 1][c]
        nxt[i][ord(s[i]) - ord('a')] = i
    ans = ""NO""
    for p in range(len(t)):
        a = t[:p]
        b = t[p:]
        dp = [[-1] * (len(b) + 1) for _ in range(len(a) + 1)]
        dp[0][0] = 0
        for la in range(len(a) + 1):
            for lb in range(len(b) + 1):
                if dp[la][lb] != -1:
                    if la < len(a):
                        if dp[la + 1][lb] != -1:
                            if nxt[dp[la][lb]][ord(a[la]) - ord('a')] != -1:
                                if nxt[dp[la][lb]][ord(a[la]) - ord('a')] < dp[la + 1][lb] - 1:
                                    dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')]
                                    dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb])
                        else:
                            dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')]
                            dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb])
                    if lb < len(b):
                        if dp[la][lb + 1] != -1:
                            if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] != -1:
                                if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] < dp[la][lb + 1] - 1:
                                    dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')]
                                    dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1])
                        else:
                            dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')]
                            dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1])
                if dp[len(a)][len(b)] != -1:
                    ans = ""YES""
                    break
    print(ans)
",O(n ^ 3)
"class Solution_TLE(object):
    def find132pattern(self, nums):
        for k in range(len(nums)):
            valid = False
            for j in range(k):
                if nums[j] < nums[k]:
                    valid = True
                elif nums[j] > nums[k]:
                    if valid:
                        return True
        return False",O(n ^ 2)
"class Solution:
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0
        stack = []
        res = 0

        for i in range(len(height)):
            while stack and height[i] >= height[stack[-1]]:
                mid = height[stack.pop()]
                if stack:
                    right = height[i]
                    left = height[stack[-1]]
                    h = min(right, left) - mid
                    w = i - stack[-1] - 1
                    res += h * w
            stack.append(i)
        return res
",O(n)
"from sys import stdin, stdout
import sys
input=sys.stdin.readline

def solve(n, t, tasks):
    lo = 0
    hi = n

    res = []
    curr_res = 0

    tasks.sort(key=lambda x: x[1])

    while lo <= hi:
        mid = lo + (hi - lo) // 2

        valid_tasks = []
        for i in tasks:
            if i[0] >= mid:
                valid_tasks.append(i)

        can_do = False

        curr_sum = 0
        total_used = 0
        r = []
        for i in valid_tasks:
            curr_sum += i[1]
            total_used += 1
            r.append(i[2])
            if curr_sum > t:
                break
            elif total_used >= mid:
                can_do = True
                curr_res = mid
                res = r
                break
        if can_do:
            lo = mid + 1
        else:
            hi = mid - 1
    return curr_res, res

def main():
    n, t = (int(x) for x in input().split("" ""))
    tasks = []
    nums = n
    idx = 1
    while n:
        a_i, t_i = (int(x) for x in input().split("" ""))
        tasks.append((a_i, t_i, idx))
        idx += 1
        n -= 1

    res, res_arry = solve(nums, t, tasks)
    print(res)
    print(res)
    stdout.write("" "".join(map(str, res_arry)))
    stdout.write(""\n"")

if __name__ == ""__main__"":
    main()
",O(nlogn)
"import os, sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
n,m,k=map(int,input().split())
row=[]
for _ in range(n):
    row.append([10**6+2]+list(map(int,input().split()))+[10**6+2])
col=[[10**6+2]*(m+2)]
for _ in range(n-1):
    col.append([10**6+2]+list(map(int,input().split()))+[10**6+2])
col.append([10**6+2]*(m+2))
if  k%2:
    dp=[[-1 for i in range(m)] for j in range(n)]
else:
    k=k//2
    dp = [[0 for i in range(m)] for j in range(n)]
    for i in range(n):
        for j in range(m):
            dp[i][j]=2*min(row[i][j],row[i][j+1],col[i][j+1],col[i+1][j+1])
    k-=1
    while k:

        k-=1
        temp = [[0 for i in range(m)] for j in range(n)]
        for i in range(n):
            for j in range(m):
                ck=dp[i][j]*8
                if i>=1:
                    ck=min(ck,dp[i-1][j]+2*col[i][j+1])
                if i<n-1:
                    ck=min(ck,dp[i+1][j]+2*col[i+1][j+1])
                if j>=1:
                    ck=min(ck,dp[i][j-1]+2*row[i][j])
                if j<m-1:
                    ck=min(ck,dp[i][j+1]+2*row[i][j+1])
                temp[i][j]=ck

        dp=temp

for i in dp:
    print(*i)
",O(n ^ 3)
"class Solution2(object):
    def minimumSum(self, nums):
        INF = float(""inf"")

        left = [INF]*len(nums)
        curr = INF
        for i in range(len(nums)):
            left[i] = curr
            curr = min(curr, nums[i])
        right = [INF]*len(nums)
        curr = INF
        for i in reversed(range(len(nums))):
            right[i] = curr
            curr = min(curr, nums[i])
        result = INF
        for i in range(len(nums)):
            if left[i] < nums[i] > right[i]:
                result = min(result, left[i]+nums[i]+right[i])
        return result if result != INF else -1",O(n)
"class Solution(object):
    def countSubarrays(self, nums):
        return sum((nums[i-1]+nums[i+1])*2 == nums[i] for i in range(1, len(nums)-1))",O(n)
"import sys
input = sys.stdin.readline

n,m=map(int,input().split())
ANS=[]

for i in range(1,n//2+1):
    for j in range(1,m+1):
        sys.stdout.write((str(i)+"" ""+str(j)+""\n""))
        sys.stdout.write((str(n-i+1)+"" ""+str(m-j+1)+""\n""))

if n%2==1:
    for j in range(1,m//2+1):
        sys.stdout.write((str(n//2+1)+"" ""+str(j)+""\n""))
        sys.stdout.write((str(n//2+1)+"" ""+str(m-j+1)+""\n""))

    if m%2==1:
        sys.stdout.write((str(n//2+1)+"" ""+str(m//2+1)+""\n""))
",O(n ^ 2)
"class Solution2(object):
    def findSubtreeSizes(self, parent, s):
        def dfs(u):
            lookup[ord(s[u])-ord('a')].append(u)
            for v in adj[u]:
                dfs(v)
                result[lookup[ord(s[v])-ord('a')][-1] if lookup[ord(s[v])-ord('a')] else u] += result[v]
            lookup[ord(s[u])-ord('a')].pop()
        
        adj = [[] for _ in range(len(parent))]
        for v, u in enumerate(parent):
            if u != -1:
                adj[u].append(v)
        lookup = [[] for _ in range(26)]
        result = [1]*len(parent)
        dfs(0)
        return result",O(n)
"n,m = map(int,input().split())
li = [[j for j in input()] for i in range(n)]

for j in range(m):
    flag = False
    for i in range(n):
        if li[i][j] == ""B"":
            flag = True
            position1 = i
            break
    if(flag == True):
        break
for j in range(m-1,-1,-1):
    flag = False
    for i in range(n-1,-1,-1):
        if li[i][j] == ""B"":
            flag = True
            position2 = i
            break
    if(flag == True):
        break
for i in range(n):
    flag = False
    for j in range(m):
        if li[i][j] == ""B"":
            flag = True
            position3 = j
            break
    if(flag == True):
        break
for i in range(n-1,-1,-1):
    flag = False
    for j in range(m-1,-1,-1):
        if li[i][j] == ""B"":
            flag = True
            position4 = j
            break
    if(flag == True):
        break

avg1 = (position1+position2)//2 + 1
avg2 = (position3 + position4)//2 + 1
print(avg1,avg2)",O(n ^ 2)
"import sys
def get_ints(): return list(map(int, sys.stdin.readline().strip().split()))

def solve(N, S, C):
    dp = [float('inf')] * N
    for i in range(1, N):
        for j in range(i):
            if S[j] < S[i]:
                dp[i] = min(dp[i], C[j] + C[i])

    dp2 = [float('inf')] * N
    for i in range(N - 1, 0, -1):
        for j in range(i + 1, N, 1):
            if S[i] < S[j]:
                dp2[j] = min(dp2[j], dp[i] + C[j])

    ans = min(dp2)
    if ans == float('inf'):
        return -1
    return ans

N = int(input())
S = get_ints()
C = get_ints()

print(solve(N, S, C))
",O(n ^ 2)
"class Node(object):
    def __init__(self, value, keys):
        self.value = value
        self.keys = keys
        self.prev = None
        self.next = None


class LinkedList(object):
    def __init__(self):
        self.head, self.tail = Node(0, set()), Node(0, set())
        self.head.next, self.tail.prev = self.tail, self.head

    def insert(self, pos, node):
        node.prev, node.next = pos.prev, pos
        pos.prev.next, pos.prev = node, node
        return node

    def erase(self, node):
        node.prev.next, node.next.prev = node.__next__, node.prev
        del node

    def empty(self):
        return self.head.__next__ is self.tail

    def begin(self):
        return self.head.__next__

    def end(self):
        return self.tail

    def front(self):
        return self.head.__next__

    def back(self):
        return self.tail.prev


class Solution(object):

    def __init__(self):
        self.bucket_of_key = {}
        self.buckets = LinkedList()

    def inc(self, key):
        if key not in self.bucket_of_key:
            self.bucket_of_key[key] = self.buckets.insert(self.buckets.begin(), Node(0, set([key])))

        bucket, next_bucket = self.bucket_of_key[key], self.bucket_of_key[key].__next__
        if next_bucket is self.buckets.end() or next_bucket.value > bucket.value+1:
            next_bucket = self.buckets.insert(next_bucket, Node(bucket.value+1, set()))
        next_bucket.keys.add(key)
        self.bucket_of_key[key] = next_bucket

        bucket.keys.remove(key)
        if not bucket.keys:
            self.buckets.erase(bucket)

    def dec(self, key):
        if key not in self.bucket_of_key:
            return

        bucket, prev_bucket = self.bucket_of_key[key], self.bucket_of_key[key].prev
        self.bucket_of_key.pop(key, None)
        if bucket.value > 1:
            if bucket is self.buckets.begin() or prev_bucket.value < bucket.value-1:
                prev_bucket = self.buckets.insert(bucket, Node(bucket.value-1, set()))
            prev_bucket.keys.add(key)
            self.bucket_of_key[key] = prev_bucket

        bucket.keys.remove(key)
        if not bucket.keys:
            self.buckets.erase(bucket)

    def getMaxKey(self):
        if self.buckets.empty():
            return """"
        return next(iter(self.buckets.back().keys))

    def getMinKey(self):
        if self.buckets.empty():
            return """"
        return next(iter(self.buckets.front().keys))",O(1)
"a, b = list(map(int,input().split()))
l = 0
r = a + 1
while r - l > 1:
    m = (r + l) // 2

    if m * (m + 1) // 2 - (a - m) > b:
        r = m
    else:
        l = m
print(a - l)",O(logn)
"import sys
input = sys.stdin.readline

n = int(input())
if n <= 4:
    print(""YES"")
    exit()

A = [None]*n

for i in range(n):
    A[i] = list(map(int,input().split()))

def is_colinear(a1,a2,a3):
    if a1 == a2 or a2 == a3 or a1 == a3:
        return True

    x1,y1 = a1
    x2,y2 = a2
    x3,y3 = a3

    if x1 == x2 or x1 == x3 or x2 == x3:
        return x1 == x2 == x3
    if y1 == y2 or y1 == y3 or y2 == y3:
        return y1 == y2 == y3
    return (y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)

X,Y,Z = A[0],A[1],A[2]

def good(X,Y):

    bad = []
    for i in range(n):
        if not is_colinear(X,Y,A[i]):
            bad.append(A[i])

    if len(bad) <= 2:
        return True

    U,V = bad[0],bad[1]
    for i in range(len(bad)):
        if not is_colinear(U,V,bad[i]):
            return False
    return True

if good(X,Y) or good(Y,Z) or good(X,Z):
    print(""YES"")
    exit()

print(""NO"")
exit()
",O(nlogn)
"def max_xor_naive(l, r):
    max_xor = 0
    xor = 0

    for a in range(l, r+1):
        for b in range(a+1, r+1):
            xor = a^b
            if xor>max_xor:
                max_xor = xor

    return max_xor

def max_xor_efficient(l, r):
    s1 = bin(l)[2:]
    s2 = bin(r)[2:]
    l1 = len(s1)
    l2 = len(s2)
    if l1<l2:
        return pow(2, l2) - 1
    x = 0
    for i in range(0, l1):
        if s1[i]!=s2[i]:
            return pow(2, l1-i) - 1

    return 0

l, r = map(int, input().split())

ans2 = max_xor_efficient(l, r)
print(ans2)
",O(logn)
"op=[0]*1000000
cl=[0]*1000000
def fun(s):
    v = []
    for i in range(len(s)):
        l = len(v)
        if s[i]=='(':
            v.append(s[i])
        elif l>0 and v[l-1]=='(':
            v.pop()
        else :
            v.append(')')

    l = len(v)
    if  l==0:
        op[0]+=1
        cl[0]+=1
    elif v[0]==v[l-1]:
        if  v[0]=='(':
            op[l]+=1
        else :
            cl[l]+=1

t = int ( input() )
while t>0:
    t-=1
    s = str ( input() )
    fun(s)
ans = 0
for i in range(1000000):
    ans+=(op[i] * cl[i])

print(ans)",O(n)
"class Solution(object):
    def timeTaken(self, edges):
        def topological_traversal():
            p = [-2]*len(adj)
            p[0] = -1
            topological_order = [0]
            for u in topological_order:
                for v in reversed(adj[u]):
                    if p[v] != -2:
                        continue
                    p[v] = u
                    topological_order.append(v)
            for u in reversed(topological_order):
                for v in adj[u]:
                    if v == p[u]:
                        continue
                    curr = [(1+int(v%2 == 0))+dp[v][0][0], v]
                    for i in range(len(dp[u])):
                        if curr > dp[u][i]:
                            curr, dp[u][i] = dp[u][i], curr

        def bfs():
            q = [(0, -1, 0)]
            while q:
                new_q = []
                for u, p, curr in q:
                    result[u] = max(dp[u][0][0], curr)
                    for v in adj[u]:
                        if v == p:
                            continue
                        new_q.append((v, u, (1+int(u%2 == 0))+max((dp[u][0][0] if dp[u][0][1] != v else dp[u][1][0]), curr)))
                q = new_q
    
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = [[[0, -1] for _ in range(2)] for _ in range(len(edges)+1)]
        topological_traversal()
        result = [0]*(len(edges)+1)
        bfs()
        return result",O(n)
"import bisect

tmp = input().split()
n = int(tmp[0])
k = int(tmp[1])

scores = list()
times = list()
for i in range(n):
    tmp = input().split()
    scores.append(int(tmp[0]))
    times.append(int(tmp[1]))

sorted_scores = sorted(zip(scores, times), key=lambda y : (y[0], -y[1]), reverse=True)

ans = 1
i = k-2
while i>=0 and (sorted_scores[i] == sorted_scores[k-1]):
    ans = ans + 1
    i = i - 1

i = k
while i < n and (sorted_scores[i] == sorted_scores[k-1]):
    ans = ans + 1
    i = i + 1

print(ans)",O(nlogn)
"k = int(input())
n = 1
up_bnd = 9
while(k > up_bnd):
    n += 1
    up_bnd += (9*n)*(10**(n-1))
low_bnd = 0
for i in range(1, n):
    low_bnd += (9*i)*(10**(i-1))
num = int((k-low_bnd)/n)
lb_val = 0
for i in range(n-1):
    lb_val = (lb_val*10)+9
num += lb_val
rm = (k-low_bnd) % n
if(rm != 0):
    num += 1
ans = 0
if(rm == 0):
    ans = num % 10
else:
    for i in range(n-rm+1):
        j = (num % 10)
        num = int(num/10)
        ans = j
print(int(ans))
",O(logn)
"import itertools


class Solution(object):
    def sortSentence(self, s):
        words = s.split()
        for i in range(len(words)):
            while int(words[i][-1])-1 != i:
                words[int(words[i][-1])-1], words[i] = words[i], words[int(words[i][-1])-1]
        return "" "".join(map(lambda x: x[:-1], words))",O(n)
"class Solution(object):
    def getCollisionTimes(self, cars):
        stk = []
        result = [-1.0]*len(cars)
        for i in reversed(range(len(cars))):
            p, s = cars[i]
            while stk and (cars[stk[-1]][1] >= s or 
                           0 < result[stk[-1]] <= float(cars[stk[-1]][0]-p)/(s-cars[stk[-1]][1])):
                stk.pop()
            if stk:
                result[i] = float(cars[stk[-1]][0]-p)/(s-cars[stk[-1]][1])
            stk.append(i)
        return result",O(n)
"class Solution(object):
    def minElements(self, nums, limit, goal):
        return (abs(sum(nums)-goal) + (limit-1))//limit",O(n)
"t = int(input())

def sol(n, k):
    p = 1
    q = 1
    acc = 0
    while n > 0 and k >= p:

        k -= p
        n -= 1
        if n >= 40:
            return n
        acc += q*(4**n-1)//3

        if k <= acc:
            return n
        p = 2*p+1
        q = 2*q+3
    return -1

for _ in range(t):
    n, k = (int(v) for v in input().split())
    ans = sol(n, k)
    if ans == -1:
        print(""NO"")
    else:
        print(""YES"", ans)
",O(logn)
"from itertools import chain
from time import time

def main():

    BITS = [1 << sh for sh in range(24)]
    B2N = {v: u for u, v in enumerate(BITS)}

    def getPt():
        return tuple(map(int, input().split()))

    def dist(ptA, ptB):
        return sum(((u-v)**2 for u, v in zip(ptA, ptB)))

    def getBits(val):
        return tuple(filter(lambda x: x&val, BITS))

    def chooseTwo(pool):
        n = len(pool)
        for i in range(n):
            for j in range(i+1, n):
                yield (pool[i], pool[j])

    ori = getPt()
    pts = []
    N = int(input())

    for _ in range(N):
        pts.append(getPt())

    vis = set([0])
    mint = [0]+[1e8]*(1<<N)
    pres = [None]*(1<<N)
    allb = (1 << N)-1
    B2P = {BITS[u]: v for u, v in enumerate(pts)}
    B2P[0] = ori
    alld = {u: {v: dist(B2P[u], B2P[v]) for v in B2P} for u in B2P}

    getDP = lambda x: mint[x]
    newDist = lambda stt, p: mint[stt] + alld[p[0]][p[1]] \
                                + alld[p[0]][0] \
                                + alld[p[1]][0]

    for stt in range(1<<N):
        if stt not in vis:
            continue

        bits = getBits(~stt&allb)

        sb = bits[0] if bits else None

        for bit in bits:

            newstt = stt | sb | bit
            nd = newDist(stt, (sb, bit))
            if getDP(newstt) > nd:
                mint[newstt] = nd
                pres[newstt] = sb | bit
                vis.add(newstt)

    print(mint[allb])
    path = ['0']
    stt = allb

    while stt:

        bits = getBits(pres[stt])
        for bit in bits:
            path.append(str(B2N[bit]+1))
        path.append('0')

        stt ^= pres[stt]

    print(' '.join(path))

import sys
st = time()
main()
print('Run {:.6f} seconds.'.format(time()-st), file=sys.stderr)",np
"n=int(input())
a=list(map(int,input().split()))
b=0
for i in range(n):
    if a[i]%2==1:
        if i%2==0:
            b+=1
        else:
            b-=1
if n%2==0:
    if b==0:
        print(""YES"")
    else:
        print(""NO"")
else:
    if b==0 or b==1:
        print(""YES"")
    else:
        print(""NO"")",O(n)
"class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

        q = deque([(root, float(""-inf""), float(""inf""))])

        while q:
            node, left, right = q.popleft()
            if not (left < node.val < right):
                return False
            if node.left:
                q.append((node.left, left, node.val))
            if node.right:
                q.append((node.right, node.val, right))

        return True
",O(n)
"import sys

from bisect import bisect_left as lb
from collections import deque

from queue import PriorityQueue as pq
from math import *
input_ = lambda: sys.stdin.readline().strip(""\r\n"")
ii = lambda : int(input_())
il = lambda : list(map(int, input_().split()))
ilf = lambda : list(map(float, input_().split()))
ip = lambda : input_()
fi = lambda : float(input_())
ap = lambda ab,bc,cd : ab[bc].append(cd)
li = lambda : list(input_())
pr = lambda x : print(x)
prinT = lambda x : print(x)
f = lambda : sys.stdout.flush()
inv =lambda x:pow(x,mod-2,mod)
mod = 10**9 + 7

for _ in range (1) :
    n = ii()

    x = 1
    i = 0

    while (x <= n) :
        x += (9*(i+1)*(10**i))
        i += 1

    x -= 9*i*(10**(i-1))

    y = str(10**(i-1) + (n-x)//i)

    print(y[(n-x)%i])
",O(logn)
"from math import log
from collections import deque
n,k=map(int,input().split())
s=list(map(int,input().split()))
ans=0
s.sort()
s1=deque(s)
for j in range(11):
    d=dict()
    z=10**j
    for i in s:
        y=i*z
        u=y%k
        if u in d:
            d[u]+=1
        else:
            d.update({u:1})
    aux=0
    for i in s1:
        y=i
        lg=int(log(i,10))+1
        lg=10**lg
        if lg==z:
            aux1=(y*z)%k
            aux2=y%k
            d[aux1]-=1
            x=(k-aux2)
            if aux2==0:
                x=0
            if x in d:
                ans+=d[x]
            d[aux1]+=1
            aux+=1
        else:
            break
    for i in range(aux):
        s1.popleft()
print(ans)
",O(nlogn)
"

class Solution(object):
    def greatestLetter(self, s):
        lookup = set(s)
        result = """"
        for c in s:
            if c.isupper() and lower(c) in s:
                if c > result:
                    result = c
        return result


",O(n)
"a,b=map(int,input().split())
print((1<<(a^b).bit_length())-1)",O(logn)
"import sys

n = sys.stdin.readline()
n = int(n)
def get_graph(n):
    graph = []
    for _ in range(n):
        entries = list(map(lambda x : int(x), sys.stdin.readline().split("" "")[1:]))
        graph.append(entries)
    return graph

def chain(target, buckets, reverse_bucket, sum_bucket, bucket_num, val):
    mask = 2**bucket_num
    mem = []
    buckets_seen = set({bucket_num})

    og_bucket = bucket_num
    og_val = val
    for _ in range(len(buckets)):
        rem = target - sum_bucket[bucket_num] + val
        if rem not in reverse_bucket:
            return None, []

        new_bucket = reverse_bucket[rem]
        if new_bucket == og_bucket and rem != og_val:
            return None, []
        elif new_bucket == og_bucket and rem == og_val:
            mem.append((rem, bucket_num))
            return mask | 2**new_bucket, mem
        elif new_bucket in buckets_seen:
            return None, []

        buckets_seen.add(new_bucket)
        mask = mask | 2**new_bucket

        mem.append((rem, bucket_num))
        bucket_num = new_bucket
        val = rem
    return None, []

def helper(chains, mask, mem):
    if mask == 0:
        return []
    if mask in mem:
        return mem[mask]

    for i, chain in enumerate(chains):
        if (mask >> i) & 0:
            continue
        for key in chain:
            if key | mask != mask:
                continue

            future = helper(chains, ~key & mask, mem)
            if future is not None:
                mem[mask] = chain[key] + future
                return mem[mask]
    mem[mask] = None
    return None
def solve(n):
    buckets = get_graph(n)
    reverse_bucket = {}
    sum_bucket = [0]* len(buckets)
    total_sum = 0
    for i, bucket in enumerate(buckets):
        for x in bucket:
            total_sum += x
            sum_bucket[i] += x
            reverse_bucket[x] = i

    target = total_sum / len(buckets)

    chains = []
    for i, bucket in enumerate(buckets):
        seto = {}
        for x in bucket:
            key, val = chain(target, buckets, reverse_bucket, sum_bucket, i, x)
            if key is not None:
                seto[key] = val
        chains.append(seto)
    mem = {}
    for i in range (2**len(buckets)-1):
        helper(chains, i, mem)
    return helper(chains, 2 ** len(buckets) - 1, mem), reverse_bucket

def result(n):
    res, reverse_bucket = solve(n)
    if res is None:
        sys.stdout.write(""No\n"")
    else:
        res = sorted(res, key = lambda x : reverse_bucket[x[0]])
        sys.stdout.write(""Yes\n"")
        for x, y in res:
            x = int(x)
            y = int(y) + 1
            stuff = "" "".join([str(x), str(y), ""\n""])
            sys.stdout.write(stuff)
result(n)",np
"class Solution3(object):
    def divisorGame(self, n):
        def factors(n):
            result = [[] for _ in range(n+1)]
            for i in range(1, n+1):
                for j in range(i, n+1, i):
                    result[j].append(i)
            return result
    
        def memoization(n):
            if lookup[n] is None:
                lookup[n] = any(not memoization(n-i) for i in FACTORS[n] if i != n)
            return lookup[n]

        FACTORS = factors(n)
        lookup = [None]*(n+1)
        return memoization(n)",O(n ^ 2)
"import sys, os

numbs = [int(x) for x in sys.stdin.buffer.read().split()]
n = numbs.pop(0)

base = []
out = []

for i in range(n):
    x = numbs[i]
    how = 0

    for b,rep in base:
        if x.bit_length() == b.bit_length():
            x ^= b
            how ^= rep

    if x:
        how |= 1 << i

        a = 0
        b = len(base)
        while a < b:
            c = a + b >> 1
            if base[c][0] > x:
                a = c + 1
            else:
                b = c
        base.insert(a, (x, how))

        out.append(0)
    else:
        outind = len(out)
        out.append(-1)

        y = bin(how).encode('ascii')
        ylen = len(y)
        for i in range(2,len(y)):
            if y[i] == 49:
                out.append(ylen - 1 - i)
        out[outind] = len(out) - 1 - outind

os.write(1, b'\n'.join(str(x).encode('ascii') for x in out))
",np
"class Solution(object):
    def numberOfPoints(self, nums):
        nums.sort()
        result = 0
        curr = nums[0]
        for i in range(1, len(nums)):
            if nums[i][0] <= curr[1]:
                curr[1] = max(curr[1], nums[i][1])
            else:
                result += curr[1]-curr[0]+1
                curr = nums[i]
        result += curr[1]-curr[0]+1
        return result",O(nlogn)
"a=list(map(int, input().split()))
h=0
for i in range(14):
    b=a[:]
    if i==13:
        j=0
    else:
        j=i+1
    if a[i]>0:
        c=0
        t=b[i]%14
        x=b[i]//14
        b[i]=0

        for i in range(14):
            b[i]+=x

        while t>0:
            b[j]+=1
            j+=1
            if j==14:
                j=0
            t-=1
        for i in range(14):
            if b[i]%2==0:
                c+=b[i]

        if c>h:
            h=c
print(h)
",O(1)
"def ct(s):
    a=[0]*26*2
    for i in s:
        if ord(i)<97:
            a[ord(i)-65]+=1
        else:
            a[ord(i)-97+26]+=1
    return max(a)
n=int(input())
s1=input()
ln=len(s1)
s1=ct(s1)
s2=ct(input())
s3=ct(input())
s=[s1,s2,s3]
for i in range(len(s)):
    if s[i]==ln and n==1: s[i]=ln-1
    else:s[i]=s[i]+n
    if s[i]>ln: s[i]=ln
s1=s[0]
s2=s[1]
s3=s[2]

s.sort()
if s[2]==s[1]:
    print('Draw')
elif s[-1]==s1:
    print('Kuro')
elif s[-1]==s2:
    print('Shiro')
elif s[-1]==s3:
    print('Katie')
",O(n)
"n=int(input())
def judge(x):
    if x%2==0:
        return 0
    else:
        return 1
ls=[int(x) for x in input().split()]
if judge(ls[0])==judge(ls[1]):
    for x in ls[2:]:
        if judge(x)!=judge(ls[0]):
            print(ls.index(x)+1)
            break
else:
    if judge(ls[2])==judge(ls[0]):
        print(2)
    elif judge(ls[2])==judge(ls[1]):
        print(1)",O(n)
"n = int(input())
ans = (2 * (n - 1) ** 2) + 2 * n - 1
print(ans)
",O(1)
"import sys

n, s = map(int, input().split())

ok, ng = 10**18+100, -1
while abs(ok - ng) > 1:
    mid = (ok + ng) >> 1
    if mid - sum(map(int, str(mid))) >= s:
        ok = mid
    else:
        ng = mid

print(max(0, n - ok + 1))
",O(logn)
"class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        rows = [0] * 9
        cols = [0] * 9
        squares = [0] * 9

        for r in range(9):
            for c in range(9):
                if board[r][c] == ""."":
                    continue

                val = int(board[r][c]) - 1
                if (1 << val) & rows[r]:
                    return False
                if (1 << val) & cols[c]:
                    return False
                if (1 << val) & squares[(r // 3) * 3 + (c // 3)]:
                    return False

                rows[r] |= (1 << val)
                cols[c] |= (1 << val)
                squares[(r // 3) * 3 + (c // 3)] |= (1 << val)

        return True
",O(n ^ 2)
"from math import sin
pi = 3.141592653589793238462643383279502884197
n, r = map(int,input().split())
theta = 2*pi / n
R = r / (1-sin(theta/2))
print(R-r)",O(1)
"n, m, k, l = map(int, input().split())
need = k + l
if need % m == 0 and need <= n:
    print(need // m)
else:
    x = need // m + 1
    if x * m > n:
        print(-1)
    else:
        print(x)",O(1)
"class Solution3(object):
    def maxBalancedSubsequenceSum(self, nums):
        NEG_INF = float(""-inf"")
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=lambda _: None,
                         query_fn=lambda x, y: max(x, y),
                         update_fn=lambda x, y: max(x, y)):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(self.tree[x], h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def query(self, L, R):
                if L > R:
                    return None
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L //= 2
                    R //= 2
                return self.query_fn(left, right)

        val_to_idx = {x:i for i, x in enumerate(sorted({x-i for i, x in enumerate(nums)}))}
        st = SegmentTree(len(val_to_idx))
        for i, x in enumerate(nums):
            v = max(st.query(0, val_to_idx[x-i]), 0)+x
            st.update(val_to_idx[x-i], v)
        return st.query(0, len(val_to_idx)-1)",O(nlogn)
"n, k = [int(x) for x in input().split()]
if k == 1:
    print(""1"" + ""0""*(n-1))
elif 3*k <= n:

    print((""0"" * ((n-k)//2)) + ""1"" + (""0""*(k-2)) + ""1"" + ""0"" * ((n-k)//2))
else:
    tmp = ""0"" * ((n-k)//2) + ""1""
    s = tmp
    s = tmp * (n // len(tmp) + 1)
    s = s[:n]
    print(s)",O(1)
"import math


class Solution(object):
    def visiblePoints(self, points, angle, location):
        arr, extra = [], 0
        for p in points:
            if p == location:
                extra += 1
                continue
            arr.append(math.atan2(p[1]-location[1], p[0]-location[0]))
        arr.sort()
        arr.extend([x + 2.0*math.pi for x in arr]) 
        d = 2.0*math.pi * (angle/360.0)
        left = result = 0
        for right in range(len(arr)):
            while arr[right]-arr[left] > d:
                left += 1
            result = max(result, right-left+1)
        return result + extra",O(nlogn)
"class Solution(object):
    def numberOfSubarrays(self, nums, k):
        def atMost(nums, k):
            result, left, count = 0, 0, 0
            for right, x in enumerate(nums):
                count += x%2
                while count > k:
                    count -= nums[left]%2
                    left += 1
                result += right-left+1
            return result

        return atMost(nums, k) - atMost(nums, k-1)",O(n)
"import sys

n = int(sys.stdin.readline().strip())
a = list(map(int,sys.stdin.readline().strip().split()))

for i in range (0, n):
    if a[i] >= 0:
        a[i] = - a[i] - 1

if n % 2 == 1:
    i = a.index(min(a))
    a[i] = - a[i] - 1

a = list(map(str,a))
print("" "".join(a))
",O(n)
"t = int(input())
ans = ''
for j in range(t):
    ab = input().split()
    a = int(ab[0])
    b = int(ab[1])
    k = 0
    while a > 0 and b > 0:
        if a >= b:
            k += a // b
            a %= b
        else:
            k += (b // a)
            b %= a
    ans += str(k) + '\n'
print(ans)
",O(1)
"import operator


class Solution(object):
    def calculate(self, s):
        def compute(operands, operators):
            right, left = operands.pop(), operands.pop()
            operands.append(ops[operators.pop()](left, right))

        ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}
        precedence = {'+':0, '-':0, '*':1, '/':1}
        operands, operators, operand = [], [], 0
        for i in range(len(s)):
            if s[i].isdigit():
                operand = operand*10 + int(s[i])
                if i == len(s)-1 or not s[i+1].isdigit():
                    operands.append(operand)
                    operand = 0
            elif s[i] == '(':
                operators.append(s[i])
            elif s[i] == ')':
                while operators[-1] != '(':
                    compute(operands, operators)
                operators.pop()
            elif s[i] in precedence:
                while operators and operators[-1] in precedence and \
                      precedence[operators[-1]] >= precedence[s[i]]:
                    compute(operands, operators)
                operators.append(s[i])
        while operators:
            compute(operands, operators)
        return operands[-1]",O(n)
"class Solution(object):
    def maxArrayValue(self, nums):
        result = curr = 0
        for i in reversed(range(len(nums))):
            if nums[i] > curr:
                curr = 0
            curr += nums[i]
            result = max(result, curr)
        return result",O(n)
"class Solution(object):
    def minSwaps(self, s):
        def cost(s, x): 
            diff = 0 
            for c in s:
                diff += int(c) != x
                x ^= 1
            return diff//2
    
        ones = s.count('1')
        zeros = len(s)-ones 
        if abs(ones-zeros) > 1:
            return -1
        if ones > zeros:
            return cost(s, 1)
        if ones < zeros:
            return cost(s, 0)
        return min(cost(s, 1), cost(s, 0))",O(n)
"n = int(input())
ai = list(map(int,input().split()))
bi = list(map(int,input().split()))
ai2 = [0] * (n+1)
n2 = 0
for i in range(n):
    num = 0
    if ai2[bi[i]] != 1:
        for j in range(n2,n):
            ai2[ai[j]] = 1
            if ai[j] == bi[i]:
                num = j + 1 - n2
                n2 = j + 1
                break
    print(num,end="" "")",O(n)
"class ListNode(object):
    def __init__(self, key, val):
        self.val = val
        self.key = key
        self.next = None
        self.prev = None


class LinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, node):
        node.next, node.prev = None, None 
        if self.head is None:
            self.head = node
        else:
            self.tail.next = node
            node.prev = self.tail
        self.tail = node

    def delete(self, node):
        if node.prev:
            node.prev.next = node.__next__
        else:
            self.head = node.__next__
        if node.__next__:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        node.next, node.prev = None, None 

    def find(self, key):
        curr = self.head
        while curr:
            if curr.key == key:
                break
            curr = curr.__next__
        return curr


class Solution(object):

    def __init__(self):
        self.__data = [LinkedList() for _ in range(10000)]

    def put(self, key, value):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if node:
            node.val = value
        else:
            l.insert(ListNode(key, value))

    def get(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if node:
            return node.val
        else:
            return -1

    def remove(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if node:
            l.delete(node)",O(1)
"def fun(grid,counter,n,m):
    for i in range(n):
        possible=True
        for j in range(m):
            if grid[i][j]=='1' and counter[j]==1:
                possible=False
                break
        if possible:
            return True
    return False

n,m=[int(_) for _ in input().split("" "")]
grid,counter=[],[0]*m
for _ in range(n):
    s=input()
    for i in range(m):
        if s[i]=='1':
            counter[i]+=1
    grid.append(s)
if fun(grid,counter,n,m):
    print(""YES"")
else:
    print(""NO"")
",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase
import threading
from bisect import bisect_right
from math import gcd,log
from collections import Counter,defaultdict,deque
from pprint import pprint
from itertools import permutations
from bisect import bisect_right
from random import randint as rti

n,m=0,0

def main(tnum):
    global n,m,d
    n,m,k=map(int,input().split())
    if k%2:
        ans=[[-1]*m for i in range(n)]
        for li in ans:
            print(*li)
        return
    cost=dict()
    dp=[[float('inf')]*m for i in range(n)]
    crr=[]
    rrr=[]
    for i in range(n):
        arr=list(map(int,input().split()))
        for j in range(m-1):
            dp[i][j]=min(dp[i][j],arr[j])
            dp[i][j+1]=min(dp[i][j+1],arr[j])
        crr.append(arr)

    for i in range(n-1):
        arr=list(map(int,input().split()))
        for j in range(m):
            dp[i][j]=min(dp[i][j],arr[j])
            dp[i+1][j]=min(dp[i+1][j],arr[j])

        rrr.append(arr)

    for i in range(1,k//2):
        ndp=[[float('inf')]*m for i in range(n)]
        for i in range(n):
            for j in range(m):
                x,y=i,j
                if x>0:
                    ndp[i][j]=min(ndp[i][j],dp[x-1][y]+rrr[x-1][y])
                if x<n-1:
                    ndp[i][j]=min(ndp[i][j],dp[x+1][y]+rrr[x][y])
                if y>0:
                    ndp[i][j]=min(ndp[i][j],dp[x][y-1]+crr[x][y-1])
                if y<m-1:
                    ndp[i][j]=min(ndp[i][j],dp[x][y+1]+crr[x][y])
        dp=ndp
    for li in dp:
        li=[2*x for x in li]
        print(*li)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":

    for _ in range(1):
        main(_+1)
",O(n ^ 3)
"global fact,inv_fact
def make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):
	global fact, inv_fact

	max_n = min(max_n, mod - 1)

	fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)
	fact[0] = 1
	for i in range(max_n):
		fact[i + 1] = fact[i] * (i + 1) % mod

	inv_fact[-1] = pow(fact[-1], mod - 2, mod)
	for i in reversed(range(max_n)):
		inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod

make_nCr_mod()
def comb(n, r):
	mod=10**9+7
	global fact,inv_fact
	res = 1
	while n or r:
		a, b = n % mod, r % mod
		if a < b:
			return 0
		res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod
		n //= mod
		r //= mod
	return res
def f():
	dp=[0]*(1000+100)
	dp[1]=1

	for i in range(2,len(dp)):
		o=bin(i).count(""1"")
		if o==1:
			dp[i]=2
		else:
			dp[i]+=dp[o]+1
	return dp

def bit(s,k):
	dp=f()
	l=[]
	ans=0
	ll=len(s)
	ans=0
	ones=0
	if k==0:
		return 1
	for i  in range(ll):
		if s[i]==""0"":
			continue
		else:
			for j in range(max(ones,1),1000):
				if dp[j]==k:
					ans=(ans+comb(ll-i-1,j-ones))%(10**9+7)
					if i==0 and k==1:
						ans-=1
		ones+=1
	if dp[ones]==k:
		ans+=1
	return (ans)%(10**9+7)

s=input().strip()
k=int(input())
print(bit(s,k))",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import ceil

def prod(a, mod=10 ** 9 + 7):
    ans = 1
    for each in a:
        ans = (ans * each) % mod
    return ans

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def lcm(a, b): return a * b // gcd(a, b)

def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

from math import inf

for _ in range(int(input()) if not True else 1):

    n, m = map(int, input().split())

    a = []
    for i in range(n):
        a += [list(map(int, input().split()))]

    alpha, omega = 0, 10**9
    def solve(mid):
        index = [-1] * (1 << m)
        for i in range(n):
            val = 0
            for j in range(m):
                if a[i][j] >= mid:
                    val += (1 << j)
            index[val] = i + 1
        is_subset = list(index)
        for i in range(m):
            for mask in range(1 << m):
                if mask & (1 << i):
                    is_subset[mask^(1<<i)] = max(is_subset[mask], is_subset[mask ^ (1 << i)])
        pos = False
        for mask in range(1 << m):
            if index[mask] == -1: continue
            mask2 = ((1 << m) - 1) ^ mask
            if is_subset[mask2] != -1:
                pos = (index[mask], is_subset[mask2])
                break
        return pos
    while alpha < omega:
        mid = (alpha + omega + 1) // 2
        if solve(mid):
            alpha = mid
        else:
            omega = mid - 1
    print(*solve(alpha))",np
"def main():
	n, k = [int(_) for _ in input().split()]
	a = [int(_) for _ in input().split()]

	p = [-1] * 256
	p[0] = 0

	for x in a:
		if p[x] < 0:
			for y in range(x - 1, max(-1, x - k), -1):
				if p[y] >= 0:
					if p[y] + k > x:
						p[x] = p[y]
					else:
						p[x] = p[y + 1] = y + 1

					break
			if p[x] < 0:
				p[x] = p[x - k + 1] = x - k + 1

	b = [p[x] for x in a]

	print(' '.join(map(str, b)))

if __name__ == '__main__':
	main()",O(n ^ 2)
"USE_STDIO = False

if not USE_STDIO:
    try: import mypc
    except: pass

def main():
    n, k = map(int, input().split(' '))
    ans = (k + n - 1) // n
    print(ans)

if __name__ == '__main__':
    main()
",O(1)
"import sys
from array import array

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

n = int(input())
prob = [tuple(map(float, input().split())) for _ in range(n)]
full_bit = (1 << n) - 1
dp = [0.0] * full_bit + [1.0]

for bit in range(full_bit, 0, -1):
    popcount = len([1 for i in range(n) if (1 << i) & bit])
    if popcount == 1 or dp[bit] == 0.0:
        continue
    div = 1 / ((popcount * (popcount - 1)) >> 1)

    for i in range(n):
        if ((1 << i) & bit) == 0:
            continue
        for j in range(i + 1, n):
            if ((1 << j) & bit) == 0:
                continue
            dp[bit - (1 << j)] += dp[bit] * prob[i][j] * div
            dp[bit - (1 << i)] += dp[bit] * prob[j][i] * div

print(*(dp[1 << i] for i in range(n)))
",np
"x,k = map(int, input().strip().split())

MOD = 1000000007

if x > 0:
	r = (pow(2, k+1, MOD) * x - pow(2, k, MOD) + 1 + MOD * 10) % MOD
else:
	r = 0

print(r)",O(logn)
"def tonum(count):
    return (count - 1) // 3

def check(n, k, logdivl):
    divl = 2**logdivl

    min_k = 2**(logdivl+1) - 2 - logdivl

    max_k = tonum(divl * divl + (divl * divl - (2*divl - 1)) * ((2**(n-logdivl))**2 - 1))

    return min_k <= k <= max_k

def main(n, k):
    if k == 1:
        return n - 1

    if n > 100:
        return n - 1

    if ((2 ** (n-1)) ** 2 - 1) // 3 + 1 >= k:
        return n -1

    for logdivl in range(1, n+1):
        if check(n, k, logdivl):
            return n - logdivl

    return None

t = int(input())
for i in range(t):
    n, k  = list(map(int, input().split()))
    ans = main(n, k)
    if ans is not None:
        print(""YES {}"".format(ans))
    else:
        print(""NO"")
",O(logn)
"import sys

def num_ops(low, high):
    if high % low == 0:
        return high // low
    else:
        return (high // low) + num_ops(high % low, low)

def main():
    n = int(sys.stdin.readline().strip())
    for _ in range(n):
        low, high = [int(i) for i in sys.stdin.readline().strip().split()]
        print(num_ops(low, high))

if __name__ == '__main__':
    main()",O(1)
"def parse():
    s, i = input().split()
    i = int(i) - 1
    return s, i

def match(p, s):
    for a, b in zip(p, s):
        if a != '_' and a != b:
            return False
    return True

def main():
    from itertools import product

    n, m, k = [int(t) for t in input().split()]
    P = [input() for _ in range(n)]
    S = [parse() for _ in range(m)]

    index_of = dict()
    for i, p in enumerate(P):
        index_of[p] = i

    G = [[] for _ in range(n)]
    for s, i in S:
        if not match(P[i], s):
            print(""NO"")
            return

        for mask in product(range(2), repeat=k):
            sp = ['_' if bit else c for bit, c in zip(mask, s)]
            sp = ''.join(sp)

            try:
                j = index_of[sp]
                if i != j:
                    G[i].append(j)
            except:
                pass

    tp = toposort(G)
    if tp is None:
        print(""NO"")
    else:
        print(""YES"")
        print(*[x+1 for x in tp])

def toposort(graph):
    res, found = [], [0] * len(graph)
    stack = list(range(len(graph)))
    while stack:
        node = stack.pop()
        if node < 0:
            res.append(~node)
        elif not found[node]:
            found[node] = 1
            stack.append(~node)
            stack += graph[node]

    for node in res:
        if any(found[nei] for nei in graph[node]):
            return None
        found[node] = 0

    return res[::-1]

import sys, os, io
input = lambda: sys.stdin.readline().rstrip('\r\n')
stdout = io.BytesIO()
sys.stdout.write = lambda s: stdout.write(s.encode(""ascii""))

main()

os.write(1, stdout.getvalue())
",np
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def evaluateTree(self, root):
        INF = float(""inf"")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y
        }
        
        def iter_dfs(root):
            ret = [0]
            stk = [(1, (root, ret))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if node.left == node.right:
                        ret[0] = node.val
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    ret[0] = OP[node.val](ret1[0], ret2[0])
            return ret[0]

        return iter_dfs(root)",O(n)
"n, k = [int(i) for i in input().split()]

mid = n//2
leftside = 1
rightside = n

candies = n-mid

while mid * (mid + 1)//2 - candies != k:
    if k > mid * (mid + 1)//2 - candies:
        leftside = mid + 1
    else:
        rightside = mid

    mid = (leftside + rightside)//2
    candies = n-mid
print(candies)",O(logn)
"a,b,c,n=map(int,input().split())
if(c>b or c>a or c>n):
    print(-1)
else:
    k=c+(a-c)+(b-c)
    k=n-k
    if(k>0):
        print(k)
    else:
        print(-1)
",O(1)
"R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort()
g.sort()
b.sort()

dp=[[[0 for i in range(B+1)] for j in range(G+1)] for i in range(R+1)]

for i in range(1,R+1):
    for j in range(1,G+1):
        dp[i][j][0]=dp[i-1][j-1][0]+r[i-1]*g[j-1]

for j in range(1,G+1):
    for k in range(1,B+1):
        dp[0][j][k]=dp[0][j-1][k-1]+b[k-1]*g[j-1]

for i in range(1,R+1):
    for k in range(1,B+1):
        dp[i][0][k]=dp[i-1][0][k-1]+r[i-1]*b[k-1]

for i in range(1,R+1):
    for j in range(1,G+1):
        for k in range(1,B+1):
            if max(r[i-1],g[j-1],b[k-1])==r[i-1]:
                dp[i][j][k]=max(dp[i-1][j-1][k]+r[i-1]*g[j-1],dp[i-1][j][k-1]+r[i-1]*b[k-1])
            elif max(r[i-1],g[j-1],b[k-1])==g[j-1]:
                dp[i][j][k]=max(dp[i-1][j-1][k]+r[i-1]*g[j-1],dp[i][j-1][k-1]+g[j-1]*b[k-1])
            else:
                dp[i][j][k]=max(dp[i][j-1][k-1]+b[k-1]*g[j-1],dp[i-1][j][k-1]+r[i-1]*b[k-1])

print(dp[R][G][B])
",O(n ^ 3)
"class Solution(object):
    def canMeasureWater(self, x, y, z):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        return z == 0 or ((z <= x + y) and (z % gcd(x, y) == 0))",O(logn)
"

class Solution(object):
    def maxContainers(self, n, w, maxWeight):
        return min(maxWeight//w, n*n)
",O(1)
"if __name__ == ""__main__"":
    x,k = map(int, input().split())

    if x==0:
    else:
        y=pow(2,k,1000000007)*(2*x-1)+1
        result=int(y%(1000000007))
",O(logn)
"R,G,B = map(int,input().split())
r = list(map(int,input().split()))
g = list(map(int,input().split()))
b = list(map(int,input().split()))
r.sort()
g.sort()
b.sort()
dp = []
for i in range(R+1):
	d = []
	for j in range(G+1):
		d.append([0]*(B+1))
	dp.append(d)
for i in range(R+1):
	for j in range(G+1):
		for k in range(B+1):
			if i+j+k<2:
				continue
			if i>0 and j>0:
				dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])
			if i>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+r[i-1]*b[k-1])
			if j>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+g[j-1]*b[k-1])
print(dp[R][G][B])
",O(n ^ 3)
"from sys import stdin
from operator import xor

rints = lambda: [int(x) for x in stdin.readline().split()]
n, a, m = int(input()), [rints()], int(input())
qur, out = [rints() for _ in range(m)], []

for i in range(1, n):
    a.append(list(map(xor, a[-1][:-1], a[-1][1:])))

for i in range(n - 1):
    a[i + 1] = list(map(max, a[i][:-1], a[i][1:], a[i + 1]))

for l, r in qur:
    out.append(a[r - l][l - 1])

print('\n'.join(map(str, out)))
",O(n ^ 2)
"class Solution(object):
    def minimumCost(self, s):
        return sum(min(i+1, len(s)-(i+1)) for i in range(len(s)-1) if s[i] != s[i+1])",O(n)
"import io
import os

from collections import Counter, defaultdict, deque

def solveBFS(NR, NG, NB, R, G, B):
    def pack(i, j, k):
        return i * 256 * 256 + j * 256 + k

    def unpack(ijk):
        i, jk = divmod(ijk, 256 * 256)
        j, k = divmod(jk, 256)
        return i, j, k

    R.sort(reverse=True)
    G.sort(reverse=True)
    B.sort(reverse=True)
    dp = [0 for i in range(256 ** 3)]
    q = deque([0])
    while q:
        ijk = q.popleft()
        d = dp[ijk]
        i, j, k = unpack(ijk)

        if i < NR:
            r = R[i]

        if j < NG:
            g = G[j]
        if k < NB:
            b = B[k]
        if i + 1 <= NR and j + 1 <= NG:
            rg = pack(i + 1, j + 1, k)
            dp[rg] = max(dp[rg], r * g + d)
            q.append(rg)

        if i + 1 <= NR and k + 1 <= NB:
            rb = pack(i + 1, j, k + 1)
            dp[rb] = max(dp[rb], r * b + d)
            q.append(rb)

        if j + 1 <= NG and k + 1 <= NB:
            gb = pack(i, j + 1, k + 1)
            dp[gb] = max(dp[gb], g * b + d)
            q.append(gb)

    return max(dp)

def solve(NR, NG, NB, R, G, B):
    assert NR == len(R)
    R.sort(reverse=True)
    G.sort(reverse=True)
    B.sort(reverse=True)

    R += [0]
    G += [0]
    B += [0]

    NR1 = NR + 2
    NG1 = NG + 2
    NB1 = NB + 2
    dp = [0 for i in range((NR1) * (NG1) * (NB1))]

    def pack(i, j, k):
        return i * NG1 * NB1 + j * NB1 + k

    inf = float(""inf"")
    for i in range(NR + 1):
        for j in range(NG + 1):
            dp[pack(i, j, -1)] = -inf
    for i in range(NR + 1):
        for k in range(NB + 1):
            dp[pack(i, -1, k)] = -inf

    for j in range(NG + 1):
        for k in range(NB + 1):
            dp[pack(-1, j, k)] = -inf

    for l in range(2, NR + NG + NB + 1, 2):
        for j in range(NG + 1):
            for k in range(NB + 1):
                i = l - j - k
                if i < 0 or i > NR:
                    continue
                r = R[i - 1]
                g = G[j - 1]
                b = B[k - 1]
                dp[pack(i, j, k)] = max(
                    r * g + dp[pack(i - 1, j - 1, k)],
                    r * b + dp[pack(i - 1, j, k - 1)],
                    b * g + dp[pack(i, j - 1, k - 1)],
                )

    return max(dp)

if False:
    import random

    random.seed()
    N = 5
    for t in range(100):
        R = [random.randint(1, 10) for i in range(random.randint(1, N))]
        G = [random.randint(1, 10) for i in range(random.randint(1, N))]
        B = [random.randint(1, 10) for i in range(random.randint(1, N))]
        ans1 = solveBFS(len(R), len(G), len(B), R, G, B)
        ans2 = solve(len(R), len(G), len(B), R, G, B)
        if ans1 != ans2:
            print(ans1, ans2)
            print(R, G, B)
        exit()
if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    NR, NG, NB = [int(x) for x in input().split()]
    R = [int(x) for x in input().split()]
    G = [int(x) for x in input().split()]
    B = [int(x) for x in input().split()]
    ans = solve(NR, NG, NB, R, G, B)
    print(ans)
",O(n ^ 3)
"import sys
from collections import defaultdict as dd

mod=10**9+7

def ri(flag=0):
	if flag==0:
		return [int(i) for i in sys.stdin.readline().split()]
	else:
		return int(sys.stdin.readline())

n = ri(1)
a= ri()

b= sorted(a)
c= dd(int)

ans = 0
val=0
for i in range(n):
	if c[b[i]]==0:
		val+=1
		for j in range(n):
			if b[j]%b[i]==0:
				c[b[j]]=val

for i in c:
	ans = max(ans , c[i])

print(ans)
",O(n ^ 2)
"class Solution(object):
    def maximumTotalSum(self, maximumHeight):
        maximumHeight.sort()
        result, prev = 0, maximumHeight[-1]+1
        for x in reversed(maximumHeight):
            prev = min(x, prev-1)
            if prev == 0:
                return -1
            result += prev
        return result",O(nlogn)
"class Solution(object):
    def maxVowels(self, s, k):
        VOWELS = set(""aeiou"")
        result = curr = 0
        for i, c in enumerate(s):
            curr += c in VOWELS
            if i >= k:
                curr -= s[i-k] in VOWELS
            result = max(result, curr)
        return result",O(n)
"class Solution(object):
    def survivedRobotsHealths(self, positions, healths, directions):
        stk = []
        for i in sorted(range(len(positions)), key=lambda x:positions[x]):
            if directions[i] == 'R':
                stk.append(i)
                continue
            while stk:
                if healths[stk[-1]] == healths[i]:
                    healths[stk.pop()] = healths[i] = 0
                    break
                if healths[stk[-1]] > healths[i]:
                    healths[i] = 0
                    healths[stk[-1]] -= 1
                    break                
                healths[stk.pop()] = 0
                healths[i] -= 1
        return [x for x in healths if x]",O(nlogn)
"n, s  = [int(i) for i in input().split()]

print(max(n - [i for i in range(s, s + 180) if i - sum([int(j) for j in str(i)]) >= s][0] + 1, 0))
",O(logn)
"test=int(input())
while test:
	test=test-1
	n,k = input().split()
	n=int(n)
	k=int(k)
	if n==2 and k==3:
		print(""NO"")
		continue
	if n>=32:
		print(""YES"",n-1)
		continue
	val=[]
	val.append(0)
	for i in range(1,n+1):
		val.append(4*val[i-1]+1)
	if val[n]<k:
		print(""NO"")
		continue
	s=0
	t=2
	rem=0
	flag=0
	while s+t-1<=k and n>0:
		s=s+t-1
		t*=2
		n=n-1
	print(""YES"",n)",O(logn)
"def read_int(): return int(input())
def read_ints(): return list(map(int, input().split()))

n = read_int()
a = read_ints()
dp = [[0] * n for _ in range(n)]
f = [[0] * n for _ in range(n)]
for i in range(n - 1, -1, -1):
	f[i][i] = a[i]
	for j in range(i + 1, n):
		f[i][j] = f[i][j - 1] ^ f[i + 1][j]
for i in range(n - 1, -1, -1):
	dp[i][i] = f[i][i]
	for j in range(i + 1, n):
		dp[i][j] = max(f[i][j], dp[i][j - 1], dp[i + 1][j])
q = read_int()
for _ in range(q):
	l, r = read_ints()
	print(dp[l - 1][r - 1])
",O(n ^ 2)
"n = int(input())
a = list(map(int, input().split()))

dp = [[505]*n for _ in range(n)]
Max = [[0]*n for _ in range(n)]

for i in range(n):
    dp[i][i] = 1
    Max[i][i] = a[i]

for len in range(1, n+1):
    for i in range(n-len+1):
        j = i + len - 1
        for k in range(i, j):
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
            if dp[i][k] == 1 and dp[k+1][j] == 1 and Max[i][k] == Max[k+1][j]:
                dp[i][j] = 1
                Max[i][j] = Max[i][k] + 1
print(dp[0][n-1])",O(n ^ 3)
"import sys
from collections import defaultdict

reader = (map(int, line.split()) for line in sys.stdin)
input = reader.__next__

n, m = input()

elems = set()
vals = defaultdict(list)
for i in range(n):
    for pos, v in enumerate(input()):
        elems.add(v)
        vals[v].append((pos, i))

elems = sorted(elems, reverse=True)

masks = [0] * n
full = (1<<m) - 1
met = {0:0}
for v in elems:
    for pos, i in vals[v]:
        curr_mask = masks[i] = masks[i] | (1<<pos)
        met[curr_mask] = i
        complement = full ^ curr_mask
        if complement in met:
            print(i+1, met[complement]+1)
            sys.exit()
",np
"x, k = map(int, input().split())
MOD = 10 ** 9 + 7

def get(a, n):
    if n == 0:
        return 1
    if n % 2 == 1:
        return (get(a, n - 1) * a) % MOD
    else:
        b = get(a, n // 2) % MOD
        return (b * b) % MOD

if x == 0:
    print(0)
else:
    print((x * get(2, k + 1) - get(2, k) + 1) % MOD)
",O(logn)
"class Solution:
    def canAttendMeetings(self, intervals: List[Interval]) -> bool:
        n = len(intervals)
        for i in range(n):
            A = intervals[i]
            for j in range(i + 1, n):
                B = intervals[j]
                if min(A.end, B.end) > max(A.start, B.start):
                    return False
        return True
",O(n ^ 2)
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        dp1_buy, dp1_sell = 0, 0
        dp2_buy = 0

        for i in range(n - 1, -1, -1):
            dp_buy = max(dp1_sell - prices[i], dp1_buy)
            dp_sell = max(dp2_buy + prices[i], dp1_sell)
            dp2_buy = dp1_buy
            dp1_buy, dp1_sell = dp_buy, dp_sell

        return dp1_buy
",O(n)
"n,s=map(int,input().split())
arr=[]
for i in range(n):
    arr.append([])
    arr[i]=[int(i) for i in input().split()]
arr=sorted(arr,reverse=True,key=lambda x:x[0])
ans,c=0,0
for i in range(n):
    if i!=0:
       c=arr[i-1][0]
    if i==0:
       ans=ans+s-arr[i][0]
    else:
       ans=ans+c-arr[i][0]
    if arr[i][1]>=ans:
        ans=ans+(arr[i][1]-ans)
ans=ans+arr[n-1][0]
print(ans)
",O(n)
"def pwr(a,n,m):
    if n==0:return 1
    ans=pwr(a,n//2,m)
    ans=ans*ans
    ans%=m
    if n%2==1:return (ans*a)%m
    else: return ans
M=1000000007
tx,tn=input().split()
x=int(tx)
n=int(tn)
ans=pwr(2,n+1,M)*x
ans%=M
ans=ans-pwr(2,n,M)+1
ans=(ans+M)%M
if x==0: ans=0
print(ans)
",O(logn)
"base = 1000000007
n , m , k = map(int,input().split())
a = list(map(int,input().split()))
mx = 0
s = 0
dp = []
dd= []
for j in range(m):
    for i in range(n+1):
        dp.append(base)
        dd.append(0)
    for i in range(n):
        dd[i+1]=dd[i]+a[i]-k*(i % m== j)
        dp[i+1] = min(dd[i],dp[i])

        if (i % m == j):
            mx = max ( mx , dd[i+1]-dp[i+1])
print(mx)",O(n ^ 2)
"class Solution(object):
    def decode(self, encoded, first):
        result = [first]
        for x in encoded:
            result.append(result[-1]^x)
        return result",O(n)
"class Solution(object):
    def wateringPlants(self, plants, capacity):
        result, can = len(plants), capacity
        for i, x in enumerate(plants):
            if can < x:
                result += 2*i
                can = capacity
            can -= x
        return result",O(n)
"import copy
lista=[]
listb=[]
temp=[]
a=int(input())
flag=0
mark=0

for i in range(0,a):
    str=input()
    for j in range(0,a):
        temp.append(str[j])
    lista.append(temp)
    temp=[]

for i in range(0,a):
    str=input()
    for j in range(0,a):
        temp.append(str[j])
    listb.append(temp)
    temp=[]

listacpy =copy.deepcopy(lista)

for i in range(0,a):
    for j in range(0,a):
        if(listacpy[i][j]!=listb[i][j]):
            mark=1
            break
    if(mark==1):
        break
if(mark==0):
    flag=1
mark=0

for i in range(0,a):
    for j in range(0,a):
        listacpy[a-1-j][i]=lista[i][j]

for i in range(0,a):
    for j in range(0,a):
        if(listacpy[i][j]!=listb[i][j]):
            mark=1
            break
    if(mark==1):
        break
if(mark==0):
    flag=1

mark = 0

for i in range(0,a):
    for j in range(0,a):
        listacpy[a-1-i][a-1-j]=lista[i][j]

for i in range(0,a):
    for j in range(0,a):
        if(listacpy[i][j]!=listb[i][j]):
            mark=1
            break
    if(mark==1):
        break
if(mark==0):
    flag=1

mark = 0

for i in range(0,a):
    for j in range(0,a):
        listacpy[j][a-1-i]=lista[i][j]

for i in range(0,a):
    for j in range(0,a):
        if(listacpy[i][j]!=listb[i][j]):
            mark=1
            break
    if(mark==1):
        break
if(mark==0):
    flag=1
mark = 0

listtemp=copy.deepcopy(lista)
for i in range(0,a):
    for j in range(0,a):
        lista[i][j]=listtemp[i][a-1-j]

listacpy =copy.deepcopy(lista)
for i in range(0,a):
    for j in range(0,a):
        if(listacpy[i][j]!=listb[i][j]):
            mark=1
            break
    if(mark==1):
        break
if(mark==0):
    flag=1
mark = 0

for i in range(0,a):
    for j in range(0,a):
        listacpy[a-1-j][i]=lista[i][j]

for i in range(0,a):
    for j in range(0,a):
        if(listacpy[i][j]!=listb[i][j]):
            mark=1
            break
    if(mark==1):
        break
if(mark==0):
    flag=1
mark = 0

for i in range(0,a):
    for j in range(0,a):
        listacpy[a-1-i][a-1-j]=lista[i][j]

for i in range(0,a):
    for j in range(0,a):
        if(listacpy[i][j]!=listb[i][j]):
            mark=1
            break
    if(mark==1):
        break
if(mark==0):
    flag=1

mark = 0

for i in range(0,a):
    for j in range(0,a):
        listacpy[j][a-1-i]=lista[i][j]

for i in range(0,a):
    for j in range(0,a):
        if(listacpy[i][j]!=listb[i][j]):
            mark=1
            break
    if(mark==1):
        break
if(mark==0):
    flag=1

if(flag==1):
    print(""yes"")
else:
    print(""no"")",O(n ^ 2)
"m=[x for x in input().split()]
tiles=[[0 for i in range(9)] for j in range(3)]
for i in range(len(m)):
    g=int(m[i][0])-1
    h=(m[i][1])
    if h==""m"":
        tiles[0][g]+=1
    elif h==""p"":
        tiles[1][g]+=1
    else:
        tiles[2][g]+=1
if m[0]==m[1] and m[1]==m[2]:
    print(0)
elif m[0]==m[1]:
    print(1)
elif m[0]==m[2]:
    print(1)
elif m[1]==m[2]:
    print(1)
else:
    n=False
    for i in range(3):
        for j in range(9):
            if tiles[i][j]!=0:
                if j!=8 and tiles[i][j+1]!=0:
                    if j!=7 and tiles[i][j+2]!=0:
                        print(0)
                        n=True
                        break
                    else:
                        print(1)
                        n=True
                        break
                elif j!=7 and j!=8 and tiles[i][j+2]!=0:
                    print(1)
                    n=True
                    break
    if n==False:
        print(2)",O(n)
"from collections import Counter
from collections import defaultdict
import math
import random
import heapq as hq
from math import sqrt
import sys
from functools import reduce

def input():
    return sys.stdin.readline().strip()

def iinput():
    return int(input())

def tinput():
    return input().split()

def rinput():
    return map(int, tinput())

def rlinput():
    return list(rinput())

mod = int(1e9)+7

def factors(n):
    return set(reduce(list.__add__,
                      ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))

if __name__ == ""__main__"":
    n = iinput()
    a = rlinput()
    dp = [[0 for i in range(n)] for j in range(n)]
    for i in range(n):
        dp[i][i] = a[i]

    for l in range(n-2, -1, -1):
        for r in range(l+1, n):
            for k in range(l, r):
                if dp[l][k] == dp[k+1][r] and dp[l][k] != 0:

                    dp[l][r] = dp[l][k]+1

    squeeze = [float('inf')]*(n+1)
    squeeze[0] = 0
    for i in range(1, n+1):
        for j in range(i):
            if dp[j][i-1] != 0:
                squeeze[i] = min(squeeze[i], squeeze[j]+1)

    print(squeeze[n])
",O(n ^ 3)
"class Solution(object):
    def maxFreeTime(self, eventTime, k, startTime, endTime):
        startTime.append(eventTime)
        endTime.insert(0, 0)
        result = curr = 0
        for i in range(len(startTime)):
            curr += startTime[i]-endTime[i]
            result = max(result, curr)
            if i-k >= 0:
                curr -= startTime[i-k]-endTime[i-k]
        return result",O(n)
"import collections


class Solution(object):
    def smallestSubsequence(self, text):
        count = collections.Counter(text)

        lookup, stk = set(), []
        for c in text:
            if c not in lookup:
                while stk and stk[-1] > c and count[stk[-1]]:
                    lookup.remove(stk.pop())
                stk += c
                lookup.add(c)
            count[c] -= 1
        return """".join(stk)",O(n)
"class Solution(object):
    def vowelStrings(self, words, left, right):
        VOWELS = {'a', 'e', 'i', 'o', 'u'}
        return sum(words[i][0] in VOWELS and words[i][-1] in VOWELS for i in range(left, right+1))",O(n)
"import collections
import random
import heapq
import bisect
import math
import time

class Solution2:

    def solve(self, s):
        pass

class Solution:

    def solve(self, n, k):

        grow = 1
        tot = 0

        while n != tot - k:
            tot += grow
            grow += 1
            n -= 1
        return tot - k

sol = Solution()
sol2 = Solution2()

for test_case in range(1):
    N, K = input().split()

    out = sol.solve(int(N),int(K))
    print(str(out))
",O(logn)
"from sys import stdin

add = lambda a, b: (a + b) % mod
mod, bits = 998244353, ['00', '01', '10', '11']
pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]

n, k = map(int, stdin.readline().split())
mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]

for i in range(4):
    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)
    if val <= k:
        mem[0][val][i] = 1

for i in range(1, n):
    for j in range(1, i * 2 + 1):
        for k1 in range(4):
            for k2 in range(4):
                val = j + pat[k1][k2]
                if val <= k:
                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])

print(sum(mem[-1][k]) % mod)
",np
"def lower_bound(n, k):
    low = 1
    high = k
    while low < high:
        mid = low + (high - low) // 2
        pipes = mid * k - (mid + 2) * (mid - 1) // 2
        if pipes >= n:
            high = mid
        else:
            low = mid + 1
    return low

def main():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    else:
        ans = lower_bound(n, k)
        if ans == k:
            print(-1)
        else:
            print(ans)

if __name__ == ""__main__"":
    main()",O(logn)
"import sys

n = sys.stdin.readline()
n = int(n)
def get_graph(n):
    graph = []
    for _ in range(n):
        entries = list(map(lambda x : int(x), sys.stdin.readline().split("" "")[1:]))
        graph.append(entries)
    return graph

def chain(target, buckets, reverse_bucket, sum_bucket, bucket_num, val):
    mask = 2**bucket_num
    mem = []
    buckets_seen = set({bucket_num})

    og_bucket = bucket_num
    og_val = val
    for _ in range(len(buckets)):
        rem = target - sum_bucket[bucket_num] + val
        if rem not in reverse_bucket:
            return None, []

        new_bucket = reverse_bucket[rem]
        if new_bucket == og_bucket and rem != og_val:
            return None, []
        elif new_bucket == og_bucket and rem == og_val:
            mem.append((rem, bucket_num))
            return mask | 2**new_bucket, mem
        elif new_bucket in buckets_seen:
            return None, []

        buckets_seen.add(new_bucket)
        mask = mask | 2**new_bucket

        mem.append((rem, bucket_num))
        bucket_num = new_bucket
        val = rem
    return None, []

def helper(chains, mask, mem):
    if mask == 0:
        return []
    if mask in mem:
        return mem[mask]

    for i, chain in enumerate(chains):
        if (mask >> i) & 0:
            continue
        for key in chain:
            if key | mask != mask:
                continue

            future = helper(chains, ~key & mask, mem)
            if future is not None:
                mem[mask] = chain[key] + future
                return mem[mask]
    mem[mask] = None
    return None

def solve(n):
    buckets = get_graph(n)
    reverse_bucket = {}
    sum_bucket = [0]* len(buckets)
    total_sum = 0
    for i, bucket in enumerate(buckets):
        for x in bucket:
            total_sum += x
            sum_bucket[i] += x
            reverse_bucket[x] = i

    target = total_sum / len(buckets)

    chains = []
    for i, bucket in enumerate(buckets):
        seto = {}
        for x in bucket:
            key, val = chain(target, buckets, reverse_bucket, sum_bucket, i, x)
            if key is not None:
                seto[key] = val
        chains.append(seto)
    return helper(chains, 2 ** len(buckets) - 1, {}), reverse_bucket

def result(n):
    res, reverse_bucket = solve(n)
    if res is None:
        sys.stdout.write(""No\n"")
    else:
        res = sorted(res, key = lambda x : reverse_bucket[x[0]])
        sys.stdout.write(""Yes\n"")
        for x, y in res:
            x = int(x)
            y = int(y) + 1
            stuff = "" "".join([str(x), str(y), ""\n""])
            sys.stdout.write(stuff)
result(n)",np
"class Solution(object):
    def makeFancyString(self, s):
        s = list(s)
        cnt = j = 0
        for i, c in enumerate(s):
            cnt = cnt+1 if i >= 1 and c == s[i-1] else 1
            if cnt < 3:
                s[j] = c
                j += 1
        s[:] = s[:j]
        return """".join(s)",O(n)
"def main():

    def num(left, right, dp, rev, revI):
        if left > right:
            return 1

        key = left, rev, revI
        if key in dp:
            return dp[key]
        nonlocal ans

        acc = 0

        for x in ('01' if ans[left]=='

            temp = None
            if left == right:
                tmp = x
            elif ans[right]=='
                tmp = '01'
            else:
                tmp = ans[right]

            for y in tmp:
                if not ((rev and x>y) or (revI and x==y=='1')):
                    acc += num(
                        left+1,
                        right-1,
                        dp,
                        rev and x==y,
                        revI and x!=y
                    )
        dp[key] = acc
        return acc

    n, k = map(int, input().split())
    k += 1

    ans = ['

    for i in range(n):
        ans[i] = '0'
        tmp = num(0, n-1, {}, True, True)

        if k > tmp:
            k -= tmp
            ans[i] = '1'

    if ans[0] == '0':
        print(''.join(ans))
    else:
        print(-1)

if __name__ == '__main__':
    import sys, os
    from time import time
    if len(sys.argv)>1 and os.path.exists(sys.argv[1]):
        sys.stdin = open(sys.argv[1], 'rb')
    st = time()
    main()
    print('----- Run {:.6f} seconds. -----'.format(time()-st), file=sys.stderr)
",O(n ^ 3)
"from itertools import*

moves =[(x*mx,y*my) for mx,my,(x,y) in product( (-1,1),(-1,1), ( (1,2),(2,1) ) )]

def ac(l,x):
	if l==0: return 0
	return l[x] if 0<=x<len(l) else 0

def work():
	x=1
	while x:
		x=0
		for r in range(len(a)):
			for c in range(len(a[0])):
				if not a[r][c] and sum(ac(ac(a,r+dr),c+dc) for dr,dc in moves)>=4:
					a[r][c]=1
					x=1

for n in [int(input())]:

	cand=set()

	for i in range(1000):
		for x,y in ( (0,i),(i,0),(i,1),(-i,0),(-i,1),(0,-i) ):
			if x==0 or x%3!=1:
				if n==len(cand): break
				cand.add((x,y))

	assert len(cand)==n

	for x,y in cand: print(x,y)
",O(1)
"def norm(x):
    return (x % 998244353 + 998244353) % 998244353

n, k = map(int, input().split())

dp1 = [0]
dp2 = [0]

for i in range(n):
    l = [1]
    cur = 0
    for j in range(n + 1):
        cur += l[j]
        if(j > i):
            cur -= l[j - i - 1]
        cur = norm(cur)
        l.append(cur)
    dp1.append(l[n])
    dp2.append(norm(dp1[i + 1] - dp1[i]))

ans = 0
for i in range(n + 1):
    for j in range(n + 1):
        if(i * j < k):
            ans = norm(ans + dp2[i] * dp2[j])

ans = norm(ans * 2)

print(ans)",O(n ^ 3)
"n, m = map(int, input().split())
a = sorted(list(map(int, input().split())))
s = sorted(list(map(int, input().split())))
if a[-1] > s[0]:
    print(-1)
else:
    if a[-1] == s[0]:
        print(sum(a[:-1])*m+sum(s))
    else:
        print(sum(a[:-2])*m+a[-2]*(m-1)+sum(s)+a[-1])
",O(nlogn)
"class Solution(object):
    def elementInNums(self, nums, queries):
        result = []
        for t, i in queries:
            t %= 2*len(nums)
            if t+i < len(nums):
                result.append(nums[t+i])
            elif i < t-len(nums):
                result.append(nums[i])
            else:
                result.append(-1)
        return result",O(n)
"import math

n = int(input())

beacons = {}
sortedKeys = [0]*n

for i in range(n):
    a, b = map(int, input().split(' '))
    sortedKeys[i] = a
    beacons[a] = b

sortedKeys.sort()
maxA = sortedKeys[-1]

sumBeacons = [0]*(maxA+1)
count = 0
for a in range(maxA+1):
    sumBeacons[a] = count

    if a in beacons:
        count += 1

f = [0]*(n+1)
minF = math.inf
for i in range(1, n+1):
    a = sortedKeys[i-1]
    b = beacons[a]
    end = max(0, a-b)
    numDestroyed = sumBeacons[a] - sumBeacons[end]
    f[i] = numDestroyed
    if i-numDestroyed > 0:
        f[i] += f[(i-1)-numDestroyed]

    minF = min(minF, f[i]+n-i)

print(minF)",O(n)
"def raschot(d, e, g, h):
    if d > e:
        return 1
    key = d, g, h
    if key in b:
        return b[key]
    f = 0
    for x in (['0', '1'] if a0[d] == '?' else [a0[d]]):
        if d == e:
            a = [x]
        else:
            a = ['0', '1'] if a0[e] == '?' else [a0[e]]
        for y in a:
            if not ((g and x > y) or (h and x == y == '1')):
                f += raschot(d + 1, e - 1, g and x == y, h and x != y)
    b[key] = f
    return f

n, m = map(int, input().split())
m += 1
a0 = ['?'] * n
for i in range(n):
    a0[i] = '0'
    b = {}
    c = raschot(0, n - 1, True, True)
    if m > c:
        m -= c
        a0[i] = '1'
if a0[0] == '0':
    print(''.join(a0))
else:
    print(-1)
",O(n ^ 3)
"import collections



class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def countPairs(self, root, distance):
        def iter_dfs(distance, root):
            result = 0
            stk = [(1, (root, [collections.Counter()]))]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    if not node.left and not node.right:
                        ret[0][0] = 1
                        continue
                    left, right = [collections.Counter()], [collections.Counter()]
                    stk.append((2, (left, right, ret)))
                    stk.append((1, (node.right, right)))
                    stk.append((1, (node.left, left)))
                else:
                    left, right, ret = params
                    for left_d, left_c in left[0].items():
                        for right_d,right_c in right[0].items():
                            if left_d+right_d+2 <= distance:
                                result += left_c*right_c
                    ret[0] = collections.Counter({k+1:v for k,v in (left[0]+right[0]).items()})
            return result
        
        return iter_dfs(distance, root)",O(n)
"s=input()
s1=input()
l=[]
l1=[]
for x in s :
    l.append(int(x))
for x in s1 :
    l1.append(int(x))
d={}
for x in l :
    d[x]=d.get(x,0)+1
f=False
if len(s1)>len(s) :
    l=sorted(l)
    l=l[::-1]
    print("""".join(map(str,l)))
    exit()
ans=[0]*len(s)

ki=0
i=0
while(i<len(l1)) :
    f=True
    for j in range(max(l1[i],ki),-1,-1) :
        if d.get(j,-1)>0 :
            ans[i]=j
            d[j]-=1
            f=False
            if j!=l1[i] :

                ki=9
            break

    if f :

        for i1 in range(i-1,-1,-1) :
            f1=False
            for j in range(max(l1[i1],ki)-1,-1,-1) :
                if d.get(j,-1)>0 :
                    d[ans[i1]]+=1
                    ans[i1]=j
                    d[j]-=1
                    f1=True
                    i=i1
                    ki=9
                    break
            if f1 :
                break
            else :
                d[ans[i1]]+=1
                ans[i1]=0
    i+=1

print("""".join(map(str,ans)))
",O(n ^ 3)
"n, k = [int(num) for num in input().split(' ')]
string = input()

def fn(string, k):
    maximum_match = 0
    for i in range(1, len(string)):
        if string[:i] == string[-i:]:
            maximum_match = i

    answer = list(string)
    extra = list(string[maximum_match:])
    for i in range(k-1):
        answer.extend(extra)

    return ''.join(answer)

print(fn(string, k))
",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase
import math
from collections import defaultdict, deque
import random

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n, k = map(int, input().split("" ""))
ans = []
for i in range(1, n*k + 1):
    if i%2:
        x,y = divmod(i//2, k)
        ans.append([x+1, y+1])
    else:
        x,y = divmod(n*k-i//2, k)
        ans.append([x + 1, y + 1])
for i in ans:
    sys.stdout.write('{} {}\n'.format(*i))",O(n ^ 2)
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n + 1) for _ in range(3024)]
d = [[] for _ in range(n)]
for i, v in enumerate(b):
    e[v][i] = i
    d[i].append(i)
for v in range(1, 3024):
    for i in range(n):
        j = e[v][i]
        h = e[v][j + 1] if j != -1 else -1
        if j != -1 and h != -1:
            e[v + 1][i] = h
            d[i].append(h)

a = [_ for _ in range(1, n + 1)]
for s in range(n):
    for e in d[s]:
        a[e] = min(a[e], a[s - 1] + 1 if s > 0 else 1)
print(a[n - 1])
",O(n ^ 3)
"class Solution(object):
    def checkZeroOnes(self, s):
        max_cnt = [0]*2
        cnt = 0
        for i in range(len(s)+1):
            if i == len(s) or (i >= 1 and s[i] != s[i-1]):
                max_cnt[int(s[i-1])] = max(max_cnt[int(s[i-1])], cnt)
                cnt = 0
            cnt += 1
        return max_cnt[0] < max_cnt[1]",O(n)
"class Solution:
    def climbStairs(self, n: int) -> int:
        if n == 1:
            return 1

        def matrix_mult(A, B):
            return [[A[0][0] * B[0][0] + A[0][1] * B[1][0],
                     A[0][0] * B[0][1] + A[0][1] * B[1][1]],
                    [A[1][0] * B[0][0] + A[1][1] * B[1][0],
                     A[1][0] * B[0][1] + A[1][1] * B[1][1]]]

        def matrix_pow(M, p):
            result = [[1, 0], [0, 1]]
            base = M

            while p:
                if p % 2 == 1:
                    result = matrix_mult(result, base)
                base = matrix_mult(base, base)
                p //= 2

            return result

        M = [[1, 1], [1, 0]]
        result = matrix_pow(M, n)
        return result[0][0]
",O(logn)
"import collections
from functools import reduce



class Solution2(object):
    def duplicateNumbersXOR(self, nums):
        return reduce(lambda x, y: x^y, (x for x, c in collections.Counter(nums).items() if c == 2), 0)",O(n)
"import os
import sys
from io import BytesIO, IOBase

def main():
    n, m = map(int, input().split())
    a = [list(map(int, input().split())) for i in range(n)]
    ans = []
    le = 0
    ri = int(1e9)

    def check(mid: int) -> bool:
        nonlocal ans
        dic = {}
        for i in range(n):
            bit = 0
            for j in range(m):
                if a[i][j] >= mid:
                    bit += 1
                bit <<= 1
            dic[bit >> 1] = i
        for x, idx in dic.items():
            for y, idy in dic.items():
                if x | y == 2**m-1:
                    ans = idx + 1, idy + 1
                    return True
        return False
    while le <= ri:
        mid = (le + ri) >> 1
        if check(mid):
            le = mid + 1
        else:
            ri = mid - 1
    print(ans[0], ans[1])

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",np
"n=int(input())
print('4 %s'%(n-4) if n%2==0 else '9 %s'%(n-9))",O(1)
"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        n, res = len(nums), nums[0]
        prefix = suffix = 0

        for i in range(n):
            prefix = nums[i] * (prefix or 1)
            suffix = nums[n - 1 - i] * (suffix or 1)
            res = max(res, max(prefix, suffix))
        return res
",O(n)
"import sys,math
from collections import deque,defaultdict
import operator as op
from functools import reduce
from itertools import permutations

I=sys.stdin.readline

def ii():
	return int(I().strip())
def li():
	return list(map(int,I().strip().split()))
def mi():
	return map(int,I().strip().split())

def ncr(n, r, p):

    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
            p - 2, p)) % p

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def valid(row,col,rows,cols,rcross,lcross):
 	return rows[row]==0 and cols[col]==0 and rcross[col+row]==0 and lcross[col-row]==0

def div(n):
	if n==1:
		return 1
	cnt=2
	for i in range(2,int(n**.5)+1):
		if n%i==0:
			if i!=n//i:
				cnt+=2
			else:
				cnt+=1
	return cnt

def isPrime(n):
	if n<=1:
		return False
	elif n<=2:
		return True
	else:
		flag=True
		for i in range(2,int(n**.5)+1):
			if n%i==0:
				flag=False
				break
		return flag

def s(b):
	ans=[]
	while b>0:
		tmp=b%10
		ans.append(tmp)
		b=b//10
	return ans

def main():
	n,k=mi()
	arr=[]
	for _ in range(n):
		x,y=mi()
		arr.append((x,y))

	arr=sorted(arr,key=lambda x: x[0],reverse=True)

	for i in range(n-1):
		for j in range(i+1,n):
			if arr[i][0]==arr[j][0] and arr[i][1]>arr[j][1]:
				arr[i],arr[j]=arr[j],arr[i]

	cnt=arr.count(arr[k-1])
	print(cnt)

if __name__ == '__main__':
	main()",O(nlogn)
"class Solution:
    def climbStairs(self, n: int) -> int:
        cache = [-1] * n
        def dfs(i):
            if i >= n:
                return i == n
            if cache[i] != -1:
                return cache[i]
            cache[i] = dfs(i + 1) + dfs(i + 2)
            return cache[i]

        return dfs(0)
",O(n)
"ch_0={0:[0,1,2],2:[2],1:[1],3:[1,2,3]}
ch_1={0:[3],3:[0],1:[0,3],2:[0,3]}
ch_2={0:[],3:[],2:[1],1:[2]}
N=998244353
n,k=map(int,input().strip().split("" ""))
dp=[[[0]*4 for j in range(k+5)] for i in range(n+5)]
dp[0][1][3]=1
dp[0][1][0]=1
dp[0][2][1]=1
dp[0][2][2]=1

for i in range(1,n):
    for j in range(1,k+1):
        for mask in range(4):
            for t in ch_0[mask]:
                dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j][t])%N
            if j>1:
                for t in ch_1[mask]:
                    dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j-1][t])%N
                if j>2:
                    for t in ch_2[mask]:
                        dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j-2][t])%N
ans=0
for mask in range(4):
    ans=(ans+dp[n-1][k][mask])%N
print(ans)
",np
"def f(x):
	dig, cnt = 1, 9
	ans = 0
	while dig != len(str(x)):
		ans += dig * cnt
		dig += 1
		cnt *= 10
	ans += (x - (cnt // 9) + 1) * dig
	return ans
k = int(input())
l, r = 1, 1000000000000
if k == 1:
    print(1)
    exit(0)
while l < r:
	mid = (l + r + 1) >> 1
	if f(mid) < k:
		l = mid
	else:
		r = mid - 1
k -= f(l)
l += 1
print(str(l)[k - 1])",O(logn)
"import heapq



class Solution(object):
    def minimumDifference(self, nums):
        max_heap = []
        for i in range(len(nums)//3):
            heapq.heappush(max_heap, -nums[i])
        prefix = [0]*(len(nums)//3+1)
        prefix[0] = -sum(max_heap)
        for i in range(len(nums)//3):
            x = -heapq.heappushpop(max_heap, -nums[i+len(nums)//3])
            prefix[i+1] = prefix[i]-x+nums[i+len(nums)//3]

        min_heap = []
        for i in reversed(range(len(nums)//3*2, len(nums))):
            heapq.heappush(min_heap, nums[i])
        suffix = sum(min_heap)
        result = prefix[len(nums)//3]-suffix
        for i in reversed(range(len(nums)//3)):
            x = heapq.heappushpop(min_heap, nums[i+len(nums)//3])
            suffix += -x+nums[i+len(nums)//3]
            result = min(result, prefix[i]-suffix)
        return result",O(nlogn)
"import math
from decimal import Decimal, ROUND_FLOOR

def sum2(s, e):
    return sum1(e) - sum1(s - 1) - (e - s)

def sum1(i):
    return i * (i + 1) / 2

n, k = map(Decimal, input().split())

if(n == 1):
    print(0)
elif(k > n):
    print(1)
elif(sum2(Decimal(2),k) < n):
    print(-1)
else:
    c = 2 * n + k - k * k
    discriminant = (9 - 4 * c).sqrt()
    res1 = int(((3 + discriminant) / 2).to_integral_exact(rounding=ROUND_FLOOR))
    res2 = int(((3 - discriminant) / 2).to_integral_exact(rounding=ROUND_FLOOR))
    res1 = max(res1, res2)
    print(k - res1 + 1);",O(logn)
"import sys
input = sys.stdin.readline

n, a, b = [int(i) for i in input().split()]
h = sorted([int(i) for i in input().split()])
Vasya = h[:b]
Petya = h[b:]
print(Petya[0] - Vasya[-1])
",O(nlogn)
"n = int(input())
a = sorted(map(int, input().split()))

ans = [0]*n
ans[0] = 1
f = ans[0] != a[0]
for i in range(1, n):
    ans[i] = a[i-1]
    if ans[i] != a[i]:
        f = True

m = 10**9
if not f:
    for i in range(n-1, -1, -1):
        if ans[i] < m:
            ans[i] += 1
            break

print(' '.join(map(str, ans)))",O(nlogn)
"n=int(input())

x=1

while n>(10**(len(str(x))-1)*9*len(str(x))):
    n-=10**(len(str(x))-1)*9*len(str(x))

    x*=10

t=len(str(x))
nadighe=False
while nadighe==False:
    qw=1
    nadighe=True
    while n>(10**(len(str(qw))-1)*9*t):
        n-=10**(len(str(qw))-1)*9*t
        nadighe=False
        qw*=10
    x+=qw-1

while n>len(str(x)):
    n-=len(str(x))
    x+=1
for i in range(len(str(x))):
    if n!=0:
        s=str(x)[i]
        n-=1
print(s)
",O(1)
"n,M=map(int,input().split())
a=[0]+[int(x) for x in input().split()]+[M]

t1=[]
t2=[]
for i in range(n+1):
    if i%2==0:
        t1.append(a[i+1]-a[i])
    else:
        t2.append(a[i+1]-a[i])
t2.append(0)

import math
ans=sum(t1)
p=0
q=sum(t2)
for i in range(math.ceil(n/2)):
    p=p+t1[i]
    q=q-t2[i-1]
    ans=max(ans,p+q-1)
print(ans)
",O(n)
"import os
import sys
from io import BytesIO, IOBase
from collections import Counter

def check(a,mid,n,m,z):
    b=Counter()
    for i in range(n):
        c=[""0""]*m
        for j in range(m):
            if a[i][j]>=mid:
                c[j]=""1""
        zz=int("""".join(c),2)
        b[zz]=i
    c=list(b.keys())
    lc=len(c)
    for i in range(lc):
        for j in range(i,lc):
            if c[i]|c[j]==z:
                mi,x,y=10000000000,b[c[i]],b[c[j]]
                for k in range(m):
                    mi=min(mi,max(a[x][k],a[y][k]))
                if mi>=mid:
                    return (x,y)
def main():
    n,m= map(int, input().split())
    a=[list(map(int,input().split())) for _ in range(n)]
    lo,hi,ans,y=0,10**9,[1,1],(1<<m)-1
    while lo<=hi:
        mid=(lo+hi)//2
        z=check(a,mid,n,m,y)
        if z:
            lo=mid+1
            ans=[z[0]+1,z[1]+1]
        else:
            hi=mid-1
    print(*ans)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",np
"def main():
    n = int(input())
    a = list(map(lambda x: int(x), input().split("" "")))
    b = list(map(lambda x: int(x), input().split("" "")))
    now = 0
    ans = []
    h = set()
    for i in range(n):
        count = 0
        while b[i] not in h:
            h.add(a[now])
            now += 1
            count += 1
        ans.append(str(count))
    print("" "".join(ans))

if __name__ == '__main__':
    main()
",O(n)
"class Solution2(object):
    def reverseList(self, head):
        [begin, end] = self.reverseListRecu(head)
        return begin

    def reverseListRecu(self, head):
        if not head:
            return [None, None]

        [begin, end] = self.reverseListRecu(head.__next__)

        if end:
            end.next = head
            head.next = None
            return [begin, head]
        else:
            return [head, head]",O(n)
"n,m = list(map(int,input().split()))
l = []
for i in range(n) :
    s = input()
    l.append(s)
x1=0
x2=0
y1=0
y2=0
for i in range (n) :
    for j in range(m) :
        if l[i][j]=='B' :
            if x1==0 and y1==0 :
                x1,y1 = [i+1,j+1]
            else :
                x2,y2 = [i+1,j+1]
res = []
x=0
y=0
if x2!=0 :
    x = (x2 - x1) // 2
    y = (y2 - y1) // 2
res.append(x1+x)
res.append(y1+y)
print(*res)",O(n ^ 2)
"for _ in range(int(input())):
    n, k = [int(x) for x in input().split()]
    if (n == 2 and k == 3) or (n <= 30 and k > (4 ** n - 1) // 3):
        print('NO')
    else:
        cn = n - 1
        ck = k - 1
        l = 1
        while cn * ck != 0 and ck >= 4 * l - 1:
            ck -= 4 * l - 1
            cn -= 1
            l *= 2
        print('YES', cn)",O(logn)
"string=input()
n=len(string)
check=True
for sub_len in range(n-1,0,-1):
    for starting_index in range(n-sub_len+1):
        if string[starting_index:starting_index+sub_len] in string[starting_index+1:]:
            print(sub_len)
            check=False
            break
    if check==False:
        break
if check:
    print(0)
",O(n ^ 3)
"import sys
import copy

input = sys.stdin.readline

n,m=map(int,input().split())
MAT=[list(map(int,input().split())) for i in range(n)]

if n==1:
    ANS=10**10
    for i in range(1,m):
        if ANS>abs(MAT[0][i]-MAT[0][i-1]):
            ANS=abs(MAT[0][i]-MAT[0][i-1])
    print(ANS)
    sys.exit()

EDGE0=[[10**10]*n for i in range(n)]
EDGE1=[[10**10]*n for i in range(n)]
MAX=0
MIN=0

if m!=1:
    for i in range(n):
        for j in range(n):

            EDGE1[i][j]=EDGE1[j][i]=min([abs(MAT[i][k]-MAT[j][k]) for k in range(m)])

            if EDGE1[i][j]>MAX:
                MAX=EDGE1[i][j]

            EDGE0[i][j]=min([abs(MAT[i][k]-MAT[j][k-1]) for k in range(1,m)])
else:
    for i in range(n):
        for j in range(n):

            EDGE1[i][j]=EDGE1[j][i]=min([abs(MAT[i][k]-MAT[j][k]) for k in range(m)])

            if EDGE1[i][j]>MAX:
                MAX=EDGE1[i][j]

def Hamilton(start,USED,rest,last,weight):

    if MEMO[last*(1<<n)+USED]!=2:
        return MEMO[last*(1<<n)+USED]
    if rest==1:
        for i in range(n):
            if USED & (1<<i)==0:
                final=i
                break

        if EDGE0[start][final]>=weight and EDGE1[last][final]>=weight:

            MEMO[last*(1<<n)+USED]=1
            return 1
        else:

            MEMO[last*(1<<n)+USED]=0
            return 0

    for j in range(n):
        if USED & (1<<j)==0 and EDGE1[last][j]>=weight:

            NEXT=USED+(1<<j)
            if Hamilton(start,NEXT,rest-1,j,weight)==1:

                MEMO[last*(1<<n)+USED]=1
                return 1
    else:

        MEMO[last*(1<<n)+USED]=0
        return 0

while MAX!=MIN:

    aveweight=(MAX+MIN+1)//2

    for start in range(n):
        MEMO=[2]*(n*1<<(n+1))
        START=1<<start
        if Hamilton(start,START,n-1,start,aveweight)==1:
            MIN=aveweight
            break
    else:
        MAX=aveweight-1

print(MAX)
",np
"n=int(input())
a=list(map(int,input().split()))
a.sort()
lose=False
pair=False
for i in range(n-1):
    if a[i]==a[i+1]==0:
        lose=True
    if a[i]==a[i+1]:
        if pair:
            lose=True
        pair=True
        if i>=1:
            if a[i]==a[i-1]+1:
                lose=True
if lose:
    print(""cslnb"")
else:
    eventual=n*(n-1)//2
    curr=sum(a)
    if (curr-eventual)%2==0:
        print(""cslnb"")
    else:
        print(""sjfnb"")",O(nlogn)
"n,m,k = map(int,input().split())
pi = list(map(int,input().split()))
num = 1
ans = 0
i = 0
while i < m:
    temp = (pi[i] - num) // k
    temp2 = i
    i += 1
    while i < m :
        if temp != (pi[i] - num) // k:
            break
        i += 1
    num += (i - temp2)
    ans += 1
print(ans)
",O(n)
"for _ in range(int(input())):
	a, b = map(int, input().split())
	result = 0
	while min(a, b)!=0:
		x = max(a, b)
		y = min(a, b)
		a = x
		b = y
		result+=a//b
		a%=b
	print(result)",O(1)
"n,m=map(int,input().split())
c=input().split()
col=[0]*n
for i in range(len(c)):
    col[int(c[i])-1]+=1
print(min(col))",O(n ^ 2)
"import random



class Solution(object):
    def outerTrees(self, trees):
        def dist(a, b):
            return ((a[0]-b[0])**2 + (a[1]-b[1])**2)**0.5

        def inside(c, p):
            return dist(c[0], p) < c[1]+EPS

        def circle_center(bx, by, cx, cy):
            B = bx*bx + by*by
            C = cx*cx + cy*cy
            D = bx*cy - by*cx
            return [float(cy*B - by*C)/(2*D),
                    float(bx*C - cx*B)/(2*D)]

        def circle_from_2_points(A, B):
            C = [(A[0]+B[0])/2.0, (A[1]+B[1])/2.0]
            return [C, dist(A, B)/2.0]

        def circle_from_3_points(A, B, C):
            I = circle_center(B[0]-A[0], B[1]-A[1],
                              C[0]-A[0], C[1]-A[1])
            I[0] += A[0]
            I[1] += A[1]
            return [I, dist(I, A)]

        def trivial(boundaries): 
            if not boundaries:
                return None
            if len(boundaries) == 1:
                return [boundaries[0], 0.0]
            if len(boundaries) == 2:
                return circle_from_2_points(boundaries[0], boundaries[1])
            return circle_from_3_points(boundaries[0], boundaries[1], boundaries[2])

        def Welzl(points, boundaries, curr):
            if curr == len(points) or len(boundaries) == 3:
                return trivial(boundaries)
            result = Welzl(points, boundaries, curr+1)
            if result is not None and inside(result, points[curr]):
                return result
            boundaries.append(points[curr])
            result = Welzl(points, boundaries, curr+1)
            boundaries.pop()
            return result

        EPS = 1e-5
        random.seed(0)
        random.shuffle(trees)
        result = Welzl(trees, [], 0)
        return result[0][0], result[0][1], result[1]",O(n)
"n,m = map(int,input().split())
li = [[j for j in input()] for i in range(n)]
position1=0
position2=0
position3=0
position4=0
for j in range(m):
    flag = False
    for i in range(n):
        if li[i][j] == ""B"":
            flag = True
            position1 = i
            break
    if(flag == True):
        break
for j in range(m-1,-1,-1):
    flag = False
    for i in range(n-1,-1,-1):
        if li[i][j] == ""B"":
            flag = True
            position2 = i
            break
    if(flag == True):
        break
for i in range(n):
    flag = False
    for j in range(m):
        if li[i][j] == ""B"":
            flag = True
            position3 = j
            break
    if(flag == True):
        break
for i in range(n-1,-1,-1):
    flag = False
    for j in range(m-1,-1,-1):
        if li[i][j] == ""B"":
            flag = True
            position4 = j
            break
    if(flag == True):
        break

avg1 = (position1+position2)//2 + 1
avg2 = (position3 + position4)//2 + 1
print(avg1,avg2)
",O(n ^ 2)
"import math
s1=input()
s2=input()
dist=0
pos=0
unrecognized=0
for i in s1:
	if i ==""+"":
		dist+=1
	else:
		dist-=1

for i in s2:
	if i ==""+"":
		pos+=1
	elif i==""-"":
		pos-=1
	elif i==""?"":
		unrecognized+=1
difference=dist-pos

if abs(difference)>abs(unrecognized):
	print(""{0:.9f}"".format(float(0)))
else:
	extra=unrecognized-abs(difference)
	perm_extra=1
	for i in range(1,unrecognized+1):
			perm_extra=perm_extra*i
	perm_extra=perm_extra/(math.factorial(extra/2+(unrecognized-extra))*math.factorial(extra/2))
	if extra%2!=0:
		print(""{0:.9f}"".format(float(0)))
	else:
		print(""{0:.9f}"".format(float(perm_extra*(0.5**unrecognized))))
",np
"class Solution(object):
    def stoneGameVII(self, stones):
        def score(i, j):
            return prefix[j+1]-prefix[i]

        prefix = [0]
        for stone in stones:
            prefix.append(prefix[-1]+stone)
        dp = [[0 for _ in range(len(stones))] for _ in range(2)]
        for i in reversed(range(len(stones))):
            for j in range(i+1, len(stones)):
                dp[i%2][j] = max(score(i+1, j)-dp[(i+1)%2][j], score(i, j-1)-dp[i%2][j-1])
        return dp[0][-1]",O(n ^ 2)
"import math
import copy
def dtb(n):
    return bin(n).replace(""0b"","""")
def btd(n):
    return int(n,2)
t=1
for k in range(t):
    n,kk=map(int,input().split())
    a=list(map(int,input().split()))[:n]
    c=copy.copy(a)
    a.sort(reverse=True)
    b=[]
    f=[]
    ans=0
    for i in range(kk):
        ans+=a[i]
        b.append(a[i])
    count=1
    x=0
    y=0
    for i in range(n):
        if len(f)==(kk-1):
            y=i
            break
        if c[i] in b:
            f.append(i-x+1)
            x=i+1
            b.remove(c[i])

    f.append(n-y)
    print(ans)
    for i in f:
        print(i,end="" "")
",O(nlogn)
"class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def swimInWater(self, grid):
        n = len(grid)
        positions = [None] * (n**2)
        for i in range(n):
            for j in range(n):
                positions[grid[i][j]] = (i, j)
        directions = ((-1, 0), (1, 0), (0, -1), (0, 1))

        union_find = UnionFind(n**2)
        for elevation in range(n**2):
            i, j = positions[elevation]
            for direction in directions:
                x, y = i+direction[0], j+direction[1]
                if 0 <= x < n and 0 <= y < n and grid[x][y] <= elevation:
                    union_find.union_set(i*n+j, x*n+y)
                    if union_find.find_set(0) == union_find.find_set(n**2-1):
                        return elevation
        return n**2-1",O(n ^ 2)
"from sys import stdin, stdout

get_string = lambda: stdin.readline().strip('\n')
get_intmap = lambda: map( int, get_string().split(' ') )

def testcase():
    n, M = get_intmap()
    a = [0] + list(get_intmap()) + [M]
    ontime = [0] * (n + 1)
    tmp = 0
    for ind in range(n, -1, -1):
        if ind %2 == 0:
            tmp += a[ind + 1] - a[ind]
        ontime[ind] = tmp
    mx = ontime[0]

    for ind in range(n + 1):
        l,r = a[ind], a[ind+1]
        if r - l <= 1: continue
        for x in (l+1, r-1):
            newtime = ontime[0] - ontime[ind]
            if ind % 2 == 0:
                newtime += x - l
            else:
                newtime += r - x
            newtime += (M - r) - ontime[ind]
            mx = max(mx, newtime)
    print(mx)

testcase();quit()
for t in range(int(input())):
    testcase()
",O(n)
"s = input()
n = len(s)
m = n - 1;
while m > 0:
    find = False
    for i in range(0, n - m):
        for j in range(i + 1, n - m + 1):
            match = True
            for k in range(0, m):
                if s[i+k] != s[j+k]:
                    match = False
                    break
            if match:
                find = True
                break
        if find:
            break
    if find:
        break
    m -= 1
print(m)
",O(n ^ 3)
"class Solution(object):
    def secondHighest(self, s):
        first = second = -1
        for c in s:
            if not c.isdigit():
                continue
            d = int(c)
            if d > first:
                first, second = d, first
            elif first > d > second:
                second = d
        return second",O(n)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        pass



class Solution(object):
    def splitCircularLinkedList(self, list):
        head1 = list
        slow, fast = head1, head1.__next__
        while head1  != fast.__next__:
            slow = slow.__next__
            fast = fast.next.__next__ if head1 != fast.next.__next__ else fast.__next__
        head2 = slow.__next__
        slow.next, fast.next = head1, head2
        return [head1, head2]",O(n)
"def check(num):
    l = list(str(num))
    l = list(dict.fromkeys(l))
    if l==['4', '7'] or l==['7', '4'] or l==['4'] or l==['7']: return True
    else: return False

lucky = False
n = int(input())
for i in range(3, n+1):
    if n%i==0 and check(i): lucky=True
print(""YES"" if lucky else ""NO"")",O(1)
"import collections



class Solution(object):
    def maxSum(self, nums, m, k):
        lookup = collections.Counter()
        result = curr = left = 0
        for right in range(len(nums)):
            curr += nums[right]
            lookup[nums[right]] += 1
            if right-left+1 == k+1:
                lookup[nums[left]] -= 1
                if lookup[nums[left]] == 0:
                    del lookup[nums[left]]
                curr -= nums[left]
                left += 1
            if right-left+1 == k and len(lookup) >= m:
                result = max(result, curr)
        return result",O(n)
"import math

def solve(n) :
    if not n%2 and math.sqrt(n//2) == int(math.sqrt(n//2)) :
        print('YES')
        return
    if not n%4 and math.sqrt(n//4) == int(math.sqrt(n//4)) :
        print('YES')
        return
    print('NO')

t = int(input())
for i in range(t) :
    n = int(input())
    solve(n)",O(1)
"n=int(input())
if n==1:
    print(1)
else:
    p=list(map(int,input().split()))
    children=[]
    for i in range(n):
        children.append([])
    for i in range(n-1):
        children[p[i]-1].append(i+1)
    layers=[1]+[0]*(n-1)
    layer=[0]
    num=2
    bylayer=[]
    while len(layer)>0:
        bylayer.append(layer)
        newlayer=[]
        for vert in layer:
            for child in children[vert]:
                layers[child]=num
                newlayer.append(child)
        layer=newlayer
        num+=1
    bylayer=bylayer[::-1]
    count=[0]*n
    for layer in bylayer:
        for vert in layer:
            if children[vert]==[]:
                count[vert]=1
            else:
                count[vert]=sum(count[v] for v in children[vert])
    count.sort()
    out=""""
    for guy in count:
        out+=str(guy)+"" ""
    print(out)",O(n ^ 2)
"class Solution:
    def minMeetingRooms(self, intervals: List[Interval]) -> int:
        intervals.sort(key=lambda x: x.start)
        min_heap = []

        for interval in intervals:
            if min_heap and min_heap[0] <= interval.start:
                heapq.heappop(min_heap)
            heapq.heappush(min_heap, interval.end)

        return len(min_heap)
",O(nlogn)
"import sys
import math
def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def minput():   return map(int, sys.stdin.readline().strip().split())
def listinput(): return list(map(int, sys.stdin.readline().strip().split()))
n,m=minput()
x=listinput()
y=listinput()
xx=set(x)
yy=set(y)
common=xx.intersection(yy)
for i in x:
    if i in common:
        print(i,end=' ')",O(n ^ 2)
"n,s=list(map(int,input().split()))
if n-sum([int(x) for x in str(n)])<s:
    print(0)
else:
    def check(n):

        return (n-sum([int(x) for x in str(n)]))>=s
    start=1
    end=n
    mid=(start+end)//2
    while mid !=end and mid!=start:

        if check(mid):
            end=mid
            mid=(start+end)//2
        else:
            start=mid
            mid = (start + end) // 2

    print(n-end+1)
",O(logn)
"import sys
sys.setrecursionlimit(1000)

def estimate(a):
    return int(((n - a) * (n + 1 - a)) / 2) - a

def dicho(lower, upper, target):
    if estimate(lower) == target:
        return lower
    elif estimate(upper) == target:
        return upper
    else:
        mid = (int)((lower + upper) / 2)
        if(estimate(mid) < target):
            upper = mid
        else:
            lower = mid
        return dicho(lower, upper, target)

n, k = map(int, input().split())
lower = 0
upper = n
print(dicho(lower, upper, k))
",O(logn)
"N, K = list(map(int, input().split()))
S = input().strip()
S = [-1 if _ == '?' else ord(_) - ord('a') for _ in S]

def check(x):
    p = [[N for i in range(N+1)] for k in range(K)]

    for k in range(K):
        keep = 0
        for i in range(N-1, -1, -1):
            keep += 1
            if S[i] != -1 and S[i] != k:
                keep = 0
            p[k][i] = p[k][i+1]
            if keep >= x:
                p[k][i] = i + x - 1

    d = [N for s in range(1<<K)]
    d [0] = -1
    for s in range(1, 1<<K):
        for k in range(K):
            if (s&(1<<k)) and (d[s^(1<<k)]<N):
                d[s] = min(d[s], p[k][d[s^(1<<k)]+1])

    return d[(1<<K)-1] < N

l, r = 0, N//K

while l < r:
    mid = (l + r + 1) // 2
    if check(mid):
        l = mid
    else:
        r = mid - 1
print(l)
",np
"from os import path
import sys
from heapq import heappush,heappop
from functools import cmp_to_key as ctk
from collections import deque,defaultdict as dd
from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right
from itertools import permutations
from datetime import datetime
from math import ceil,sqrt,log,gcd
def ii():return int(input())
def si():return input().rstrip()
def mi():return map(int,input().split())
def li():return list(mi())
abc='abcdefghijklmnopqrstuvwxyz'

mod=998244353
inf = float(""inf"")
vow=['a','e','i','o','u']
dx,dy=[-1,1,0,0],[0,0,1,-1]

def bo(i):
    return ord(i)-ord('a')

def sod(n):
    s = 0
    while n:
        s += (n%10)
        n //= 10
    return s

def solve():

    n,s = mi()

    def fun(mid):
        return mid - sod(mid) >= s

    l = 0
    r = n
    ans = -1
    while l <= r:
        m = l+(r-l)//2
        if fun(m):
            ans = m
            r = m-1
        else:
            l = m+1
    if ans == -1:
        ans = n+1
    print(n-ans+1)

if __name__ ==""__main__"":

    if path.exists('input.txt'):
        sys.stdin=open('input.txt', 'r')
        sys.stdout=open('output.txt','w')
    else:
        input=sys.stdin.readline
    solve()",O(logn)
"class Solution(object):

    def __init__(self, big, medium, small):
        self.__space = [0, big, medium, small]

    def addCar(self, carType):
        if self.__space[carType] > 0:
            self.__space[carType] -= 1
            return True
        return False",O(1)
"class Solution(object):
    def goodBinaryStrings(self, minLength, maxLength, oneGroup, zeroGroup):
        MOD = 10**9+7
        result = 0
        w = max(oneGroup, zeroGroup)+1
        dp = [0]*w
        dp[0] = 1
        for i in range(maxLength+1):
            if i >= minLength:
                result = (result+dp[i%w])%MOD
            if i+oneGroup <= maxLength:
                dp[(i+oneGroup)%w] = (dp[(i+oneGroup)%w]+dp[i%w])%MOD
            if i+zeroGroup <= maxLength:
                dp[(i+zeroGroup)%w] = (dp[(i+zeroGroup)%w]+dp[i%w])%MOD
            dp[i%w] = 0
        return result",O(n)
"class Solution(object):
    def findPeakElement(self, nums):
        left, right = 0, len(nums) - 1

        while left < right:
            mid = left + (right - left) / 2
            if nums[mid] > nums[mid + 1]:
                right = mid
            else:
                left = mid + 1

        return left",O(logn)
"def maximum_candies_after_n_movies(n):
    return n * (n + 1) // 2

def solve1():
    n,k = list(map(lambda x: int(x), input().split()))
    m = maximum_candies_after_n_movies(n)
    current_candies = n
    eaten_candies = 0
    while m != k:
        m = m - current_candies - 1
        current_candies -= 1
        eaten_candies += 1

    print(eaten_candies)

def solve():
    n, k = list(map(lambda x: int(x), input().split()))
    upper_bound = n
    lower_bound = 0
    while upper_bound > lower_bound:
        if upper_bound == lower_bound + 1:
            u_c = maximum_candies_after_n_movies(upper_bound)
            if u_c == k:
                print(n - upper_bound)
                break

        middle = (upper_bound + lower_bound) // 2
        m_candies = maximum_candies_after_n_movies(middle) - (n - middle)
        if m_candies == k:
            print(n - middle)
            break
        elif m_candies < k:
            lower_bound = middle
        else :
            upper_bound = middle

solve()
",O(logn)
"from collections import Counter
ts=Counter(''.join(reversed(t)) for t in input().split())
t0 = None
run = 0
ans = 3
for t, c in sorted(ts.items()):
    if t0 is None or t[0] != t0[0] or int(t[1]) != int(t0[1])+1:
        run = 0
    t0 = t
    run += 1
    ans = min(ans, 3-max(c,run))
for s in 'spm':
    for r in range(1, 10):
        if s+str(r-1) in ts and s+str(r+1) in ts:
            ans = min(ans, 1)
print(ans)
",O(nlogn)
"def f(a, b):
    global ans
    maks = max(a, b)
    mins = min(a, b)
    ans += (maks//mins)

    if (mins == 1):
        return ans
    else:
        if (maks % mins == 0):
            return ans
        else:
            return f(maks%mins, mins)
for i in range(int(input())):
    a, b = list(map(int, input().split()))
    ans = 0
    print(f(a, b))",O(1)
"n=int(input());
if n % 2 == 0:

    print((n-4),"" 4"")
else:

    print((n-9),"" 9"")
",O(1)
"class Solution(object):
    def arrayRankTransform(self, arr):
        return list(map({x: i+1 for i, x in enumerate(sorted(set(arr)))}.get, arr))",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase

def main():
    l,r=map(int,input().split("" ""))
    n=len(bin(r)[2:])
    ans=0
    for x in range(0,n+1):
        if (r>>x)&1==1 and (l>>x)&1==0:
            ans=max(ans,(1<<x)^((1<<x)-1))
    print(ans)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(logn)
"n,m = map(int,input().split())
x = input().split()
t = input().split()
r = [0]*n
d = [0]*m
countr = 0
countd = 0
for i in range(n+m):
    if int(t[i]) == 1:
        d[countd] = int(x[i])
        countd += 1
    else:
        r[countr] = int(x[i])
        countr += 1
current = 0
count = [0]*m
for i in range(n):
    while current < m-1:
        if d[current+1] >= r[i]:
            break
        current += 1
    if current == m-1:
        count[m-1] += (n-i)
        break
    if 2*r[i] <= (d[current]+d[current+1]):
        count[current] += 1
    else:
        count[current+1] += 1
s = """"
for i in range(m):
    s += str(count[i])+"" ""
print(s[:-1])
",O(nlogn)
"print(sum(i for i in range(int(input()),-1,-2)))",O(n)
"class Solution(object):
    def isIsomorphic(self, s, t):
        if len(s) != len(t):
            return False

        s2t, t2s = {}, {}
        for p, w in zip(s, t):
            if w not in s2t and p not in t2s:
                s2t[w] = p
                t2s[p] = w
            elif w not in s2t or s2t[w] != p:
                return False
        return True",O(n)
"class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        maxArea = 0

        for i in range(n):
            height = heights[i]

            rightMost = i + 1
            while rightMost < n and heights[rightMost] >= height:
                rightMost += 1

            leftMost = i
            while leftMost >= 0 and heights[leftMost] >= height:
                leftMost -= 1

            rightMost -= 1
            leftMost += 1
            maxArea = max(maxArea, height * (rightMost - leftMost + 1))
        return maxArea
",O(n ^ 2)
"class Solution(object):
    def maxScore(self, nums, x):
        dp = [float(""-inf"")]*2
        dp[nums[0]%2] = nums[0]
        for i in range(1, len(nums)):
            dp[nums[i]%2] = max(dp[nums[i]%2], dp[(nums[i]+1)%2]-x)+nums[i]
        return max(dp)",O(n)
"def pow(n):
    if(n > 0):
        if(n % 2 == 0):
            x = pow(n // 2) % 1000000007
            return (x * x) % 1000000007
        else: return (pow(n - 1) * 2)% 1000000007
    else:
        return 1

n, k = map(int, input().split())
if(n == 0): print(0)
else: print((pow(k) * (2 * n - 1) + 1) % 1000000007)
",O(logn)
"import math


class Solution(object):
    def getPermutation(self, n, k):
        seq, k, fact = """", k - 1, math.factorial(n - 1)
        perm = [i for i in range(1, n + 1)]
        for i in reversed(range(n)):
            curr = perm[k / fact]
            seq += str(curr)
            perm.remove(curr)
            if i > 0:
                k %= fact
                fact /= i
        return seq",O(n ^ 2)
"import sys
input = sys.stdin.readline

def inlt():
    return(list(map(int,input().split())))
def insr():
    s = input()
    return(list(s[:len(s) - 1]))
def cint(c):
    return ord(c) - 96

def find_min_weight(n, k, stages):
    n = len(stages)
    min_weight = float('inf')

    def backtrack(s, w, t):
        nonlocal min_weight

        if t >= k:
            min_weight = min(min_weight, w)
            return

        if s >= n - 1:
            return

        for i in range(s+1, n, 1):
            if stages[i] - stages[s] > 1:
                backtrack(i, w+stages[i], t+1)

    backtrack(0, stages[0], 1)

    if min_weight == float('inf'):
        return -1

    return min_weight

n, k = inlt()
stages = list(set(map(cint, insr())))
stages.sort()
print(find_min_weight(n, k, stages))
",O(n)
"x=list(map(int,input().split()))
pos=x[1]
n=x[0]
l=x[2]
r=x[3]
step=0
if pos<l :
    step=l-pos+1

    if r< n :
        step+=r-l+1
elif pos>r:
    step=pos-r+1

    if l> 1 :
        step+=r-l+1
else:
    if l>1 and n>r:
        step+=min(pos-l,r-pos)+r-l+2
    elif l==1 and n>r:
        step=r-pos+1
    elif l>1 and n==r:
        step+=pos-l+1
    else:
        step=0

print(step)",O(1)
"from bisect import bisect_right,bisect_left
n,c_tv,c_es=map(int,input().split())
start=[]
end=[]
add=0
for _ in range(n):
    l,r=map(int,input().split())
    add+=(r-l)
    start.append(l)
    end.append(r)
start.sort()
end.sort()
ans=add*c_es+n*c_tv
M=10**9+7
v=[0]*(n+1)
for i in range(n):
    indx=bisect_left(end,start[i])-1
    k=indx
    while k>=0 and (start[i]-end[k])*c_es<c_tv and v[k]==1:
        k-=1
    if k==-1:
        continue
    if (start[i]-end[k])*c_es<c_tv:
        ans-=c_tv-(start[i]-end[k])*c_es
        v[k]=1
print(ans%M)",O(nlogn)
"import collections


class Solution(object):
    def pathSum(self, root, sum):
        def pathSumHelper(root, curr, sum, lookup):
            if root is None:
                return 0
            curr += root.val
            result = lookup[curr-sum] if curr-sum in lookup else 0
            lookup[curr] += 1
            result += pathSumHelper(root.left, curr, sum, lookup) + \
                      pathSumHelper(root.right, curr, sum, lookup)
            lookup[curr] -= 1
            if lookup[curr] == 0:
                del lookup[curr]
            return result

        lookup = collections.defaultdict(int)
        lookup[0] = 1
        return pathSumHelper(root, 0, sum, lookup)",O(n)
"import random



class Solution(object):
    def putMarbles(self, weights, k):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        for i in range(len(weights)-1):
            weights[i] += weights[i+1]
        weights.pop()
        result = 0
        nth_element(weights, (k-1)-1, compare=lambda a, b: a > b)
        result += sum(weights[i] for i in range(k-1))
        nth_element(weights, (k-1)-1)
        result -= sum(weights[i] for i in range(k-1))
        return result",O(n)
"import math
k = int(input())

def cnt_digit_order(X):
    res = 0
    if X == 0:
        return 0
    for i in range(1, X+1):
        res += i*(9*pow(10, i-1))
    return res

L = -1
leftcnt = 0
for length in range(1, 100):
    if cnt_digit_order(length - 1) < k <= cnt_digit_order(length):
        L = length
        leftcnt = k - cnt_digit_order(length - 1)
        break

M = str(math.ceil(leftcnt/L) + (10**(L-1) - 1))
leftcnt -= 1
leftcnt %= L
print(M[leftcnt])
",O(logn)
"N, M, K = map(int, raw_input().split())
A = [int(a) for a in raw_input().split()]
S = [0]
for a in A:
    S.append(S[-1]+M*a-K)
MI = [(10**50)] * M
ans = 0
for i in range(N+1):
    MI[i%M] = min(MI[i%M], S[i])
    for j in range(M):
        ans = max(ans, (S[i]-MI[(i-j)%M] - K*((-j)%M))//M)
print(ans)
",O(n ^ 2)
"import sys
import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

from collections import defaultdict

n, a, b = map(int, input().split())
XV = []
for i in range(n):
    x, vx, vy = map(int, input().split())
    XV.append((x, vx, vy))
if a != 0:
    ans = 0
    d = defaultdict(lambda:0)
    dvx = defaultdict(lambda:0)
    dvy = defaultdict(lambda:0)
    dvxy = defaultdict(lambda:0)
    for x, vx, vy in XV:
        k = -a*vx+vy
        ans += max(0, d[k]-(dvx[(k, vx)]+dvy[(k, vy)]-dvxy[(k, vx, vy)]))
        d[k] += 1
        dvx[(k, vx)] += 1
        dvy[(k, vy)] += 1
        dvxy[(k, vx, vy)] += 1
    print(ans*2)
else:
    ans = 0
    d = defaultdict(lambda:defaultdict(lambda:0))
    ds = defaultdict(lambda:0)
    for x, vx, vy in XV:
        ans += max(0, ds[vy]-d[vy][vx])
        d[vy][vx] += 1
        ds[vy] += 1
    print(ans*2)
",O(n)
"from collections import defaultdict as dd
from collections import deque, Counter
import bisect
import heapq
from math import inf

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def ri():
    return int(input())

def rl():
    return list(map(int, input().split()))

n, m = rl()
aa = rl()

bb = [-1]*n
for i in range(n):
	if aa[i] == m:
	    bb[i] = 1
	elif aa[i] < m:
	    bb[i] = -1
	else:
	    bb[i] = 1

prefix_sum= [0]*(n+1)
for i in range(1, n+1):
    prefix_sum[i] = bb[i-1] + prefix_sum[i-1]

def mergeSortGoodOrder(arr):

    if len(arr) == 1:
        return arr, 0
    else:
        a = arr[:len(arr)//2]
        b = arr[len(arr)//2:]

        a, ai = mergeSortGoodOrder(a)
        b, bi = mergeSortGoodOrder(b)
        c = []

        i = 0
        j = 0
        good = 0 + ai + bi

    while i < len(a) and j < len(b):
        if a[i] < b[j]:
            c.append(a[i])
            i += 1
            good += (len(b)-j)
        else:
            c.append(b[j])
            j += 1

    c += a[i:]
    c += b[j:]

    return c, good

idx = 0
for i in range(n):
    if aa[i] == m:
        idx = i

_, good = mergeSortGoodOrder(prefix_sum)

_, bad_left = mergeSortGoodOrder(prefix_sum[:idx + 1])

_, bad_right = mergeSortGoodOrder(prefix_sum[idx + 1:])

first_count = good - bad_left - bad_right

bb = [-1]*n
for i in range(n):
	if aa[i] == m + 1:
	    bb[i] = 1
	elif aa[i] < m + 1:
	    bb[i] = -1
	else:
	    bb[i] = 1

prefix_sum= [0]*(n+1)
for i in range(1, n+1):
    prefix_sum[i] = bb[i-1] + prefix_sum[i-1]

_, good = mergeSortGoodOrder(prefix_sum)

_, bad_left = mergeSortGoodOrder(prefix_sum[:idx + 1])

_, bad_right = mergeSortGoodOrder(prefix_sum[idx + 1:])

second_count = good - bad_left - bad_right

ans   = first_count - second_count

print(ans)
",O(nlogn)
"n=int(input())
ns=[]
for i in range(n):
    s=input()
    ns.append(s)
ns2=[]
for i in range(n):
    s=input()
    ns2.append(s)

def rotate(i,j):
    return j,n-1-i
def flip(i,j):
    return j,i

def main():
    same=True
    for i in range(n):
        for j in range(n):
            if ns[i][j]!=ns2[i][j]:
                same=False
                break
        if same==False:
            break
    if same:
        return True

    same=True
    for i in range(n):
        for j in range(n):
            a, b = rotate(i, j)
            if ns[i][j] != ns2[a][b]:
                same = False
                break
        if same == False:
            break
    if same:
        return True

    same=True
    for i in range(n):
        for j in range(n):
            a, b = rotate(i, j)
            a, b = rotate(a, b)
            if ns[i][j] != ns2[a][b]:
                same = False
                break
        if same == False:
            break
    if same:
        return True

    same=True
    for i in range(n):
        for j in range(n):
            a, b = rotate(i, j)
            a, b = rotate(a, b)
            a, b = rotate(a, b)
            if ns[i][j] != ns2[a][b]:
                same = False
                break
        if same == False:
            break
    if same:
        return True

    same=True
    for i in range(n):
        for j in range(n):
            a,b=flip(i,j)
            if ns[a][b]!=ns2[i][j]:
                same=False
                break
        if same==False:
            break
    if same:
        return True

    same=True
    for i in range(n):
        for j in range(n):
            a, b = rotate(i, j)
            a, b = flip(a, b)
            if ns[i][j] != ns2[a][b]:
                same = False
                break
        if same == False:
            break
    if same:
        return True

    same=True
    for i in range(n):
        for j in range(n):
            a, b = rotate(i, j)
            a, b = rotate(a, b)
            a, b = flip(a, b)
            if ns[i][j] != ns2[a][b]:
                same = False
                break
        if same == False:
            break
    if same:
        return True

    same=True
    for i in range(n):
        for j in range(n):
            a, b = rotate(i, j)
            a, b = rotate(a, b)
            a, b = rotate(a, b)
            a, b = flip(a, b)
            if ns[i][j] != ns2[a][b]:
                same = False
                break
        if same == False:
            break
    if same:
        return True
    else:
        return False

if main():
    print('Yes')
else:
    print('No')
",O(n ^ 2)
"import bisect



class Solution4(object):
    def findMaximumLength(self, nums):
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        dp = [float(""inf"")]*(len(nums)+1)
        dp[0] = 0
        prev = [-1]*(len(nums)+1)
        left = -1
        for right in range(len(nums)):
            left = max(left, prev[right])
            dp[right+1] = dp[left+1]+1
            next_right = bisect.bisect_left(prefix, prefix[right+1]+(prefix[right+1]-prefix[left+1]))-1
            prev[next_right] = right
        return dp[-1]",O(nlogn)
"class Solution:
    def findMin(self, nums: List[int]) -> int:
        return min(nums)
",O(n)
"class Solution2(object):
    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):
        x1 -= x_center
        y1 -= y_center
        x2 -= x_center
        y2 -= y_center        
        x = min(abs(x1), abs(x2)) if x1*x2 > 0 else 0
        y = min(abs(y1), abs(y2)) if y1*y2 > 0 else 0
        return x**2 + y**2 <= radius**2",O(1)
"class Solution(object):
    def addStrings(self, num1, num2):
        result = []
        i, j, carry = len(num1) - 1, len(num2) - 1, 0

        while i >= 0 or j >= 0 or carry:
            if i >= 0:
                carry += ord(num1[i]) - ord('0')
                i -= 1
            if j >= 0:
                carry += ord(num2[j]) - ord('0')
                j -= 1
            result.append(str(carry % 10))
            carry /= 10
        result.reverse()

        return """".join(result)

    def addStrings2(self, num1, num2):
        length = max(len(num1), len(num2))
        num1 = num1.zfill(length)[::-1]
        num2 = num2.zfill(length)[::-1]
        res, plus = '', 0
        for index, num in enumerate(num1):
            tmp = str(int(num) + int(num2[index]) + plus)
            res += tmp[-1]
            if int(tmp) > 9:
                plus = 1
            else:
                plus = 0
        if plus:
            res += '1'
        return res[::-1]",O(n)
"m = int(input())
values = []
idx = []
for i in range(m):
    x = int(input())
    ans = 0
    for j,xx in enumerate(values):
        if (xx^x) < x:
            x^=xx
            ans^=idx[j]
    if x == 0:
        anss = []
        for j in range(i):
            if (ans&1)!=0:
                anss.append(j)
            ans>>=1
        print(len(anss),*anss)
    else:
        print(0)
        values.append(x)
        idx.append(ans^(2**i))
",np
"n=int(input())+1
if n<2:
    print(0)
elif n%2==0:
    print(n//2)
else:
    print(n)",O(1)
"import sys

input = sys.stdin.readline

r, g, b = map(int, input().split())
sticks, dp, ans = [sorted([int(i) for i in input().split()], reverse = True) for j in range(3)], [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)], 0

for i in range(r + 1):
    for j in range(g + 1):
        for k in range(b + 1):
            ans = max(ans, dp[i][j][k])
            if i < r and j < g:
                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + sticks[0][i] * sticks[1][j])
            if i < r and k < b:
                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + sticks[0][i] * sticks[2][k])
            if j < g and k < b:
                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + sticks[1][j] * sticks[2][k])
print(ans)
",O(n ^ 3)
"class Solution(object):
    def prevPermOpt1(self, A):
        for left in reversed(range(len(A)-1)):
            if A[left] > A[left+1]:
                break
        else:
            return A
        right = len(A)-1
        while A[left] <= A[right]:
            right -= 1
        while A[right-1] == A[right]:
            right -= 1
        A[left], A[right] = A[right], A[left]
        return A",O(n)
"n, K = map(int, input().split())
dp = [[[0] * 4 for j in range(K + 2)] for i in range(n)]
MOD = 998244353
dp[0][1][0] = 1
dp[0][1][1] = 1
dp[0][2][2] = 1
dp[0][2][3] = 1
for i in range(n - 1):
    for j in range(1, K + 1):
        if j < K + 1:
            for k in range(4):
                    dp[i + 1][j][k] += dp[i][j][k]
                    dp[i + 1][j][k] %= MOD

            for k in range(2):
                dp[i + 1][j][k] += dp[i][j][2]
                dp[i + 1][j][k] %= MOD

            for k in range(2):
                dp[i + 1][j][k] += dp[i][j][3]
                dp[i + 1][j][k] %= MOD

    for j in range(1, K):
        for k in range(4):
            if k != 0:
                dp[i + 1][j + 1][k] += dp[i][j][0]
                dp[i + 1][j + 1][k] %= MOD

        for k in range(4):
            if k != 1:
                dp[i + 1][j + 1][k] += dp[i][j][1]
                dp[i + 1][j + 1][k] %= MOD

        if j + 2 < K + 1:
            dp[i + 1][j + 2][2] += dp[i][j][3]
            dp[i + 1][j + 2][2] %= MOD
            dp[i + 1][j + 2][3] += dp[i][j][2]
            dp[i + 1][j + 2][3] %= MOD

num = 0
for i in range(4):
    num += dp[n - 1][K][i]
    num %= MOD

print(num)",np
"from collections import Counter


class Solution(object):
    def removeDuplicateLetters(self, s):
        remaining = Counter(s)

        in_stack, stk = set(), []
        for c in s:
            if c not in in_stack:
                while stk and stk[-1] > c and remaining[stk[-1]]:
                    in_stack.remove(stk.pop())
                stk += c
                in_stack.add(c)
            remaining[c] -= 1
        return """".join(stk)",O(n)
"class Solution(object):
    def minimumReplacement(self, nums):
        def ceil_divide(a, b):
            return (a+b-1)//b

        result = 0
        curr = nums[-1]
        for x in reversed(nums):
            cnt = ceil_divide(x, curr)
            result += cnt-1
            curr = x//cnt
        return result",O(n)
"q = int(input())
b = []
for m in range(q):
    n, k = map(int, input().split())
    l = input()
    k1 = 'R'
    k2 = 'G'
    k3 = 'B'
    for i in range(1, k):
        if k1[i - 1] == 'R':
            k1 = k1 + 'G'
        if k1[i - 1] == 'G':
            k1 = k1 + 'B'
        if k1[i - 1] == 'B':
            k1 = k1 + 'R'
        if k2[i - 1] == 'R':
            k2 = k2 + 'G'
        if k2[i - 1] == 'G':
            k2 = k2 + 'B'
        if k2[i - 1] == 'B':
            k2 = k2 + 'R'
        if k3[i - 1] == 'R':
            k3 = k3 + 'G'
        if k3[i - 1] == 'G':
            k3 = k3 + 'B'
        if k3[i - 1] == 'B':
            k3 = k3 + 'R'
    minn = n

    for i in range(n - k + 1):
        tec = 0
        for j in range(k):
            if l[i + j] != k1[j]:
                tec += 1
        if tec < minn: minn = tec
    for i in range(n - k + 1):
        tec = 0
        for j in range(k):
            if l[i + j] != k2[j]:
                tec += 1
        if tec < minn: minn = tec
    for i in range(n - k + 1):
        tec = 0
        for j in range(k):
            if l[i + j] != k3[j]:
                tec += 1

        if tec < minn: minn = tec
    b.append(minn)
for i in range(q):
    print(b[i])
",O(n ^ 2)
"import math

def find_nCr(n, r):
	return (math.factorial(n) / (math.factorial(r)*math.factorial(n-r)) )

sent = input()
received = input()

final_pos = 0
current_pos = 0
uncertain = 0

for s in sent:
	if s == ""+"":
		final_pos += 1
	else:
		final_pos -= 1

for s in received:
	if s == ""+"":
		current_pos += 1
	elif s == ""-"":
		current_pos -= 1
	else:
		uncertain += 1

if uncertain == 0:
	if final_pos == current_pos:
		print(1)
	else:
		print(0)
else:

	positions = list(range(current_pos-uncertain, current_pos+uncertain+2, 2))

	try:
		pos_index = positions.index(final_pos)
		a = find_nCr(uncertain, pos_index)
		b = math.pow(2, uncertain)
		print(a/b)
	except:
		pos_index = -1
		print(0)
",np
"
class Solution(object):
    def findTarget(self, root, k):
        class BSTIterator(object):
            def __init__(self, root, forward):
                self.__node = root
                self.__forward = forward
                self.__s = []
                self.__cur = None
                next(self)

            def val(self):
                return self.__cur

            def __next__(self):
                while self.__node or self.__s:
                    if self.__node:
                        self.__s.append(self.__node)
                        self.__node = self.__node.left if self.__forward else self.__node.right
                    else:
                        self.__node = self.__s.pop()
                        self.__cur = self.__node.val
                        self.__node = self.__node.right if self.__forward else self.__node.left
                        break


        if not root:
            return False
        left, right = BSTIterator(root, True), BSTIterator(root, False)
        while left.val() < right.val():
            if left.val() + right.val() == k:
                return True
            elif left.val() + right.val() < k:
                next(left)
            else:
                next(right)
        return False

",O(n)
"n,m=map(int,input().split())
l=[]
for i in range(n):
    s=input()
    l.append(s)
minX,minY,maxX,maxY=n,m,0,0
for i in range(n):
    for j in range(m):
        if l[i][j]=='B':
            minX,minY,maxX,maxY=min(minX,i),min(minY,j),max(maxX,i),max(maxY,j)
print((minX+maxX)//2+1,(minY+maxY)//2+1)",O(n ^ 2)
"def solve(a: int, b: int) -> int:
    if a > b:
        a, b = b, a
    ba = bin(a)[2:]
    bb = bin(b)[2:]
    r = ''
    if len(ba) != len(bb):
        int('1' * len(bb), 2)
    else:
        for ca, cb in zip(ba, bb):
            if ca == cb:
                r += '0'
            else:
                r += '1'
                break
    r += '1' * (len(bb) - len(r))
    return int(r, 2)

a, b = map(int, input().split())
print(solve(a, b))
",O(logn)
"import sys

n = int(input())
l = list(map(int,input().split()))
c = list(map(int,input().split()))

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

a = {0:0}
b = [0]

for i in range(n):
    for p in b:
        d = gcd(p, l[i])
        cost = a[p] + c[i]
        if d not in a:
            a[d] = cost
            b.append(d)
        elif a[d] > cost: a[d] = cost

if 1 not in a: a[1] = -1
print(a[1])
",np
"n, pos, l, r = map(int, input().split())
result = abs(pos - l) + r - l + 2
if (l == 1):
    if (abs(pos - r) + 1 < result):
        result = abs(pos - r) + 1
if (r == n):
    if (abs(pos - l) + 1 < result):
        result = abs(pos - l) + 1
if (l == 1 and r == n):
    result = 0
if (abs(pos - r) + r - l + 2 < result):
    result = abs(pos - r) + r - l + 2
print(result)",O(1)
"import collections


class Solution(object):
    def sumOfUnique(self, nums):
        return sum(x for x, c in collections.Counter(nums).items() if c == 1)",O(n)
"A,B = map(int,input().split())
print((1<<(A^B).bit_length()) - 1)",O(logn)
"class Solution(object):
    def average(self, salary):
        total, mi, ma = 0, float(""inf""), float(""-inf"")
        for s in salary:
            total += s
            mi, ma = min(mi, s), max(ma, s)
        return 1.0*(total-mi-ma)/(len(salary)-2)",O(n)
"class Solution(object):
    def subsequenceSumOr(self, nums):
        result = prefix = 0
        for x in nums:
            prefix += x
            result |= x|prefix
        return result",O(n)
"n = int(input())
A = [0] + list(map(int,input().split()))

vec = []
for i in range(1, n+1) :
	vec = vec + [[A[i], i]]
list.sort(vec)
list.reverse(vec)

if vec[0][0] == 1 :
	print(""NO"")
	exit(0)

dia = 0
path = [vec[0][1]]
ans = []
bol, col, idx = 1, 1, 0
for i in vec[1:] :

	if i[0] != 1 :
		ans = ans + [[path[-1], i[1]]]
		dia = dia+1
		A[path[-1]] = A[path[-1]]-1
		path += [i[1]];
		A[path[-1]] = A[path[-1]]-1
	else :
		if col == 1:
			dia = dia+1
			col = 0
			A[path[0]] -= 1
			ans = ans+ [[path[0], i[1]]]
		elif bol == 1:
			dia = dia+1
			bol = 0
			A[path[-1]] -= 1
			ans = ans + [[path[-1], i[1]]]
		else :
			while idx < len(path) and A[path[idx]] == 0 :
				idx = idx+1
			if idx == len(path) :
				print(""NO"")
				exit(0)
			A[path[idx]] = A[path[idx]] - 1;
			ans = ans + [[path[idx], i[1]]]

print(""YES"", dia)
print(len(ans))
for i in ans :
	print(i[0], i[1])
",O(nlogn)
"class Solution2(object):
    def postorderTraversal(self, root):
        result, stack = [], [(root, False)]
        while stack:
            root, is_visited = stack.pop()
            if root is None:
                continue
            if is_visited:
                result.append(root.val)
            else:
                stack.append((root, True))
                stack.append((root.right, False))
                stack.append((root.left, False))
        return result",O(n)
"class Solution3(object):
    def rearrangeArray(self, nums):
        pos, neg = [], []
        for i in reversed(range(len(nums))):
            if nums[i] > 0:
                pos.append(nums[i])
            else:
                neg.append(nums[i])
        result = []
        for i in range(len(nums)):
            if i%2 == 0:
                result.append(pos.pop())
            else:
                result.append(neg.pop())
        return result",O(n)
"from sys import stdin
from operator import xor

rints = lambda: [int(x) for x in stdin.readline().split()]
n, a, m = int(input()), [rints()], int(input())
qur, out = [rints() for _ in range(m)], []

for i in range(1, n):
    a.append(map(xor, a[-1][:-1], a[-1][1:]))

for i in range(n - 1):
    a[i + 1] = map(max, a[i][:-1], a[i][1:], a[i + 1])

for l, r in qur:
    out.append(a[r - l][l - 1])

print('\n'.join(map(str, out)))
",O(n ^ 2)
"class Solution(object):
    def isPossible(self, n, edges):
        adj = [set() for _ in range(n)]
        for u, v in edges:
            adj[u-1].add(v-1)
            adj[v-1].add(u-1)
        odds = [u for u in range(n) if len(adj[u])%2]
        if len(odds) == 0:
            return True
        if len(odds) == 2:
            return any(odds[0] not in adj[u] and odds[1] not in adj[u] for u in range(n))
        if len(odds) == 4:
            return ((odds[0] not in adj[odds[1]] and odds[2] not in adj[odds[3]]) or
                    (odds[0] not in adj[odds[2]] and odds[1] not in adj[odds[3]]) or
                    (odds[0] not in adj[odds[3]] and odds[1] not in adj[odds[2]]))
        return False",O(n)
"mod = 1000000000 + 7

n, m = map(int, input().split())

if n == 0:
    print(0)
    exit()

ans = n * 2
ans %= mod

if m:
    t = 1
    x = 2
    while m > 0:
        if m & 1:
            t = t * x % mod
        x = x * x % mod
        m >>= 1
    ans -= 1
    ans = (t * ans + 1) % mod

print(ans)",O(logn)
"class NextStringIndex:
    def __init__(self, string):
        self.INF = 10 ** 9
        self.alph = ""abcdefghijklmnopqrstuvwxyz""
        self.kind = len(self.alph)
        self.to_ind = {char: ind for ind, char in enumerate(self.alph)}

        self.string = string
        self.len_s = len(string)
        self.next_ = self.make_next()

    def __getitem__(self, tup):
        ind, char = tup
        return self.next_[ind][self.to_ind[char]]

    def make_next(self):
        dp = [[self.INF] * self.kind for i in range(self.len_s + 1)]
        for i in range(len_s)[::-1]:
            for j, char in enumerate(self.alph):
                if s[i] == char:
                    dp[i][j] = i + 1
                else:
                    dp[i][j] = dp[i + 1][j]
        return dp

def solve(t1, t2, len_s):
    INF = 10 ** 9
    len_t1 = len(t1)
    len_t2 = len(t2)
    dp = [[INF] * (len_t2 + 1) for i in range(len_t1 + 1)]
    dp[0][0] = 0

    for i in range(len_t1 + 1):
        for j in range(len_t2 + 1):
            length = dp[i][j]
            if length > len_s:
                continue
            if i < len_t1 and s_next[length, t1[i]] < INF:
                dp[i + 1][j] = min(dp[i + 1][j], s_next[length, t1[i]])
            if j < len_t2 and s_next[length, t2[j]] < INF:
                dp[i][j + 1] = min(dp[i][j + 1], s_next[length, t2[j]])

    return dp[-1][-1] < INF

query = int(input())
for _ in range(query):
    s = input()
    t = input()
    len_s = len(s)
    len_t = len(t)

    s_next = NextStringIndex(s)

    flag = False
    for i in range(len_t + 1):
        flag |= solve(t[0:i], t[i:], len_s)
    if flag:
        print(""YES"")
    else:
        print(""NO"")",O(n ^ 3)
"def func(u,v,a,l):
    if (v**2-u**2)>=2*a*l:
        return ((u**2+2*a*l)**(1/2)-u)/a
    else:
        t1=(v-u)/a
        t2=(l-(u*t1+a*t1*t1/2))/v
        return t1+t2
def efficient(v,a,w,d):
    if 2*v*v-w*w<=2*a*d:
        t1=v/a
        t2=(v-w)/a
        t3=(d-0.5*a*t1*t1-v*t2+0.5*a*t2*t2)/v
        return t1+t2+t3
    else:
        bound=((2*a*d+w*w)/2)**0.5
        t1=bound/a
        t2=(bound-w)/a
        t3=func(0,w,a,d)
        return t1+t2
        return min(t1+t2,t3)
def main():
    string1=input()
    string2=input()
    arr1=string1.split("" "")
    arr2=string2.split("" "")
    a=int(arr1[0])
    v=int(arr1[1])
    l=int(arr2[0])
    d=int(arr2[1])
    w=int(arr2[2])
    if 2*a*d<=w**2 or v<=w:
        t1=func(0,v,a,l)
        print(""%.8f""%(t1))
    else:
        t1=efficient(v,a,w,d)
        t2=func(w,v,a,l-d)
        print(""%.8f""%(t1+t2))
main()
",O(1)
"n=int(input())
a=[*map(int,input().split())]
s=[0]*n
m=n
while m:
 for i,x in enumerate(a):
  r=range(i%x,n,x)
  if s[i]==0:
   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1
   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1
print(''.join(s))",O(n ^ 2)
"import collections



class Solution(object):
    def largestPalindromic(self, num):
        cnt = collections.Counter(num)
        result = []
        for i in reversed(range(10)):
            if not cnt[str(i)]//2 or (i == 0 and not result):
                continue
            for _ in range(cnt[str(i)]//2):
                result.append(str(i))
        result.append(max([k for k, v in cnt.items() if v%2] or [""""]))
        for i in reversed(range(len(result)-1)):
            result.append(result[i])
        return """".join(result) or ""0""",O(n)
"n = int(input())
a = tuple(map(int, input().split()))
if n * 2 > sum(a) + 2:
	print(""NO"")
else:
	n1 = []
	on = []
	for i in range(n):
		if a[i] != 1:
			n1.append(i)
		else:
			on.append(i)
	print(""YES"", len(n1) + min(2, len(on)) - 1)
	print(n - 1)
	n1it = iter(n1)
	next(n1it)
	for v, u in zip(n1, n1it):
		print(v + 1, u + 1)
	if on:
		print(on.pop() + 1, n1[-1] + 1)
	if on:
		print(on.pop() + 1, n1[0] + 1)
	on = iter(on)
	for n11 in n1:
		for i in range(a[n11] - 2):
			try:
				print(n11 + 1, next(on) + 1)
			except StopIteration:
				break
		else:
			continue
		break
",O(n)
"a, b, c, d, e, f, g, h = map(int, input().split(' '))
i, j, k, l, m, n, o, p = map(int, input().split(' '))

s1 = [[a, b], [c, d], [e, f], [g, h]]
s1.sort()
bleft = s1[0]
tr = s1[3]
u, v, w, x = bleft[0], bleft[1], tr[0], tr[1]

def check(xd, dx, u, v, w, x):
	return (u <= xd and xd <= w and v <= dx and dx <= x)

god = [(i+k+m+o)/4, (j+l+n+p)/4]
nani = 0
for moo in [[i, j], [k, l], [m, n], [o, p]]:
	if check(moo[0], moo[1], u, v, w, x):
		print(""Yes"")
		quit()

if check(god[0], god[1], u, v, w, x):
	nani += 1

i, j = i+j, i-j
k, l = k+l, k-l
m, n = m+n, m-n
o, p = o+p, o-p

a, b = a+b, a-b
c, d = c+d, c-d
e, f = e+f, e-f
g, h = g+h, g-h

a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p = i, j, k, l, m, n, o, p, a, b, c, d, e, f, g, h

s1 = [[a, b], [c, d], [e, f], [g, h]]
s1.sort()
bleft = s1[0]
tr = s1[3]
u, v, w, x = bleft[0], bleft[1], tr[0], tr[1]

def check(xd, dx, u, v, w, x):
	return (u <= xd and xd <= w and v <= dx and dx <= x)

god = [(i+k+m+o)/4, (j+l+n+p)/4]

for moo in [[i, j], [k, l], [m, n], [o, p]]:
	if check(moo[0], moo[1], u, v, w, x):
		print(""Yes"")
		quit()

if check(god[0], god[1], u, v, w, x):
	nani += 1
if nani == 2:
	print(""Yes"")
	quit()

print(""No"")",O(1)
"import sys
input = sys.stdin.readline

n,m=map(int,input().split())
ANS=[]

for i in range(1,n//2+1):
    for j in range(1,m+1):
        sys.stdout.write("""".join((str(i),"" "",str(j),""\n"")))
        sys.stdout.write("""".join((str(n-i+1),"" "",str(m-j+1),""\n"")))

if n%2==1:
    for j in range(1,m//2+1):
        sys.stdout.write("""".join((str(n//2+1),"" "",str(j),""\n"")))
        sys.stdout.write("""".join((str(n//2+1),"" "",str(m-j+1),""\n"")))

    if m%2==1:
        sys.stdout.write("""".join((str(n//2+1),"" "",str(m//2+1),""\n"")))
",O(n ^ 2)
"class Solution(object):
    def countPalindromicSubsequence(self, s):
        first, last = [len(s)]*26, [-1]*26
        for i, c in enumerate(s):
            first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i)
            last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i)
        return sum(len(set(s[i] for i in range(first[c]+1, last[c]))) for c in range(26))",O(n)
"class Solution(object):
    def secondsToRemoveOccurrences(self, s):
        result = cnt = 0
        for c in s: 
            if c == '0':
                cnt += 1
                continue
            if cnt:
                result = max(result+1, cnt)
        return result",O(n)
"from collections import Counter
import math
l=list(input())
l1=list(input())
a=Counter(l)
b=Counter(l1)
if a['+']<b['+'] or a['-']<b['-']:
	print(""0"")
	exit()
else:
	a1=a['+']-b['+']
	b1=a['-']-b['-']
s=(math.factorial(a1+b1))//((math.factorial(a1))*(math.factorial(b1)))
s1=float(2**(a1+b1))
print(s/s1)",np
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, = getIntList()

zb = getIntList()

za1 = [0]
za2 = [zb[0]]

for i in range(1, N//2):
    t1 = zb[i] - za1[-1]
    if t1 <= za2[-1]:
        za1.append(za1[-1])
        za2.append(t1)
        continue
    t2 = zb[i] - za2[-1]
    if t2 >= za1[-1]:
        za1.append(t2)
        za2.append(za2[-1])
        continue
    assert False

zr = za1 + za2[ : :-1]
zs = []
for x in zr:
    zs .append(str(x))

r = ' '.join(zs)

print(r)
",O(n)
"import collections


class Solution(object):
    def findMaxValueOfEquation(self, points, k):
        result = float(""-inf"")
        dq = collections.deque()
        for i, (x, y) in enumerate(points):
            while dq and points[dq[0]][0] < x-k:
                dq.popleft()
            if dq:
                result = max(result, (points[dq[0]][1]-points[dq[0]][0])+y+x)
            while dq and points[dq[-1]][1]-points[dq[-1]][0] <= y-x:
                dq.pop()
            dq.append(i)
        return result",O(n)
"class Solution2(object):
    def placedCoins(self, edges, cost):
        def dfs(u, p):
            arr = [cost[u]]
            for v in adj[u]:
                if v == p:
                    continue
                arr.extend(dfs(v, u))
                arr.sort()
                if len(arr) > 5:
                    arr = arr[:2]+arr[-3:]
            result[u] = 1 if len(arr) < 3 else max(arr[0]*arr[1]*arr[-1], arr[-3]*arr[-2]*arr[-1], 0)
            return arr
                
        adj = [[] for _ in range(len(cost))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]*len(cost)
        dfs(0, -1)
        return result",O(nlogn)
"n,l,r,d=[int(i) for i in input().split()]
op=[int(i) for i in input().split()]
c=0
for i in range(2,2**n):
    s=0
    k=0
    maxx=0
    minn=1000001
    x=bin(i)[2:]
    x='0'*(n-len(x))+x
    for j in range(n):
        if x[j]=='1':
            s+=op[j]
            k+=1
            if maxx<op[j]:
                maxx=op[j]
            if op[j]<minn:
                minn=op[j]
    if l<=s<=r and maxx-minn>=d and k>=2:
        c+=1
print(c)",np
"n,m=map(int,input().split())
a=list(map(int,input().split()))
b=list(map(int,input().split()))
a.sort()
b.sort()
a.reverse()
b.reverse()
if a[0]>b[-1]:
    print(-1)
else:
    que=[]
    flag=True
    if b[-1]==a[0]:
        s=sum(b)
        flag=False
    else:
        s=sum(b)-b[-1]+a[0]
    if flag:
        s+=(sum(a)-a[0])*m+b[-1]-a[1]
    else:
        s+=(sum(a)-a[0])*m
    print(s)
",O(nlogn)
"
class UndirectedGraphNode(object):
    def __init__(self, x):
        self.label = x
        self.neighbors = []

class Solution(object):
    def cloneGraph(self, node):
        if node is None:
            return None
        cloned_node = UndirectedGraphNode(node.label)
        cloned, queue = {node:cloned_node}, [node]

        while queue:
            current = queue.pop()
            for neighbor in current.neighbors:
                if neighbor not in cloned:
                    queue.append(neighbor)
                    cloned_neighbor = UndirectedGraphNode(neighbor.label)
                    cloned[neighbor] = cloned_neighbor
                cloned[current].neighbors.append(cloned[neighbor])
        return cloned[node]

",O(n)
"n = int(input())
if n==0:
    print(0)
elif n%2==1:
    print((n+1)//2)
else:
    print(n+1)",O(1)
"class Solution(object):
    def removeKdigits(self, num, k):
        result = []
        for d in num:
            while k and result and result[-1] > d:
                result.pop()
                k -= 1
            result.append(d)
        return ''.join(result).lstrip('0')[:-k or None] or '0'",O(n)
"class Solution(object):
    def carPooling(self, trips, capacity):
        line = [x for num, start, end in trips for x in [[start, num], [end, -num]]]
        line.sort()
        for _, num in line:
            capacity -= num
            if capacity < 0:
                return False
        return True",O(nlogn)
"MOD = int(1e9+9)

def fast_power(x, y):
    res = 1
    while y > 0:
        if y % 2 == 1:
            res = res * x%MOD
        x = x * x % MOD
        y //= 2
    return res

n, m, k = map(int, input().split())
x = max(0, m - n // k * (k - 1) - n % k)
z = (m - x * k) % MOD
res = fast_power(2, x+1)
res = (res - 2) % MOD * k % MOD
res = (res + z) % MOD
print(res)
",O(logn)
"a,b = map(int, input().split())
x, y, z = map(int, input().split())

ans = max(0, 2*x+y-a)+max(0, 3*z+y-b)
print(ans)
",O(1)
"import string
from collections import deque, Counter
from functools import lru_cache
import math

DEBUG = 0

def main():

    T = 1
    while T:
        n, M = Input.read_typed(int)
        N = n

        f = [[0 for _ in range(n+1)] for _ in range(n+1)]
        comb = [[0 for _ in range(n+1)] for _ in range(n+1)]
        fact = [0] * (n+1)
        inv = [0] * (n+1)
        fact[0] = inv[0] = 1

        for i in range(1, n+1):
            fact[i] = (fact[i-1] * i) % M
            inv[i] = pow(fact[i], M-2, M)

        for i in range(0, n+1):
            for j in range(0, i+1):

                comb[i][j] = ((fact[i] * inv[j]) % M * inv[i-j]) % M

        pow2 = [0] * (n+1)
        pow2[0] = 1
        for i in range(1, n+1):
            pow2[i] = pow2[i-1]*2 % M
            f[i][i] = pow2[i-1]

        for total in range(1, n+1):
            for manual in range(1, total):
                if total > manual * 2 or total < manual: continue
                for l in range(1, manual):
                    f[total][manual] += f[total-l-1][manual-l] * pow2[l-1] * comb[manual][l]

                    f[total][manual] %= M

        c = 0
        for i in range(1, n+1):
            c += f[n][i]

        print(c % M)
        T -= 1

class Input:
    def __init__(self):
        pass

    @staticmethod
    def read_typed(cls):
        return list(map(cls, input().split()))

    @staticmethod
    def read():
        return input()

class Debug():
    def __init__(self):
        import sys
        sys.stdout = open('output.out', 'w')
        sys.stdin = open('input.in', 'r')

    def __delete__(self):
        sys.stdout.close()
        sys.stdin.close()

def run():
    if DEBUG: _ = Debug()
    main()

run()
",O(n ^ 3)
"class Solution(object):
    def countDays(self, days, meetings):
        meetings.sort()
        result = curr = 0
        for s, e in meetings:
            result += max((s-1)-curr, 0)
            curr = max(curr, e)
        result += days-curr
        return result",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')
from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

def main():
    n, k = RL()
    cds = RLL()
    fn = RLL()
    sc = [0]+RLL()

    rec = set(fn)
    uses = 0
    dic = defaultdict(int)
    for i in cds:
        if i in rec:
            dic[i]+=1
            uses+=1

    dp = [[0]*(uses+1) for _ in range(n+1)]

    for i in range(1, n+1):
        for j in range(1, uses+1):
            for l in range(k+1):
                if l>j: break
                val = sc[l]
                dp[i][j] = max(dp[i][j], dp[i-1][j-l]+val)
    res = 0

    for i, v in Counter(fn).items():
        res+=dp[v][dic[i]]

    print(res)

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"import sys,os,io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

n = int(input())
c = [int(i) for i in input().split()]
a = [int(i)-1 for i in input().split()]
vis = [-1]*n
ans = 0
for i in range (n):
    ind = i
    while(vis[ind]==-1):
        vis[ind]=i
        ind = a[ind]
    if vis[ind]==i:
        start = ind
        ind = a[ind]
        cost = c[start]
        while(ind!=start):
            cost = min(cost, c[ind])
            ind = a[ind]
        ans+=cost
print(ans)
",O(n)
"t = int(input())
def maxsa(A):
    ans = 0

    for i in range(n):
        cur_maxx = 0
        for j in range(4):
            cur_maxx = max(cur_maxx, A[j][i])
        ans+= cur_maxx
    return ans

def fu(A):
    answer = 0
    for j in range(n):
        A[0] = A[0][1:] + A[0][:1]
        for i in range(n):
            A[1] = A[1][1:] + A[1][:1]
            for k in range(n):
                A[2] = A[2][1:] + A[2][:1]
                for l in range(n):
                    A[3] = A[3][1:] + A[3][:1]

                    cur_ans = maxsa(A)
                    answer = max(answer, cur_ans)
    return answer

for j in range(t):
    n,m = map(int,input().split())
    A = [0] * n
    inds = [-1,-1,-1,-1]
    maxs  =[ 0,0,0,0]
    for j in range(n):
        A[j] = list(map(int,input().split()))
    for j in range(m):
        cur_maxs = 0
        for i in range(n):
            cur_maxs = max(cur_maxs, A[i][j])
        maxs.append(cur_maxs)
        inds.append(j)
        ind  = 4

        while ind !=0 and maxs[ind] > maxs[ind-1]:
            inds[ind], inds[ind-1] = inds[ind-1] , inds[ind]
            maxs[ind], maxs[ind - 1] = maxs[ind - 1], maxs[ind]
            ind-=1
        maxs.pop()
        inds.pop()

    S = [0] * 4
    for j in range(4):
        if inds[j] != -1:

            S[j] = [s[inds[j]] for s in A]

        else:
            S[j] = [0] * n

    print(fu(S))",np
"class Solution(object):
    def newInteger(self, n):
        result, base = 0, 1
        while n > 0:
            result += (n%9) * base
            n /= 9
            base *= 10
        return result",O(logn)
"import bisect
import itertools


class Solution(object):
    def minArea(self, image, x, y):
        def binarySearch(left, right, find, image, has_one):
            while left <= right: 
                mid = left + (right - left) / 2
                if find(image, has_one, mid): 
                    right = mid - 1
                else:
                    left = mid + 1
            return left


        searchColumns = lambda image, has_one, mid: any([int(row[mid]) for row in image]) == has_one
        left = binarySearch(0, y - 1, searchColumns, image, True)
        right = binarySearch(y + 1, len(image[0]) - 1, searchColumns, image, False)

        searchRows = lambda image, has_one, mid: any(map(int, image[mid])) == has_one
        top = binarySearch(0, x - 1, searchRows, image, True)
        bottom = binarySearch(x + 1, len(image) - 1, searchRows, image, False)

        return (right - left) * (bottom - top)",O(nlogn)
"import math
a=list(input())
b=list(input())
p=a.count('+')-b.count('+')
m=a.count('-')-b.count('-')
if m<0 or p<0:
    print(0)
    exit(0)
l=math.factorial(p+m)/(math.factorial(p)*math.factorial(m))
print(l*(.5**(p+m)))",np
"n = int(input())
lst = list(map(int,input().split()))
lst = set(lst)
lst = list(lst)
lst.remove(min(lst))
if(len(lst)==0):
    print(""NO"")
else:
    print(min(lst))
",O(nlogn)
"from math import *

def nCr(n, r):
    f = factorial
    return f(n) / f(r) / f(n - r)

s1, s2 = [input() for i in range(2)]
s1_pos, s2_pos, s1_neg, s2_neg, s1_q = s1.count('+'), s2.count('+'), s1.count('-'), s2.count('-'), s2.count('?')

ans = 0
if s1_q == 0:
    if s1_pos == s2_pos:
        ans = 1
    else:
        ans = 0
else:
    diff1 = s1_pos - s2_pos
    if diff1 > s1_q or diff1 < 0:
        ans = 0
    else:
        ans = nCr(s1_q, diff1) / 2 ** s1_q

print('{:.12f}'.format(ans))
",np
"import sys
input = sys.stdin.readline

RI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]
rw = lambda : input().strip().split()

infinite = float('inf')

t=int(input())

for _ in range(t):
    n,k=RI()
    s=input()

    mini=n

    test=""RGB""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    test=""GBR""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    test=""BRG""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    print(mini)
",O(n ^ 2)
"n,s = map(int,input().split())
l = n+1
for i in range(s,min(s+1000000, n)+1,1):
    cur = sum([int(j) for j in str(i)])
    if(i-cur>=s):
        l = i; break
print(n-l+1)",O(logn)
"from sys import stdin
input = stdin.buffer.readline

n,k=map(int,input().split())
arr=[int(x) for x in input().split()]

l=[]
for i in range(n):
    l.append((arr[i],i))

l.sort(reverse=True)

dp=[]
x=0
for i in range(k):
    dp.append(l[i][1])
    x=x+l[i][0]

print(x)
dp.sort()
dp=[-1]+dp

l=len(dp)
for i in range(1,l-1):
    print(dp[i]-dp[i-1],end="" "")
print(n-1-dp[l-2])",O(nlogn)
"class Solution(object):
    def numberOfArithmeticSlices(self, A):
        res, i = 0, 0
        while i+2 < len(A):
            start = i
            while i+2 < len(A) and A[i+2] + A[i] == 2*A[i+1]:
                res += i - start + 1
                i += 1
            i += 1

        return res",O(n)
"import sys
n,s=map(int,input().split())
if 2*s>n*(n+1) or s<2*n-1:
  print('NO')
  sys.exit()
for i in range(n,-1,-1):
  if i==0:
    branch=1
    break
  tmp=0
  tmpn=n
  j=1
  while tmpn-i**(j-1)>=0:
    tmp+=j*(i**(j-1))
    tmpn-=i**(j-1)
    j+=1
  tmp+=j*(tmpn)
  if tmp>s:
    branch=i+1
    break
tmp=0
tmpn=n
j=1
i=branch
dic={}
while tmpn-i**(j-1)>=0:
  tmp+=j*(i**(j-1))
  dic[j]=(i**(j-1))
  tmpn-=i**(j-1)
  j+=1
tmp+=j*(tmpn)
dic[j]=tmpn
maxi=j
while tmp<s:
  for j in range(maxi,-1,-1):
    while dic[j]>1:
      if s-tmp+j<=maxi:
        dic[j]-=1
        dic[s-tmp+j]+=1
        tmp=s
      else:
        dic[j]-=1
        dic[maxi+1]=1
        tmp+=maxi+1-j
        maxi+=1
      if tmp==s:
        break
    if tmp==s:
      break
b=[]
for i in dic:
  for j in range(dic[i]):
    b.append(i)
b.sort()
print('YES')
children=[0]*n
ans=[-1]*n
curr=0
pointer=0
for i in range(1,n):
  while b[i]>b[curr]+1:
    curr+=1
  ans[i]=curr
  children[curr]+=1
  if children[curr]==branch:
    curr+=1
finans=[]
for i in range(1,n):
  finans.append(ans[i]+1)
print(' '.join(map(str,finans)))",O(nlogn)
"import sys
input=sys.stdin.readline
n=int(input())
c=["" ""]+[input().rstrip() for i in range(n)]
mod=10**9+7
dp=[[0]*(n+1) for i in range(n+1)]
dp[1][0]=1
sdp=[0]*(n+1)
sdp[0]=1
for i in range(1,n+1):
    if i>=2 and c[i-1]==""f"":
        for j in range(1,n+1):
            dp[i][j]=dp[i-1][j-1]
            dp[i][j]%=mod
        dp[i][0]=0
    else:
        for j in range(n+1):
            dp[i][j]=sdp[j]
            dp[i][j]%=mod
    sdp=[dp[i][j] for j in range(n+1)]
    for j in range(1,n+1)[::-1]:
        sdp[j-1]+=sdp[j]
        sdp[j-1]%=mod
print(sdp[0]%mod)",O(n ^ 2)
"R, G, B = list(map(int, input().split()))
r = [int(x) for x in input().split()]
r.sort(reverse=True)
g = [int(x) for x in input().split()]
g.sort(reverse=True)
b = [int(x) for x in input().split()]
b.sort(reverse=True)

ans = 0
dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
            if j<G and k<B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])
            if i<R and k<B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])
            ans = max(ans, dp[i][j][k])
print(ans)
",O(n ^ 3)
"import collections



class Solution(object):
    def distance(self, nums):
        result = [0]*len(nums)
        cnt1, left = collections.Counter(), collections.Counter()
        for i in range(len(nums)):
            result[i] += cnt1[nums[i]]*i-left[nums[i]]
            cnt1[nums[i]] += 1
            left[nums[i]] += i
        cnt2, right = collections.Counter(), collections.Counter()
        for i in reversed(range(len(nums))):
            result[i] += right[nums[i]]-cnt2[nums[i]]*i
            cnt2[nums[i]] += 1
            right[nums[i]] += i
        return result",O(n)
"import itertools
class Solution2(object):
    def smallestStringWithSwaps(self, s, pairs):
        def dfs(i, adj, lookup, component):
            lookup.add(i)
            component.append(i)
            for j in adj[i]:
                if j in lookup:
                    continue
                dfs(j, adj, lookup, component)
            
        adj = collections.defaultdict(list)
        for i, j in pairs:
            adj[i].append(j)
            adj[j].append(i)
        lookup = set()
        result = list(s)
        for i in range(len(s)):
            if i in lookup:
                continue
            component = []
            dfs(i, adj, lookup, component)
            component.sort()
            chars = sorted(result[k] for k in component)
            for comp, char in zip(component, chars):
                result[comp] = char
        return """".join(result)",O(nlogn)
"class Codec:

    def serialize(self, root: Optional[TreeNode]) -> str:
        if not root:
            return ""N""
        res = []
        queue = deque([root])
        while queue:
            node = queue.popleft()
            if not node:
                res.append(""N"")
            else:
                res.append(str(node.val))
                queue.append(node.left)
                queue.append(node.right)
        return "","".join(res)

    def deserialize(self, data: str) -> Optional[TreeNode]:
        vals = data.split("","")
        if vals[0] == ""N"":
            return None
        root = TreeNode(int(vals[0]))
        queue = deque([root])
        index = 1
        while queue:
            node = queue.popleft()
            if vals[index] != ""N"":
                node.left = TreeNode(int(vals[index]))
                queue.append(node.left)
            index += 1
            if vals[index] != ""N"":
                node.right = TreeNode(int(vals[index]))
                queue.append(node.right)
            index += 1
        return root
",O(n)
"class Solution(object):
    def largestValues(self, root):
        def largestValuesHelper(root, depth, result):
            if not root:
                return
            if depth == len(result):
                result.append(root.val)
            else:
                result[depth] = max(result[depth], root.val)
            largestValuesHelper(root.left, depth+1, result)
            largestValuesHelper(root.right, depth+1, result)

        result = []
        largestValuesHelper(root, 0, result)
        return result",O(n)
"import sys
import io, os
input = sys.stdin.readline

n, m = map(int, input().split())
A = [input().rstrip() for i in range(n)]
C = [0]*m
for i in range(n):
    a = A[i]
    for j, c in enumerate(a):
        C[j] += int(c)

for i in range(n):
    a = A[i]
    for j, c in enumerate(a):
        C[j] -= int(c)
    for j in range(m):
        if C[j] == 0:
            break
    else:
        print('YES')
        exit()
        continue
    for j, c in enumerate(a):
        C[j] += int(c)
print('NO')
",O(n ^ 2)
"class Solution(object):
    def sumRemoteness(self, grid):
        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))
        def bfs(i, j):
            total, cnt = grid[i][j], 1
            grid[i][j] = -1
            q = [(i, j)]
            while q:
                new_q = []
                for i, j in q:
                    for di, dj in DIRECTIONS:
                        ni, nj = i+di, j+dj
                        if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[ni][nj] != -1):
                            continue
                        total += grid[ni][nj]
                        cnt += 1
                        grid[ni][nj] = -1
                        new_q.append((ni, nj))
                q = new_q
            return total, cnt
    
        groups = [bfs(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] != -1]
        total = sum(t for t, _ in groups)
        return sum((total-t)*c for t, c in groups)",O(n ^ 2)
"from collections import defaultdict
n, s = int(input()), []
for i in range(n):
  a = [int(x) for x in input().split()]
  s += [(a[0], 0), (a[1], 1)]
s.sort()
now = 0
rev = defaultdict(int)
for a,b in zip(s, s[1:]):

  if(a[1] == 0):
    now += 1

    rev[now] += b[0] - a[0]
    if b[1] == 1:

      rev[now] += 1

  else:
    now -= 1

    if b[0] != a[0]:
      rev[now] += b[0] - a[0]
      if b[1] == 0:

        rev[now] -= 1

for i in range(1, n+1):
  print(rev[i], end="" "")",O(nlogn)
"t = int(input())

for iter in range(t):
    n, k = map(int, input().split())
    if n >= 50:
        if k == 0:
            print(""YES "" + str(n))
        else:
            print(""YES "" + str(n - 1))
    else:
        a = [0] * (n + 1)
        b = [0] * (n + 1)
        c = [0] * (n + 1)
        a[0] = 0
        b[n] = 1
        c[n] = 0

        for i in range(1, n + 1):
            a[i] = 4 * a[i - 1] + 1
        for i in range(n - 1, -1, -1):
            b[i] = b[i + 1] * 2 + 1
        for i in range(n - 1, -1, -1):
            c[i] = c[i + 1] + b[i + 1]

        res = -1
        for d in range(n + 1):
            if c[d] <= k and k <= a[n] - a[d] * b[d]:
                res = d

        if res == -1:
            print(""NO"")
        else:
            print(""YES "" + str(res))
",O(logn)
"import sys
import bisect
import heapq
import math

INF = 10**9+7
sys.setrecursionlimit(INF)

def fi():
    return int(sys.stdin.readline())

def fi2():
    return map(int, sys.stdin.readline().split())

def fi3():
    return sys.stdin.readline().rstrip()

def fo(*args):
    for s in args:
        sys.stdout.write(str(s)+' ')
    sys.stdout.write('\n')

def puts(*args):
    for s in args:
        sys.stdout.write(str(s))

def mask(n1):
    arr = []
    for i in range(64):
        arr.append(n1&1)
        n1 = n1 >> 1
    arr.reverse()
    return arr

def getn(mask):
    if sum(mask) == 0:
        return 0
    res = 0
    for i in range(63, -1, -1):
        res += (2*mask[i])**(63-i)
    return res

n1, n2 = fi2()
m1 = mask(n1)
m2 = mask(n2)

sol = [0 for i in range(64)]

for i in range(64):
    if m1[i] != m2[i]:
        sol[i] = 1
        break

i += 1
for j in range(i, 64):
    sol[j] = 1

res = getn(sol)
fo(res)
",O(logn)
"class Solution(object):
    def countConsistentStrings(self, allowed, words):
        lookup = [False]*26
        for c in allowed:
            lookup[ord(c)-ord('a')] = True
        result = len(words)
        for word in words:
            for c in word:
                if not lookup[ord(c)-ord('a')]:
                    result -= 1
                    break
        return result",O(n)
"n=int(input())
l=list(map(int,input().split(' ')))
l.sort(reverse=True)

coin=0
total_sum=sum(l)
current_sum=0
for i in range(len(l)):
    coin+=1
    current_sum=current_sum+l[i]
    remaining_sum=total_sum-current_sum
    if current_sum>remaining_sum:
        break
print(coin)",O(nlogn)
"class Solution(object):
    def minLength(self, s):
        stk = []
        for c in s:
            if stk and ((stk[-1] == 'A' and c == 'B') or (stk[-1] == 'C' and c == 'D')):
                stk.pop()
                continue
            stk.append(c)
        return len(stk)",O(n)
"class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if nums[i] + nums[j] == target:
                    return [i, j]
        return []
",O(n ^ 2)
"n,m,k,l=map(int,input().split())
q=(l+k-1)//m+1
if q*m>n:print(-1)
else:print(q)
",O(1)
"class Solution(object):
    def countDigits(self, num):
        result = 0
        curr = num
        while curr:
            result += int(num%(curr%10) == 0)
            curr //= 10
        return result",O(logn)
"class Solution(object):
    def countHousePlacements(self, n):
        MOD = 10**9+7
        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b % MOD for a, b in zip(row, col)) % MOD for col in ZB] for row in A]
 
        def matrix_expo(A, K):
            result = [[int(i == j) for j in range(len(A))] for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        T = [[1, 1],
             [1, 0]]
        return pow(matrix_mult([[2, 1]], matrix_expo(T, n-1))[0][0], 2, MOD)",O(logn)
"n = int(input())
leafs = set()
other = {}
other_indices = []
s = 0
for i, a in enumerate(map(int, input().split())):
    if a == 1:
        leafs.add(i)
    else:
        other[i] = a
        other_indices.append(i)
    s += a

if not other:

    print(""NO"")
    exit(0)

other_indices.sort(key=lambda index: other[index])
other_indices = [other_indices[-1]] + other_indices[:-1]

edges = []
for i1, i2 in zip(other_indices, other_indices[1:]):
    edges.append((i1, i2))
    other[i1] -= 1
    if other[i1] == 0:
        del other[i1]
    other[i2] -= 1
    if other[i2] == 0:
        del other[i2]

diam = len(other_indices) + min(2, len(leafs))

has_start = has_end = False

while leafs:
    if len(other) == 0:
        print(""NO"")
        exit(0)
    l = leafs.pop()
    if not has_start and other.get(other_indices[0], 0):
        i = other_indices[0]
        has_start = True
    elif not has_end and other.get(other_indices[-1], 0):
        i = other_indices[-1]
        has_end = True
    else:
        i = next(iter(other))
    edges.append((l, i))
    other[i] -= 1
    if other[i] == 0:
        del other[i]

print(""YES"", diam - 1)
print(len(edges))
for x, y in edges:
    print(x+1, y+1)
",O(nlogn)
"from collections import defaultdict
import sys
input = sys.stdin.readline
n = int(input())
a = map(int, input().split())
mod = 998244353
d = defaultdict(int)
for x in a:
    d[x] += 1
d[0] = 0
b = list(d.items())
b.sort()
m = len(b)
ba = [0] * m
cn = [0] * (m + 1)
k = h = 0
for i, x in enumerate(b):
    while h < m and x[0] >= b[h][0] * 2:
        h += 1
    ba[i] = h - 1
    while k < m and x[0] * 2 > b[k][0]:
        k += 1
    cn[k] += x[1]
for i in range(m):
    cn[i+1] += cn[i]
dp = [0] * m
dp[0] = 1
b = [x[1] for x in b]
for i in range(n):
    ndp = [0] * m
    for j in range(1, m):
        if cn[j] >= i - 1:
            ndp[j] = dp[j] * (cn[j] - i + 1) % mod
        dp[j] += dp[j-1]
        if dp[j] >= mod:
            dp[j] -= mod
    for j in range(1, m):
        ndp[j] += dp[ba[j]] * b[j]
        ndp[j] %= mod
    dp = ndp
print(sum(dp) % mod)",O(n ^ 3)
"a, b = map(int, input().split(' '))
res = 0
temp = 0

if a%b == 0:
    print(int(a/b))
else:
    while b!=0:
        res += a//b
        a%=b
        temp = a
        a = b
        b = temp
    print(res)
",O(1)
"class Solution(object):
    def firstBadVersion(self, n):
        left, right = 1, n
        while left <= right:
            mid = left + (right - left) / 2
            if isBadVersion(mid):
                right = mid - 1
            else:
                left = mid + 1
        return left",O(logn)
"import math
n = int(input())
A = [i + 1 for i in range(n)]
x = int(math.sqrt(n))
X = [A[i:i + x] for i in range(0, len(A), x)]
X = X[::-1]
f = [item for sublist in X for item in sublist]
print(*f)",O(n)
"n,m=map(int,input().split())
a=[list('') for x in range(n)]
b=[list('.'*m) for x in range(n)]
start=0

for i in range(n):
    a[i]=list(input())
    if (start==0):
        if ('.' in a[i]):
            start=((i-3)//3) *3
for i in range(start):
    b[i]=list('

for i in range(start,n-2):
    for j in range(m-2):
        ok=True
        if a[i][j]=='
            for y in range(i,i+3):
                if ok==False:
                    break
                for x in range(j,j+3):
                    if not((y==i+1)and(x==j+1)):
                        if a[y][x]!='

                            ok=False
                            break
            if ok:
                for y in range(i,i+3):
                    for x in range(j,j+3):
                        if not((y==i+1)and(x==j+1)):
                            b[y][x]='

if a==b:
    print('YES')
else:
    print('NO')
",O(n ^ 2)
"I=lambda:list(map(int,input().split()))
n,s,a=int(input()),I(),I()
t=3*10**9
q=[0]*n
for i in range(n-1,-1,-1):
    u=10**8
    for j in range(i-1,-1,-1):
        if s[i]>s[j]:u=min(u,a[j])
    q[i]=u
for i in range(n):
    for j in range(i+1,n):
        if s[i]<s[j]:t=min(t,a[i]+a[j]+q[i])
print(t if t<=sum(a)else -1)",O(n ^ 2)
"import collections


class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def minMalwareSpread(self, graph, initial):
        union_find = UnionFind(len(graph))
        for i in range(len(graph)):
            for j in range(i+1, len(graph)):
                if graph[i][j] == 1:
                    union_find.union_set(i, j)
        union_size = collections.Counter(union_find.find_set(i) for i in range(len(graph)))
        malware_count = collections.Counter(union_find.find_set(i) for i in initial)
        return min(initial, key=lambda x: [malware_count[union_find.find_set(x)] > 1,
                                           -union_size[union_find.find_set(x)],
                                           x])",O(n ^ 2)
"def getsum(n):
    return ((1 << (2*n)) - 1) // 3

def b(n, k):
    l = n - 1
    r = max(0, l - 41)
    while True:
        mid = (l + r) // 2
        count = getsum(n - mid)
        if count <= k:
            l = mid
        else:
            r = mid
        if l - r <= 1:
            break
        del count
    g = getsum(n - r)
    if g < k:
        del g
        return None
    elif g == k:
        del g
        return r
    return l

t = int(input())
for i in range(t):
    n, k = map(int, input().split())
    min_side = b(n, k)
    if min_side is None:
        print('NO')
        continue
    k -= getsum(n - min_side)
    if n == 2 and min_side == 1 and k == 2:
        print('NO')
        continue
    num_squares = (1 << (n - min_side)) * 2 - 1
    if k >= num_squares:
        print('YES ' + str(min_side - 1))
    else:
        print('YES ' + str(min_side))",O(logn)
"n, k = [int(i) for i in input().split()]

def split_k(x):
    t = x + 1
    addition = t*(t+1)//2

    return(addition - (n- x -1) - k, n - x - 1 )

j = 0

while split_k(j)[0] != 0:
    j += 1

print(split_k(j)[1])
",O(logn)
"n,m=map(int,input().split())
seq=[int(i) for i in input().split()][:n]
f=[int(i) for i in input().split()][:m]
a=[]
for i in range(n):
    for j in range(m):
        if(seq[i]==f[j]):
            a.append(seq[i])

for i in range(len(a)):
    print(a[i],end=' ')",O(n ^ 2)
"R,G,B = map(int,input().split())
r = sorted(list(map(int,input().split())), reverse=True)
g = sorted(list(map(int,input().split())), reverse=True)
b = sorted(list(map(int,input().split())), reverse=True)

dp = [[[0]*(B+1) for i in range(G+1)] for j in range(R+1)]
ans = 0
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if j*k > 0:
                dp[i][j][k] = max(dp[i][j-1][k-1]+g[j-1]*b[k-1],dp[i][j][k])
            if i*k > 0:
                dp[i][j][k] = max(dp[i-1][j][k-1]+r[i-1]*b[k-1],dp[i][j][k])
            if i*j > 0:
                dp[i][j][k] = max(dp[i-1][j-1][k]+g[j-1]*r[i-1],dp[i][j][k])
            ans = max(ans,dp[i][j][k])
print(ans)",O(n ^ 3)
"class Solution2(object):
    def averageOfSubtree(self, root):
        def dfs(node):
            if not node:
                return [0]*3
            left = dfs(node.left)
            right = dfs(node.right)
            return [left[0]+right[0]+node.val,
                    left[1]+right[1]+1,
                    left[2]+right[2]+int((left[0]+right[0]+node.val)//(left[1]+right[1]+1) == node.val)]
        
        return dfs(root)[2]",O(n)
"import sys

f = sys.stdin

def line():
    return f.readline().strip().split()

def powers(limit):
    size = limit+1
    p = [1]*size
    for n in range(1,size):
        p[n] = (2*p[n-1]) % M

    return p

def binomials(limit):
    size = limit+1
    bc = [[0 for k in range(size)] for n in range(size)]
    for n in range(size):
        bc[n][0]=1

    for n in range(1,size):
        for k in range(1,n+1):
            bc[n][k] = bc[n-1][k-1] + bc[n-1][k]
            bc[n][k] %= M

    return bc

def solve():

    size = N+1
    dp = [[0 for _ in range(size)] for _ in range(size)]
    dp[1][0]=1

    for i in range(2,size):
        for k in range(1,i):
            for j in range(1,k):
                dp[i][j] += BC[i-j][k-j] * dp[k-1][j-1] * POW[i-k-1]
                dp[i][j] %= M
        dp[i][0] = POW[i-1]

    res=0
    for j in range(0,N-1):
        res = (res + dp[N][j]) % M

    return str(res)

T = 1
for test in range(1,T+1):
    N,M = map(int,line())

    BC = binomials(N)
    POW = powers(N)

    print(solve())

f.close()",O(n ^ 3)
"def main():
    n, m, k = [int(v) for v in input().split()]
    dxy = [[-1, 0], [1, 0], [0, -1], [0, 1]]

    w = [[[0 for d in range(4)] for j in range(m)] for i in range(n)]
    for i in range(n):
        row = [int(v) for v in input().split()]
        for j in range(m-1):
            w[i][j+1][2] = row[j]
            w[i][j][3] = row[j]
    for i in range(n-1):
        row = [int(v) for v in input().split()]
        for j in range(m):
            w[i][j][1] = row[j]
            w[i+1][j][0] = row[j]
    if k % 2 == 1:
        for i in range(n):
            for j in range(m):
                print(-1, end="" "")
            print()
        return
    else:
        k //= 2
    dp = [[[int(40 * 1e6) for d in range(k+1)] for j in range(m)] for i in range(n)]
    for i in range(n):
        for j in range(m):
            dp[i][j][0] = 0
    for d in range(1, k+1):
        for i in range(n):
            for j in range(m):
                for di, (dx, dy) in enumerate(dxy):
                    ii = i + dx
                    jj = j + dy
                    if 0 <= ii < n and 0 <= jj < m:
                        dp[i][j][d] = min(dp[i][j][d], dp[ii][jj][d-1] + w[i][j][di])
    for i in range(n):
        for j in range(m):
            print(dp[i][j][k] * 2, end="" "")
        print()

main()
",O(n ^ 3)
"import random


class Solution(object):
    dp = {}

    def getKth(self, lo, hi, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def partition_around_pivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left <= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == n:
                    return
                elif new_pivot_idx > n:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1
                    
        def power_value(x):
            y, result = x, 0
            while x > 1 and x not in Solution.dp:
                result += 1
                if x%2:
                    x = 3*x + 1
                else:
                    x //= 2
            Solution.dp[y] = result + (Solution.dp[x] if x > 1 else 0)
            return Solution.dp[y], y
        
        arr = list(map(power_value, list(range(lo, hi+1))))
        nth_element(arr, k-1)
        return arr[k-1][1]",O(n)
"n = int(input().rstrip())
arr = []
mod = pow(10,9) + 7
indent_num = 0
for i in range(n):
    arr.append(input().rstrip())
    if arr[i] == 'f':
        indent_num += 1
dp = [0 for i in range(indent_num + 1)]
first_block_index = 0
max_indent = 0
for i in arr:
    if i != 'f':
        break
    first_block_index += 1
    max_indent += 1

dp[max_indent] = 1

cur_indent = 0
pref = [0 for i in range(indent_num + 1)]
def cal_pref(dp, pref):
    pref[0] = dp[0]
    for i in range(1, len(dp)):
        pref[i] = pref[i - 1] + dp[i]

for i in range(first_block_index + 1,n):
    if arr[i] == 'f':
        cur_indent += 1
        max_indent += 1
        continue

    cur = [0 for i in range(indent_num + 1)]
    cal_pref(dp, pref)
    for j in range(cur_indent,indent_num + 1):
        res_idx = j - cur_indent
        res_result = pref[res_idx - 1] if res_idx > 0 else 0
        cur[j] = (pref[indent_num] - res_result) % mod

    cur[max_indent] = 1 if not cur[max_indent] else cur[max_indent]
    dp = cur
    cur_indent = 0

print(sum(dp) % mod)
",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase
import math
from queue import Queue
import collections
import itertools
import bisect
import heapq

import random

def main():
    pass

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while (n > 1):
        n //= 2
        p += 1
    return (p)

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n = n / i
    if n > 2:
        l.append(int(n))
    return (l)

def primeFactorsCount(n):
    cnt=0
    while n % 2 == 0:
        cnt+=1
        n = n // 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            cnt+=1
            n = n // i
    if n > 2:
        cnt+=1
    return (cnt)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)

def countcon(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if (s[i] == ch):
            c += 1
        else:
            break
    return (c)

def lis(arr):
    n = len(arr)
    lis = [1] * n
    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
    maximum = 0
    for i in range(n):
        maximum = max(maximum, lis[i])
    return maximum

def isSubSequence(str1, str2):
    m = len(str1)
    n = len(str2)
    j = 0
    i = 0
    while j < m and i < n:
        if str1[j] == str2[i]:
            j = j + 1
        i = i + 1
    return j == m

def maxfac(n):
    root = int(n ** 0.5)
    for i in range(2, root + 1):
        if (n % i == 0):
            return (n // i)
    return (n)

def p2(n):
    c = 0
    while (n % 2 == 0):
        n //= 2
        c += 1
    return c

def seive(n):
    primes = [True] * (n + 1)
    primes[1] = primes[0] = False
    i = 2
    while (i * i <= n):
        if (primes[i] == True):
            for j in range(i * i, n + 1, i):
                primes[j] = False
        i += 1
    pr = []
    for i in range(0, n + 1):
        if (primes[i]):
            pr.append(i)
    return pr

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p

def denofactinverse(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (pow(fac, m - 2, m))

def numofact(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (fac)

def sod(n):
    s = 0
    while (n > 0):
        s += n % 10
        n //= 10
    return s
def chk1(i):

    if(i!=n-1 and l1[i]==l2[i]==l2[i+1]==""0""):
        l1[i] = l2[i] = l2[i + 1] = ""X""
        return True
    return False
def chk2(i):

    if(i!=n-1 and l1[i]==l1[i+1]==l2[i]==""0""):
        l1[i] = l1[i + 1] = l2[i] = ""X""
        return True
    return False
def chk3(i):
    if (i != n - 1 and l1[i] == l1[i + 1] == l2[i+1] == ""0""):
        l1[i] = l1[i + 1] = l2[i+1] = ""X""
        return True
    return False
def chk4(i):
    if (i != n - 1 and l2[i+1] == l1[i + 1] == l2[i] == ""0""):
        l1[i] = l1[i + 1] = l2[i] = ""X""
        return True
    return False

def check1(i):
    if (i <= n - 3 and l1[i:i + 3] == l2[i:i + 3] == [""0"",""0"",""0""]):
        for j in range(i,i+3):
            l1[j]=l2[j]=""X""
        return True

def check2(i):
    if(chk1(i) or chk2(i) or chk3(i) or chk4(i)):
        return True
    return False

l1=list(input())
l2=list(input())

n=len(l1)
i=0
ans=0
while(i<n):
    if(check1(i)):

        ans+=2
        i+=3
    else:
        if(check2(i)):
            ans+=1
            i+=2
        else:
            i+=1
print(ans)
",O(1)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict as dd
for t in range(int(input())):
    n=int(input())
    l=list(map(int,input().split()))
    l1=dd(int)
    a=0
    for j in l:
        l1[j]+=1
        if l1[j]==4:
            a=j
    if a:
        print(a,a,a,a)
    else:
        c=0
        x=0
        l2=[]
        for j in l1:
            if l1[j]>=2:
                l2.append(j)
        l2.sort()
        for j in l2:
                c+=1
                if c==1:
                    a=j
                elif c==2:
                    b=j
                else:
                    if x/j+j/x<a/b+b/a:
                        a,b=x,j
                x=j
        print(a,a,b,b)",O(nlogn)
"n = int(input())
l1 = list(input().split())
l2 = []
for i in l1:
    l2.append(int(i))
l1 = set(l2)
l1 = list(l1)
for i in range(0, len(l1)):
    for j in range(i + 1, len(l1)):
        if l1[i] > l1[j]:
            temp = l1[j]
            l1[j] = l1[i]
            l1[i] = temp
if len(l1) > 1:
    print(l1[1])
else:
    print('NO')
",O(nlogn)
"import sys
import math
input = sys.stdin.readline

a,b,c=input().split()

s=[]
p=[]
m=[]

if a[1]=='p':
	p.append(int(a[0]))
elif a[1]=='s':
	s.append(int(a[0]))
else:
	m.append(int(a[0]))

if b[1]=='p':
	p.append(int(b[0]))
elif b[1]=='s':
	s.append(int(b[0]))
else:
	m.append(int(b[0]))

if c[1]=='p':
	p.append(int(c[0]))
elif c[1]=='s':
	s.append(int(c[0]))
else:
	m.append(int(c[0]))

s.sort()
p.sort()
m.sort()

cur=2
if len(s)==3:
	if s[0]==s[1] and s[1]==s[2]:
		cur=0
	elif s[0]==s[1] or s[1]==s[2]:
		cur=1
	else:
		if s[0]+1==s[1] and s[1]+1==s[2]:
			cur=0
		elif s[0]+1==s[1] or s[1]+1==s[2]:
			cur=1
		elif s[0]+2==s[1] or s[1]+2==s[2]:
			cur=1
		else:
			cur=2
elif len(s)==2:
	if s[0]==s[1]:
		cur=1
	elif s[0]+1==s[1]:
		cur=1
	elif s[0]+2==s[1]:
		cur=1
	else:
		cur=2
else:
	cur=2

x=2
if len(p)==3:
	if p[0]==p[1] and p[1]==p[2]:
		x=0
	elif p[0]==p[1] or p[1]==p[2]:
		x=1
	else:
		if p[0]+1==p[1] and p[1]+1==p[2]:
			x=0
		elif p[0]+1==p[1] or p[1]+1==p[2]:
			x=1
		elif p[0]+2==p[1] or p[1]+2==p[2]:
			x=1
		else:
			x=2
elif len(p)==2:
	if p[0]==p[1]:
		x=1
	elif p[0]+1==p[1]:
		x=1
	elif p[0]+2==p[1]:
		x=1
	else:
		x=2
else:
	x=2

y=2
if len(m)==3:
	if m[0]==m[1] and m[1]==m[2]:
		y=0
	elif m[0]==m[1] or m[1]==m[2]:
		y=1
	else:
		if m[0]+1==m[1] and m[1]+1==m[2]:
			y=0
		elif m[0]+1==m[1] or m[1]+1==m[2]:
			y=1
		elif m[0]+2==m[1] or m[1]+2==m[2]:
			y=1
		else:
			y=2
elif len(m)==2:
	if m[0]==m[1]:
		y=1
	elif m[0]+1==m[1]:
		y=1
	elif m[0]+2==m[1]:
		y=1
	else:
		y=2
else:
	y=2

print(min(cur,x,y))",O(nlogn)
"l, r = (int(x) for x in input().split())
limit = l ^ r

if limit != 0:
  limit = len(bin(limit)) - 2
  maxXor = '1' * limit
  print(int(maxXor, 2))
else:
  print(0)
",O(logn)
"n, p = map(int, input().split())
a = list(map(int, input().split()))
a = [c % p for c in a]
s = sum(a)
sp = s % p
if sp == s or sp + 1 == p:
    print(sp)
else:
    print(sp + p)",O(n)
"class SortedList:
    def __init__(self, iterable=None, _load=200):

        if iterable is None:
            iterable = []
        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):

        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):

        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):

        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):

        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):

        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):

        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):

        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):

        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):

        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):

        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):

        return self._len

    def __getitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):

        return (value for _list in self._lists for value in _list)

    def __reversed__(self):

        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):

        return 'SortedList({0})'.format(list(self))
n,x,y=map(int,input().split())
xx=[]
for i in range(n):
    xx.append(tuple(map(int,input().split())))

xx.sort()

mod=10**9+7
tv=SortedList()
end=[]
c=0
an=0
for i in xx:

    if not len(tv):
        tv.add(i[1])
        an+=x+(i[1]-i[0])*y
    else:
        if tv[0]>=i[0]:
            tv.add(i[1])
            an =(an+ x + (i[1] - i[0]) * y)%mod
        else:
            pp=tv.bisect_left(i[0])-1
            tt=tv[pp]
            del tv[pp]
            tv.add(i[1])
            an=(an+min(x,(i[0]-tt)*y)+(i[1]-i[0])*y)%mod

print(an)",O(nlogn)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def diameterOfBinaryTree(self, root):
        def iter_dfs(node):
            result = 0
            stk = [(1, [node, [0]])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, [node, ret1, ret2, ret]))
                    stk.append((1, [node.right, ret2]))
                    stk.append((1, [node.left, ret1]))
                elif step == 2:
                    node, ret1, ret2, ret = params
                    result = max(result, ret1[0]+ret2[0])
                    ret[0] = 1+max(ret1[0], ret2[0])
            return result
        
        return iter_dfs(root)",O(n)
"class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        count = {}
        for num in nums:
            count[num] = 1 + count.get(num, 0)

        arr = []
        for num, cnt in count.items():
            arr.append([cnt, num])
        arr.sort()

        res = []
        while len(res) < k:
            res.append(arr.pop()[1])
        return res
",O(nlogn)
"class Solution(object):
    def rearrangeArray(self, nums):
        pos, neg = 0, 1
        result = [0]*len(nums)
        for x in nums:
            if x > 0:
                result[pos] = x
                pos += 2
            else:
                result[neg] = x
                neg += 2
        return result",O(n)
"class Solution(object):
    def minimumAbsDifference(self, arr):
        result = []
        min_diff = float(""inf"")
        arr.sort()
        for i in range(len(arr)-1):
            diff = arr[i+1]-arr[i]
            if diff < min_diff:
                min_diff = diff
                result = [[arr[i], arr[i+1]]]
            elif diff == min_diff:
                result.append([arr[i], arr[i+1]])
        return result",O(nlogn)
"class Solution(object):
    def hasSpecialSubstring(self, s, k):
        l = 0
        for i in range(len(s)):
            l += 1
            if i+1 == len(s) or s[i] != s[i+1]:
                if l == k:
                    return True
                l = 0
        return False",O(n)
"from math import factorial
from decimal import *
A=input()
B=input()
a=0
cnt2=0
cnt1=0
b=0
for i in A:
    if i=='+':
        a+=1
        cnt1+=1
    else:
        a-=1
        cnt2+=1
cnt3=0
cnt=0
cnt4=0
for i in B:
    if i=='+':
        b+=1
        cnt3+=1
    elif i=='-':
        b-=1
        cnt4+=1
    else:
        cnt+=1
if cnt3>cnt1 or cnt4>cnt2:
    print(format(0,'.12f'))
else:
    No_of_plus=cnt1-cnt3
    No_of_minus=cnt2-cnt4
    Total_cases=2**cnt
    Total_No_of_favourable_cases=factorial(cnt)//(factorial(No_of_plus)*factorial(No_of_minus))

    print(format(Decimal(Total_No_of_favourable_cases)/Decimal(Total_cases), '.12f'))
",np
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        l, r = 0, 1
        maxP = 0

        while r < len(prices):
            if prices[l] < prices[r]:
                profit = prices[r] - prices[l]
                maxP = max(maxP, profit)
            else:
                l = r
            r += 1
        return maxP
",O(n)
"import os
import re
import sys
from bisect import bisect, bisect_left, insort, insort_left
from collections import Counter, defaultdict, deque
from copy import deepcopy
from decimal import Decimal
from fractions import gcd
from io import BytesIO, IOBase
from itertools import (
    accumulate, combinations, combinations_with_replacement, groupby,
    permutations, product)
from math import (
    acos, asin, atan, ceil, cos, degrees, factorial, hypot, log2, pi, radians,
    sin, sqrt, tan)
from operator import itemgetter, mul
from string import ascii_lowercase, ascii_uppercase, digits

def inp():
    return(int(input()))

def inlist():
    return(list(map(int, input().split())))

def instr():
    s = input()
    return(list(s[:len(s)]))

def invr():
    return(map(int, input().split()))

def getSum(p, q):
    n = q - p + 1

    temp = (n * (p + q)//2) - n + 1

    return temp, n

def main():

    n, k = invr()

    l = 2
    r = k
    ans = -1

    while l <= r:
        mid = l + (r - l) // 2
        tot, count = getSum(mid, k)
        if tot >= n:
            ans = count
        if tot < n:
            r = mid - 1
        else:
            l = mid + 1
    if n == 1:
        ans = 0
    print(ans)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(logn)
"n,k = map(int,input().split())
t = input()
if n==1:
    print(t*k)
else:
    i = len(t)-1
    while i>0 and t[-i:] != t[:i]:
            i-=1
    t2 = t[i:]
    print(t+t2*(k-1))",O(n ^ 2)
"class Solution2(object):
    def baseNeg2(self, N):
        BASE = -2
        result = []
        while N:
            N, r = divmod(N, BASE)
            if r < 0:
                r -= BASE
                N += 1
            result.append(str(r))
        result.reverse()
        return """".join(result) if result else ""0""",O(logn)
"n = int(input())
a = input().split()
d = {}
k = 0
for i in range(len(a)):
    d[a[i]] = i
for s in input().split():
    if d[s] != -1:
        c = d[s]
        print(c - k + 1, end=' ')
        for i in range(k, c + 1):
            d[a[i]] = -1
        k = c + 1
    else:
        print(0, end=' ')
",O(n)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        pass



class Solution(object):
    def removeNodes(self, head):
        stk = []
        while head:
            while stk and stk[-1].val < head.val:
                stk.pop()
            if stk:
                stk[-1].next = head
            stk.append(head)
            head = head.__next__
        return stk[0]",O(n)
"import math

n, r = (int(x) for x in input().split())

s = math.sin(math.pi/n)
ans = (r*s)/(1-s)

print(""%.7f"" % ans)",O(1)
"class Solution(object):
    def isValid(self, s):
        stack, lookup = [], {""("": "")"", ""{"": ""}"", ""["": ""]""}
        for parenthese in s:
            if parenthese in lookup:
                stack.append(parenthese)
            elif len(stack) == 0 or lookup[stack.pop()] != parenthese:
                return False
        return len(stack) == 0",O(n)
"class Solution(object):
    def areSentencesSimilar(self, sentence1, sentence2):
        if len(sentence1) > len(sentence2):
            sentence1, sentence2 = sentence2, sentence1
        count = 0
        for idx in (lambda x:x, lambda x:-1-x):
            for i in range(len(sentence1)+1):
                c1 = sentence1[idx(i)] if i != len(sentence1) else ' '
                c2 = sentence2[idx(i)] if i != len(sentence2) else ' '
                if c1 != c2:
                    break
                if c1 == ' ':
                    count += 1
        return count >= sentence1.count(' ')+1",O(n)
"class Solution(object):
    def maxConsecutive(self, bottom, top, special):
        special.sort()
        result = max(special[0]-bottom, top-special[-1])
        for i in range(1, len(special)):
            result = max(result, special[i]-special[i-1]-1)
        return result",O(nlogn)
"x=input()
x,k=x.split()
x=int(x)
k=int(k)
mul=pow(2,k+1,1000000007)
y=(x%1000000007*mul)%1000000007
ans=y
if x!=0:
    ans=(ans%1000000007-(pow(2,k,1000000007)-1)%1000000007)%1000000007

print(ans)",O(logn)
"x, y, z, t1, t2, t3, = map(int, input().split())
if abs(x-z)*t2 + abs((x-y))*t2 + t3*3 <= t1*abs((x-y)):
    print(""YES"")
else:
    print(""NO"")",O(1)
"ax, ay = map(int, input().split())
bx, by = map(int, input().split())
cx, cy = map(int, input().split())
if ax > bx:
    ax, bx = bx, ax
    ay, by = by, ay
if ax > cx:
    ax, cx = cx, ax
    ay, cy = cy, ay
if bx > cx:
    bx, cx = cx, bx
    by, cy = cy, by
ans = []
for i in range(min(ay, by, cy), max(ay, by, cy) + 1):
    ans.append([bx, i])
for i in range(ax, bx):
    ans.append([i, ay])
for i in range(bx + 1, cx + 1):
    ans.append([i, cy])
print(len(ans))
for x in ans:
    print(x[0], x[1])
",O(1)
"class Solution2(object):
    def minimumPerimeter(self, neededApples):
        x = int((2*neededApples)**(1.0/3))
        x -= x%2
        assert((x-2)*(x-1)*x < 2*neededApples < (x+2)**3)
        x += 2
        if (x-2)*(x-1)*x < 2*neededApples:
            x += 2
        return 8*(x-2)//2",O(1)
"a,b,c,n= [int(c) for c in input().split()]
u=a+b-c
if a<c or b<c:
	print(-1)
else:
	if n-u>=1:
		print(n-u)
	else:
		print(-1)
",O(1)
"n, m, k = list(map(int, input().split()))
a = list(map(int, input().split()))
ret = 0
for i in range(m):
	cur = 0
	for j in range(i, n):
		if j % m == i:
			cur = max(0, cur)
			cur -= k
		cur += a[j]
		ret = max(ret, cur)
print(ret)
",O(n ^ 2)
"from collections import Counter

def mx(f):
    res = []
    for k in sorted(f.keys(), reverse=True):
        for _ in range(f[k]):
            res.append(k)
    return res

def solve(n, a, b):
    res = None
    for k in range(n + 1):
        aa = Counter(a)
        cur = []
        for i in range(k):
            if aa[b[i]] == 0:
                return res
            cur.append(b[i])
            aa[b[i]] -= 1
        if k < n:
            for e in range(b[k] - 1, -1, -1):
                if aa[e] > 0:
                    cur.append(e)
                    aa[e] -= 1
                    cur.extend(mx(aa))
                    break
            if len(cur) < n:
                continue
        res = cur
    return res

a = Counter(map(int, input()))
b = list(map(int, input()))
if sum(a.values()) < len(b):
    res = mx(a)
else:
    res = solve(len(b), a, b)
print(''.join(map(str, res)))",O(n ^ 3)
"class Solution:

    def countSubstrings(self, s: str) -> int:
        res = 0

        for i in range(len(s)):
            res += self.countPali(s, i, i)
            res += self.countPali(s, i, i + 1)
        return res

    def countPali(self, s, l, r):
        res = 0
        while l >= 0 and r < len(s) and s[l] == s[r]:
            res += 1
            l -= 1
            r += 1
        return res
",O(n ^ 2)
"class Solution2(object):
    def getDirections(self, root, startValue, destValue):
        def dfs(node, val, path):
            if node.val == val:
                return True
            if node.left and dfs(node.left, val, path):
                path.append('L')
            elif node.right and dfs(node.right, val, path):
                path.append('R')
            return path

        src, dst = [], []
        dfs(root, startValue, src)
        dfs(root, destValue, dst)
        while len(src) and len(dst) and src[-1] == dst[-1]:
            src.pop()
            dst.pop()
        dst.reverse()
        return """".join(['U']*len(src) + dst)",O(n)
"class Solution2(object):
    def findDuplicates(self, nums):
        result = []
        i = 0
        while i < len(nums):
            if nums[i] != nums[nums[i]-1]:
                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]
            else:
                i += 1

        for i in range(len(nums)):
            if i != nums[i]-1:
                result.append(nums[i])
        return result",O(n)
"class Solution(object):
    def maxIntersectionCount(self, y):
        val_to_idx = {x:i for i, x in enumerate(sorted(set(y)))}
        cnts = [0]*(2*len(val_to_idx)+1)
        for i in range(len(y)-1):
            left, right = 2*val_to_idx[y[i]], 2*val_to_idx[y[i+1]]+(-1 if y[i] < y[i+1] else +1)
            cnts[min(left, right)] += 1
            cnts[max(left, right)+1] -= 1
        cnts[2*val_to_idx[y[-1]]] += 1
        cnts[2*val_to_idx[y[-1]]+1] -= 1
        result = cnt = 0
        for c in cnts:
            cnt += c
            result = max(result, cnt)
        return result",O(nlogn)
"class Solution(object):
    def generate(self, numRows):
        result = []
        for i in range(numRows):
            result.append([])
            for j in range(i + 1):
                if j in (0, i):
                    result[i].append(1)
                else:
                    result[i].append(result[i - 1][j - 1] + result[i - 1][j])
        return result

    def generate2(self, numRows):
        if not numRows: return []
        res = [[1]]
        for i in range(1, numRows):
            res += [list(map(lambda x, y: x + y, res[-1] + [0], [0] + res[-1]))]
        return res[:numRows]

    def generate3(self, numRows):
        if numRows == 0: return []
        if numRows == 1: return [[1]]
        res = [[1], [1, 1]]

        def add(nums):
            res = nums[:1]
            for i, j in enumerate(nums):
                if i < len(nums) - 1:
                    res += [nums[i] + nums[i + 1]]
            res += nums[:1]
            return res

        while len(res) < numRows:
            res.extend([add(res[-1])])
        return res",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase

def main():
    n,m,k=map(int,input().split())
    if (k%2==0):
        DP=[[[10**9 for i in range(m)] for j in range(n)] for v in range(k//2)]
        A=[]
        B=[]
        for i in range(n):
            L=list(map(int,input().split()))
            A.append(L)
            for j in range(m-1):
                DP[0][i][j]=min(DP[0][i][j],L[j])
                DP[0][i][j+1]=min(L[j],DP[0][i][j+1])

        for i in range(n-1):
            L=list(map(int,input().split()))
            B.append(L)
            for j in range(m):
                DP[0][i][j]=min(DP[0][i][j],L[j])
                DP[0][i+1][j]=min(DP[0][i+1][j],L[j])

        for k1 in range(1,k//2):
            for i in range(n):
                for j in range(m):
                    if (i>0):
                        DP[k1][i][j]=min(DP[k1][i][j],B[i-1][j]+DP[k1-1][i-1][j])
                    if (j>0):
                        DP[k1][i][j]=min(DP[k1][i][j],A[i][j-1]+DP[k1-1][i][j-1])
                    if (i<(n-1)):
                        DP[k1][i][j]=min(DP[k1][i][j],B[i][j]+DP[k1-1][i+1][j])
                    if (j<(m-1)):
                        DP[k1][i][j]=min(DP[k1][i][j],A[i][j]+DP[k1-1][i][j+1])

        for val in DP[(k//2)-1]:
            ans=[i*2 for i in val]
            print(*ans)

    else:
        for i in range(n):
            L=list(map(int,input().split()))

        for i in range(n-1):
            L=list(map(int,input().split()))

        for i in range(n):
            ans=[-1]*m
            print(*ans)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"n = int(input())
black = list(input())
white = list(input())
katie = list(input())

ALPHABET = [chr(i) for i in range(65, 65+26)] + [chr(i)
                                                 for i in range(97, 97+26)]

def optimal_score(LIST):
    d = {char: 0 for char in ALPHABET}
    for v in LIST:
        d[v] += 1
    max_freq = max(d.values())
    L = len(LIST)
    res = 0
    for freq in d.values():
        if L - freq >= n:
            res = max(res, freq + n)
        else:
            if not (L -freq < n and n == 1):
                res = L
            else:
                res = max(res, L - 1)
    return res

score_black = optimal_score(black)
score_white = optimal_score(white)
score_katie = optimal_score(katie)

M = max(score_black, score_katie, score_white)
MAXCNT = 0

winner = ""NOBODY""

if M == score_black:
    winner = ""Kuro""
    MAXCNT += 1
if M == score_white:
    winner = ""Shiro""
    MAXCNT += 1
if M == score_katie:
    winner = ""Katie""
    MAXCNT += 1

if MAXCNT == 1:
    print(winner)

else:
    print(""Draw"")
",O(n)
"def check(s,t1,t2):
    s1 = len(t1)
    s2 = len(t2)
    n = len(s)
    dp = [[-1] * (s1+1) for i in range(n + 1)]
    dp[0][0] = 0
    for i in range(n):
        for j in range(s1+1):
            if dp[i][j] >= 0:
                if  j < s1 and t1[j] == s[i]:
                    dp[i+1][j+1] = max(dp[i+1][j+1],dp[i][j])
                if dp[i][j] < s2 and t2[dp[i][j]] == s[i]:
                    dp[i+1][j] = max(dp[i+1][j],dp[i][j]+1)
            dp[i+1][j] = max(dp[i+1][j],dp[i][j])

    if dp[n][s1] == s2:
        return True
    else:
        return False

def solve():
    s = input()
    t = input()
    le = len(t)

    for i in range(le):
        t1 = t[:i]
        t2 = t[i:]
        if check(s,t1,t2) == True:
            print(""YES"")
            return
    print(""NO"")

T = int(input())
while T:
    T -= 1
    solve()",O(n ^ 3)
"def sum_of_digits(n):
    ans = 0
    while(n):
        ans += n%10
        n//=10
    return ans

n,s = map(int,input().split())
lo = 0; hi = n
x = n+1
while(lo<=hi):
    mid = (lo+hi)//2
    if(mid - sum_of_digits(mid) >= s):
        x = min(mid,x)
        hi = mid - 1
    else:
        lo = mid + 1
print(n - x + 1)",O(logn)
"n = int(input())
values = list(map(int, input().split()))
queries = int(input())

dp = [[0] * 5009 for i in range(5009)]

for i in range(n):
    dp[0][i] = values[i]

for i in range(1, n):
    for j in range(n-i+1):
        top = dp[i-1][j]
        right = dp[i-1][j+1]
        dp[i][j] = top ^ right

for i in range(1, n):
    for j in range(n-i+1):
        top = dp[i-1][j]
        right = dp[i-1][j+1]
        dp[i][j] = max(right, max(dp[i][j], top))

for i in range(queries):
    left, right = map(int, input().split())
    last_row = (right - 1) - (left - 1)
    last_column = (left - 1)
    print(dp[last_row][last_column])
",O(n ^ 2)
"n = int(input())

dp = [0] * 1000007

majak = [0] * 1000007

q = 1000007

p = 0

for i in range(n):

    a, b = map(int, input().split())

    q = min(q, a)

    majak[a] = b

dp[q] = 1

ma = 1

for i in range(q + 1, 1000003, 1):

    if(majak[i] == 0):

        dp[i] = dp[i - 1]

    else:

        dp[i] = dp[i - majak[i] - 1] + 1

        ma = max(ma, dp[i])

print(n - ma)
",O(n)
"import bisect


class Solution(object):
    def nextGreatestLetter(self, letters, target):
        i = bisect.bisect_right(letters, target)
        return letters[0] if i == len(letters) else letters[i]",O(logn)
"def main():
    high = 10 ** 12
    n, m, k = map(int, input().split())
    hozs = []
    for i in range(n):
        hozs.append(list(map(int, input().split())))
    verts = []
    for i in range(n - 1):
        verts.append(list(map(int, input().split())))
    if k % 2:
        for i in range(n):
            print(""-1 "" * m)
        return
    k //= 2
    dp = []
    for i in range(n):
        dp.append([])
        for j in range(m):
            dp[-1].append([])
            for kay in range(k + 1):
                dp[-1][-1].append(0)
    for depth in range(1, k + 1):
        for i in range(n):
            for j in range(m):
                if i == 0:
                    up = high
                else:
                    up = verts[i - 1][j] + dp[i - 1][j][depth - 1]
                if i == n - 1:
                    down = high
                else:
                    down = verts[i][j] + dp[i + 1][j][depth - 1]
                if j == 0:
                    left = high
                else:
                    left = hozs[i][j - 1] + dp[i][j - 1][depth - 1]
                if j == m - 1:
                    right = high
                else:
                    right = hozs[i][j] + dp[i][j + 1][depth - 1]
                min_cost = min(up, down, left, right)

                dp[i][j][depth] += min_cost
    for i in range(n):
        print(*[2 * dp[i][j][k] for j in range(m)])
main()",O(n ^ 3)
"x, k = map(int, input().split())
if x == 0:
    print(0)
    exit()
mod = 10**9+7
ans = 1+(2*x-1)*pow(2, k, mod)
print(ans%mod)
",O(logn)
"class Solution(object):
    def getHappyString(self, n, k):
        base = 2**(n-1)
        if k > 3*base:
            return """"
        result = [chr(ord('a')+(k-1)//base)]
        while base > 1:
            k -= (k-1)//base*base
            base //= 2
            result.append(('a' if result[-1] != 'a' else 'b') if (k-1)//base == 0 else
                          ('c' if result[-1] != 'c' else 'b'))
        return """".join(result)",O(n)
"class Solution(object):
    def squareIsWhite(self, coordinates):
        return (ord(coordinates[0])-ord('a'))%2 != (ord(coordinates[1])-ord('1'))%2",O(1)
"import math

[n,k]=[int(i) for i in input().split()]

if(n==1):
	print(0)
else:

	r=int(math.sqrt(9+8*(k+n)))
	y=(-3+r)//2
	print(n-y)
",O(logn)
"import math
import collections

def func(a, k):
    if a % k != 0:
        mod = 1
    else:
        mod = 0
    return math.floor(a / k) * k + mod * k

n, m, k = input().split()
list = input().split()
k = int(k)
temp = k
size = 0
answer = 0
c = 0
c2 = 0
check = 'false'
used = 0

temp = func(int(list[0]), k)
for i in range(len(list)):
    list[i] = int(list[i])
    used = 0
    if list[i] <= temp:
        c += 1
        check = 'true'
        used = 1
    if list[i] >= temp:
        if check is 'true':
            answer += 1
            check = 'false'
            temp += c
            c = 0
            if list[i] - c <= temp and used == 0:
                c += 1
                check = 'true'
                used = 1
            else:
                temp = temp + func(int(list[i]) - temp, k)
                if list[i] - c <= temp and used == 0:
                    c += 1
                    check = 'true'
                    used = 1
        elif check is 'false':
            temp = temp + func(int(list[i]) - temp, k)
            if list[i] - c <= temp and used == 0:
                c += 1
                check = 'true'
                used = 1

print(answer if check is 'false' else answer + 1)",O(n)
"class Solution6(object):
    def bestTeamScore(self, scores, ages):
        players = sorted(zip(ages, scores))
        dp = [0]*len(players)
        result = 0
        for i in range(len(players)):
            dp[i] = players[i][1]
            for j in range(i):
                if players[j][1] <= players[i][1]:
                    dp[i] = max(dp[i], dp[j] + players[i][1])
            result = max(result, dp[i])
        return result",O(n ^ 2)
"x, y, z, t1, t2, t3 = map(int, input().split())
a = abs(x - y) * t1
b = abs(x - z) * t2 + abs(x - y) * t2 + t3 * 3
if a < b:
    print('NO')
else:
    print('YES')",O(1)
"class Solution(object):
    def nthUglyNumber(self, n, a, b, c):
        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a

        def lcm(x, y):
            return x//gcd(x, y)*y

        def count(x, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c):
            return x//a + x//b + x//c - (x//lcm_a_b + x//lcm_b_c + x//lcm_c_a) + x//lcm_a_b_c

        lcm_a_b, lcm_b_c, lcm_c_a = lcm(a, b), lcm(b, c), lcm(c, a)
        lcm_a_b_c = lcm(lcm_a_b, lcm_b_c)

        left, right = 1, 2*10**9
        while left <= right:
            mid = left + (right-left)//2
            if count(mid, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c) >= n:
                right = mid-1
            else:
                left = mid+1
        return left",O(logn)
"class Solution4(object):
    def trap(self, height):
        result = 0
        stk = []
        for i in range(len(height)):
            prev = 0
            while stk and height[stk[-1]] <= height[i]:
                j = stk.pop()
                result += (height[j] - prev) * (i - j - 1)
                prev = height[j]
            if stk:
                result += (height[i] - prev) * (i - stk[-1] - 1)
            stk.append(i)
        return result",O(n)
"class Solution2(object):
    def stoneGameV(self, stoneValue):
        n = len(stoneValue)
        prefix = [0]
        for v in stoneValue:
            prefix.append(prefix[-1] + v)

        mid = [[0]*n for _ in range(n)]
        for l in range(1, n+1):
            for i in range(n-l+1):
                j = i+l-1
                p = i if l == 1 else mid[i][j-1]
                while prefix[p]-prefix[i] < prefix[j+1]-prefix[p]:
                    p += 1 
                mid[i][j] = p
        
        rmq = [[0]*n for _ in range(n)]
        for i in range(n):
            rmq[i][i] = stoneValue[i]

        dp = [[0]*n for _ in range(n)]
        for l in range(2, n+1):
            for i in range(n-l+1):
                j = i+l-1
                p = mid[i][j]
                max_score = 0
                if prefix[p]-prefix[i] == prefix[j+1]-prefix[p]:
                    max_score = max(rmq[i][p-1], rmq[j][p])
                else:
                    if i <= p-2:
                        max_score = max(max_score, rmq[i][p-2])
                    if p <= j:
                        max_score = max(max_score, rmq[j][p])
                dp[i][j] = max_score
                rmq[i][j] = max(rmq[i][j-1], (prefix[j+1]-prefix[i]) + max_score)
                rmq[j][i] = max(rmq[j][i+1], (prefix[j+1]-prefix[i]) + max_score)
        return dp[0][n-1]",O(n ^ 2)
"from sys import stdin
input = stdin.buffer.readline

n,m=map(int,input().split())
arr=[int(x) for x in input().split()]

dp=[[] for i in range(m)]
for i in range(n):
    dp[arr[i]%m].append(i)

res=0
k=n//m
ans=arr.copy()
s=[]
for t in range(2):
    for i in range(m):
        if len(dp[i])<k:
            while len(s)!=0 and len(dp[i])<k:
                x=s.pop()
                y=arr[x]%m
                if i>y:
                    ans[x]=ans[x]+(i-y)
                    res=res+(i-y)
                else:
                    ans[x]=ans[x]+(m-1-y)+(i+1)
                    res=res+(m-1-y)+(i+1)
                dp[i].append(""xxx"")
        if len(dp[i])>k:
            while len(dp[i])>k:
                s.append(dp[i].pop())

print(res)
print(*ans)",O(n)
"n = int(input())
p = [list(map(int, input().split())) for _ in range(n)]
f = lambda a, b, c: (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])
def g(fi, se, p):
    q = []
    for x in p:
        if f(fi, se, x):
            if len(q) < 2:
                q.append(x)
            else:
                if f(q[0], q[1], x):
                    return 1
    return 0
print('NO' if n > 4 and all([g(p[0], p[1], p), g(p[0], p[2], p), g(p[1], p[2], p)]) else 'YES')
",O(nlogn)
"from collections import defaultdict

def E1():

    mod = 10 ** 9 + 7

    comb = [[1]]
    for i in range(1, 1010):
        x = [1]
        for j in range(1, i):
            x.append((comb[i - 1][j - 1] + comb[i - 1][j]) % mod)
        x.append(1)
        comb.append(x)

    dp = [1]
    for i in range(1, 1010):
        r = 0
        for k in range(i):
            r += dp[k] * comb[i - 1][k]
            r %= mod
        dp.append(r)

    m, n = map(int, input().split())

    ns = [0 for __ in range(m)]
    for j in range(n):
        temp = input()
        s = [int(i) for i in temp]
        for i in range(m):
            ns[i] |= s[i] << j

    dd = defaultdict(int)
    for e in ns:
        dd[e] += 1

    ans = 1
    for b in dd.values():
        ans = ans * dp[b] % mod

    print(ans)

if __name__=='__main__':
    E1()
",O(n ^ 2)
"def isPrime(n):
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return False
n=int(input());d=0
if n%2==0:
    print('4 '+str(n-4))
else:
    i=4
    while i<=int(n//2)+1:
        k=n-i
        if isPrime(k)==False:
            print(str(i)+' '+str(k))
            break
        i+=2
",O(1)
"class Solution(object):
    def canSortArray(self, nums):
        def popcount(x):
            return bin(x).count(""1"")
    
        left = mx = 0
        for right in range(len(nums)):
            if right+1 != len(nums) and popcount(nums[right+1]) == popcount(nums[right]):
                continue
            if mx > min(nums[i] for i in range(left, right+1)):
                return False
            mx = max(nums[i] for i in range(left, right+1))
            left = right+1
        return True",O(n)
"class Solution(object):
    def shiftingLetters(self, S, shifts):
        result = []
        times = sum(shifts) % 26
        for i, c in enumerate(S):
            index = ord(c) - ord('a')
            result.append(chr(ord('a') + (index+times) % 26))
            times = (times-shifts[i]) % 26
        return """".join(result)",O(n)
"USE_STDIO = False

if not USE_STDIO:
    try: import mypc
    except: pass

def main():
    q,  = map(int, input().split(' '))
    for _ in range(q):
        n, m, k = map(int, input().split(' '))
        if n > k or m > k:
            print(-1)
        elif (n - m) % 2:
            print(k - 1)
        elif (n - k) % 2:
            print(k - 2)
        else:
            print(k)

if __name__ == '__main__':
    main()
",O(1)
"import math
def sportMafia(n,k):
    r=round(n+1.5-math.sqrt(2*(n+k)+2.75))
    return r

n,k = map(int,input().split())
print(sportMafia(n,k))
",O(logn)
"def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]

def Binary_Search(arr , n , x):
    l , r = 0 , n-1
    while l <= r :
        mid = l + (r - l )//2
        if arr[mid] == x :
            return mid+1
        elif arr[mid] > x :
            r = mid - 1
        else:
            l = mid + 1
    return r + 1

n , q = MAP()
a = LIST()
b = LIST()
ps = list(accumulate(a))
res = []
sm = 0
for i in range(q):
    sm += b[i]
    if sm >= ps[-1]:
        res.append(n)
        sm = 0
    else:
        z = (Binary_Search(ps , n , sm))
        res.append(n - z)
for i in res:
    print(i)
",O(nlogn)
"def find(curr_pos, max_pos, curr_s, choose):
    if curr_pos == 0:
        if curr_s <= 0:
            return True
        else:
            return False
    if curr_pos == max_pos:
        low = 1
    else:
        low = 0
    high = 9
    for d in range(low, high + 1):
        curr_val = d * (10 ** curr_pos -  1)
        if curr_val + p[curr_pos - 1] < curr_s:
            continue
        choose[curr_pos] = d
        return find(curr_pos - 1, max_pos, curr_s - curr_val, choose)
    return False

n, s = map(int, input().split())
p = [0]
for i in range(1, 19):
    p.append(p[-1] + 9 * (10 ** i - 1))
choose = [0] * 19
ans = n + 1
for num_digit in range(1, 19):
    for i in range(1, num_digit + 1):
        choose[i] = 0
    if find(num_digit, num_digit, s, choose):
        res = 0
        for i in range(num_digit, -1, -1):
            res = res * 10 + choose[i]
        ans = min(ans, res)
        break
print(n - ans + 1)",O(logn)
"class Solution(object):
    def getMaxLen(self, nums):
        result, neg_cnt, last_zero_pos, first_valid_neg_pos = 0, 0, -1, -1
        for i in range(len(nums)):
            if nums[i] == 0:
                neg_cnt = 0
                last_zero_pos = i
                first_valid_neg_pos = -1
                continue
            if nums[i] < 0:
                if first_valid_neg_pos == -1:
                    first_valid_neg_pos = i
                neg_cnt += 1
            result = max(result, i-(last_zero_pos if neg_cnt%2 == 0 else first_valid_neg_pos))
        return result",O(n)
"n , k = map(int , input().split())
lst = []
for i in range(n):
    p , t =  map(int , input().split())
    lst.append([p,-t])

tmp  = sorted(lst , key =lambda x : (x[0],x[-1]) , reverse = True)[k-1]
print(lst.count(tmp))",O(nlogn)
"import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__
m,n=[int(ele) for ele in input().split()]
a=[]
for i in range(m):
    a.append(list(map(int, input().split())))

ina,mo=0,10**9+1
pos1,pos2=0,0
mask=(1<<n)-1
def check(tang):
    key=set()
    dic=dict()
    for i in range(m):
        temp=0
        for j in range(n):
            if a[i][j]>=tang:

                temp+=(1<<j)

        if temp in key:
            continue
        key.add(temp)
        tempk=temp
        while tempk>=0:
            tempk &= temp
            dic[tempk]=i
            tempk-=1

        tocheck = mask ^ temp

        if tocheck in dic:
            return dic[tocheck],i,True

    return -1,-1,False

while ina<mo-1:

    tang=(ina+mo)//2

    temppos1,temppos2,status=check(tang)

    if status:
        pos1,pos2=temppos1,temppos2
        ina=tang
    else:
        mo=tang
print(pos1+1,pos2+1)
",np
"class Solution(object):
    def numDifferentIntegers(self, word):
        result, num = set(), None
        for i in range(len(word)+1):
            c = word[i] if i < len(word) else ' '
            if c.isdigit():
                num = 10*num+int(c) if num is not None else int(c)
            elif num is not None:
                result.add(num)
                num = None
        return len(result)",O(n)
"import sys
input = sys.stdin.readline
from itertools import combinations
from collections import defaultdict
n,m = map(int,input().split())
a = [list(map(int,input().split())) for i in range(n)]
mx = max(max(a[i]) for i in range(n))
if n == 1:
  print(1,1)
  exit()
l = 0
r = mx+1
while l+1 < r:
  flg = 0
  x = (l+r)//2
  jud = set()
  dc = defaultdict(int)
  for i in range(n):
    jnum = 0
    for j in range(m):
      if a[i][j] >= x:
        jnum += 1<<j
    if dc[jnum] == 0:
      dc[jnum] = i+1
    if jnum == (1<<m)-1:
      flg = 1
      if i == 0:
        ans = (i+1,i+2)
      else:
        ans = (1,i+1)
    jud.add(jnum)
  for p,q in combinations(jud,2):
    if p|q == (1<<m)-1:
      flg = 1
      ans = (dc[p],dc[q])
  if flg:
    l = x
  else:
    r = x
if l == 0:
  print(1,2)
else:
  print(*ans)",np
"n=int(raw_input())

l=list(map(int,raw_input().split()))

index = []
ans=[]
for i in range(n):
	index.append(i+1)
	ans.append(0)

l1,index1 = zip(*sorted(zip(l, index),reverse=True))

for i in range(n):

	k=1
	flag=False
	while (index1[i]-k*l1[i])>0:
		if l[index1[i]-k*l1[i]-1]>l[index1[i]-1]:
			if ans[index1[i]-k*l1[i]-1]==""B"":
				ans[index1[i]-1]=""A""
				flag=True
				break
		k+=1

	k=1
	if flag==False:
		while (index1[i]+k*l1[i])<=n:
			if l[index1[i]+k*l1[i]-1]>l[index1[i]-1]:
				if ans[index1[i]+k*l1[i]-1]==""B"":
					ans[index1[i]-1]=""A""
					flag=True
					break
			k+=1

	if flag==False:
		ans[index1[i]-1]=""B""

print(''.join(ans))
",O(nlogn)
"class Solution:
    def climbStairs(self, n: int) -> int:
        sqrt5 = math.sqrt(5)
        phi = (1 + sqrt5) / 2
        psi = (1 - sqrt5) / 2
        n += 1
        return round((phi**n - psi**n) / sqrt5)
",O(logn)
"n, m = int(input()), int(input())
value = False
for j in range(n + 1):
    if pow(2, j) > m:
        value = True
        break
if value:
    print(m)
else:
    print(m % pow(2, n))",O(1)
"class TrieNode:
    def __init__(self):
        self.children = {}
        self.endOfWord = False

class PrefixTree:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        cur = self.root
        for c in word:
            if c not in cur.children:
                cur.children[c] = TrieNode()
            cur = cur.children[c]
        cur.endOfWord = True

    def search(self, word: str) -> bool:
        cur = self.root
        for c in word:
            if c not in cur.children:
                return False
            cur = cur.children[c]
        return cur.endOfWord

    def startsWith(self, prefix: str) -> bool:
        cur = self.root
        for c in prefix:
            if c not in cur.children:
                return False
            cur = cur.children[c]
        return True
",O(n)
"class Solution(object):
    def reformatDate(self, date):
        lookup = {""Jan"":1, ""Feb"":2, ""Mar"":3, ""Apr"":4,
                  ""May"":5, ""Jun"":6, ""Jul"":7, ""Aug"":8,
                  ""Sep"":9, ""Oct"":10, ""Nov"":11, ""Dec"":12}
        return ""{:04d}-{:02d}-{:02d}"".format(int(date[-4:]), lookup[date[-8:-5]], int(date[:date.index(' ')-2]))",O(1)
"import math
import collections
import bisect
import heapq
import time
import itertools
import sys

N = int(input())
B = [int(x) for x in input().split()]

A = [0] * N

i, j = N//2-1, N//2
A[i] = B[-1] // 2
A[j] = B[-1] // 2 if B[-1] % 2 == 0 else B[-1] // 2 + 1
l, r = A[i], A[j]
for bi in range(len(B)-2, -1, -1):
    b = B[bi]
    i -= 1
    j += 1

    if b-l >= A[j-1]:
        A[i] = l
        A[j] = b-l
        r = b-l
    else:
        A[j] = r
        A[i] = b-r
        l = b-r

print(' '.join(map(str, A)))
",O(n)
"N = int(input())
src = [tuple(map(int,input().split() + [i])) for i in range(N)]
src.sort()

prev_l = max_r = 0
prev_i = outer = -1
for l,r,i in src:
    if prev_l == l:
        print(prev_i+1, i+1)
        exit()
    if r <= max_r:
        print(i+1, outer+1)
        exit()
    else:
        max_r = r
        outer = i
    prev_l = l
    prev_i = i
print(-1,-1)
",O(nlogn)
"n, m = int(input()), int(input())
value = False
for j in range(n + 1):
    if pow(2, j) > m:
        value = True
        break
if value:
    print(m)
else:
    print(m % pow(2, n))
",O(1)
"n, k = [int(i) for i in input().split()]
for i in range(100*k+100*n):
    if i*(i+1) == (n+k-i)*2:
        print(n-i)
        break",O(n)
"l,r = map(int,input().split())

a = ""{0:062b}"".format(l)
b = ""{0:062b}"".format(r)

n = len(a)
i = 0

if (l == r):
    print(0)
else:
    while (i<n and a[i] == b[i]):
        i += 1
    print(2**(62-i) - 1)",O(logn)
"x1, y1, x2, y2, x3, y3, x4, y4 = map(int, input().split())
X1, Y1, X2, Y2, X3, Y3, X4, Y4 = map(int, input().split())

x = [x1, x2, x3, x4]
y = [y1, y2, y3, y4]
x = list(set(x))
y = list(set(y))
x.sort()
y.sort()
xl, xr = x
yl, yr = y

if xl <= X1 <= xr and yl  <= Y1 <= yr:
    print('YES')
    exit()
if xl <= X2 <= xr and yl  <= Y2 <= yr:
    print('YES')
    exit()
if xl <= X3 <= xr and yl  <= Y3 <= yr:
    print('YES')
    exit()
if xl <= X4 <= xr and yl  <= Y4 <= yr:
    print('YES')
    exit()

CX, CY = (X1+X2+X3+X4)//4,  (Y1+Y2+Y3+Y4)//4
X1, X2, X3, X4 = X1-CX, X2-CX, X3-CX, X4-CX
Y1, Y2, Y3, Y4 = Y1-CY, Y2-CY, Y3-CY, Y4-CY

if xl <= CX <= xr and yl  <= CY <= yr:
    print('YES')
    exit()

A = 0
for X in (X1, X2, X3, X4):
    A = max(A, abs(X))
if abs(x1-CX)+abs(y1-CY) <= A:
    print('YES')
    exit()
if abs(x2-CX)+abs(y2-CY) <= A:
    print('YES')
    exit()
if abs(x3-CX)+abs(y3-CY) <= A:
    print('YES')
    exit()
if abs(x4-CX)+abs(y4-CY) <= A:
    print('YES')
    exit()
print('NO')
",O(1)
"import sys
n,d,k=map(int,input().split())
if(n<=d):
    print('NO')
    sys.exit()
if(k==1 and n>2):
    print('NO')
    sys.exit()

edgestot=[]
edges=[[] for i in range(n)]
tovisit=[]
for i in range(d):
    edgestot.append([i,i+1])
    tovisit.append([i+1,min(i+1,d-i-1)])
    edges[i].append(i+1)
    edges[i+1].append(i)
cur=d+1
while(cur<n and len(tovisit)>0):
    x=tovisit.pop()
    if(x[1]==0):
        continue
    while(len(edges[x[0]])<k and cur<n):
        tovisit.append([cur,x[1]-1])
        edgestot.append([cur,x[0]])
        edges[x[0]].append(cur)
        edges[cur].append(x[0])
        cur+=1

if(len(edgestot)==n-1):
    print('YES')
    for i in range(n-1):
        print(edgestot[i][0]+1,edgestot[i][1]+1)

else:
    print('NO')
",O(n ^ 2)
"s = input()
def is_pal(s):
      if s == s[::-1]:
            return True
      else:
            return False
if not is_pal(s):
      print(len(s))
else:
      not_eq = False
      for i in range(len(s)-1):
            if s[i] != s[i+1]:
                  print(len(s)-1)
                  not_eq = True
                  break
      if not not_eq:
            print(0)",O(n)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

n = ii()
a = li()
b = [abs(x) for x in a]
if n == 1:
    ans = a[0]
elif all(x > 0 for x in a) or all(x < 0 for x in a):
    b.sort()
    ans = sum(b) - 2 * b[0]
else:
    ans = sum(b)
print(ans)
",O(nlogn)
"n = int(input())
a = [int(s) for s in input().split()]
os = 0
oss = []
nos = 0
nos_0 = -1
nos_1 = -1
sumnos = 0
for i in range(n):
    if a[i] == 1:
        os += 1
        oss.append(i+1)
    else:
        sumnos += a[i]
        nos += 1
        if nos_0 == -1:
            nos_0 = i+1
        nos_1 = i+1

if os <= sumnos-(2*(nos-1)):
    es = []
    oss_i = 0
    ans = nos-1
    if os >= 1:
        ans += 1
        es.append((nos_0, oss[0]))
        oss_i += 1
    if os >= 2:
        ans += 1
        es.append((nos_1, oss[1]))
        oss_i += 1
    print(""YES"", ans)
    prev_nos = -1
    for i in range(n):
        if a[i] > 1:
            if prev_nos != -1:
                es.append((prev_nos+1, i+1))
            for j in range(a[i]-2):
                if oss_i >= os:
                    break
                es.append((i+1, oss[oss_i]))
                oss_i += 1
            prev_nos = i
    print(len(es))
    for e in es:
        print(*e)
else:
    print(""NO"")
",O(n)
"import sys
import math
from collections import defaultdict,deque
import heapq
n,k=map(int,sys.stdin.readline().split())

mod=998244353
dp=[[0,0,0,0] for x in range(k+3)]
dp[1][0]=1
dp[1][1]=1
dp[2][2]=1
dp[2][3]=1
newdp=[[0,0,0,0] for x in range(k+3)]
for i in range(n-1):

    for j in range(k+1):
        newdp[j+1][1]+=dp[j][0]
        newdp[j+1][3]+=dp[j][0]
        newdp[j+1][2]+=dp[j][0]
        newdp[j][0]+=dp[j][0]
        newdp[j][1]+=dp[j][1]
        newdp[j+1][3]+=dp[j][1]
        newdp[j+1][2]+=dp[j][1]
        newdp[j+1][0]+=dp[j][1]
        newdp[j][1]+=dp[j][2]
        newdp[j+2][3]+=dp[j][2]
        newdp[j][2]+=dp[j][2]
        newdp[j][0]+=dp[j][2]
        newdp[j][1]+=dp[j][3]
        newdp[j][3]+=dp[j][3]
        newdp[j+2][2]+=dp[j][3]
        newdp[j][0]+=dp[j][3]

        for a in range(3):
            for b in range(4):
                newdp[a+j][b]%=mod
    for a in range(k+3):
        for b in range(4):
            dp[a][b]=newdp[a][b]
            newdp[a][b]=0
ans=sum(dp[k])
ans%=mod
print(ans)
",np
"q = int(input())
for t in range(q):
    n, k = map(int, input().split())
    rgb = input()
    dp = [0] * 3
    dp[0] = [0] * (n + 1)
    dp[1] = [0] * (n + 1)
    dp[2] = [0] * (n + 1)
    for i in range(0, n):
        if rgb[i] == 'R':
            dp[0][i + 1] = dp[2][i]
            dp[1][i + 1] = dp[0][i] + 1
            dp[2][i + 1] = dp[1][i] + 1
        if rgb[i] == 'G':
            dp[0][i + 1] = dp[2][i] + 1
            dp[1][i + 1] = dp[0][i]
            dp[2][i + 1] = dp[1][i] + 1
        if rgb[i] == 'B':
            dp[0][i + 1] = dp[2][i] + 1
            dp[1][i + 1] = dp[0][i] + 1
            dp[2][i + 1] = dp[1][i]
    repl = k
    dif = k % 3
    for j in range(3):
        for i in range(1, n - k + 2):
            repl = min(repl, -dp[j][i - 1] + dp[(j + dif) % 3][i + k - 1])
    print(repl)
",O(n)
"ans={}
for _ in range(int(input())):
    a,b=map(int,input().split())
    ans[a]=b
for _ in range(int(input())):
    a,b=map(int,input().split())
    if a in ans:
        ans[a]=max(ans[a],b)
    else:
        ans[a]=b
print(sum(ans.values()))
",O(nlogn)
"n = int(input())
n+=1
if n==1:
	print(0)
elif n%2==0:
	print(n//2)
elif n%2!=0 and n!=1:
	print(n)",O(1)
"from math import *
n,m = map(int,input().split())
li = [[j for j in input()] for i in range(n)]
min1=inf
min2=inf
max1=-inf
max2=-inf
for i in range(n):
    for j in range(m):
        if li[i][j] == ""B"":
            min1 = min(min1,i)
            min2 = min(min2, j)
            max1 = max(max1, i)
            max2 = max(max2, j)
print((min1+max1)//2+1,(min2+max2)//2+1)",O(n ^ 2)
"import os,sys
from io import BytesIO,IOBase

def main():
    n = int(input())
    a = [0]+list(map(int,input().split()))
    dp = [[[-1,-1,-1] for _ in range(n+1)]for _ in range(n+1)]

    for i in range(1,n+1):
        dp[i][i] = (a[i],a[i],1)
    for i in range(n-1,0,-1):
        for j in range(i+1,n+1):
            mini = 10**10
            for k in range(j-i):
                x = dp[i][i+k][2]+dp[i+k+1][j][2]
                if dp[i][i+k][1] == dp[i+k+1][j][0]:
                    if mini > x-1:
                        mini = x-1
                        dp[i][j][0] = dp[i][i+k][0]+(dp[i][i+k][2]==1)
                        dp[i][j][1] = dp[i+k+1][j][1]+(dp[i+k+1][j][2]==1)
                        dp[i][j][2] = x-1
                else:
                    if mini > x:
                        mini = x
                        dp[i][j][0] = dp[i][i+k][0]
                        dp[i][j][1] = dp[i+k+1][j][1]
                        dp[i][j][2] = x
    print(dp[1][n][2])

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(n ^ 3)
"import math as m
a=input()
b=input()
total_sum=0
req_pos=0
unreco=0
for i in a:
    if i=='+':
        total_sum+=1
        req_pos+=1

    elif i=='-':
        total_sum-=1
for i in b:
    if i=='+':
        total_sum-=1
        req_pos-=1

    elif i=='-':
        total_sum+=1
    else:
        unreco+=1

if (total_sum==0 and unreco==0):
    print(1.000000000)
elif (abs(total_sum)>unreco or req_pos<0):
    print(0.000000000)
else:
    ans=m.factorial(unreco)/(m.factorial(req_pos)*m.factorial(unreco-req_pos)*(2**unreco))
    print(ans)
",np
"

class Solution:
    def toArray(self, node):
        while node.prev:
            node = node.prev
        result = []
        while node:
            result.append(node.val)
            node = node.__next__
        return result
",O(n)
"import collections



class Solution3(object):
    def maxSelectedElements(self, nums):
        nums.sort()
        dp = collections.defaultdict(int)
        for x in nums:
            dp[x+1] = dp[x]+1
            dp[x] = dp[x-1]+1
        return max(dp.values())",O(nlogn)
"class Solution(object):
    def minimumSum(self, nums):
        INF = float(""inf"")

        right = [INF]*len(nums)
        curr = INF
        for i in reversed(range(len(nums))):
            right[i] = curr
            curr = min(curr, nums[i])
        result = curr = INF
        for i in range(len(nums)):
            if curr < nums[i] > right[i]:
                result = min(result, curr+nums[i]+right[i])
            curr = min(curr, nums[i])
        return result if result != INF else -1",O(n)
"from math import *
from cmath import *
from itertools import *
from decimal import *
from fractions import *
from sys import *
from types import CodeType, new_class

a = []
n, m = map(int, input().split())
minx, miny, maxx, maxy = n, m, 0, 0
for x in range(n):
    a.append(input())
    for y in range(m):
        if a[x][y] == 'B':
            minx = min(minx, x + 1)
            miny = min(miny, y + 1)
            maxx = max(maxx, x + 1)
            maxy = max(maxy, y + 1)
print((maxx + minx) // 2 , (maxy + miny) // 2)
",O(n ^ 2)
"class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        return max(self.helper(nums[1:]),
                   self.helper(nums[:-1]))

    def helper(self, nums: List[int]) -> int:
        if not nums:
            return 0
        if len(nums) == 1:
            return nums[0]

        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])

        for i in range(2, len(nums)):
            dp[i] = max(dp[i - 1], nums[i] + dp[i - 2])

        return dp[-1]
",O(n)
"import math
xy = list(map(int,input().split()))
x = [[xy[0],xy[2],xy[4]],[xy[1],xy[3],xy[5]]]
aa = 0
max_ll = 0
for i in range(3):
    aa += x[0][i]*x[1][i]
    max_ll = max(max_ll,x[0][i],x[1][i])

bb = math.sqrt(aa)

if bb*bb!=aa or max_ll!=bb:
    print(-1)
else:
    bb = int(bb)
    mt = [['']*bb for _ in range(bb)]
    max_l = 0
    chars = ['A','B','C']
    x = [[xy[0],xy[1]],[xy[2],xy[3]],[xy[4],xy[5]]]
    max_lp = -1
    max_li = -1
    ii=0
    oh = []
    for i in x:
        if max(i)>=max_l:
            max_l = max(i)
            max_lp = sum(i)-max(i)
            max_li = ii

        ii+=1

    max_ls = []
    ii=0
    for i in x:
        if max(i)==max_l:
            max_ls.append(i+[ii])
        else:
            oh+=[ii]
        ii+=1
    if len(max_ls)==3:

        for i in range(max_l):
            for j in range(max_l):
                if i<(max_ls[0][0]+max_ls[0][1]-max_l):
                    mt[i][j] = chars[max_ls[0][2]]
                elif i<(max_ls[0][0]+max_ls[0][1]-max_l + max_ls[1][0]+max_ls[1][1]-max_l):
                    mt[i][j] = chars[max_ls[1][2]]
                else:
                    mt[i][j] = chars[max_ls[2][2]]
    else:

        for i in range(max_lp):
            for j in range(max_l):
                mt[i][j] = chars[max_li]

        bb = max_l-max_lp
        for i in range(max_lp,max_l):
            for j in range(max_l):
                if j<(sum(x[oh[0]])-bb):
                    mt[i][j] = chars[oh[0]]
                else:
                    mt[i][j] = chars[oh[1]]

    print(max_l)
    for j in mt:
        print(''.join(j))
",np
"class Solution(object):
    def removeDuplicates(self, A):
        if not A:
            return 0

        last = 0
        for i in range(len(A)):
            if A[last] != A[i]:
                last += 1
                A[last] = A[i]
        return last + 1",O(n)
"class Solution_Recu(object):
    def moveSubTree(self, root, p, q):
        def find_parents(node, parent, p, q, is_ancestor, lookup):
            if node in (p, q):
                lookup[node] = parent
                if len(lookup) == 2:
                    return True, is_ancestor
            for child in node.children:
                found, new_is_ancestor = find_parents(child, node, p, q, is_ancestor or node == p, lookup)
                if found:
                    return True, new_is_ancestor
            return False, False

        lookup = {}
        is_ancestor = find_parents(root, None, p, q, False, lookup)[1]
        if p in lookup and lookup[p] == q:
            return root
        q.children.append(p)
        if not is_ancestor:
            lookup[p].children.remove(p)
        else:
            lookup[q].children.remove(q)
            if p == root:
                root = q
            else:
                lookup[p].children[lookup[p].children.index(p)] = q
        return root",O(n)
"cards=list(input().split())
lm=[0]*9
lp=[0]*9
ls=[0]*9
for item in cards:
    if item[1]=='m':
        lm[int(item[0])-1]+=1
    elif item[1]=='p':
        lp[int(item[0])-1]+=1
    else :
        ls[int(item[0])-1]+=1
if max(lm)==3 or max(lp)==3 or max(ls)==3:
    print(0)
else :
    flag=0
    def seq_checker(li):
        flag=0
        for i in range(9):
            if flag==0:
                if lm[i]==1:
                    flag=1
            else :
                if lm[i]==1:
                    flag+=1
                else :
                    break
        return flag
    if seq_checker(lm)==3 or seq_checker(lp)==3 or seq_checker(ls)==3:
        print(0)
    elif max(lm)==2 or max(lp)==2 or max(ls)==2:
        print(1)
    else :
        m=0
        for i in range(0,7):
            m=max(sum(lm[i:i+3]),sum(lp[i:i+3]),sum(ls[i:i+3]),m)
        print(3-m)",O(n)
"n = int(input())

a = [input() for _ in range(n)]
b = [input() for _ in range(n)]

cost = 0
for s in [""M"", ""S"", ""XS"", ""XXS"", ""XXXS"", ""L"", ""XL"", ""XXL"", ""XXXL""]:
    ca = a.count(s)
    cb = b.count(s)
    cost += ca - min(ca, cb)

print(cost)",O(n)
"class BIT(object): 
    def __init__(self, n):
        self.__bit = [0]*(n+1) 

    def add(self, i, val):
        i += 1 
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def query(self, i):
        i += 1 
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret



class Solution(object):
    def goodTriplets(self, nums1, nums2):
        lookup = [0]*len(nums1)
        for i, x in enumerate(nums1):
            lookup[x] = i
        result = 0
        bit = BIT(len(nums1))
        for i, x in enumerate(nums2):
            smaller = bit.query(lookup[x]-1)
            larger = (len(nums1)-(lookup[x]+1))-(i-smaller)
            result += smaller*larger
            bit.add(lookup[x], 1)
        return result",O(nlogn)
"import sys
import math
from collections import defaultdict,deque

input = sys.stdin.readline
def inar():
    return [int(el) for el in input().split()]
def main():
    n=int(input())
    s=list(input().strip())
    t=list(input().strip())
    res=True
    ans=[]
    for i in range(n):
        if s[i]==t[i]:
            continue
        else:
            ind=-1
            for j in range(i+1,n):
                if t[i]==s[j]:
                    ind=j
                    break
            if ind==-1:
                res=False
                break
            for j in range(ind-1,i-1,-1):
                ans.append(j+1)
                s[j],s[j+1]=s[j+1],s[j]
    if res:
        print(len(ans))
        print(*ans)
    else:
        print(-1)

if __name__ == '__main__':
    main()
",O(n ^ 2)
"class Solution:
    def numDecodings(self, s: str) -> int:
        dp = dp2 = 0
        dp1 = 1
        for i in range(len(s) - 1, -1, -1):
            if s[i] == ""0"":
                dp = 0
            else:
                dp = dp1

            if i + 1 < len(s) and (s[i] == ""1"" or
               s[i] == ""2"" and s[i + 1] in ""0123456""
            ):
                dp += dp2
            dp, dp1, dp2 = 0, dp, dp1
        return dp1
",O(n)
"a=input()
b=input()
c=input()
info=a.split()
info=list(map(int, info))
y=b.split()
powers=list(map(int, y))
z=c.split()
coins=list(map(int, z))
l=sorted(zip(powers,coins,range(info[0])))
final=[0]*info[0]
s=0
w=[]
for _, c, i in l:
    s+=c
    final[i]=s
    w=sorted(w+[c])
    if len(w)>info[1]:
        s-=w[0]
        del w[0]
print(*final)",O(nlogn)
"def solve():
    from sys import stdin
    f_i = stdin

    n = int(f_i.readline())

    segments = []
    for i in range(n):
        x, w = map(int, f_i.readline().split())
        segments.append((x + w, x - w))
    segments.sort()

    ans = 0
    t = segments[0][1]
    for end, start in segments:
        if t <= start:
            ans += 1
            t = end

    print(ans)

solve()",O(nlogn)
"def helper(n,k,l):

	res = 0
	for i in range(n-k+1):
		base_seg = l[i:i+k]
		sm_bseg = sum(base_seg)
		ln_bseg = len(base_seg)
		ans = sm_bseg/ln_bseg

		for j in range(i+k,n):
			sm_bseg+=l[j]
			ln_bseg+=1
			ans=max(ans,sm_bseg/ln_bseg)

		res = max(res,ans)

	return res

n,k = map(int,input().split())
l = list(map(int,input().split()))

print(helper(n,k,l))",O(n ^ 2)
"class Solution(object):
    def decode(self, encoded):
        curr = 0
        for i in range(1, (len(encoded)+1) + 1):
            curr ^= i
            if i < len(encoded) and i%2 == 1:
                curr ^= encoded[i]
        result = [curr]
        for x in encoded:
            result.append(result[-1]^x)
        return result",O(n)
"for _ in range(int(input())):
    n,m=map(int,input().split())

    a=[[int(x) for x in input().split()] for j in range(n)]

    x=[[a[i][j] for i in range(n)] for j  in range(m)]
    x.sort(key=lambda xx:-max(xx))
    dp=[[0 for i in range(1<<n)] for j in range(m+1)]
    an=0

    for i in range(m):
        for prev in range(1<<n):
            for pres in range(1<<n):

                for j in range(n):

                    ma=0
                    if prev^pres!=prev+pres:
                        continue
                    for st in range(n):

                        if pres&(1<<st):
                            ma+=x[i][(st+j)%n]

                    dp[i+1][pres^prev]=max(dp[i+1][pres^prev],dp[i][prev]+ma)

    print(dp[m][(1<<n)-1])",np
"class Solution(object):
    def searchInsert(self, nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) / 2
            if nums[mid] >= target:
                right = mid - 1
            else:
                left = mid + 1

        return left",O(logn)
"n=int(input())
d={}
for _ in range(n):
    a,x=map(int, input().split())
    d[a]=x
m=int(input())
for _ in range(m):
    b,y=map(int, input().split())
    d[b]=max(y, d.get(b,0))
print(sum(d.values()))
",O(nlogn)
"import atexit
import io
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER

@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())

def main():
    n, k = [int(x) for x in input().split()]
    p = [int(x) for x in input().split()]
    t = []
    g={}
    for x in p:
        if x in g:
            t.append(g[x])
            continue
        kk = x - 1
        while True:
            if kk in g:
                if x - g[kk] < k:
                    ttt = g[kk]
                else:
                    ttt= kk + 1
                for i in range(kk +1 , x + 1):
                    g[i] = ttt
                t.append(g[x])
                break
            elif kk<0 or x - kk == k:
                for i in range(kk +1 , x + 1):
                    g[i] = kk + 1
                t.append(g[x])
                break
            kk -= 1

    print(' '.join((str(x) for x in t)))

if __name__ == '__main__':
    main()
",O(n ^ 2)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
from collections import defaultdict
from itertools import permutations

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

a=sorted(input())
b=int(input())
a=a[::-1]
p=""""
while a:
	for i, z in enumerate(a):
		n=p+a[i]+"""".join(sorted(a[:i]+a[i+1:]))
		if int(n)<=b:
			p+=z
			a.pop(i)
			break
print(p)",O(n ^ 3)
"class Solution(object):
    def toHex(self, num):
        if not num:
            return ""0""

        result = []
        while num and len(result) != 8:
            h = num & 15
            if h < 10:
                result.append(str(chr(ord('0') + h)))
            else:
                result.append(str(chr(ord('a') + h-10)))
            num >>= 4
        result.reverse()

        return """".join(result)",O(logn)
"
import collections


class Solution(object):
    def minSteps(self, s, t):
        diff = collections.Counter(s) - collections.Counter(t)
        return sum(diff.values())
",O(n)
"import math


class Solution(object):
    def poorPigs(self, buckets, minutesToDie, minutesToTest):
        return int(math.ceil(math.log(buckets) / math.log(minutesToTest / minutesToDie + 1)))",O(1)
"n, k = list( map( int, input().split()))
p = list( map( int, input().split()))
c = list( map( int, input().split()))

m = {}
for i in range( n ):
    if p[ i ] not in m:
        m[ p[ i ] ] = list()
    m[ p[ i ] ].append( c[ i ] )

a = {}
t = []
for key, val in sorted( m.items() ):
    a[ key ] = sum( t )
    t += val
    t.sort()
    t = t[ max( 0, len( t ) - k ) : len( t ) ]

print( "" "".join( [ str( a[ p[ i ] ] + c[ i ] ) for i in range( n )]))
",O(nlogn)
"n = int(input())
A = list(map(int, input().split()))
A.sort()
ans = 1
for i in range(1, n):
  ok = False
  for j in range(i):
    if A[i] % A[j] == 0:
      ok = True
  if not ok:
    ans += 1
print(ans)
",O(n ^ 2)
"a=int(input())
b=list(map(int,input().split()))
z=max(b)
if z==1:b[b.index(z)]=2
else:b[b.index(z)]=1
print(*sorted(b))",O(nlogn)
"def main():
    n, d, k = map(int, input().split())
    _min = d+1

    if n < _min:
        print('NO')
    else:
        res = []
        deg = [0] * (n+1)
        dist = [0] * (n+1)

        stack = []
        deg[1] = 1
        for i in range(1, d+1):
            res.append((i, i+1))
            if i > 1:
                deg[i] += 2
            dist[i] = max(i-1, d+1-i)
        dist[d+1] = d
        deg[d+1] = 1

        for i in range(2, d+1):
            stack.append(i)

        next = d+2
        while stack:
            if next > n:
                break
            v = stack.pop()
            if dist[v] < d:
                while next <= n and deg[v] < k:
                    res.append((v, next))
                    deg[v] += 1
                    deg[next] += 1
                    dist[next] = dist[v] + 1
                    if dist[next] < d:
                        stack.append(next)
                    next += 1

        ok = next > n
        ok &= all(deg[i] <= k for i in range(1, n+1))
        ok &= all(dist[i] <= d for i in range(1, n+1))

        if not ok:
            print('NO')
        else:
            print('YES')
            for e in res:
                print(*e)

if __name__ == '__main__':
    main()
",O(n ^ 2)
"n, k = map(int, input().split())
d = int((9 + 8 * (n + k)) ** 0.5)
x = (d - 3) // 2
print(n - x)",O(1)
"import sys
input = sys.stdin.readline
n,k=map(int,input().split())
A=[int(i) for i in input().split()]
B=[]
for i in range(1,n):
  B.append(A[i]-A[i-1])
B.sort()
print(sum(B[:n-k]))
",O(nlogn)
"class Solution(object):
    def getSumAbsoluteDifferences(self, nums):
        prefix, suffix = 0, sum(nums)
        result = []
        for i, num in enumerate(nums):
            suffix -= num
            result.append((i*num-prefix) + (suffix-((len(nums)-1)-i)*num))
            prefix += num
        return result",O(n)
"import sys

def main():
    pass

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def lts(l):
    s = ''.join(map(str, l))
    return s

def stl(s):

    l = list(s)

    return l

def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans

def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1

    return (cnt)

def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)

mod = int(1e9) + 7
def ssinp(): return sys.stdin.readline().strip()

def iinp(): return int(input())

def nninp(): return map(int, sys.stdin.readline().strip().split())

def llinp(): return list(map(int, sys.stdin.readline().strip().split()))

def p(xyz): print(xyz)
def p2(a, b): print(a, b)
import math

n,k=nninp()
nos=math.floor(math.sqrt(2*k))
for i in range(nos,12309123):
    if((i*(i+1))//2-k+i==n):
        print((i*(i+1))//2-k)
        exit()
",O(logn)
"class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        if head is None:
            return None

        l1 = head
        while l1:
            l2 = Node(l1.val)
            l2.next = l1.random
            l1.random = l2
            l1 = l1.next

        newHead = head.random

        l1 = head
        while l1:
            l2 = l1.random
            l2.random = l2.next.random if l2.next else None
            l1 = l1.next

        l1 = head
        while l1 is not None:
            l2 = l1.random
            l1.random = l2.next
            l2.next = l1.next.random if l1.next else None
            l1 = l1.next

        return newHead
",O(n)
"n , m = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]
diff = [0] * n
for i in range(n):
	if a[i] < m:
		diff[i] = -1
	if a[i] > m:
		diff[i] = 1

aim = a.index(m)
left = {}
right = {}
suml = 0
for i in reversed(range(aim + 1)):
	suml += diff[i]
	if not suml in left:
		left[suml] = 0
	left[suml] += 1

sumr = 0
for i in range(aim, n):
	sumr += diff[i]
	if not sumr in right:
		right[sumr] = 0
	right[sumr] += 1

ans = 0
for i in left:
	wk1 = -i
	if wk1 in right:
		ans += left[i] * right[wk1]
	wk1 = 1 - i
	if wk1 in right:
		ans += left[i] * right[wk1]

print(ans)
",O(nlogn)
"def path(x1,y1,x2,y2,hor):
    out=[]
    if hor:
        for i in range(x2-x1):
            out.append((x1+i,y1))
        if y2>y1:
            for i in range(y2-y1):
                out.append((x2,y1+i))
        else:
            for i in range(y1-y2):
                out.append((x2,y1-i))
    else:
        for i in range(x2-x1):
            out.append((x2-i,y2))
        if y2>y1:
            for i in range(y2-y1):
                out.append((x1,y2-i))
        else:
            for i in range(y1-y2):
                out.append((x1,y2+i))
    return out[1:]
a,b=map(int,input().split())
c,d=map(int,input().split())
e,f=map(int,input().split())
if a>c:
    a,b,c,d=c,d,a,b
if c>e:
    c,d,e,f=e,f,c,d
if a>c:
    a,b,c,d=c,d,a,b
if c==e and abs(f-b)<abs(d-b):
    c,d,e,f=e,f,c,d
g1=path(a,b,c,d,True)
if d>b:
    if f<b:
        g2=path(c,b,e,f,True)
    elif f<d:
        g2=path(c,f,e,f,True)
    else:
        g2=path(c,d,e,f,True)
else:
    if f<d:
        g2=path(c,d,e,f,True)
    elif f<b:
        g2=path(c,f,e,f,True)
    else:
        g2=path(c,b,e,f,True)
print(len(g1)+len(g2)+3)
print(a,b)
print(c,d)
print(e,f)
for x,y in g1:
    print(x,y)
for x,y in g2:
    print(x,y)",O(1)
"class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        lastIndex = {}
        for i, c in enumerate(s):
            lastIndex[c] = i

        res = []
        size = end = 0
        for i, c in enumerate(s):
            size += 1
            end = max(end, lastIndex[c])

            if i == end:
                res.append(size)
                size = 0
        return res
",O(n)
"from sys import stdin, stdout
import collections

N,M,K = [int(x) for x in stdin.readline().split()]
arr = [int(x) for x in stdin.readline().split()]

res = 0
for j in range(M):
    s = 0
    mini = 0
    for i in range(j,N):
        if i%M==j:
            mini = min(mini,s)
            s -= K

        s += arr[i]

        res = max(res,s-mini)

print(res)
",O(n ^ 2)
"n, M = map(int, input().strip().split())
a = list(map(int, input().strip().split()))

a.insert(0, 0)
n += 1

lit = [0] * (n + 1)
for i in range(1, n):
    if i % 2 == 0:
        lit[i] = lit[i - 1]
    else:
        lit[i] = lit[i - 1] + a[i] - a[i - 1]
if n % 2 == 0:
    lit[n] = lit[n - 1]
else:
    lit[n] = lit[n - 1] + M - a[n - 1]

ans = lit[n]
for i in range(n):
    pre_lit = lit[i]
    post_lit = M - a[i] - (lit[n] - lit[i])

    if i > 0 and a[i - 1] + 1 < a[i]:
        if i % 2 == 0:
            ans = max(ans, pre_lit + 1 + post_lit)
        else:
            ans = max(ans, pre_lit - 1 + post_lit)
    if (i + 1 < n and a[i] + 1 < a[i + 1]) or (i + 1 == n and a[n - 1] + 1 < M):
        if i % 2 == 0:
            ans = max(ans, pre_lit + post_lit + 1)
        else:
            ans = max(ans, pre_lit + post_lit - 1)
print(ans)",O(n)
"n=int(input())
s=['Power','Time','Space','Soul','Reality','Mind']
for _ in range(n):
    i=input()
    if(i=='purple'):
        s.remove('Power')
    elif(i=='green'):
        s.remove('Time')
    elif(i=='blue'):
        s.remove('Space')
    elif(i=='orange'):
        s.remove('Soul')
    elif(i=='red'):
        s.remove('Reality')
    elif(i=='yellow'):
        s.remove('Mind')
print(len(s))
for i in range(len(s)):
    print(s[i])
",O(1)
"import sys
import math
import collections
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n,k=get_ints()
    arr=get_list()
    ans=0
    for i in range(n):
        val=arr[i]
        c=1
        sol=0
        if c >= k:
            sol = max(sol, val / c)
        for j in range(i+1,n):
            val+=arr[j]
            c+=1
            if c>=k:
                sol=max(sol,val/c)
        ans=max(sol,ans)
    print(ans)",O(n ^ 2)
"class Solution(object):
    def mincostTickets(self, days, costs):
        durations = [1, 7, 30]
        W = durations[-1]
        dp = [float(""inf"") for i in range(W)]
        dp[0] = 0
        last_buy_days = [0, 0, 0]
        for i in range(1,len(days)+1):
            dp[i%W] = float(""inf"")
            for j in range(len(durations)):
                while i-1 < len(days) and \
                      days[i-1] > days[last_buy_days[j]]+durations[j]-1:
                    last_buy_days[j] += 1 
                dp[i%W] = min(dp[i%W], dp[last_buy_days[j]%W]+costs[j])
        return dp[len(days)%W]",O(n)
"import sys

def input():
    return sys.stdin.readline().rstrip()

def slv():
    k = int(input())

    def cnt_special(N):
        if N == 0:
            return 0
        return cnt_special(N - 1) + N * (pow(10, N) - pow(10, N - 1))

    def cnt_digit(N):
        ord = len(str(N))
        bound = ord - 1
        return cnt_special(bound) + ord * (N + 1 - 10 ** bound)

    if k < 10:
        print(k)
    else:
        l = 1
        r = int(1e12)
        while r - l > 1:
            med = (r + l)//2
            if cnt_digit(med) >= k:
                r = med
            else:
                l = med

        rep = k - cnt_digit(l)
        print(str(r)[rep - 1])
        return

def main():
    t = 1
    for i in range(t):
        slv()
    return

if __name__ == ""__main__"":
    main()
",O(logn)
"(n, k) = list(map(int, raw_input().split(' ')))

def sol(lo, hi, actions, k):
    while lo < hi:
        mid = (hi - lo) / 2 + lo
        put_candies = mid * (mid + 1) / 2
        eat_candies = actions - mid
        if put_candies - eat_candies == k:
            return eat_candies
        elif put_candies - eat_candies > k:
            hi = mid - 1
        else:
            lo = mid + 1
    return actions - hi

res = sol(1, n, n, k)
print(res)
",O(logn)
"MOD = 10**9+7
FACT, INV, INV_FACT = [[1]*2 for _ in range(3)]
def nCr(n, k):
    if n < k:
        return 0
    while len(INV) <= n: 
        FACT.append(FACT[-1]*len(INV) % MOD)
        INV.append(INV[MOD%len(INV)]*(MOD-MOD//len(INV)) % MOD) 
        INV_FACT.append(INV_FACT[-1]*INV[-1] % MOD)
    return (FACT[n]*INV_FACT[n-k] % MOD) * INV_FACT[k] % MOD


class Solution(object):
    def minMaxSums(self, nums, k):
        MOD = 10**9+7
        nums.sort()
        result = 0
        cnt = 1
        for i in range(len(nums)):
            result = (result+(nums[i]+nums[~i])*cnt)%MOD
            cnt = (cnt*2-nCr(i, k-1)) % MOD
        return result",O(nlogn)
"class Solution(object):
    def numberOfWays(self, n):
        MOD = 10**9+7












        return (1+((n//2)+1)*(n//2)//2)%MOD",O(1)
"def add(a,b):
	a = a%(1000000000+7)
	b=b%(1000000000+7)
	return (a+b)%(1000000000+7)

n  =int(input())
i=1
statements = []
dp = [[0 for i in range(n)] for i in range(n)]
prefix = [[0 for i in range(n)] for i in range(n)]
while(i<=n):
	s = input()
	statements.append(s)
	i+=1

dp[0][0]=1
prefix[0][0]=1
j=1
while(j<n):
	dp[0][j]=0
	prefix[0][j] = dp[0][j] + prefix[0][j-1]
	j+=1

i=1
while(i<n):
	if(statements[i-1]=='f'):
		j=1
		while(j<n):
			dp[i][0]=0
			prefix[i][0]=0
			dp[i][j] = dp[i-1][j-1]
			prefix[i][j] = add(prefix[i][j-1],dp[i][j])

			j+=1
	else:
		j=0
		while(j<n):
			if(j==0):
				dp[i][j] = prefix[i-1][n-1]
			else:
				dp[i][j] = prefix[i-1][n-1] - prefix[i-1][j-1]
			prefix[i][j] = add(prefix[i][j-1],dp[i][j])
			j+=1

	i+=1

ans = 0
j=0
while(j<n):
	ans=add(ans,dp[n-1][j])
	j+=1

print(ans%(1000000000+7))
",O(n ^ 2)
"class Solution(object):
    def countValidWords(self, sentence):
        result = token = hyphen = 0
        for i in range(len(sentence)+1):
            if i == len(sentence) or sentence[i] == ' ':
                if token == 1:
                    result += 1
                token = hyphen = 0
                continue
            if sentence[i].isdigit() or \
               (sentence[i] in ""!.,"" and not (i == len(sentence)-1 or sentence[i+1] == ' ')) or \
               (sentence[i] == '-' and not (hyphen == 0 and 0 < i < len(sentence)-1 and sentence[i-1].isalpha() and sentence[i+1].isalpha())):
                token = -1
                continue
            if token == 0:
                token = 1
            if sentence[i] == '-':
                hyphen = 1
        return result",O(n)
"n = int(input())

arr = list(map(int, input().split()))

solved = False
s = sum(arr)
if s == 0:
	print(""cslnb"")
	solved = True

if not solved:
	n_num = {}

	for item in arr:
		if item in n_num:
			n_num[item] += 1
		else:
			n_num[item] = 1

	if 0 in n_num and n_num[0] >= 2:
		print('cslnb')
		solved = True

	if not solved:
		for key in n_num.keys():
			if n_num[key] >= 3:
				print(""cslnb"")
				solved = True

		ind_pairs = []
		if not solved:
			for key in n_num.keys():
				if n_num[key] == 2:
					ind_pairs.append(key)

			if len(ind_pairs) >= 2:
				print(""cslnb"")
				solved = True
			elif len(ind_pairs) == 1 and (ind_pairs[0]-1) in n_num:
				print(""cslnb"")
				solved = True
			else:

				sum_targ = n*(n-1) // 2

				dif_sum = s - sum_targ

				if dif_sum % 2 == 0:
					print(""cslnb"")
				else:
					print(""sjfnb"")",O(n)
"l, r = [int(x) for x in input().split()]

r = bin(r)[2:]
l = bin(l)[2:]

r = r[::-1]
l = l[::-1]

if l == r:
    print(0)
else:

    l += '0' * (len(r) - len(l))
    p = -1
    for i in range(len(r)):
        if r[i] != l[i]:
            p = i

    a = '1' * p + '0'
    b = '0' * p + '1'

    print(int(a, 2) ^ int(b, 2))
",O(logn)
"from math import *
k,n,s,p = map(int,input().split())
sheetsforone = ceil(n/s)
sheetsfork = sheetsforone*k
packs = ceil(sheetsfork/p)
print(int(packs))",O(1)
"from sys import exit
n = int(input())
if n <= 10:
    for i in range(n):
        print(0, i)
    exit()

print(0, 0)
for i in range(4, n + 1, 3):
    k = (i // 3) * 2
    print(k, 0)
    print(k - 1, 1)
    print(k - 2, 2)
k = ((n + 1) // 3) * 2
if n % 3 == 0:
    print(k - 1, 1)
    print(k - 2, 2)
elif n % 3 == 2:
    print(k - 2, 2)
",O(n)
"from itertools import combinations

n, l, r, x = map(int, input().split())
a = list(map(int, input().split()))

arr = []

for i in range(2, n+1):
    ar = combinations(a, i)
    for j in ar:
        arr += [(list(j))]

count = 0
for i in arr:
    dif = max(i) - min(i)
    total = sum(i)
    if dif >= x and (total >= l and total <= r):
        count +=1

print(count)
",np
"class Solution(object):
    def calculateTax(self, brackets, income):
        result = prev = 0
        for u, p in brackets:
            result += max((min(u, income)-prev)*p/100.0, 0.0)
            prev = u
        return result",O(n)
"r,g,b = list(map(int, input().split()))
ls_r = sorted(list(map(int, input().split())))
ls_g = sorted(list(map(int, input().split())))
ls_b = sorted(list(map(int, input().split())))

dp = [[[None for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)]

def recursive(idx_r, idx_g, idx_b):
    if dp[idx_r][idx_g][idx_b] is not None:
        return dp[idx_r][idx_g][idx_b]
    res_1 = 0
    res_2 = 0
    res_3 = 0
    if (idx_r-1) >= 0 and (idx_g-1) >= 0:
        res_1 = recursive(idx_r-1, idx_g-1, idx_b) + ls_r[idx_r-1] * ls_g[idx_g-1]
    if (idx_g-1) >= 0 and (idx_b-1) >= 0:
        res_2 = recursive(idx_r, idx_g-1, idx_b-1) + ls_g[idx_g-1] * ls_b[idx_b-1]
    if (idx_r-1) >= 0 and (idx_b-1) >= 0:
        res_3 = recursive(idx_r-1, idx_g, idx_b-1) + ls_r[idx_r-1] * ls_b[idx_b-1]

    dp[idx_r][idx_g][idx_b] = max(res_1, res_2, res_3)
    return dp[idx_r][idx_g][idx_b]

print(recursive(r,g,b))",O(n ^ 3)
"pfs=[i*i for i in range(1,3163)]
p=[i for i in range(0,10000001)]
for i in range(1,10000001):
    if(p[i]==i):
        for j in pfs:
            if(i*j>10000000): break
            p[i*j]=i
t=int(input())
for lll in range(0,t):
    n,k=map(int,input().split())
    zc=list(map(int,input().split()))
    s=[p[zc[i]] for i in range(0,len(zc))]
    dp=[n]*(k+1)
    dp[0]=1
    ys=[{}]*(n+1)
    for i in range(0,len(s)):
        for j in range(k,-1,-1):
            if(dp[j]==n): continue
            if(ys[j].get(s[i],-1)!=-1):
                if(j<k and dp[j]<dp[j+1]):
                    dp[j+1]=dp[j]
                    ys[j+1]=ys[j]
                dp[j]+=1
                ys[j]={}
            ys[j][s[i]]=1
    print(min(dp))
",O(n ^ 3)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a + b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10 ** 6, func=lambda a, b: min(a, b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD = 10 ** 9 + 7

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

mod = 10 ** 9 + 7
omod = 998244353

prime = [True for i in range(10)]
pp = [0] * 10

def SieveOfEratosthenes(n=10):
    p = 2
    c = 0
    while (p * p <= n):

        if (prime[p] == True):
            c += 1
            for i in range(p, n + 1, p):
                pp[i] += 1
                prime[i] = False
        p += 1

def binarySearch(arr, n, key):
    left = 0
    right = n - 1
    res = -1
    while (left <= right):
        mid = (right + left) // 2
        if (arr[mid] >= key):
            res = arr[mid]
            right = mid - 1
        else:
            left = mid + 1
    return res
def binarySearch1(arr, n, key):
    left = 0
    right = n - 1
    res = -1
    while (left <= right):
        mid = (right + left) // 2
        if (arr[mid]>=key):
            right = mid - 1
        else:
            res = arr[mid]
            left = mid + 1
    return res

n,k=map(int,input().split())
prev=defaultdict(int)
for ik in range(k):
    cur=int(input())
    s=list(input())
    t=2
    while(cur%t==0):
        t*=2
    t//=4
    for i in range(len(s)):
        if cur==(n+1)//2:
            if s[i]=='U':
                continue
            else:
                if s[i]=='L':
                    cur-=t
                else:
                    cur+=t
                t//=2
        elif cur%2==1:
            if s[i]==""U"":
                if cur&2==0:
                    cur+=1
                else:
                    cur-=1
                t=1
        else:
            if s[i] == 'L':
                cur-=t
                t//=2
            elif s[i]==""U"":
                if cur&t*4==0:
                    cur+=t*2
                else:
                    cur-=t*2
                t*=2
            else:
                cur+=t
                t//=2
    print(cur)
",np
"class Solution2(object):
    def numOfWays(self, n):
        MOD = 10**9 + 7
        aba, abc = 6, 6
        for _ in range(n-1):
            aba, abc = (3*aba%MOD + 2*abc%MOD)%MOD, \
                       (2*abc%MOD + 2*aba%MOD)%MOD
        return (aba+abc)%MOD",O(n)
"
import operator
from functools import reduce



class Solution(object):
    def xorBeauty(self, nums):
        return reduce(operator.xor, nums)
",O(n)
"class Solution(object):
    def countAsterisks(self, s):
        result = cnt = 0
        for c in s:
            if c == '|':
                cnt = (cnt+1)%2
                continue
            if c == '*' and cnt == 0:
                result += 1
        return result",O(n)
"n,m,k = map(int,input().split())
wh=[]

for j in range(n):
    l=list(map(int,input().split()))
    wh.append(l)

wv=[]

for j in range(n-1):
    l=list(map(int,input().split()))
    wv.append(l)

if(k%2!=0):
    ans = [[-1 for _ in range(m)]for j in range(n)]
    for res in ans:
        print(*res)
else:
    dp = [[[0 for i in range(25)]for j in range(505)]for q in range(505)]
    for x in range(1,k+1):
        for i in range(1,n+1):
            for j in range(1,m+1):
                dp[i][j][x]=1234567890
                if(i!=n):
                    dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-1]+wv[i-1][j-1])
                if(i!=1):
                    dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-1]+wv[i-2][j-1])
                if(j!=m):
                    dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-1]+wh[i-1][j-1])
                if(j!=1):
                    dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-1]+wh[i-1][j-2])
    for i in range(1,n+1):
        for j in range(1,m+1):
            ans = 1234567890
            for x in range(1,k+1):
                if(k%x==0 and (k//x)%2==0 ):
                    ans = min(ans,dp[i][j][x]*(k//x))
            print(ans,end="" "")
        print()",O(n ^ 3)
"def check(x,n,k):
    ate = x
    rem = n-ate

    if rem*(rem+1)//2 == k+ate and rem >= 0 and ate >= 0:
        return True

    return False

def main():
    n,k = map(int,input().split())
    b = -1*(2*n+3)
    a = 1
    c = n**2
    c += n-(2*k)

    d = ((b**2)-(4*a*c))**0.5
    x1 = (-b+d)/2*a
    x2 = (-b-d)/2*a

    if check(x1,n,k):
        print(int(x1))
        return

    print(int(x2))

main()
",O(logn)
"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        nums.sort()
        return nums[len(nums) - k]
",O(nlogn)
"def socket(n,m,k,arr):
    arr.sort(reverse=True)
    devices=m
    curr_socket=0
    e_socket=k
    i=0
    t_socket=0
    count=0
    while i<n:
        if e_socket>=devices:
            return 0
        if curr_socket==0:
            curr_socket+=arr[i]
            count+=1
            e_socket-=1
            t_socket=curr_socket+e_socket
        else:
            if t_socket>=devices:
                return count
            else:
                curr_socket+=arr[i]-1
                count+=1
                t_socket=curr_socket+e_socket
        i+=1
    if t_socket>=devices:
        return count
    return -1

n,m,k=map(int,input().split())
arr=list(map(int,input().split()))
print(socket(n,m,k,arr))",O(nlogn)
"class Solution(object):
    def possibleStringCount(self, word):
        return len(word)-sum(word[i] != word[i+1] for i in range(len(word)-1))",O(n)
"r=input()
t1=int(r)
t2=int(r[:len(r)-1])
t3=int(r[:len(r)-2]+r[-1])
print(max(t1,t2,t3))
",O(1)
"n,m = map(int,input().split())
arr1 = [int(i) for i in input().split()]
arr2 = [int(i) for i in input().split()]

for first in arr1:
    for second in arr2:
        if first == second:

            print(first,end="" "")",O(n ^ 2)
"import sys,os,io
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from sys import stdin

import math

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2

    for i in range(3,int(math.sqrt(n))+1,2):

        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))

def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res

def si():
    return input()

def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r

def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1

def ii():
    return int(input())

def li():
    return list(map(int,input().split()))

def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"")
    sys.stdout = open(""output.txt"",""w"")

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

t = int(input())
for _ in range(t):
    n = ii()
    l = li()
    l1 = l[:]
    arr = defaultdict(lambda:0)
    for i in l:
        arr[i]+=1
    l = []
    graterthan4 = 0
    isgraterthan4 = False
    for i in list(arr.keys()):
        if (arr[i]>=4):
            isgraterthan4 = True
            graterthan4 = i
        if (arr[i]>=2):
            l.append(i)
    n = len(l)
    l.sort()
    m = 1000000000000
    mi = []

    for i in range(n-1):
        a = l[i]
        b = l[i+1]

        if (a/b+b/a<m):
            m = a/b+b/a

            mi = [a,b]
    if (isgraterthan4==True):
        print(graterthan4,graterthan4,graterthan4,graterthan4)
    else:
        a,b = mi
        print(a,a,b,b)
",O(nlogn)
"class Solution(object):
    def nearestValidPoint(self, x, y, points):
        smallest, idx = float(""inf""), -1
        for i, (r, c) in enumerate(points):
            dx, dy = x-r, y-c
            if dx*dy == 0 and abs(dx)+abs(dy) < smallest:
                smallest = abs(dx)+abs(dy)
                idx = i
        return idx",O(n)
"n,m=map(int,input().split())
lock=0
for i in range(n):
    s=str(input())
    if(('B' in s) and (lock==0)):
        Rstart=s.index('B')
        cnt=s.count('B')
        Rcen=Rstart+(cnt//2)
        Cstart=i
        Ccen=Cstart+(cnt//2)
        lock=1

print(Ccen+1,Rcen+1)
",O(n ^ 2)
"import sys
from collections import defaultdict
out = sys.stdout

t = int(sys.stdin.readline())
while(t):
    n = int(sys.stdin.readline())
    dic = defaultdict(lambda:0,{})
    ls = list(sorted(list(map(int,sys.stdin.readline().split())),reverse=True))
    st = set()

    f=1
    for i in ls:
        dic[i]+=1
        if(dic[i]==4):
            f=0
            out.write(str(i)+ "" "" +str(i)+ "" "" +str(i)+ "" "" +str(i)+""\n"")
            break
    if(not f ):
        t-=1
        f=1
        continue
    for i in ls:
        if(dic[i]>=2):
            st.add(i)
    st = list(sorted(st,reverse=True))
    ln = len(st)

    mn = (4*(st[0]+st[1])**2)/ (st[0]*st[1])
    a,b,c,d=st[1] , st[1],st[0] , st[0]
    for i in range(1,ln-1):
        if ((4*(st[i]+st[i+1])**2)/ (st[i]*st[i+1])) < mn:

            a,b,c,d=st[i] , st[i],st[i+1] , st[i+1]

            mn = (4*(st[i]+st[i+1])**2)/ (st[i]*st[i+1])
    out.write(str(a)+ "" "" +str(b)+ "" "" +str(c)+ "" "" +str(d)+""\n"")
    t-=1",O(nlogn)
"from collections import Counter


class Solution(object):
    def leastInterval(self, tasks, n):
        counter = Counter(tasks)
        _, max_count = counter.most_common(1)[0]
        return max((max_count-1) * (n+1) + list(counter.values()).count(max_count), len(tasks))",O(n)
"s = map(int, raw_input().rstrip().split())
n = s[0]
v = s[1]

primo = min(n -1, v)
if primo == n-1:
    print(primo)
else:
    rimane = n - primo
    print(primo - 1 + (rimane)*(rimane + 1) / 2)",O(1)
"def fastio():
	import sys
	from io import StringIO
	from atexit import register
	global input
	sys.stdin = StringIO(sys.stdin.read())
	input = lambda : sys.stdin.readline().rstrip('\r\n')
	sys.stdout = StringIO()
	register(lambda : sys.__stdout__.write(sys.stdout.getvalue()))

MOD = 10**9 + 7
I = lambda:list(map(int,input().split()))

l, r = I()
if l - r == 0:
	print(0)

else:
	ans = []
	a = list(format(l, '064b'))
	b = list(format(r, '064b'))
	i = 0
	ll = l
	rr = r
	while a[i] == b[i]:
		i += 1
	for i in range(i, 64):
		if a[i] == '0' and b[i] == '0':
			k = l ^ (2**(64 - i - 1))
			if k <= rr:
				l = k
				a[i] = '1'
		elif a[i] == '1' and b[i] == '1':
			k = r - (2**(64 - i - 1))
			if k >= ll:
				b[i] = '0'
				r = k
	print(l^r)",O(logn)
"n,m,a,b = map(int,input().split())
if n%m!=0:
    mn = n//m * m
    mx = n//m * m + m
    print(min(((n - mn) * b),((mx - n) * a)))
else:print(0)",O(n)
"def main():
    import sys
    input = sys.stdin.readline

    n, k = map(int, input().split())

    l = 1
    r = n + 1

    while r - l != 1:
        m = l + r >> 1
        candies = m * (m + 1) // 2
        eat = n - m

        if candies - eat <= k:
            l = m
        else:
            r = m

    print(n - l)

    return 0

main()",O(logn)
"l,r=map(int,input().split())
a=bin(l)
b=bin(r)
a=""0""*(len(b)-len(a))+a[2:len(a)]
b=b[2:len(b)]
c=[0 for i in range(len(a))]
flag=False
for i in range(len(a)):
    if(a[i]!=b[i]):
        flag=True
    if(flag):c[i]=1
ans=0
for j in range(len(a)):
    ans+=c[len(a)-1-j]*(2**(j))
print(ans)",O(logn)
"class Solution(object):
    def findCelebrity(self, n):
        candidate = 0
        for i in range(1, n):
            if knows(candidate, i): 
                candidate = i       
        for i in range(n):
            candidate_knows_i = knows(candidate, i)
            i_knows_candidate = knows(i, candidate)
            if i != candidate and (candidate_knows_i or
                                   not i_knows_candidate):
                return -1
        return candidate",O(n)
"x,k = map(int,input().split())
mod = 10**9 + 7
if x == 0:
    print(0)
else:
    print(((2*x-1)*pow(2,k,mod) + 1)%mod)
",O(logn)
"import sys
import threading
inp = sys.stdin.buffer.readline
input = lambda: sys.stdin.readline().rstrip()
def I(): return list(map(int,inp().split()))
def main():
    n,=I() ; vis=[0]*n ; st=[0]*n
    if n==1:
        print(1)
        exit(0)
    def dfs(g,e):
        if vis[e]==1: return
        else:
            vis[e]=1
            for i in g[e]:
                dfs(g,i)
            if len(g[e])==1 and e!=0: st[e]+=1
            for i in g[e]:
                st[e]+=st[i]
    a=[int(i)-1 for i in input().split()]
    g=[[] for i in range(n)]
    for i in range(n-1):
        g[i+1].append(a[i])
        g[a[i]].append(i+1)
    dfs(g,0)
    st.sort()
    print(*st)
sys.setrecursionlimit(2097152)
threading.stack_size(134217728)
main_thread = threading.Thread(target=main)
main_thread.start()
main_thread.join()",O(n ^ 2)
"class Solution:
    def countBits(self, n: int) -> List[int]:
        return [bin(i).count('1') for i in range(n + 1)]
",O(n)
"def getIntList():
    return list(map(int, input().split()));
n, k = getIntList();
p=getIntList();
choosed=[False]*256;
left=[i for i in range(256)];
for i, x in enumerate(p):
    if not choosed[x]:
        best=x;

        for j in range(x-1, max(-1, x-k), -1):

            if not choosed[j]:
                best=j;
            else:
                if x-left[j]<k:
                    best=left[j];
                break;

        for j in range(best, x+1):
            choosed[j]=True;
            left[j]=best;
    p[i]=left[x];
print(' '.join(map(str, p)));",O(n ^ 2)
"def main():
    import sys
    input = sys.stdin.readline

    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    kek = [0] * (n - 1)
    for i in range(n - 1):
        kek[i] =  -arr[i + 1] + arr[i]

    kek.sort()

    ans = arr[-1] - arr[0]
    for i in range(k - 1):
        ans += kek[i]

    print(ans)

    return 0

main()",O(nlogn)
"import sys
coins = []
coinsValueTotal = 0
n = int(sys.stdin.readline())
inputs = sys.stdin.readline().split()
for i in range(len(inputs)):
    coin = int(inputs[i])
    coins.append(coin)
    coinsValueTotal += coin
coins.sort(reverse = True)
minCoins = 0
halfCoinsValueTotal = coinsValueTotal / 2
for i in range(len(coins)):
    minCoins +=  coins[i]
    if(minCoins > halfCoinsValueTotal):
        print(i+1)
        break
",O(nlogn)
"class Solution(object):
    def minimumOperations(self, num):
        lookup = [0]*10
        for i in reversed(range(len(num))):
            if ((num[i] in ""05"" and lookup[0]) or
                (num[i] in ""27"" and lookup[5])):
                return (len(num)-i)-2
            lookup[ord(num[i])-ord('0')] = 1
        return len(num)-lookup[0]",O(n)
"from sys import stdout
N,M=map(int,input().split())
if M%2==0 and N%2==0:
    for m in range (1,M//2+1):
        for n in range (1,N+1):
            stdout.write(str(n)+' '+str(m)+'\n')
            stdout.write(str(N+1-n)+' '+str(M+1-m)+'\n')
elif M%2==0 and N%2==1:
    for m in range (1,M//2+1):
        for i in range (1,N+1):
            stdout.write(str(i)+' '+str(m)+'\n')
            stdout.write(str(N+1-i)+' '+str(M+1-m)+'\n')
else:
    for m in range (1,(M+1)//2):
        for n in range (1,N+1):
            stdout.write(str(n)+' '+str(m)+'\n')
            stdout.write(str(N+1-n)+' '+str(M+1-m)+'\n')
    if N%2==0:
        for i in range (1,N//2+1):
            stdout.write(str(i)+' '+str((M+1)//2)+'\n')
            stdout.write(str(N+1-i)+' '+str((M+1)//2)+'\n')
    else:
        for i in range (1,(N+1)//2):
            stdout.write(str(i)+' '+str((M+1)//2)+'\n')
            stdout.write(str(N+1-i)+' '+str((M+1)//2)+'\n')
        stdout.write(str((N+1)//2)+' '+str((M+1)//2)+'\n')",O(n ^ 2)
"import math
import sys
from collections import deque

def scan() -> list:
    return list(map(int, sys.stdin.readline().strip().split()))

def solution() -> None:

    n, k = scan()
    print(round(n+1.5-math.sqrt(2*(n+k)+2.75)))

if __name__ == '__main__':
    solution()
",O(logn)
"import collections


class Solution(object):
    def shortestPathBinaryMatrix(self, grid):
        directions = [(-1, -1), (-1, 0), (-1, 1), \
                      ( 0, -1), ( 0, 1), \
                      ( 1, -1), ( 1, 0), ( 1, 1)]
        result = 0
        q = collections.deque([(0, 0)])
        while q:
            result += 1
            next_depth = collections.deque()
            while q:
                i, j = q.popleft()
                if 0 <= i < len(grid) and \
                   0 <= j < len(grid[0]) and \
                    not grid[i][j]:
                    grid[i][j] = 1
                    if i == len(grid)-1 and j == len(grid)-1:
                        return result
                    for d in directions:
                        next_depth.append((i+d[0], j+d[1]))
            q = next_depth
        return -1",O(n ^ 2)
"class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        memo = [-1] * len(cost)

        def dfs(i):
            if i >= len(cost):
                return 0
            if memo[i] != -1:
                return memo[i]
            memo[i] = cost[i] + min(dfs(i + 1), dfs(i + 2))
            return memo[i]

        return min(dfs(0), dfs(1))
",O(n)
"def Fast_power(x , y):
    res = 1
    while y > 0 :
        if (y % 2 != 0):
            res = res * x

        y = y // 2
        x = x * x

    return res

n = int(input())
m = int(input())

if n <= 40 :
    print(m % Fast_power(2 , n))
else:
    print(m)
",O(1)
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=None):
        self.BIT=[0]*(n+1)
        self.num=n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        self.mod = mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

class SegmentTree:
    def __init__(self, init_val, segfunc, ide_ele):
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        k += self.num
        self.tree[k] = x
        while k > 1:
            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])
            k >>= 1

    def query(self, l, r):
        res = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                l += 1
            if r & 1:
                res = self.segfunc(res, self.tree[r - 1])
            l >>= 1
            r >>= 1
        return res

    def bisect_l(self,l,r,x):
        l += self.num
        r += self.num
        Lmin = -1
        Rmin = -1
        while l<r:
            if l & 1:
                if self.tree[l] <= x and Lmin==-1:
                    Lmin = l
                l += 1
            if r & 1:
                if self.tree[r-1] <=x:
                    Rmin = r-1
            l >>= 1
            r >>= 1

        if Lmin != -1:
            pos = Lmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        elif Rmin != -1:
            pos = Rmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        else:
            return -1

from heapq import heappush, heappop
class MinCostFlow:
    INF = 10**18

    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap, cost):
        forward = [to, cap, cost, None]
        backward = forward[3] = [fr, 0, -cost, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def flow(self, s, t, f):
        N = self.N; G = self.G
        INF = MinCostFlow.INF

        res = 0
        H = [0]*N
        prv_v = [0]*N
        prv_e = [None]*N

        d0 = [INF]*N
        dist = [INF]*N

        while f:
            dist[:] = d0
            dist[s] = 0
            que = [(0, s)]

            while que:
                c, v = heappop(que)
                if dist[v] < c:
                    continue
                r0 = dist[v] + H[v]
                for e in G[v]:
                    w, cap, cost, _ = e
                    if cap > 0 and r0 + cost - H[w] < dist[w]:
                        dist[w] = r = r0 + cost - H[w]
                        prv_v[w] = v; prv_e[w] = e
                        heappush(que, (r, w))
            if dist[t] == INF:
                return None

            for i in range(N):
                H[i] += dist[i]

            d = f; v = t
            while v != s:
                d = min(d, prv_e[v][1])
                v = prv_v[v]
            f -= d
            res += d * H[t]
            v = t
            while v != s:
                e = prv_e[v]
                e[1] -= d
                e[3][1] += d
                v = prv_v[v]
        return res

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.buffer.readline()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

k = li()
k.sort()
k = tuple(k)

ans = [(2,4,4),(3,3,3)]
if k.count(1)>=1:
    print(""YES"")
elif k.count(2)>=2:
    print(""YES"")
elif k.count(3)>=3:
    print(""YES"")
elif k in ans:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"class Solution(object):
    def splitIntoFibonacci(self, S):
        def startswith(S, k, x):
            y = 0
            for i in range(k, len(S)):
                y = 10*y + int(S[i])
                if y == x:
                    return i-k+1
                elif y > x:
                    break
            return 0

        MAX_INT = 2**31-1
        a = 0
        for i in range(len(S)-2):
            a = 10*a + int(S[i])
            b = 0
            for j in range(i+1, len(S)-1):
                b = 10*b + int(S[j])
                fib = [a, b]
                k = j+1
                while k < len(S):
                    if fib[-2] > MAX_INT-fib[-1]:
                        break
                    c = fib[-2]+fib[-1]
                    length = startswith(S, k, c)
                    if length == 0:
                        break
                    fib.append(c)
                    k += length
                else:
                    return fib
                if b == 0:
                    break
            if a == 0:
                break
        return []",O(n ^ 3)
"class Solution2(object):
    def minOperations(self, n):
        result = 0
        while n:
            if n&1:
                n >>= 1
                n += n&1
                result += 1
            n >>= 1
        return result",O(logn)
"s = input()
l = list(map(int,input().split()))
l.sort(reverse = True)
s = sum(l)
x = 0
c = 0
for i in l:
    if x <= s:
        c+=1
        x+=i
        s-=i
    else:
        break
print(c)",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase
import heapq as h
from bisect import bisect_left, bisect_right

from types import GeneratorType
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict as dd, deque as dq
import math, string

def getInts():
    return [int(s) for s in input().split()]

def getInt():
    return int(input())

def getStrs():
    return [s for s in input().split()]

def getStr():
    return input()

def listStr():
    return list(input())

MOD = 998244353

def solve():
    N = getInt()
    A = getInts()
    dp = [[-1 for j in range(N)] for i in range(N)]
    for i in range(N):
        dp[i][i] = A[i]
    for X in range(2,N+1):
        for i in range(N-X+1):
            j = i+X-1
            for k in range(i,j):
                if dp[i][k] == dp[k+1][j] and dp[i][k] != -1:
                    dp[i][j] = dp[i][k] + 1
                    break

    ans = [10**9+1]*(N+1)
    ans[0] = 0
    for i in range(1,N+1):
        for k in range(1,i+1):
            if dp[k-1][i-1] != -1:
                ans[i] = min(ans[i],ans[k-1]+1)

    return ans[N]

print(solve())
",O(n ^ 3)
"n = int(input())
print(2*(n**2)-2*n+1)",O(1)
"def solve():
    n, k = [int(x) for x in input().split(' ')]
    t = input()
    j = 0
    for i in range(1, n):
        if t[:i] == t[-i:]:
            j = i
    s = t + (k - 1) * t[-(n - j):]
    return s

print(solve())",O(n ^ 2)
"class Solution(object):
    def corpFlightBookings(self, bookings, n):
        result = [0]*(n+1)
        for i, j, k in bookings:
            result[i-1] += k
            result[j] -= k
        for i in range(1, len(result)):
            result[i] += result[i-1]
        result.pop()
        return result",O(n)
"import collections



class Solution(object):
    def subsequencesWithMiddleMode(self, nums):
        def nC2(x):
            return x*(x-1)//2

        MOD = 10**9+7
        result = 0
        left = collections.defaultdict(int)
        right = collections.defaultdict(int)
        for x in nums:
            right[x] += 1
        left_x_sq = 0 
        right_x_sq = sum(v**2 for v in right.values()) 
        left_x_right_x = 0 
        left_x_sq_right_x = 0 
        left_x_right_x_sq = 0 
        for i, v in enumerate(nums):
            left_x_sq -= left[v]**2
            right_x_sq -= right[v]**2
            left_x_right_x -= left[v]*right[v]
            left_x_sq_right_x -= left[v]**2*right[v]
            left_x_right_x_sq -= left[v]*right[v]**2
            right[v] -= 1

            l, r = i, len(nums)-(i+1)
            result += nC2(l)*nC2(r)
            result -= nC2(l-left[v])*nC2(r-right[v])
            result -= ((left_x_sq-(l-left[v]))*(r-right[v])-(left_x_sq_right_x-left_x_right_x))*right[v]//2
            result -= ((right_x_sq-(r-right[v]))*(l-left[v])-(left_x_right_x_sq-left_x_right_x))*left[v]//2
            result -= left[v]*left_x_right_x*(r-right[v])-left[v]*left_x_right_x_sq
            result -= right[v]*left_x_right_x*(l-left[v])-right[v]*left_x_sq_right_x
            result -= right[v]*(left_x_sq_right_x-left_x_right_x)//2
            result -= left[v]*(left_x_right_x_sq-left_x_right_x)//2

            left[v] += 1
            left_x_sq += left[v]**2
            right_x_sq += right[v]**2
            left_x_right_x += left[v]*right[v]
            left_x_sq_right_x += left[v]**2*right[v]
            left_x_right_x_sq += left[v]*right[v]**2
        return result % MOD",O(n)
"class Solution(object):
    def longestBeautifulSubstring(self, word):
        result = 0
        l = cnt = 1
        for i in range(len(word)-1):
            if word[i] > word[i+1]:
                l = cnt = 1
            else:
                l += 1
                cnt += int(word[i] < word[i+1])
            if cnt == 5:
                result = max(result, l)
        return result",O(n)
"n=int(input())
l=list(map(int,input().split()))
s=input()
water=0
grass=0
cgrass=0
time=0
seen=False
for i in range(n):
    if s[i]==""G"":
        dist=l[i]
        if water>=dist:
            water-=dist
            time+=2*dist
            cgrass+=dist
        else:
            dist-=water
            time+=2*water
            cgrass+=water
            water=0
            time+=3*dist
            grass+=dist
    elif s[i]==""W"":
        water+=l[i]
        time+=2*l[i]
        seen=True
    else:
        dist=l[i]
        if water>=dist:
            water-=dist
            time+=2*dist
        else:
            dist-=water
            time+=2*water
            water=0
            if cgrass>=dist:
                cgrass-=dist
                grass+=dist
                time+=3*dist
            else:
                dist-=cgrass
                grass+=cgrass
                time+=3*cgrass
                cgrass=0
                if grass>=dist:
                    grass-=dist
                    time+=3*dist
                else:
                    dist-=grass
                    time+=3*grass
                    grass=0
                    if seen:
                        time+=4*dist
                    else:
                        time+=6*dist
print(time)",O(n)
"class Solution(object):
    def monkeyMove(self, n):
        MOD = 10**9+7
        return (pow(2, n, MOD)-2)%MOD",O(logn)
"import io,os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
from collections import defaultdict as dd
I = lambda : list(map(int,input().split()))

n,m=I()
l=[]
an=-1;a=b=0
for _ in range(n):
	k=I()
	l.append(k+[_+1])
	if an<min(k):
		a=b=_+1
		an=min(k)
le=an;r=10**9+1
while le<r:
	md = (le+r)//2
	f=0;a1=a2=-1
	s=[0]*n
	for i in range(n):
		for j in range(m):
			if l[i][j]>=md:
				s[i]|=1<<j

	po=1<<m
	d=[0]*po
	for i in range(n):
		d[s[i]]=i+1
	for i in range(1,po):
		if d[i]:
			pp=i
			while pp:
				d[pp]=d[i]
				pp=(pp-1)&i
	if d[po-1]:
		f=1
		a1=a2=d[po-1]
	for i in range(1,po):
		if d[i] and d[(po-1)^i]:
			f=1
			a1 = d[i]
			a2 = d[(po-1)^i]
			break
	if f:
		le=md+1
		if md>an:
			a,b=a1,a2
			an=md
	else:
		r=md
print(a,b)",np
"import sys
input = lambda : sys.stdin.readline().rstrip()

sys.setrecursionlimit(2*10**5+10)
write = lambda x: sys.stdout.write(x+""\n"")
debug = lambda x: sys.stderr.write(x+""\n"")
writef = lambda x: print(""{:.12f}"".format(x))

class SG:
    def __init__(self, n, v=None):
        self._n = n
        self.geta = 0
        x = 0
        while (1 << x) < n:
            x += 1
        self._log = x
        self._size = 1 << self._log
        self._d = [ninf] * (2 * self._size)
        if v is not None:
            for i in range(self._n):
                self._d[self._size + i] = v[i]
        for i in range(self._size - 1, 0, -1):
            self._update(i)
    def _update(self, k):
        self._d[k] = op(self._d[2 * k], self._d[2 * k + 1])
    def update(self, p, x):
        assert 0 <= p < self._n

        p += self._size
        self._d[p] = x
        for i in range(1, self._log + 1):

            k = p>>i
            self._d[k] = op(self._d[2 * k], self._d[2 * k + 1])
    def get(self, p):
        assert 0 <= p < self._n
        return self._d[p + self._size]
    def check(self):
        return [self.get(p) for p in range(self._n)]
    def query(self, left, right):

        assert 0 <= left <= right <= self._n
        sml = ninf
        smr = ninf
        left += self._size
        right += self._size

        while left < right:
            if left & 1:
                sml = op(sml, self._d[left])
                left += 1
            if right & 1:
                right -= 1
                smr = op(self._d[right], smr)
            left >>= 1
            right >>= 1
        return op(sml, smr)

    def query_all(self):
        return self._d[1]
    def max_right(self, left, f):

        if left == self._n:
            return self._n
        left += self._size
        sm = ninf
        first = True
        while first or (left & -left) != left:
            first = False
            while left % 2 == 0:
                left >>= 1
            if not f(op(sm, self._d[left])):
                while left < self._size:
                    left *= 2
                    if f(op(sm, self._d[left])):
                        sm = op(sm, self._d[left])
                        left += 1
                return left - self._size
            sm = op(sm, self._d[left])
            left += 1
        return self._n
    def min_left(self, right, f):

        if right == 0:
            return 0
        right += self._size
        sm = ninf
        first = True
        while first or (right & -right) != right:
            first = False
            right -= 1
            while right > 1 and right % 2:
                right >>= 1
            if not f(op(self._d[right], sm)):
                while right < self._size:
                    right = 2 * right + 1
                    if f(op(self._d[right], sm)):
                        sm = op(self._d[right], sm)
                        right -= 1
                return right + 1 - self._size
            sm = op(self._d[right], sm)
        return 0
op = max
ninf = 0

n = int(input())
a = list(map(int, input().split()))
vs = [[0]*(n-i) for i in range(n)]
vs[0] = a
for i in range(1,n):
    for j in range(n-i):
        vs[i][j] = vs[i-1][j]^vs[i-1][j+1]
def f(l,r):
    return vs[r-l][l]
ms = [[0]*n for _ in range(n)]
for l in range(n):
    ms[l][l] = f(l,l)
    for r in range(l+1,n):
        ms[l][r] = max(ms[l][r-1], f(l,r))
sgs = []
for r in range(n):
    l = [ms[l][r] for l in range(r+1)]
    sg = SG(len(l), l)
    sgs.append(sg)
q = int(input())
ans = []
for _ in range(q):
    l,r = map(int, input().split())
    l -= 1
    r -= 1
    val = sgs[r].query(l,r+1)
    ans.append(val)

write(""\n"".join(map(str, ans)))",O(n ^ 2)
"class Solution2(object):
    def findErrorNums(self, nums):
        result = [0] * 2
        for i in nums:
            if nums[abs(i)-1] < 0:
                result[0] = abs(i)
            else:
                nums[abs(i)-1] *= -1
        for i in range(len(nums)):
            if nums[i] > 0:
                result[1] = i+1
            else:
                nums[i] *= -1
        return result",O(n)
"from collections import Counter
import string
import math
import sys

from fractions import Fraction
def array_int():
    return [int(i) for i in sys.stdin.readline().split()]
def vary(arrber_of_variables):
    if arrber_of_variables==1:
        return int(sys.stdin.readline())
    if arrber_of_variables>=2:
        return map(int,sys.stdin.readline().split())
def makedict(var):
    return dict(Counter(var))
testcases=1
for _ in range(testcases):
    n=vary(1)
    indices=array_int()
    cost=array_int()
    ans=float('inf')
    mint=[]
    for i in range(n):
        ans=float('inf')
        total=cost[i]
        flag=0
        for j in range(i):
            if indices[i]>indices[j]:
                ans=min(ans,cost[j])
                flag=1
        if flag!=0:
            total+=ans
            ans=float('inf')
            flag=0
            for k in range(i+1,n):
                if indices[k]>indices[i]:
                    ans=min(ans,cost[k])
                    flag=1
            if flag!=0:
                total+=ans
                mint.append(total)
            else:
                continue
        else:
            continue
    if len(mint)>0:
        print(min(mint))
    else:
        print(-1)
",O(n ^ 2)
"class Solution(object):
    def reachableNodes(self, n, edges, restricted):
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = 0
        lookup = [False]*n
        for x in restricted:
            lookup[x] = True
        q = [0]
        lookup[0] = True
        while q:
            new_q = []
            for u in q:
                result += 1
                for v in adj[u]:
                    if lookup[v]:
                        continue
                    lookup[v] = True
                    new_q.append(v)
            q = new_q
        return result",O(n)
"class Solution(object):
    def maxSelectedElements(self, nums):
        nums.sort()
        result = 1
        dp = [1]*2 
        for i in range(1, len(nums)):
            if nums[i] == nums[i-1]:
                dp[1] = dp[0]+1
            elif nums[i] == nums[i-1]+1:
                dp[0] += 1
                dp[1] += 1
            elif nums[i] == nums[i-1]+2:
                dp[0] = dp[1]+1
                dp[1] = 1
            else:
                dp[0] = dp[1] = 1
            result = max(result, dp[0], dp[1])
        return result",O(nlogn)
"class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        stack = [(p, q)]

        while stack:
            node1, node2 = stack.pop()

            if not node1 and not node2:
                continue
            if not node1 or not node2 or node1.val != node2.val:
                return False

            stack.append((node1.right, node2.right))
            stack.append((node1.left, node2.left))

        return True
",O(n)
"class Solution3(object):
    def getConcatenation(self, nums):
        return nums*2",O(n)
"import math

n=int(input())
a=list(map(int ,input().split()))
x=10**9+2
y=0
for i in range(n):
    if(x>math.ceil((a[i]-i)/n)*n+i+1):
        x=math.ceil((a[i]-i)/n)*n+i+1
        y=i+1
print(y)",O(n)
"import copy

n,m,k=map(int,input().split())
A=list(map(int,input().split()))

ANS=0

for i in range(m):
    B=copy.deepcopy(A)
    for j in range(i,n,m):
        B[j]-=k

    NOW=0

    for j in range(i,n):
        if j%m==i:
            NOW=max(NOW+B[j],B[j])
        else:
            NOW+=B[j]

        ANS=max(ANS,NOW)

print(ANS)
",O(n ^ 2)
"import sys

inp = [int(x) for x in sys.stdin.read().split()]; ii = 0

n = inp[ii]; ii += 1
m = inp[ii]; ii += 1
k = inp[ii]; ii += 1

if k%2 == 1:
	for _ in range(n):
		toprint = [""-1"" for __ in range(m)]
		print("" "".join(toprint))

	sys.exit()

yw = []

for _ in range(n):
	yw.append(inp[ii:ii+m-1])
	ii += m-1

xw = []

for _ in range(n-1):
	xw.append(inp[ii:ii+m])
	ii += m

inf = 10**10

steps = k//2

dp = [[[inf for _ in range(m)] for _ in range(n)] for _ in range(steps+1)]

for i in range(n):
	for j in range(m):
		dp[0][i][j] = 0

for step in range(1, steps + 1):
	for i in range(n):
		for j in range(m):

			if i > 0:
				dp[step][i][j] = min(dp[step][i][j], dp[step-1][i-1][j] + xw[i-1][j])

			if i < n-1:
				dp[step][i][j] = min(dp[step][i][j], dp[step-1][i+1][j] + xw[i][j])

			if j > 0:
				dp[step][i][j] = min(dp[step][i][j], dp[step-1][i][j-1] + yw[i][j-1])

			if j < m-1:
				dp[step][i][j] = min(dp[step][i][j], dp[step-1][i][j+1] + yw[i][j])

for x in dp[-1]:
	print("" "".join(list(map(str, [2*o for o in x]))))",O(n ^ 3)
"class Solution2_Recu(object):
    def minTime(self, n, edges, hasApple):
        def dfs(graph, par, node, has_subtree):
            result, extra = 0, int(hasApple[node])
            for nei in graph[node]:
                if nei == par:
                    continue
                count = dfs(graph, node, nei, hasApple)
                result += count
                extra |= bool(count)
            return result+extra
        
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        return 2*max(dfs(graph, -1, 0, hasApple)-1, 0)",O(n)
"def main():
    nNodes = int(input())
    neighborsOf = {node: [] for node in map(str, range(1, nNodes+1))}
    threeNeighborNodeExists, threeNeighborNode = False, None
    for i in range(1, nNodes):
        node1, node2 = input().split()
        neighborsOf[node1].append(node2), neighborsOf[node2].append(node1)
        if len(neighborsOf[node1]) == 3:
            if threeNeighborNodeExists:
                return 'No'
            threeNeighborNodeExists, threeNeighborNode = True, node1
        elif len(neighborsOf[node2]) == 3:
            if threeNeighborNodeExists:
                return 'No'
            threeNeighborNodeExists, threeNeighborNode = True, node2

    if threeNeighborNodeExists:
        return tnnDecompositionFrom(neighborsOf, threeNeighborNode+' ')

    return decompositionFrom(neighborsOf)

def tnnDecompositionFrom(tree, threeNeighborNode):
    paths = tuple(threeNeighborNode + node for node in tree if len(tree[node]) == 1)
    return f'Yes\n{len(paths)}\n' + '\n'.join(paths)

def decompositionFrom(tree):
    return 'Yes\n1\n' + ' '.join(node for node in tree if len(tree[node]) == 1)

if __name__ == '__main__':
    print(main())
",O(n)
"from sortedcontainers import SortedList
import collections



class Solution(object):
    def findXSum(self, nums, k, x):
        def update(v, d, curr):
            if d == 1:
                sl.add((-cnt[v], -v))
            if sl.index((-cnt[v], -v)) < x:
                curr += d*cnt[v]*v
                if x < len(sl):
                    nc, nv = sl[x]
                    curr -= d*nc*nv
            if d != 1:
                sl.remove((-cnt[v], -v))
            return curr

        sl = SortedList()
        cnt = collections.defaultdict(int)
        result = []
        curr = 0
        for i, v in enumerate(nums):
            if v in cnt:
                curr = update(v, -1, curr)
            cnt[v] += 1
            curr = update(v, +1, curr)
            if i < k-1:
                continue
            result.append(curr)
            curr = update(nums[i-(k-1)], -1, curr)
            cnt[nums[i-(k-1)]] -= 1
            if cnt[nums[i-(k-1)]]:
                curr = update(nums[i-(k-1)], +1, curr)
            else:
                del cnt[nums[i-(k-1)]]
        return result",O(nlogn)
"n, k = list(map(int, input().split()))

teams = []
for _ in range(n):
    teams.append(list(map(int, input().split())))

teams.sort(key=lambda x: x[0]*100 - x[1], reverse=True)

count = 0

kth = teams[k-1][0]*100 + teams[k-1][1]
for t in teams:
    if t[0]*100 + t[1] == kth:
        count += 1
print(count)
",O(nlogn)
"class Solution(object):
    def checkTwoChessboards(self, coordinate1, coordinate2):
        def parity(a):
            return reduce(lambda accu, x: (accu+x)%2, (ord(x) for x in a), 0)
        
        return parity(coordinate1) == parity(coordinate2)",O(1)
"n = int(input())
print(3*(n//2))",O(1)
"n=int(input())
a=input()
b=a.count('T')
c=-1
for i in range(n):
    d=0
    for j in range(b):
        d+=int(a[(i+j)%n]=='H')
    if c==-1 or d<c:
        c=d
print(c)",O(n)
"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        preIdx = inIdx = 0
        def dfs(limit):
            nonlocal preIdx, inIdx
            if preIdx >= len(preorder):
                return None
            if inorder[inIdx] == limit:
                inIdx += 1
                return None

            root = TreeNode(preorder[preIdx])
            preIdx += 1
            root.left = dfs(root.val)
            root.right = dfs(limit)
            return root
        return dfs(float('inf'))
",O(n)
"n = int(input())
pokemons = input()

last = {}
start_of_all = 0
for i in range(n):
    ty = pokemons[i]
    if ty not in last:
        start_of_all = i
    last[ty] = 0

minlen = 100001
for i in range(n):
    ty = pokemons[i]
    last[ty] = i
    length = i + 1 - min(last.values())
    if i >= start_of_all and length < minlen:
        minlen = length

print(minlen)
",O(n)
"import math
s = input()
s1 = input()
plus=s.count('+')-s1.count('+')
minus=s.count('-')-s1.count('-')
v = s1.count('?')
if plus<0 or minus<0:
    print(0)
    exit()
print((math.factorial(v)/math.factorial(v-plus)/math.factorial(plus))*(0.5**v))",np
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()
def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

n,m=map(int,input().split())
c=list(map(int,input().split()))
kk=get_frequency(c)
if len(set(c))==n:
    print(min(kk.values()))
else:
    print(0)
",O(n ^ 2)
"a=list(map(int,input().split()))
mr=0
for t in range(14):
    b=list(a)
    m=b[t]
    k=t
    i=1
    b[k]=0
    while(m>0):
        if(m//14==0):
            b[(k+i)%14]+=1
            m-=1
            i+=1
        else:
            q=m//14
            for c in range(14):
                b[c]+=q
            m-=14*q
    p=sum([ x  for x in b if x%2==0 ])
    mr=max(p,mr)
print(mr)
",O(1)
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math

alphabets = list('abcdefghijklmnopqrstuvwxyz')

def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))
def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def power_set(L):

    cardinality=len(L)
    n=2 ** cardinality
    powerset = []

    for i in range(n):
        a=bin(i)[2:]
        subset=[]
        for j in range(len(a)):
            if a[-j-1]=='1':
                subset.append(L[j])
        powerset.append(subset)

    powerset_orderred=[]
    for k in range(cardinality+1):
        for w in powerset:
            if len(w)==k:
                powerset_orderred.append(w)

    return powerset_orderred
def fastPlrintNextLines(a):

    print('\n'.join(map(str,a)))

def sortByFirstAndSecond(A):
    A = sorted(A,key = lambda x:x[0])
    A = sorted(A,key = lambda x:x[1])
    return list(A)

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"")

t = 1

for _ in range(t):
    n,k = li()
    s = list(si())
    cnt = 0
    ans = []
    covered = 0
    for i in range(n):
        if (s[i]=='('):
            cnt+=1
            ans.append('(')
        else:
            ans.append(')')
            covered+=1
        if cnt==k//2:
            break
    ans+=[')']*(k//2-covered)
    print(''.join(ans))",O(n)
"from sortedcontainers import SortedList


class Solution2(object):
    def minimumCoins(self, prices):
        dp = [float(""inf"")]*(len(prices)+1)
        dp[0] = 0
        sl = SortedList()
        j = 0
        for i in range(len(prices)):
            sl.add((dp[i]+prices[i], i))
            while j+(j+1) < i:
                sl.remove(((dp[j]+prices[j], j)))
                j += 1
            dp[i+1] = sl[0][0]
        return dp[-1]",O(nlogn)
"class Solution(object):
    def decrypt(self, code, k):
        result = [0]*len(code)
        if k == 0:
            return result
        left, right = 1, k
        if k < 0:
            k = -k
            left, right = len(code)-k, len(code)-1
        total = sum(code[i] for i in range(left, right+1))
        for i in range(len(code)):
            result[i] = total
            total -= code[left%len(code)]
            total += code[(right+1)%len(code)]
            left += 1
            right += 1
        return result",O(n)
"class Solution(object):
    def resultsArray(self, nums, k):
        result = [-1]*(len(nums)-k+1)
        left = 0
        for right in range(len(nums)):
            if nums[right]-nums[left] != right-left:
                left = right
            if right-left+1 == k:
                result[left] = nums[right]
                left += 1
        return result",O(n)
"x,k = map(int, input().split())
mod = 1000000007
flag = True
if x==0:
    flag=False
if flag:
    print((pow(2,k+1,mod)*x-pow(2,k,mod)+1+mod)%mod)
else:
    print(0)
",O(logn)
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]

z, zz = fast, lambda: (map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())

def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer, end='\n'): stdout.write(str(answer) + end)

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]

n = int(z())
a = zzz()

d = {}
power = [2**i for i in range(31)]
ans = []
for i in a:
    d[i] = 0

for num in d.keys():
    for p in power:
        if num+p in d:
            ans = [num, num+p]
            if num+p+p in d:
                print(3)
                ans.append(num+p+p)
                print(*ans)
                exit()
if ans:
    print(2)
    print(*ans)
else:
    print(1)
    print(a[0])
",O(nlogn)
"n,x,y=int(input())-1,1,9
while n>x*y:n,x,y=n-x*y,x+1,y*10
print(str(10**(x-1)+n//x)[n%x])",O(logn)
"from itertools import groupby
n=int(input())
s=input()
x=[len(list(group)) for key,group in groupby(s) if key==""x""]
ans=sum(max(0,l-3+1) for l in x)
print(ans)",O(n)
"n=int(input())
a=int(input())

s=0
t=a
b=[]
for i in range(n):
    s+=t%10
    b.append(t%10)
    t//=10

b.reverse()

i=2
ans=False

if(s==0): ans=True
while(i<=s):

    if(s%i!=0):
        i+=1
        continue
    l=s//i
    c=0
    su=0
    for j in range(n):
        if(su>l):
            break
        else:
            su+=b[j]
            if(su==l):
                su=0
                c+=1
    if(c==i):
        ans=True

    i+=1
if(ans): print(""YES"")
else:print(""NO"")",O(n ^ 2)
"candies = 0
n, k = map(int,input().split())
summ = 0
if k == 0:
    for i in range (n-1,-1,-1):
        summ = summ + 1
        candies = candies + summ
        if candies == i:
            print(i)
            break

if k != 0:
    for i in range (n-1,-1,-1):
        summ = summ + 1
        candies = candies + summ
        if candies - i == k:
            print(i)
            break
",O(logn)
"n = int(input())
coins = list(map(int, input().split()))
coins.sort(reverse=True)
target = (sum(coins)+2)//2

count = 1
total = coins[count-1]
while total < target:
    count += 1
    total += coins[count-1]

print(count)
",O(nlogn)
"import sys
input = sys.stdin.readline

r, g, b, = [int(_) for _ in input().split()]
R = [int(_) for _ in input().split()]
G = [int(_) for _ in input().split()]
B = [int(_) for _ in input().split()]
R = sorted(R, reverse=True)
G = sorted(G, reverse=True)
B = sorted(B, reverse=True)

dp = []
for i in range(r+1):
    sdp = [[0]*(b+1) for _ in range(g+1)]
    dp.append(sdp)

answer = 0
for nb_taken in range(r+g+b):
    if nb_taken % 2:
        continue

    for i in range(nb_taken+1):
        if i > r:
            break
        for j in range(nb_taken-i-b, nb_taken-i+1):
            if j > g:
                break
            k = nb_taken-i-j
            if k > b:
                continue
            if i+j < k or i+k < j or j+k < i:
                continue

            if i < r and j < g:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + R[i]*G[j])

                answer = max(answer, dp[i+1][j+1][k])
            if i < r and k < b:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + R[i]*B[k])

                answer = max(answer, dp[i+1][j][k+1])
            if j < g and k < b:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + G[j]*B[k])

                answer = max(answer, dp[i][j+1][k+1])

print(answer)
",O(n ^ 3)
"class Solution(object):
    def goodDaysToRobBank(self, security, time):
        right = [0]
        for i in reversed(range(1, len(security))):
            right.append(right[-1]+1 if security[i] >= security[i-1] else 0)
        right.reverse()
        result = []
        left = 0
        for i in range(len(security)):
            if left >= time and right[i] >= time:
                result.append(i)
            if i+1 < len(security):
                left = left+1 if security[i] >= security[i+1] else 0
        return result",O(n)
"class Solution(object):
    def divisorGame(self, n):
        return n % 2 == 0",O(1)
"class Solution(object):
    def maximumScore(self, nums, k):
        result = curr = nums[k]
        left = right = k
        while left-1 >= 0 or right+1 < len(nums):
            if (nums[left-1] if left-1 >= 0 else 0) <= (nums[right+1] if right+1 < len(nums) else 0):
                right += 1
            else:
                left -= 1
            curr = min(curr, nums[left], nums[right])
            result = max(result, curr*(right-left+1))
        return result",O(n)
"import sys
readline = sys.stdin.readline

N = int(readline())
A = list(map(int, readline().split()))
Q = int(readline())

cnt = 0
for i in range(N):
    for j in range(i+1, N):
        if A[i] > A[j]:
            cnt += 1

cnt %= 2

Ans = [None]*Q
for qu in range(Q):
    l, r = map(int, readline().split())
    if (r-l+1)*(r-l)//2 & 1:
        cnt ^= 1

    Ans[qu] = 'odd' if cnt else 'even'

print('\n'.join(Ans))",O(n ^ 2)
"from math import sqrt, floor, ceil
n = int(input())

ran = list(range(2, 1+n//2))
xx = [ d*(n//d-1)     for d in ran]
print(sum(xx)*4)
",O(n)
"import collections


class Solution(object):
    def isAnagram(self, s, t):
        if len(s) != len(t):
            return False
        count = collections.defaultdict(int)
        for c in s:
            count[c] += 1
        for c in t:
            count[c] -= 1
            if count[c] < 0:
                return False
        return True",O(n)
"class Solution2(object):
    def maxNumOfMarkedIndices(self, nums):
        nums.sort()
        left = 0
        for right in range(len(nums)):
            if nums[right] >= 2*nums[left]:
                left += 1
        return min(left, len(nums)//2)*2",O(nlogn)
"n = int(input())
if n==0:
    print(*[0,0,0])
elif n==1:
    print(*[0,0,1])
else:
    prev2 = 0
    prev1 = 1
    prev = 1
    while prev!=n:
        curr = prev+prev1
        prev2 = prev1
        prev1 = prev
        prev = curr
    print(*[0,prev2,prev1])
",O(1)
"n, k = map(int, input().split())
ps = list(map(int, input().split()))

g = [None for i in range(256)]
f = [None for i in range(256)]
ans = []
for i in range(n):
    p = ps[i]
    if g[p] is not None:
        ans.append(g[p])
        f[p] = 1
    else:
        gb= 0
        for j in range(k):
            ind = p - j
            if f[ind] is not None:
                gb = ind +1
                break
            if ind <= 0:
                break
            if j == k-1:
                gb = ind
        ans.append(gb)
        for j in range(k):
            if gb+j >= 256:
                break
            if f[gb + j] is None:
                g[gb+j] = gb
            else:
                break
        f[gb] = 1
        f[p] = 1
print(' '.join([str(i) for i in ans]))",O(n ^ 2)
"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**13
mod = 10**9+7
dd = [(-1,0),(0,1),(1,0),(0,-1)]
ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)

def main():
    n = I()
    aa = [LI() for _ in range(n)]
    r = []
    for a,b in aa:
        al = a + (1-a%2)
        ar = b - (1-b%2)
        sa = (ar-al) // 2 + 1
        tr = -(al+ar) * sa // 2

        bl = a + (a%2)
        br = b - (b%2)
        sb = (br-bl) // 2 + 1
        tr += (bl+br) * sb // 2
        r.append(tr)

    return ""\n"".join(map(str,r))

print(main())
",O(1)
"class Solution(object):
    def canAliceWin(self, nums):
        total1 = total2 = 0
        for x in nums:
            if x < 10:
                total1 += x
            else:
                total2 += x
        return total1 != total2",O(n)
"n=int(input())
w=[int(k) for k in input().split()]
m=int(input())
c=0
for i in range(n):
    for j in range(i+1, n):
        if w[i]>w[j]:
            c+=1
c%=2
for j in range(m):
    l, r=[int(k) for k in input().split()]
    x=r-l+1
    if x!=1 and (x*(x-1)//2)%2:
        c=not c
    if c:
        print(""odd"")
    else:
        print(""even"")",O(n ^ 2)
"import sys
dp=[]
a=[]
def calcdp(l,r):
    global dp,a
    if l+1==r :
        dp[l][r]=a[l]
        return dp[l][r]
    if dp[l][r]!=0:
        return dp[l][r]
    dp[l][r]=-1
    for k in range(l+1,r):
        la=calcdp(l,k)
        ra=calcdp(k,r)
        if la>0 and la==ra:
            dp[l][r]=la+1
    return dp[l][r]
def solve(n):
    dp2=[float('inf')]*(n+1)
    dp2[0]=0
    for i in range(n):
        for j in range(i+1,n+1):
            if calcdp(i,j)>0:
                dp2[j]=min(dp2[j],dp2[i]+1)

    return dp2[n]
def ip():
    global dp,a

    n=int(sys.stdin.readline())
    a=list(map(int,sys.stdin.readline().split()))
    a.append(0)

    dp=[]
    ll=[0]*(n+1)
    for _ in range(n+1):
        dp.append(list(ll))

    print(solve(n))

ip()
",O(n ^ 3)
"n=int(input())
a=[]
for i in range(n):
    l=[int(i) for i in input().split()]
    if i==0:
        t=sum(l)
    a.append(sum(l))
a.sort(reverse=True)
print(a.index(t)+1)",O(n)
"import collections


class Solution(object):
    def findAllPeople(self, n, meetings, firstPerson):
        meetings.sort(key=lambda x: x[2])
        result = {0, firstPerson}
        adj = collections.defaultdict(list)
        for i, (x, y, _) in enumerate(meetings):
            adj[x].append(y)
            adj[y].append(x)
            if i+1 != len(meetings) and meetings[i+1][2] == meetings[i][2]:
                continue
            q = [i for i in adj.keys() if i in result]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if v in result:
                            continue
                        result.add(v)
                        new_q.append(v)
                q = new_q
            adj = collections.defaultdict(list)
        return list(result)",O(nlogn)
"def main():
    n = int(input())
    a = list(map(int, input().split(' ')))
    array = []
    array.append(a)

    for i in range(n - 1):
        aux = []
        for j in range(1, len(array[-1])):
            xor = (array[-1][j-1] ^ array[-1][j])
            aux.append(xor)
        array.append(aux)

    for j in range(1, len(array)):
        for k in range(len(array[j])):
            maximo = max(array[j][k], array[j-1][k], array[j-1][k+1])
            array[j][k] = maximo

    q = int(input())
    aux2 = []

    for i in range(q):
        l, r = map(int, input().split(' '))
        aux2.append((l, r))

    for i in aux2:
        l, r = i[0], i[1]
        print(str(array[r-l][l-1]))

main()",O(n ^ 2)
"import sys
a = list(map(int, sys.stdin.readlines()[1][:-1].split()))
mx = 0
for i in range(len(a)):
	if a[i] > mx:
		print(i+1)
		sys.exit(0)
	mx = max(mx,a[i] + 1)
print(-1)",O(n)
"n, m = map(int, input().split())
a = list(map(int, input().split()))
dict = {i:0 for i in set(a)}
for i in range(m):
    dict[a[i]] += 1
k = 1
while sum(dict[i]//k for i in dict) >= n:
    k += 1
print(k - 1)
",O(nlogn)
"def main():
    N, M, K = map(int, input().split())

    if K % 2:
        print((""-1 "" * M + ""\n"") * N)
        return

    colEdges = []
    for i in range(N):
        edges = list(map(int, input().split()))
        colEdges.append(edges)

    rowEdges = []
    for i in range(N - 1):
        edges = list(map(int, input().split()))
        rowEdges.append(edges)

    dp = [[[0 for i in range(M)] for j in range(N)] for k in range(2)]
    p = [[[(i, j) for j in range(M)] for i in range(N)] for k in range(2)]
    prev = 0
    for k in range(K // 2):
        cur = prev ^ 1
        for i in range(N):
            for j in range(M):
                cand = (float('inf'), None)

                if j:
                    nxt = (dp[prev][i][j - 1] + colEdges[i][j - 1], p[prev][i][j - 1])
                    cand = min(cand, nxt)
                if j < M - 1:
                    nxt = (dp[prev][i][j + 1] + colEdges[i][j], p[prev][i][j + 1])
                    cand = min(cand, nxt)
                if i:
                    nxt = (dp[prev][i - 1][j] + rowEdges[i - 1][j], p[prev][i - 1][j])
                    cand = min(cand, nxt)
                if i < N - 1:
                    nxt = (dp[prev][i + 1][j] + rowEdges[i][j], p[prev][i + 1][j])
                    cand = min(cand, nxt)

                dp[cur][i][j], p[cur][i][j] = cand
        prev = cur

    for i in range(N):
        for j in range(M):
             print(dp[prev][i][j] * 2, end="" "")
        print()
main()",O(n ^ 3)
"a, b  = map(int, input().split())

k = 2**(a^b).bit_length()-1
print(k)",O(logn)
"n=int(input())
n+=1
if(n==1):print(0)
elif n%2==0:print(n//2)
else :print(n)",O(1)
"def norm(x):
    return (x % 998244353 + 998244353) % 998244353

n, k = map(int, input().split())

dp1 = [0]
dp2 = [0]

for i in range(n):
    l = [1]
    cur = 0
    for j in range(n + 1):
        cur += l[j]
        if(j > i):
            cur -= l[j - i - 1]
        cur = norm(cur)
        l.append(cur)
    dp1.append(l[n])
    dp2.append(norm(dp1[i + 1] - dp1[i]))

ans = 0
for i in range(n + 1):
    for j in range(n + 1):
        if(i * j < k):
            ans = norm(ans + dp2[i] * dp2[j])

ans = norm(ans * 2)

print(ans)",O(n ^ 2)
"n,k=map(int,input().split())
s=input();flag=True;lenn=10**10;ans=0
for i in range(n):
  s1=s+s[n-i-1:]*(k-1);cnt=0
  for i in range(len(s1)-len(s)+1):
     if s1[i:i+len(s)]==s:cnt+=1
  if cnt==k and len(s1)<lenn:ans=s1;lenn=len(s1)
print(ans)
",O(n ^ 2)
"class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        n = len(intervals)
        i = 0
        res = []

        while i < n and intervals[i][1] < newInterval[0]:
            res.append(intervals[i])
            i += 1

        while i < n and newInterval[1] >= intervals[i][0]:
            newInterval[0] = min(newInterval[0], intervals[i][0])
            newInterval[1] = max(newInterval[1], intervals[i][1])
            i += 1
        res.append(newInterval)

        while i < n:
            res.append(intervals[i])
            i += 1

        return res
",O(n)
"n = int(input())

number_sequence = [int(x) for x in input().split("" "")]
number_total = sum(number_sequence)

current_total = 0
current_position = 0

for number in number_sequence:
    current_total = current_total + number
    current_position = current_position + 1
    if(current_total >= number_total/2):
        print(current_position)
        break
",O(n)
"def main():
    n, k = map(int, input().split())
    m = 10 ** 9 + 7
    print((pow(2, k, m) * (2 * n - 1) + 1) % m if n else 0)

if __name__ == '__main__':
    main()
",O(logn)
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=None):
        self.BIT=[0]*(n+1)
        self.num=n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        self.mod = mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

class SegmentTree:
    def __init__(self, init_val, segfunc, ide_ele):
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        k += self.num
        self.tree[k] = x
        while k > 1:
            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])
            k >>= 1

    def query(self, l, r):
        res = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                l += 1
            if r & 1:
                res = self.segfunc(res, self.tree[r - 1])
            l >>= 1
            r >>= 1
        return res

    def bisect_l(self,l,r,x):
        l += self.num
        r += self.num
        Lmin = -1
        Rmin = -1
        while l<r:
            if l & 1:
                if self.tree[l] <= x and Lmin==-1:
                    Lmin = l
                l += 1
            if r & 1:
                if self.tree[r-1] <=x:
                    Rmin = r-1
            l >>= 1
            r >>= 1

        if Lmin != -1:
            pos = Lmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        elif Rmin != -1:
            pos = Rmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        else:
            return -1

from heapq import heappush, heappop
class MinCostFlow:
    INF = 10**18

    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap, cost):
        forward = [to, cap, cost, None]
        backward = forward[3] = [fr, 0, -cost, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def flow(self, s, t, f):
        N = self.N; G = self.G
        INF = MinCostFlow.INF

        res = 0
        H = [0]*N
        prv_v = [0]*N
        prv_e = [None]*N

        d0 = [INF]*N
        dist = [INF]*N

        while f:
            dist[:] = d0
            dist[s] = 0
            que = [(0, s)]

            while que:
                c, v = heappop(que)
                if dist[v] < c:
                    continue
                r0 = dist[v] + H[v]
                for e in G[v]:
                    w, cap, cost, _ = e
                    if cap > 0 and r0 + cost - H[w] < dist[w]:
                        dist[w] = r = r0 + cost - H[w]
                        prv_v[w] = v; prv_e[w] = e
                        heappush(que, (r, w))
            if dist[t] == INF:
                return None

            for i in range(N):
                H[i] += dist[i]

            d = f; v = t
            while v != s:
                d = min(d, prv_e[v][1])
                v = prv_v[v]
            f -= d
            res += d * H[t]
            v = t
            while v != s:
                e = prv_e[v]
                e[1] -= d
                e[3][1] += d
                v = prv_v[v]
        return res

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.buffer.readline()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n = int(input())
a = li()

inv = 0
for i in range(n):
    for j in range(i+1,n):
        if a[i] > a[j]:
            inv += 1
inv %= 2

m = int(input())
for _ in range(m):
    l,r = mi()
    L = r-l+1

    all = L*(L-1)//2
    if all%2==1:
        inv = 1 - inv

    print(""odd"" if inv else ""even"")
",O(n ^ 2)
"import sys
input = sys.stdin.readline

n = int(input())
a = list(map(int, input().split()))
swaps = 0
for i in range(0, 2*n, 2):
    if a[i] == a[i+1]:
        continue

    c = a[i]
    j = i + 2
    while c != a[j]:
        j += 1

    MIN = i+1
    while j > MIN:
        a[j], a[j-1] = a[j-1], a[j]
        j -= 1
        swaps += 1

print(swaps)
",O(n ^ 2)
"import sys
input = lambda: sys.stdin.readline().rstrip('\r\n')
from collections import defaultdict as dft

n,m,k=map(int,input().split())
dct={}
global case
case=0
iput=[]
for i in range(n):
    word=input()
    dct[word]=i+1
    iput.append(word)
d=[[] for i in range(n+1)]
size=[0]*(n+1)
for _ in range(m):

    word,idx=input().split()
    idx=int(idx)
    temp=1
    w=iput[idx-1]

    for x in range(k):
        if w[x]!='_' and w[x]!=word[x]:
            temp=0
            print(""NO"")
            exit()
            break

    res=[]
    for i in range(1<<k):
        s="""".join([word[x] if i & (1<<x) ==0 else '_' for x in range(k)])

        if s in dct:
            j=dct[s]
            if j!=idx:
                d[idx].append(j)
                size[j]+=1

st=[nd  for nd in range(1,n+1) if size[nd]==0]

for i in st:

    for j in d[i]:
        size[j]-=1
        if size[j]==0:
            st.append(j)

if len(st)==n:
    print(""YES"")
    print(*st)
else:
    print(""NO"")
",np
"n, m = [int(x) for x in input().split()]
mat = []
v = []

for i in range(n):
    mat.append([x == '
    v.append([False]*m)

def check(m, v, x, y):
    for i in (-1,0,1):
        for j in (-1,0,1):
            if (i,j) == (0,0):
                continue
            if not m[x+i][y+j]:
                return

    for i in (-1,0,1):
        for j in (-1,0,1):
            if (i,j) != (0,0):
                v[x+i][y+j] = True

for x in range(1, n-1):
    for y in range(1,m-1):
        check(mat, v, x, y)

flag = True
for i in range(0,n):
    for j in range(0,m):
        if mat[i][j] and (not v[i][j]):
            flag = False

if flag:
    print(""YES"")
else:
    print(""NO"")
",O(n ^ 2)
"a, b = map(int, input().split())
q, r = divmod(a, 2)
print('01'*q + '0'*r)
",O(n)
"def power(x , y):
    res = 1
    while y > 0 :
        if y % 2 != 0 :
            res = res * x
        y //= 2
        x *= x

    return res

n = int(input())
m = int(input())

if n <= 40 :
    print(m % power(2 , n))

else:
    print(m)
",O(1)
"class Solution(object):
    def maximumDifference(self, nums):
        result, prefix = 0, float(""inf"")
        for x in nums: 
            result = max(result, x-prefix)
            prefix = min(prefix, x)
        return result if result else -1",O(n)
"n, m = map(int, input().split())
a = [int(x) for x in input().split()]
c = sum(a)
if n == 1:
	print(0)
	exit(0)
a.sort()
res = 0
pocl = a[n - 1]
f = False
for i in range(n - 2, -1, -1):
	if pocl > 1:
		if a[i] >= pocl:
			res += 1
			pocl -= 1
			res += (a[i] - 1)
		else:
			f = True
			pocl = a[i]
			res += 1
			res += (a[i] - 1)
			pocl -= 1
	elif pocl == 1:
		if f:
			res += 1
		res += (a[i] - 1)
		pocl -= 1
	else:
		res += (a[i] - 1)

print(res)
",O(nlogn)
"class Solution(object):
    def maximumSwap(self, num):
        digits = list(str(num))
        left, right = 0, 0
        max_idx = len(digits)-1
        for i in reversed(range(len(digits))):
            if digits[i] > digits[max_idx]:
                max_idx = i
            elif digits[max_idx] > digits[i]:
                left, right = i, max_idx
        digits[left], digits[right] = digits[right], digits[left]
        return int("""".join(digits))",O(logn)
"import heapq


class Solution(object):
    def findMaximizedCapital(self, k, W, Profits, Capital):
        curr = []
        future = sorted(zip(Capital, Profits), reverse=True)
        for _ in range(k):
            while future and future[-1][0] <= W:
                heapq.heappush(curr, -future.pop()[1])
            if curr:
                W -= heapq.heappop(curr)
        return W",O(nlogn)
"import itertools

def q121a_v2():
	good_num_arr = generate_47_arr()
	num = int(input())
	for element in good_num_arr:
		if(num % element == 0):
			print(""YES"")
			return
	print(""NO"")

def generate_47_arr():
	arr = []
	for digits in range(1, 4):
		arr += itertools.product(""47"", repeat=digits)
	for i in range(len(arr)):
		arr[i] = int("""".join(list(arr[i])))
	arr.append(4444444444)
	return arr

q121a_v2()",O(1)
"class Solution(object):
    def maxAmount(self, initialCurrency, pairs1, rates1, pairs2, rates2):
        def BellmanFord(dist, pairs, rates):
            for _ in range(len(pairs)):
                for i in range(len(pairs)):
                    dist[pairs[i][1]] = max(dist[pairs[i][1]], dist[pairs[i][0]]*rates[i])
                    dist[pairs[i][0]] = max(dist[pairs[i][0]], dist[pairs[i][1]]*(1/rates[i]))
        
        dist = collections.defaultdict(int)
        dist[initialCurrency] = 1.0
        BellmanFord(dist, pairs1, rates1)
        BellmanFord(dist, pairs2, rates2)
        return dist[initialCurrency]
import collections",O(n ^ 2)
"n, m, k = map(int, input().split())

h = []
for i in range(n):
  h.append(list(map(int, input().split())))

v = []
for i in range(n - 1):
  v.append(list(map(int, input().split())))

if k % 2 == 0:
  d = [[0] * m for i in range(n)]
  for t in range(k // 2):
    dt = [[0] * m for i in range(n)]
    for i in range(n):
      for j in range(m):
        x = float('inf')
        if i - 1 >= 0:
          x = min(x, d[i - 1][j] + v[i - 1][j] * 2)
        if i + 1 < n:
          x = min(x, d[i + 1][j] + v[i][j] * 2)
        if j - 1 >= 0:
          x = min(x, d[i][j - 1] + h[i][j - 1] * 2)
        if j + 1 < m:
          x = min(x, d[i][j + 1] + h[i][j] * 2)
        dt[i][j] = x
    d = dt.copy()
else:
  d = [[-1] * m for i in range(n)]
for i in d:
    print(*i)",O(n ^ 3)
"n = int(input())
a = input()
b = input()

c = [10**10 for i in range(n + 10)]

c[0] = 0 if a[0] == b[0] else 1

for i in range(1, n):
    if a[i] == b[i]:
        c[i] = c[i - 1]
    elif a[i] == b[i - 1] and a[i - 1] == b[i]:
        c[i] = (1 + c[i - 2] if i > 1 else 1)
    c[i] = min(c[i], c[i - 1] + 1)

print(c[n - 1])
",O(n)
"class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        prod, zero_cnt = 1, 0
        for num in nums:
            if num:
                prod *= num
            else:
                zero_cnt +=  1
        if zero_cnt > 1: return [0] * len(nums)

        res = [0] * len(nums)
        for i, c in enumerate(nums):
            if zero_cnt: res[i] = 0 if c else prod
            else: res[i] = prod // c
        return res
",O(n)
"class Solution(object):
    def replaceDigits(self, s):
        return """".join(chr(ord(s[i-1])+int(s[i])) if i%2 else s[i] for i in range(len(s)))",O(n)
"a0 = (1 << 30) - 1

a0 = 3
b0 = 1

def mock_query(c, d):
    res = (a0 ^ c) - (b0 ^ d)
    if res > 0:
        return 1
    elif res < 0:
        return -1
    else:
        return 0

def query2(c, d):
    ans = mock_query(c, d)
    print('? {:08b} {:08b} --> {}'.format(c, d, ans))
    return ans

def query(c, d):
    print('?', c, d)
    return int(input())

def solve():
    a = 0
    b = 0
    last_ans = query(0, 0)

    pos = 29
    while pos >= 0:
        bit = 1 << pos

        ans = query(a + bit, b + bit)
        if (last_ans, ans) == (1, -1):
            a += bit
            last_ans = query(a, b)
        elif (last_ans, ans) == (-1, 1):
            b += bit
            last_ans = query(a, b)

        else:
            last_ans = ans
            ans = query(a + bit, b)
            if ans == -1:
                a += bit
                b += bit

        pos -= 1

    print('!', a, b)

solve()
",O(1)
"k = int(input())
k -= 1

pow_10, length = 1, 1

while 9 * pow_10 * length < k:
    k -= 9 * pow_10 * length
    pow_10 *= 10
    length += 1

div = k / length
rem = k % length

num = pow_10 + div

print(str(num)[rem])
",O(logn)
"from itertools import chain, combinations, permutations

def powerset(iterable):

    xs = list(iterable)

    return chain.from_iterable(combinations(xs,n) for n in range(len(xs)+1))

n = int(input())
cl1 = []
cl2 = []
for i in range(n):
  s = input()
  a = []
  for j in range(n):
    a.append(s[j])
  cl1.append(a)

for i in range(n):
  s = input()
  a = []
  for j in range(n):
    a.append(s[j])
  cl2.append(a)

def copy(m):
  res = []
  for i in range(n):
    a = []
    for j in range(n):
      a.append(m[i][j])
    res.append(a)
  return res

def pow(m):
  res = []
  for i in range(n):
    a = []
    for j in range(n):
      a.append(m[n-1-j][i])
    res.append(a)
  return res

def vert(m):
  res = []
  for i in range(n):
    res.append(m[i][::-1])
  return res

def gor(m):
  res = []
  for i in range(n):
    a = []
    for j in range(n):
      a.append(m[i][n-1-j])
    res.append(a)
  return res

comblist = [[1], []]
cm = [pow, pow, pow, vert, gor]
cm = list(powerset(cm))
res = False
if cl1 == cl2:
  res = True
else:
  for x in cm:
    for y in permutations(x):
      t = copy(cl1)
      for z in y:
        t = z(t)
      if t==cl2:
        res = True

if res:
  print('Yes')
else:
  print('No')",O(n ^ 2)
"n=int(input())
pieces=[]
blacks=[0]*4
whites=[0]*4
for i in range(4):
    grid=[]
    for j in range(n):
        grid.append(input())
    if i<3:
        input()
    count=0
    for j in range(n):
        for k in range(n):
            if (int(grid[j][k])+j+k)%2:
                count+=1
    blacks[i]=count
    whites[i]=n*n-count
ans=4*n*n
for white1 in range(3):
    for white2 in range(white1+1,4):
        for black1 in range(4):
            if black1==white1 or black1==white2:
                continue
            for black2 in range(black1+1,4):
                if black2==white1 or black2==white2:
                    continue
                ans=min(ans,whites[white1]+whites[white2]+blacks[black1]+blacks[black2])
print(ans)",O(n ^ 2)
"n = int(input())
if n%2==0:
    a = n - 8
    print(a,8)
else:
    a = n-9
    print(a,9)
",O(1)
"R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

dp=[[[-1 for i in range(205)] for j in range(205)] for k in range(205)]
def recurser(x,y,z):
    if (x>=R and y>=G) or (y>=G and z>=B) or (z>=B and x>=R):
        return 0
    if dp[x][y][z]!=-1:
        return dp[x][y][z]
    maxi=0
    if x<R and y<G:
        maxi=max(maxi,r[x]*g[y]+recurser(x+1,y+1,z))
    if y<G and z<B:
        maxi=max(maxi,g[y]*b[z]+recurser(x,y+1,z+1))
    if z<B and x<R:
        maxi=max(maxi,r[x]*b[z]+recurser(x+1,y,z+1))
    dp[x][y][z]=maxi
    return maxi
print(recurser(0,0,0))",O(n ^ 3)
"from collections import Counter
import sys
readline = sys.stdin.readline

def check(A):
    CA = Counter(A)
    if CA[0] >= 2:
        return False
    cnt = 0
    for k, v in CA.items():
        if v > 2:
            return False
        if v == 2 and CA[k-1] >= 1:
            return False
        if v >= 2:
            cnt += 1
    if cnt >= 2:
        return False
    L = len(A)
    if (sum(A) - L*(L-1)//2) % 2 == 0:
        return False
    return True

N = int(readline())
if check(list(map(int, readline().split()))):
    print('sjfnb')
else:
    print('cslnb')
",O(n)
"from sys import stdin
input = stdin.readline

n=int(input())
arr=[int(x) for x in input().split()]

arr.sort(reverse=True)

d={}
for i in range(n):
    if arr[i] in d:
        d[arr[i]].append(i)
    else:
        d[arr[i]]=[i]

cnt=0
vis=[-1]*n
for i in range(n):
    s=bin(arr[i])
    s=s[2:]
    s=s[::-1]
    l=len(s)
    x=0
    for j in range(l):
        if s[j]==""0"":
            x=x+(2**j)
    x=x+1

    if x in d:
        if x==arr[i] and len(d[x])==1:
            if vis[i]==-1:
                cnt=cnt+1
        else:
            if vis[d[x][0]]==-1:
                for j in d[x]:
                    vis[j]=1
    else:
        if vis[i]==-1:
            cnt=cnt+1
    vis[i]=1

print(cnt)",O(nlogn)
"class Solution2(object):
    def lemonadeChange(self, bills):
        five, ten = 0, 0
        for bill in bills:
            if bill == 5:
                five += 1
            elif bill == 10:
                if not five:
                    return False
                five -= 1
                ten += 1
            else:
                if ten and five:
                    ten -= 1
                    five -= 1
                elif five >= 3:
                    five -= 3
                else:
                    return False
        return True",O(n)
"class Solution(object):
    def maximalRectangle(self, matrix):
        def largestRectangleArea(heights):
            stk, result, i = [-1], 0, 0
            for i in range(len(heights)+1):
                while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):
                    result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))
                stk.append(i) 
            return result

        if not matrix:
            return 0
        result = 0
        heights = [0]*len(matrix[0])
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0
            result = max(result, largestRectangleArea(heights))
        return result",O(n ^ 2)
"class Solution(object):
    def separateSquares(self, squares):
        class SegmentTreeRecu(object):
            def __init__(self, sorted_x):
                self.sorted_x = sorted_x
                n = len(sorted_x)-1
                l = 1<<((n-1).bit_length()+1)
                self.tree = [0]*l
                self.cnt = [0]*l
        
            def update(self, ql, qr, v, l, r, i): 
                if ql >= r or qr <= l:
                    return
                if ql <= l and r <= qr:
                    self.cnt[i] += v
                else:
                    m = l+(r-l)//2
                    self.update(ql, qr, v, l, m, 2*i)
                    self.update(ql, qr, v, m, r, 2*i+1)
                if self.cnt[i] > 0:
                    self.tree[i] = self.sorted_x[r]-self.sorted_x[l]
                else:
                    if r-l == 1:
                        self.tree[i] = 0
                    else:
                        self.tree[i] = self.tree[2*i]+self.tree[2*i+1]
    
        events = []
        x_set = set()
        for x, y, l in squares:
            events.append((y, 1, x, x+l))
            events.append((y+l, -1, x, x+l))
            x_set.add(x)
            x_set.add(x+l)
        events.sort(key=lambda e: e[0])
        sorted_x = sorted(x_set) 
        x_to_idx = {x:i for i, x in enumerate(sorted_x)}
        st = SegmentTreeRecu(sorted_x)
        prev = events[0][0]
        intervals = []
        for y, v, x1, x2 in events:
            if y != prev:
                intervals.append([prev, y, st.tree[1]])
                prev = y
            st.update(x_to_idx[x1], x_to_idx[x2], v, 0, len(sorted_x)-1, 1)
        expect = sum((y2-y1)*curr for y1, y2, curr in intervals)/2.0
        total = 0.0
        for y1, y2, curr in intervals:
            if total+(y2-y1)*curr >= expect:
                break
            total += (y2-y1)*curr
        return y1+(expect-total)/curr",O(nlogn)
"class Solution(object):
    def minMoves(self, rooks):
        def count(arr):
            cnt = [0]*len(arr)
            for x in arr:
                cnt[x] += 1
            return sum(abs(i-x) for i, x in enumerate(x for x, cnt in enumerate(cnt) for _ in range(cnt)))

        return sum(count(arr) for arr in zip(*rooks))",O(n)
"import atexit
import io
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__

def main():
    n, a, b = [int(x) for x in input().split()]
    dc = {}
    for i in range(n):
        x, vx, vy = [int(x) for x in input().split()]
        nx = x + vx
        ny = a * x + b + vy
        dd = a * nx - ny + b
        if dd not in dc:
            dc[dd] = {}
        if (vx, vy) not in dc[dd]:
            dc[dd][(vx, vy)] = 0
        dc[dd][(vx, vy)] += 1

    tot = 0
    for v, k in dc.items():
        tt = 0
        pp = 0
        for _, cc in k.items():
            tt -= cc * (cc + 1) // 2
            pp += cc
        tt += pp * (pp + 1) // 2
        tot += tt * 2
    print(tot)

if __name__ == '__main__':
    main()",O(n)
"import sys

from bisect import bisect_right as rb
from collections import deque

from queue import PriorityQueue
from math import *
input_ = lambda: sys.stdin.readline().strip(""\r\n"")
ii = lambda : int(input_())
il = lambda : list(map(int, input_().split()))
ilf = lambda : list(map(float, input_().split()))
ip = lambda : input_()
fi = lambda : float(input_())
ap = lambda ab,bc,cd : ab[bc].append(cd)
li = lambda : list(input_())
pr = lambda x : print(x)
prinT = lambda x : print(x)
f = lambda : sys.stdout.flush()
inv =lambda x:pow(x,mod-2,mod)
mod = 10**9 + 7

def bit(n) :
    if (n == 0) :return 0
    val = 1

    while (val&n) == 0 :
        val *= 2

    return val

n,q = il()
x = n+1

for i in range(q) :
    t1 = ii()

    for j in ip() :
        val = bit(t1)

        if (j == ""U"") :
            tem = (t1-val)|(val*2)
            if (tem < n) :
                t1 = tem
        elif (j == ""L"" and val>1) :
            t1 -= val//2
        elif (j == ""R"" and val>1) :
            t1 += val//2

    print(t1)
",np
"class Solution(object):
    def sortColors(self, nums):
        def triPartition(nums, target):
            i, left, right = 0, 0, len(nums)-1
            while i <= right:
                if nums[i] > target:
                    nums[i], nums[right] = nums[right], nums[i]
                    right -= 1
                else:
                    if nums[i] < target:
                        nums[left], nums[i] = nums[i], nums[left]
                        left += 1
                    i += 1

        triPartition(nums, 1)",O(n)
"class Solution(object):
    def partitionDisjoint(self, A):
        B = A[:]
        for i in reversed(range(len(A)-1)):
            B[i] = min(B[i], B[i+1])
        p_max = 0
        for i in range(1, len(A)):
            p_max = max(p_max, A[i-1])
            if p_max <= B[i]:
                return i",O(n)
"n = int(input())
nums = [int(x) for x in input().split()]
ans = 10 ** 12
for idx, num in enumerate(nums):
    dist = max(idx, n - idx - 1)
    curr = num // dist
    ans = min(ans, curr)
print(ans)",O(n)
"class Solution(object):
    def maxScoreSightseeingPair(self, A):
        result, curr = 0, 0
        for x in A:
            result = max(result, curr+x)
            curr = max(curr, x)-1
        return result",O(n)
"n=int(input())
a=[-1]+list(map(int,input().split()))
s=set()
s.add(-1)
a.sort()
count,add=0,0
flag=0
for i in range(1,n+1):
    if a[i] in s and a[i]-1 in s:
        flag=1
        break
    if a[i] in s:
        add+=1
    if(add==2):
        flag=1
        break
    s.add(a[i])
    count+=a[i]-(i-1)
if(flag==0 and count%2==1):
    print(""sjfnb"")
else:
    print(""cslnb"")",O(nlogn)
"n, m, k = map(int, input().split());
a = list(map(int, input().split()));
a.sort(reverse = True);
if sum(a)+k-n < m:
    print(-1);
elif k >= m:
    print(0);
else:
    for i in range (1, n+1):
        if sum(a[:i])+k-i >= m:
            print(i)
            break;
",O(nlogn)
"import sys
input = lambda: sys.stdin.readline().rstrip()

N, M, K = map(int, input().split())
if K % 2:
    for _ in range(N):
        print(*[-1] * M)
    exit()
A = [[int(a) for a in input().split()] for _ in range(N)]
B = [[int(a) for a in input().split()] for _ in range(N-1)]
X = [[0] * M for _ in range(N)]
inf = 1 << 30
for k in range(1, K // 2 + 1):
    nX = [[inf] * M for _ in range(N)]
    for i in range(N):
        for j in range(M):
            if i: nX[i][j] = min(nX[i][j], X[i-1][j] + B[i-1][j])
            if i < N - 1: nX[i][j] = min(nX[i][j], X[i+1][j] + B[i][j])
            if j: nX[i][j] = min(nX[i][j], X[i][j-1] + A[i][j-1])
            if j < M - 1: nX[i][j] = min(nX[i][j], X[i][j+1] + A[i][j])
    X = nX
for x in X:
    print(*[a * 2 for a in x])
",O(n ^ 3)
"import sys
input = sys.stdin.buffer.readline
from itertools import permutations

k = list(map(int,input().split()))

worked = 0
for k1,k2,k3 in permutations(k):
    worked2 = 1
    for t in range(10000):
        if not (t % k1 == 0 or t % k2 == 1 or t % k3 == 2):
            worked2 = 0

    if worked2:
        worked = 1
        break

if worked:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        def dfs(l, r):
            if l > r:
                return float(""-inf"")

            m = (l + r) >> 1
            leftSum = rightSum = curSum = 0
            for i in range(m - 1, l - 1, -1):
                curSum += nums[i]
                leftSum = max(leftSum, curSum)

            curSum = 0
            for i in range(m + 1, r + 1):
                curSum += nums[i]
                rightSum = max(rightSum, curSum)

            return (max(dfs(l, m - 1),
                        dfs(m + 1, r),
                        leftSum + nums[m] + rightSum))

        return dfs(0, len(nums) - 1)
",O(nlogn)
"class Solution(object):
    def countGoodNumbers(self, n):
        def powmod(a, b, mod):
            a %= mod
            result = 1
            while b:
                if b&1:
                    result = (result*a)%mod
                a = (a*a)%mod
                b >>= 1
            return result

        MOD = 10**9 + 7
        return powmod(5, (n+1)//2%(MOD-1), MOD)*powmod(4, n//2%(MOD-1), MOD) % MOD",O(logn)
"r, g, b = map(int, input().split(' '))
R = list(map(int, input().split(' ')))
G = list(map(int, input().split(' ')))
B = list(map(int, input().split(' ')))
dp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)
R.insert(0, 0)
G.insert(0, 0)
B.insert(0, 0)
dp[0][0][0], ans = 0, 0
for i in range(0, r+1):
    for j in range(0, g+1):
        for k in range(0, b+1):
            if i == 0 and j == 0 and k == 0:continue
            if i and j and dp[i - 1][j - 1][k] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j])
            if k and j and dp[i][j - 1][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j])
            if i and k and dp[i - 1][j][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k])
            ans = max(ans,dp[i][j][k])
print(ans)",O(n ^ 3)
"class Solution(object):
    def maxActiveSectionsAfterTrade(self, s):
        curr = prev = mx = cnt1 = 0
        for x in s:
            if x == '0':
                curr += 1
            else:
                if curr:
                    prev = curr
                    curr = 0
                cnt1 += 1
            mx = max(mx, prev+curr)
        return cnt1 if mx in (prev, curr) else mx+cnt1",O(n)
"class Solution(object):
    def amountPainted(self, paint):
        points = collections.defaultdict(list)
        for i, (s, e) in enumerate(paint):
            points[s].append((True, i))
            points[e].append((False, i))
        min_heap = []
        lookup = [False]*len(paint)
        result = [0]*len(paint)
        prev = -1
        for pos in sorted(points.keys()):
            while min_heap and lookup[min_heap[0]]:
                heapq.heappop(min_heap)
            if min_heap:
                result[min_heap[0]] += pos-prev
            prev = pos
            for t, i in points[pos]:
                if t:
                    heapq.heappush(min_heap, i)
                else:
                    lookup[i] = True
        return result
from sortedcontainers import SortedList",O(nlogn)
"class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        while len(tokens) > 1:
            for i in range(len(tokens)):
                if tokens[i] in ""+-*/"":
                    a = int(tokens[i-2])
                    b = int(tokens[i-1])
                    if tokens[i] == '+':
                        result = a + b
                    elif tokens[i] == '-':
                        result = a - b
                    elif tokens[i] == '*':
                        result = a * b
                    elif tokens[i] == '/':
                        result = int(a / b)
                    tokens = tokens[:i-2] + [str(result)] + tokens[i+1:]
                    break
        return int(tokens[0])
",O(n ^ 2)
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

def main():

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc=1
    for _ in range(tc):
        n=ri()
        ans=[]
        i=1
        k=1
        t=0
        while True:
            k=i*i
            if k<=n:
                t=i
            else:
                break
            i+=1
        a=[]
        z=[]
        for i in range(n):
            z+=[i+1]
            if len(z)==t:
                a=z+a
                z=[]
        a=z+a
        wia(a)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(n)
"class Solution(object):
    def maximumXorProduct(self, a, b, n):
        MOD = 10**9+7
        for i in reversed(range(n)):
            base = 1<<i
            if min(a, b)&base == 0:
                a, b = a^base, b^base
        return (a%MOD)*(b%MOD)%MOD",O(n)
"l = [int(x) for x in raw_input().split()]
n, s = l[0], l[1]

def getval(x):
	cur, ans = 0, 0
	while(x):
		dig = (x % 10)
		ans += dig * cur
		cur *= 10
		cur += 9
		x /= 10
	return ans

low = 1
high = n
for _ in range(64):
	mid = (low + high) // 2
	if(getval(mid) < s):
		low = mid + 1
	else:
		high = mid;

if(low > high):
	print(0)
elif(getval(low) >= s):
	print(n - low + 1)
else:
	print(n - high + 1)",O(logn)
"class Solution(object):
    def missingNumber(self, arr):
        def check(arr, d, x):
            return arr[x] != arr[0] + d*x

        d = (arr[-1]-arr[0])//len(arr)
        left, right = 0, len(arr)-1
        while left <= right:
            mid = left + (right-left)//2
            if check(arr, d, mid):
                right = mid-1
            else:
                left = mid+1
        return arr[0] + d*left",O(logn)
"

class Solution(object):
    def minimumOperations(self, nums):
        return len({x for x in nums if x})
",O(n)
"import re
input()
print(sum(len(f)-2 for f in re.findall('x{3,}',input())))",O(n)
"z,x=map(int,input().split())
z-=1;x-=1
if x*(x+1)/2 < z :
  print(-1)
elif z==0:
    print(0)
elif z==x:
    print(1)
else:
    import sys
    start = 1 ; end = x
    while end > start:
        mid = (end +start)//2
        ans =(x*(x+1)//2)-((mid-1)*(mid)//2 )
        if ans == z:
            print(x-mid+1)
            sys.exit(0)
        elif ans > z:
            start = mid+1
        elif ans < z:
            end = mid
    print(x-end+2)
",O(logn)
"n=input()
i=0
while(True):
    if (n-9*10**i*(i+1))<=0:
        break
    n-=9*10**i*(i+1)
    i+=1

a=n/(i+1)
b=n%(i+1)
if(b!=0):
    print(str(10**i+a)[b-1])
else:
    print(str(10**i+a-1)[-1])
",O(1)
"class Solution(object):
    def reversePrefix(self, word, ch):
        i = word.find(ch)
        return word[:i+1][::-1]+word[i+1:]",O(n)
"class Solution3(object):
    def amountOfTime(self, root, start):
        def bfs(root):
            adj = collections.defaultdict(list)
            q = [root]
            while q:
                new_q = []
                for u in q:
                    for v in (u.left, u.right):
                        if v is None:
                            continue
                        adj[u.val].append(v.val)
                        adj[v.val].append(u.val)
                        new_q.append(v)
                q = new_q
            return adj

        def bfs2(adj, start):
            result = -1
            q = [start]
            lookup = {start}
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if v in lookup:
                            continue
                        lookup.add(v)
                        new_q.append(v)
                q = new_q
                result += 1
            return result

        adj = bfs(root)
        return bfs2(adj, start)",O(n)
"if __name__ == ""__main__"":
    n = int(input())
    nums = [int(a) for a in input().strip().split()]
    counts = 0

    for i in range(n-1):
        for j in range(i + 1, n):
            if nums[i] > nums[j]:
                counts += 1

    ans = counts % 2
    ans_tmp = []
    m = int(input())
    for i in range(m):
        l, r = [int(a) for a in input().strip().split()]

        tmp = r - l + 1
        tmp_count = (tmp * (tmp - 1) // 2)
        if tmp_count % 2 == 1:
            ans = (ans + 1) % 2
        ans_tmp.append(ans)

    for i in range(m):
        ans = ans_tmp[i]
        if ans % 2 == 1:
            print(""odd"")
        else:
            print(""even"")
",O(n ^ 2)
"n = int(input())
l = list(map(int, input().split("" "")))
r = list(map(int, input().split("" "")))

slr = [l[i]+r[i] for i in range(n)]
ans = [n-slr[i] for i in range(n)]

flag = True
if l[0]!=0 or r[n-1]!=0:
	flag= False

for i in range(n):
	great = 0
	for j in range(i+1, n):
		if ans[i]<ans[j]:
			great = great + 1
	if r[i]!=great:
		flag = False
		break
for i in range(n-1, -1, -1):
	great = 0
	for j in range(i-1, -1, -1):
		if ans[i]<ans[j]:
			great = great + 1
	if l[i]!=great:
		flag = False
		break

if flag:
	print(""YES"")
	for i in range(0, n-1):
		print(ans[i], end="" "")
	print(ans[n-1])
else:
	print(""NO"")
",O(n ^ 2)
"from sys import stdin, stdout
from collections import defaultdict

n, m, k = map(int, stdin.readline().split())

dic = defaultdict(lambda : {})
for i in range(n):
    line = tuple(map(int, stdin.readline().split()))
    for j in range(m-1):
        dic[i*m+j][i*m+j+1] = line[j]*2
        dic[i*m+j+1][i*m+j] = line[j]*2

for i in range(n-1):
    line = tuple(map(int, stdin.readline().split()))
    for j in range(m):
        dic[i*m+j][(i+1)*m+j] = line[j]*2
        dic[(i+1)*m+j][i*m+j] = line[j]*2

if k % 2 != 0:
    for i in range(n):
        stdout.write(' '.join(('-1',)*m))
        stdout.write('\n')
else:
    prev = []
    di = (1, 0, -1, 0)
    dj = (0, 1, 0, -1)
    for _ in range(n):
        prev.append((0,)*m)

    for _ in range(k//2):
        new = []
        for _ in range(n):
            new.append([100_000_000]*m)

        for num in dic:
            i = num // m
            j = num % m
            for idx in range(4):
                ii = i + di[idx]
                jj = j + dj[idx]
                if not ((0 <= ii < n) and (0 <= jj < m)): continue
                new[ii][jj] = min(new[ii][jj], prev[i][j] + dic[i*m+j][ii*m+jj])

        prev = new

    for i in range(n):
        stdout.write(' '.join(map(str, prev[i])))
        stdout.write('\n')
",O(n ^ 3)
"import sys, collections, math, itertools, random, bisect
INF = sys.maxsize
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_array(): return list(map(int, sys.stdin.readline().strip().split()))
def input(): return sys.stdin.readline().strip()
mod = 1000000007

l,r = get_ints()
if r-l < 2:
    print(-1)
elif l%2 == 0:
    print(l, l+1, l+2)
elif r-l > 2:
    print(l+1, l+2, l+3)
else:
    print(-1)",O(1)
"import sys,math
from collections import deque,defaultdict
import operator as op
from functools import reduce
from itertools import permutations
import heapq

I=sys.stdin.readline

alpha=""abcdefghijklmnopqrstuvwxyz""

def ii():
	return int(I().strip())
def li():
	return list(map(int,I().strip().split()))
def mi():
	return map(int,I().strip().split())

def ncr(n, r):
    r = min(r, n-r)
    numer = reduce(op.mul, range(n, n-r, -1), 1)
    denom = reduce(op.mul, range(1, r+1), 1)
    return numer // denom

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def isPrime(n):
	if n<=1:
		return False
	elif n<=2:
		return True
	else:

		for i in range(2,int(n**.5)+1):
			if n%i==0:
				return False
		return True

def main():

	n=ii()
	arr=li()

	sett=set(arr)

	power=[2**i for i in range(32)]

	ans=[]

	for i in power:
		for j in arr:
			tmp=[j]
			for k in range(2):
				if tmp[-1]+i in sett:
					tmp.append(tmp[-1]+i)

			if len(tmp)>len(ans):

				ans=[x for x in tmp]

			if len(ans)==3:
				break

		if len(ans)==3:
			break

	print(len(ans))
	print(*ans)

if __name__ == '__main__':
	main()",O(nlogn)
"def main():
    pieces_Dimension = int(input())
    piece1 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece2 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece3 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece4 = ''.join(input() for _ in range(pieces_Dimension))

    brokenPieces = (piece1, piece2, piece3, piece4)
    nSquares = pieces_Dimension*pieces_Dimension
    squares = '01'*-(-nSquares//2)

    return nSquaresToRecolorIn(brokenPieces, nSquares, squares)

def nSquaresToRecolorIn(brokenPieces, nSquares, squares):
    possible_nSquares = [(sum(piece[i] != squares[:-1][i] for i in range(nSquares)),
                          sum(piece[i] != squares[1:][i] for i in range(nSquares)))
                         for piece in brokenPieces]
    possible_nSquares.sort(key=lambda x: x[0])

    return possible_nSquares[0][0] + possible_nSquares[1][0] + possible_nSquares[2][1] + possible_nSquares[3][1]

if __name__ == '__main__':
    print(main())
",O(n ^ 2)
"from sys import stdin, stdout

MOD = 10 ** 9 + 7

def bin_pow(n, k):
    res = 1

    while k:
        if k & 1:
            res = (res * n) % MOD

        n = (n * n) % MOD
        k >>= 1

    return res

x, k = map(int, stdin.readline().split())

if x == 0:
    stdout.write('0')
else:
    ans = (bin_pow(2, k + 1) * x - bin_pow(2, k) + 1) % MOD
    stdout.write(str(ans))",O(logn)
"n = int(input())

if n % 2 == 0 :
    print(4 , n - 4)
else:
    print(9 , n - 9)
",O(1)
"def main():
    import sys
    import collections
    input = sys.stdin.readline
    n, m, K = map(int, input().split())

    A = [input().rstrip() for i in range(n)]

    B = [list(input().rstrip().split()) for i in range(m)]

    alpha = 'abc'

    D = dict()
    for i, x in enumerate(A):
        D[x] = i

    G = [set() for i in range(n)]
    X = [set() for i in range(n)]

    for i in range(m):
        a, b = B[i]
        b = int(b)
        flag = False
        for j in range(2**K):
            x = []
            for k in range(K):
                if (j >> k) % 2 == 1:
                    x.append('_')
                else:
                    x.append(a[k])
            x = ''.join(x)
            if x in D:
                if D[x] == b-1:
                    flag = True
                    continue
                else:
                    G[b-1].add(D[x])
                    X[D[x]].add(b-1)
        if flag:
            continue
        else:
            print(""NO"")
            exit(0)
    X = [len(X[i]) for i in range(n)]
    ANS = []
    s = set()
    q = collections.deque()
    for i in range(n):
        if X[i] == 0:
            q.append(i)
            s.add(i)

    while(q):
        if len(ANS) == n:
            print(""NO"")
            exit(0)
        x = q.popleft()
        ANS.append(x+1)
        for y in G[x]:
            if X[y] == 0:
                continue
            else:
                X[y] -= 1
                if X[y] == 0:
                    q.append(y)
    if len(ANS) == n:
        print(""YES"")
        print(*ANS)
    else:
        print(""NO"")

main()
",np
"class Solution(object):
    def lengthOfLongestSubstringTwoDistinct(self, s):
        longest, start, distinct_count, visited = 0, 0, 0, [0 for _ in range(256)]
        for i, char in enumerate(s):
            if visited[ord(char)] == 0:
                distinct_count += 1
            visited[ord(char)] += 1
            while distinct_count > 2:
                visited[ord(s[start])] -= 1
                if visited[ord(s[start])] == 0:
                    distinct_count -= 1
                start += 1
            longest = max(longest, i - start + 1)
        return longest",O(n)
"import math
n=int(input())
lst = list(map(int, input().strip().split(' ')))

p=max(lst)
ind=lst.index(p)
if p==1:
    lst[ind]=2
else:
    lst[ind]=1
lst.sort()
for j in range(n):
    print(lst[j],end="" "")",O(nlogn)
"def main():
    import sys
    input = sys.stdin.readline

    n = int(input())
    a = list(map(int, input().split()))
    cnt = 0
    for i in range(n):
        for j in range(i+1, n):
            if a[i] > a[j]:
                cnt += 1
    even = cnt % 2 == 0
    q = int(input())
    ans = []
    for _ in range(q):
        l, r = map(int, input().split())
        len = r - l + 1
        pairs = len * (len-1) // 2
        if pairs % 2 == 1:
            even = not even
        if even:
            ans.append('even')
        else:
            ans.append('odd')
    print('\n'.join(ans))

main()",O(n ^ 2)
"import sys
import math
import collections
import bisect
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n,m=get_ints()
    space=0
    saved=[]
    for i in range(n):
        a,b=get_ints()
        space+=a
        saved.append(a-b)
    saved.sort(reverse=True)
    if space-sum(saved)>m:
        print(-1)
        continue
    i=0
    count=0
    if space<=m:
        print(0)
        continue
    while i<n:
        count+=1
        space-=saved[i]
        if space<=m:
            print(count)
            break
        i+=1",O(nlogn)
"n,k=map(int,input().split())
if 2*n-1<k :
	print(0)
elif k<=n+1 :
	if k%2:
		print(k//2)
	else:
		print(k//2-1)
else:
	t1=k-n
	if k%2==0:
		print(k//2-t1)
	else:
		print(k//2-t1+1)
",O(1)
"from __future__ import division
from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]
n, m = rints()
a, cur, ans = rints()[::-1], 2, -1

for i in range(n - 2):
    cur = max(cur, i + 2)
    for j in range(cur, n):
        if a[i] - a[j] < 1:
            cur += 1
            continue

        if a[i] - a[j] > m:
            break

        cur += 1

        v = (a[i] - a[j - 1]) / (a[i] - a[j])
        ans = max(ans, v)

print(ans)
",O(nlogn)
"import os
import sys
import math
import heapq
from decimal import *
from io import BytesIO, IOBase
from collections import defaultdict, deque

def r():
    return int(input())
def rm():
    return map(int,input().split())
def rl():
    return list(map(int,input().split()))

r,g,b = rm()
R = rl()
G = rl()
B = rl()
R.sort()
G.sort()
B.sort()
dp = [[[0]*(b+1) for j in range(g+1)] for i in range(r+1)]
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i and j:
                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+R[i-1]*G[j-1])
            if j and k:
                dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+G[j-1]*B[k-1])
            if k and i:
                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+B[k-1]*R[i-1])
print(dp[r][g][b])",O(n ^ 3)
"from sys import stdout

ask_count = 0

n = int(input())

def ask(num):
    global ask_count
    print(""? "" + str(num))
    stdout.flush()
    ask_count += 1
    return int(input())

def ans(num):
    print(""! "" + str(num))
    stdout.flush()

def opposite(num):
    return num + n // 2

low = 1
high = opposite(low)
lval = ask(low)
hval = ask(high)
prev_l_less_h = (lval < hval)

while high - low > 1:

    mid = (low + high) // 2

    lval = ask(mid)
    hval = ask(opposite(mid))
    l_less_h = (lval < hval)

    if abs(lval - hval) % 2 == 1:
        ans(-1)
        exit(0)
    elif hval == lval:
        ans(mid)
        exit(0)
    else:
        if l_less_h == prev_l_less_h:
            low = mid
        else:
            high = mid
ans(-1)",O(logn)
"class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()

        for i, a in enumerate(nums):
            if a > 0:
                break

            if i > 0 and a == nums[i - 1]:
                continue

            l, r = i + 1, len(nums) - 1
            while l < r:
                threeSum = a + nums[l] + nums[r]
                if threeSum > 0:
                    r -= 1
                elif threeSum < 0:
                    l += 1
                else:
                    res.append([a, nums[l], nums[r]])
                    l += 1
                    r -= 1
                    while nums[l] == nums[l - 1] and l < r:
                        l += 1

        return res
",O(n ^ 2)
"class Solution2(object):
    def countHighestScoreNodes(self, parents):
        def dfs(adj, i, result):
            cnts = [dfs(adj, child, result) for child in adj[i]]
            total = sum(cnts)+1
            score = max((len(adj)-total), 1)*reduce(lambda x, y: x*y, cnts, 1)
            if score > result[0]:
                result[:] = [score, 1]
            elif score == result[0]:
                result[1] += 1
            return total

        adj = [[] for _ in range(len(parents))] 
        for i in range(1, len(parents)):
            adj[parents[i]].append(i)
        result = [0]*2
        dfs(adj, 0, result)
        return result[1]",O(n)
"class Solution(object):
    def numTimesAllBlue(self, light):
        result, right = 0, 0
        for i, num in enumerate(light, 1):
            right = max(right, num)
            result += (right == i)
        return result",O(n)
"class Solution(object):
    def beautySum(self, s):
        result = 0 
        for i in range(len(s)):
            lookup = [0]*26
            for j in range(i, len(s)):
                lookup[ord(s[j])-ord('a')] += 1
                result += max(lookup) - min(x for x in lookup if x)
        return result",O(n ^ 2)
"from collections import defaultdict, Counter,deque
from math import sqrt, log10, log, floor, factorial,gcd
from bisect import bisect_left, bisect_right
from itertools import permutations,combinations
import sys, io, os
input = sys.stdin.readline

inf = float('inf')
mod = 10 ** 9 + 7
def yn(a): print(""YES"" if a else ""NO"")
ceil = lambda a, b: (a + b - 1) // b
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class masks:
    def all_masks_sos(self,arr,lim=22):
        lim = 22
        maxbits = lim
        self.masks=masks = 1 << lim
        self.dp = [-1] * masks
        for i in arr:
            self.dp[i] = i
        for i in range(masks):
            for j in range(maxbits):
                if self.dp[i] == -1 and i & (1 << j):
                    self.dp[i] = self.dp[i - (1 << j)]

t=1
m=masks()
for i in range(1):
    n=int(input())
    l=[int(i) for i in input().split()]
    m.all_masks_sos(l,22)
    ans = [m.dp[i ^ (m.masks - 1)] for i in l]
    print(*ans)
",np
"n,m = map(int, input().strip().split(' '))
a='8'*1129 + '9'
b='1'*1130
print(a)
print(b)",O(1)
"from sys import stdin,stdout
input=stdin.readline

def count(audrey,imba,banget):
    return((imba-audrey-1)%(banget-1))

n,q=map(int,input().split())
L=list(map(int,input().split()))
maxi=max(L)
indexmax=L.index(maxi)
P=[]
for i in range(indexmax):
    P.append((L[0],L[1]))
    if L[0]<L[1]:
        L.append(L.pop(0))
    else:
        L.append(L.pop(1))
Y=tuple(L[1:])
for p in range(q):
    m=int(input())
    if m<=indexmax:
        print(str(P[m-1][0])+' '+str(P[m-1][1]))
    else:
        stdout.write(str(maxi)+' '+str(Y[count(indexmax,m,n)])+'\n')",O(n)
"import random
import collections



class Solution(object):
    def minCost(self, basket1, basket2):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        cnt = collections.Counter()
        for x in basket1:
            cnt[x] += 1
        for x in basket2:
            cnt[x] -= 1
        mn = min(cnt.keys())
        swaps = []
        for k, v in cnt.items():
            if v%2:
                return -1
            swaps.extend(k for _ in range(abs(v)//2))
        nth_element(swaps, len(swaps)//2)
        return sum(min(swaps[i], mn*2) for i in range(len(swaps)//2))",O(n)
"from sys import stdin

def f(lst, num):
    new = lst[num:] + lst[:num]
    return new

t = int(stdin.readline())
for i in range(t):
    row, col = tuple(int(x) for x in stdin.readline().split())
    lst = list([int(x)] for x in stdin.readline().split())

    for j in range(row-1):
        line = tuple(int(x) for x in stdin.readline().split())
        for k in range(len(line)):
            lst[k].append(line[k])

    lst.sort(key=lambda x: max(x), reverse = True)

    ans = float('-inf')
    for a in range(4):
        for b in range(4):
            for c in range(4):
                for d in range(4):
                    if col >= 1:
                        aa = f(lst[0], a)
                    else:
                        aa = (0,)*row
                    if col >= 2:
                        bb = f(lst[1], b)
                    else:
                        bb = (0,)*row
                    if col >= 3:
                        cc = f(lst[2], c)
                    else:
                        cc = (0,)*row
                    if col >= 4:
                        dd = f(lst[3], d)
                    else:
                        dd = (0,)*row

                    ans = max(ans,
                              sum(max(x[j] for x in (aa, bb, cc, dd))
                                  for j in range(row)))
    print(ans)
",np
"import sys
keta=29
print(""?"",0,0,flush=True)

A00=int(input())
if A00==0:
    ANS=0
    for k in range(keta,-1,-1):
        print(""?"",2**k,0,flush=True)
        if int(input())==-1:
            ANS+=2**k
    print(""!"",ANS,ANS,flush=True)
    sys.exit()

A=0
B=0
for k in range(keta,-1,-1):
    LIST=[]
    print(""?"",2**k+A,B,flush=True)
    LIST.append(int(input()))
    print(""?"",A,2**k+B,flush=True)
    LIST.append(int(input()))

    if LIST[0]!=LIST[1]:
        if LIST[0]==-1:
            A+=2**k
            B+=2**k

    else:
        if A00==1:
            A+=2**k
        else:
            B+=2**k
        A00=LIST[0]
print(""!"",A,B,flush=True)
",O(logn)
"

class Solution(object):
    def triangleType(self, nums):
        nums.sort()
        a, b, c = nums
        if a+b <= c:
            return ""none""
        if a == b == c:
            return ""equilateral""
        if a == b or b == c:
            return ""isosceles""
        return ""scalene""
",O(1)
"class Solution(object):
    def countCoveredBuildings(self, n, buildings):
        left = [n]*n
        right = [-1]*n
        up = [-1]*n
        down = [n]*n
        for x, y in buildings:
            x -= 1
            y -= 1
            left[y] = min(left[y], x)
            right[y] = max(right[y], x)
            up[x] = max(up[x], y)
            down[x] = min(down[x], y) 
        return sum(left[y-1] < x-1 < right[y-1] and down[x-1] < y-1 < up[x-1] for x, y in buildings)",O(n)
"class Solution2(object):
    def findDuplicate(self, nums):
        left, right = 1, len(nums) - 1

        while left <= right:
            mid = left + (right - left) / 2
            count = 0
            for num in nums:
                if num <= mid:
                    count += 1
            if count > mid:
                right = mid - 1
            else:
                left = mid + 1
        return left",O(nlogn)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

import random
import time
random.seed( int(time.time()) )

bb = random.randint(0, 2**30-1)

hat1 = 0
hat2 = 0
lastresult = None
for i in range(29, -1, -1):
    g1 = hat1 + (1<<i)
    g2 = hat2 + (1<<i)

    if lastresult is None:
        print('?',hat1^ bb,hat2)
        t1 = int(input())
    else:
        t1 = lastresult
    if t1!=0:
        print('?',g1^ bb,g2)
        t2 = int(input())
        if t1!=t2:
            if t1==1:
                hat1+= (1<<i)
            else:
                hat2+= (1<<i)
            lastresult = None
            continue
    lastresult = t1
    print('?',g1^ bb,hat2)
    t3 = int(input())
    if t3==1:
        pass
    else:
        hat1+= (1<<i)
        hat2+= (1<<i)

print('!', hat1^bb% (2**30), hat2)
",O(1)
"d = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"", ""orange"":""Soul"", ""red"":""Reality"", ""yellow"":""Mind""}
s = set()
n = int(input())
for _ in range(n):
	w = input()
	s.add(w)
print(6 - n)
for (key, value) in d.items():
	if key not in s:
		print(value)
",O(1)
"n = int(input())
b = list(map(int, input().split()))
a = [0] * (2 * (len(b)))
a[-1] = b[0]
for i in range(1, len(b)):
    if b[i] - a[i - 1] <= a[-i]:
        a[i] = a[i - 1]
        a[-i - 1] = b[i] - a[i - 1]
    else:
        a[-i - 1] = a[-i]
        a[i] = b[i] - a[-i - 1]
print(*a)
",O(n)
"class Solution(object):
    def findDuplicate(self, nums):
        slow = nums[0]
        fast = nums[nums[0]]
        while slow != fast:
            slow = nums[slow]
            fast = nums[nums[fast]]

        fast = 0
        while slow != fast:
            slow = nums[slow]
            fast = nums[fast]
        return slow",O(n)
"from sys import stdin, stdout
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))

for _ in range(1):
    sa=sorted(input(), reverse=True)
    na=len(sa)
    sb=input()
    nb=len(sb)
    if nb>na:
        print(''.join(sa))
        continue
    ans=''
    while sa:
        for i in range(len(sa)):
            new=ans+sa[i]+''.join(sorted(sa[:i]+sa[i+1:]))
            if int(new)<=int(sb):
                ans+=sa[i]
                sa.pop(i)
                break
    print(ans)",O(n ^ 3)
"class Solution(object):
    def flatten(self, root):
        self.flattenRecu(root, None)

    def flattenRecu(self, root, list_head):
        if root:
            list_head = self.flattenRecu(root.right, list_head)
            list_head = self.flattenRecu(root.left, list_head)
            root.right = list_head
            root.left = None
            return root
        else:
            return list_head

",O(n)
"class Solution:
    def reverseBits(self, n: int) -> int:
        res = n
        res = (res >> 16) | (res << 16) & 0xFFFFFFFF
        res = ((res & 0xff00ff00) >> 8) | ((res & 0x00ff00ff) << 8)
        res = ((res & 0xf0f0f0f0) >> 4) | ((res & 0x0f0f0f0f) << 4)
        res = ((res & 0xcccccccc) >> 2) | ((res & 0x33333333) << 2)
        res = ((res & 0xaaaaaaaa) >> 1) | ((res & 0x55555555) << 1)
        return res & 0xFFFFFFFF
",O(1)
"import sys
import bisect
from bisect import bisect_left as lb
input_=lambda: sys.stdin.readline().strip(""\r\n"")
from math import log
from math import gcd
from math import atan2,acos
from random import randint
sa=lambda :input_()
sb=lambda:int(input_())
sc=lambda:input_().split()
sd=lambda:list(map(int,input_().split()))
sflo=lambda:list(map(float,input_().split()))
se=lambda:float(input_())
sf=lambda:list(input_())
flsh=lambda: sys.stdout.flush()

mod=10**9+7
mod1=998244353
gp=[]
cost=[]
dp=[]
mx=[]
ans1=[]
ans2=[]
special=[]
specnode=[]
a=0
kthpar=[]
def dfs(root,par):
    if par!=-1:
        dp[root]=dp[par]+1
    for i in range(1,20):
        if kthpar[root][i-1]!=-1:
            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]
    for child in gp[root]:
        if child==par:continue
        kthpar[child][0]=root
        dfs(child,root)
ans=0
def setting(s):
    if s=='0':
        return -1
    i=len(s)-1
    cc=0
    while(i>=0 and s[i]=='0'):
        cc+=1
        i-=1
    return cc
def hnbhai(tc):
    n,q=sd()
    up=n+1
    x=len(bin(n)[2:])-1
    for i in range(q):
        v=sb()
        s=sa()
        for j in s:
            temp=bin(v)[2:]
            abe=setting(temp)

            if j==""U"":
                if abe>=x:
                    continue
                p=v+(1<<(abe))
                n=v-(1<<(abe))
                x1=setting(bin(p)[2:])

                x2=setting(bin(n)[2:])
                if x1==abe+1:
                    v=p
                else:
                    v=n
            elif j==""L"":
                if abe<=0:
                    continue
                v=v-(1<<(abe-1))

            else:
                if abe<=0:
                    continue
                v=v+(1<<(abe-1))
        print(v)
for _ in range(1):
    hnbhai(_+1)
",np
"n, k = [int(x) for x in input().split()]

ps = [int(x) for x in input().split()]

mapping = [-1 for _ in range(256)]

res = []
for p in ps:
    if mapping[p] == -1:
        j = p - k + 1
        while j < 0 or (mapping[j] != -1 and mapping[j] + k <= p):
            j += 1
        for i in range(j, p+1):
            mapping[i] = j

    res.append(mapping[p])
print("" "".join(map(str, res)))
",O(n ^ 2)
"from sys import maxsize, stdout, stdin,stderr
mod = int(1e9+7)
import sys
def I(): return int(stdin.readline())
def lint(): return [int(x) for x in stdin.readline().split()]
def S(): return input().strip()
def grid(r, c): return [lint() for i in range(r)]
from collections import defaultdict, Counter, deque
import math
import heapq
from heapq import heappop , heappush
import bisect
from itertools import groupby
def gcd(a,b):
    while b:
        a %= b
        tmp = a
        a = b
        b = tmp

    return a

def lcm(a,b):
    return a  // gcd(a, b) * b

def check_prime(n):
    for i in range(2, int(n ** (1 / 2)) + 1):
        if not n % i:
            return False
    return True
def Bs(a, x):
    i=0
    j=0
    left = 1
    right = x
    flag=False
    while left<right:

        mi = (left+right)//2

        if a[mi]<=x:
            left = mi+1
            i+=1

        else:

            right = mi
            j+=1

    if left>0 and a[left-1]==x:
        return i-1, j
    else:
        return -1, -1
def nCr(n, r):

    return (fact(n) // (fact(r)
                * fact(n - r)))

def fact(n):

    res = 1

    for i in range(2, n+1):
        res = res * i

    return res
def primefactors(n):
    num=0

    while n % 2 == 0:
        num+=1
        n = n / 2

    for i in range(3,int(math.sqrt(n))+1,2):

        while n % i== 0:
            num+=1
            n = n // i

    if n > 2:
        num+=1
    return num

def ask(a):
    print('? {}'.format(a),flush=True)
    n=I()

    return n

def dfs(i,p):

    a,tmp=0,0
    for j in d[i]:
        if j!=p:
            a+=1
            tmp+=dfs(j,i)

    if a==0:
        return 0

    return tmp/a + 1
def primeFactors(n):
    l=[]

    while n % 2 == 0:
        l.append(2)
        n = n // 2

    if n > 2:
        l.append(n)
    return l
a = sorted(input())
b = int(input())
a = a[::-1]
p = ''
cnt = [0]*10

while a :
    for i, d in enumerate(a):
        n = p + d + """".join(sorted(a[:i]+a[i+1:]))

        if int(n) <= b :
            p += d
            a.pop(i)

            break

print(p)
",O(n ^ 3)
"class Solution2(object):
    def rotate(self, nums, k):
        def apply_cycle_permutation(k, offset, cycle_len, nums):
            tmp = nums[offset]
            for i in range(1, cycle_len):
                nums[(offset + i * k) % len(nums)], tmp = tmp, nums[(offset + i * k) % len(nums)]
            nums[offset] = tmp

        k %= len(nums)
        num_cycles = gcd(len(nums), k)
        cycle_len = len(nums) / num_cycles
        for i in range(num_cycles):
            apply_cycle_permutation(k, i, cycle_len, nums)",O(n)
"from itertools import permutations,combinations
from math import factorial
word1 = list(map(str,input()))
word2 = list(map(str,input()))
expected = 0
for i in word1:
    if i=='+':
        expected+=1
    else:
        expected-=1
blank = 0
for i in word2:
    if i=='+':
        expected-=1
    elif i=='-':
        expected+=1
    else:
        blank+=1
if abs(expected)>blank:
    print(float(0))
elif blank==0:
    if expected==0:
        print(1)
    else:
        print(0)
else:
    total = 2**blank
    if expected==blank-1:
        print(float(0))
    else:
        f = (blank-expected)//2
        if expected>0:
            a,b = expected+f,f
        elif expected<0:
            a,b = expected+f,f
        else:
            a,b = f,f
        ans = factorial(a+b)/(factorial(a))
        ans = ans/factorial(b)
        ans = ans/total
        print(ans)",np
"from math import factorial as fact
s=input()
t=input()
pos=s.count('+')-t.count('+')
neg=s.count('-')-t.count('-')
que=t.count('?')
if pos<0 or neg<0:
    print(0)
else:
    print((fact(que)/(fact(pos)*fact(neg)))/(2**que))",np
"n, c = map(int, input().split())
res1 = [0] * 500001
res = 0
for ai in map(int, input().split()):
	res1[ai] = max(res1[ai], res1[c])
	res1[ai] += 1
	res = max(res, res1[ai] - res1[c])
print(res + res1[c])
",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):

    def __init__(self, root):
        self.__stk = []
        self.__traversalLeft(root)
        self.__vals = []
        self.__pos = -1

    def hasNext(self):
        return self.__pos+1 != len(self.__vals) or self.__stk

    def __next__(self):
        self.__pos += 1
        if self.__pos == len(self.__vals):
            node = self.__stk.pop()
            self.__traversalLeft(node.right)
            self.__vals.append(node.val)
        return self.__vals[self.__pos]
        
    def hasPrev(self):
        return self.__pos-1 >= 0

    def prev(self):
        self.__pos -= 1
        return self.__vals[self.__pos]
    
    def __traversalLeft(self, node):
        while node is not None:
            self.__stk.append(node)
            node = node.left",O(1)
"n = int(input())

lst = []
for x in range(n):
    (a, b) = map(int, input().split())
    lst.append((a, b))

def scal(x1, y1, x2, y2, x3, y3):
    if (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1) == 0:
        return True
    return False

def check():
    for x in range(n - 2):
        if len(s2) >= 3:
            if not scal(lst[s2[-3]][0], lst[s2[-3]][1], lst[s2[-2]][0], lst[s2[-2]][1], lst[s2[-1]][0], lst[s2[-1]][1]):
                return False
        if scal(lst[0][0], lst[0][1], lst[1][0], lst[1][1], lst[x + 2][0], lst[x + 2][1]):
            s1.append(x + 2)
        else:
            s2.append(x + 2)
    if len(s2) >= 3:
        if not scal(lst[s2[-3]][0], lst[s2[-3]][1], lst[s2[-2]][0], lst[s2[-2]][1], lst[s2[-1]][0], lst[s2[-1]][1]):
            return False
    return True

flag = True

if n >= 5:
    s1 = []
    s2 = []
    if not check():
        lst[1], lst[s2[0]] = lst[s2[0]], lst[1]
        x = s2[0]
        s1 = []
        s2 = []
        if not check():
            lst[0], lst[s2[0]] = lst[s2[0]], lst[0]
            s1 = []
            s2 = []
            if not check():
                flag = False

if flag:
    print(""YES"")
else:
    print(""NO"")
",O(nlogn)
"n, d, k = map(int, input().split())

if d+1 > n:
    print('NO')
    exit()

ans = []
dist = [0]*n
deg = [0]*n
for i in range(d+1):
    if i == 0 or i == d:
        deg[i] = 1
    else:
        deg[i] = 2
    if i != d:
        ans.append((i+1, i+2))
    dist[i] = max(i, d-i)

for i in range(n):
    if deg[i] > k:
        print('NO')
        exit()

from collections import deque
q = deque(list(range(d+1)))
cur = d+1
while q and cur < n:
    v = q.popleft()
    if dist[v] < d and deg[v] < k:
        deg[v] += 1
        dist[cur] = dist[v]+1
        deg[cur] = 1
        ans.append((v+1, cur+1))
        q.append(v)
        q.append(cur)
        cur += 1
    else:
        continue
if cur != n:
    print('NO')
else:
    print('YES')
    for i in range(len(ans)):
        print(*ans[i])
",O(n ^ 2)
"import sys
def ask(x,y,rev):
	if (rev==0):
		print(""? %d %d""%(x,y))
	else:
		print(""? %d %d""%(y,x))
	sys.stdout.flush()
	if (rev==1):
		return -int(input())
	else:
		return int(input())

comp=ask(0,0,0)
nowa=0
nowb=0
rev=0
for i in range(29,-1,-1):
	if (comp<0):
		rev^=1
		nowa,nowb=nowb,nowa
		comp=-comp
	if comp>=0:
		comp=ask(nowa|(1<<i),nowb|(1<<i),rev)
		if (comp<0):
			nowa|=1<<i
			comp=ask(nowa,nowb,rev)
		else:
			tmp=ask(nowa|(1<<i),nowb,rev)
			if (tmp<0):
				nowa|=1<<i
				nowb|=1<<i
if (rev==1):
	nowa,nowb=nowb,nowa
print(""! %d %d""%(nowa,nowb))
",O(1)
"class Solution(object):
    def countEven(self, num):
        def parity(x):
            result = 0
            while x:
                result += x%10
                x //= 10
            return result%2

        return (num-parity(num))//2",O(logn)
"
import bisect


class Solution(object):
    def lengthOfLIS(self, nums):
        LIS = []
        def insert(target):
            left = bisect.bisect_left(LIS, target)
            if left == len(LIS):
                LIS.append(target)
            else:
                LIS[left] = target
    
        for num in nums:
            insert(num)
        return len(LIS)


",O(nlogn)
"from collections import defaultdict

def f(b,d):
    fi = int(b[0])
    if len(b)==1:
        j=fi
        while(j>=0):
            if d[j]:
                return str(j)
            j+=-1

        return """"

    fi=int(b[0])
    s=""""
    if d[fi]>0:
        d1=defaultdict(lambda:0)
        for j in d:
            d1[j]=d[j]
        d1[fi]+=-1
        s=f(b[1:],d1)

    if s!="""":
        return str(fi)+s

    else:
        s1=""""
        j=fi-1
        while(j>=0):
            if d[j]>0:
                s1+=str(j)
                d[j]+=-1
                break
            j+=-1
        if s1=="""":
            return """"
        else:
            j=9
            while(j>=0):
                if d[j]==0:
                    j+=-1

                else:
                    s1+=str(j)
                    d[j]+=-1

            return s1

a=input()
b=input()
d=defaultdict(lambda:0)
res=[]
for j in a:
    d[int(j)]+=1
    res.append(int(j))
res.sort(reverse=True)
for j in range(len(a)):
    res[j]=str(res[j])
if len(b)>len(a):
    print("""".join(res))

else:
    print(f(b,d))
",O(n ^ 3)
"n,m=list(map(int,input().split()))
for i in range(1,n+1):
    j=i*(i+1)//2

    if j>=m:
        if j==m and i==n:
            print(0)
            break
        else:
            t=n-i
            if j-t==m:
                print(t)
                break
            elif j-t<m:

                continue
",O(logn)
"n,m=map(int,input().split())
M=[['0' for x in range(m)] for y in range(n)]
for a in range(n):
    i=input()
    for b in range(len(i)):

        M[a][b]=i[b]
start=[]
end=[]
for a in range(n):
    for b in range(m):
        if M[a][b]=='B':
            if not start:

                start.append(a+1)
                start.append(b+1)
            else:

                end.clear()
                end.append(a+1)
                end.append(b+1)

if not start or not end:
    print(start[0],start[1])
else:
    mid1=int((end[0]+start[0])/2)
    mid2=int((end[1]+start[1])/2)
    print(mid1,mid2)
",O(n ^ 2)
"n=int(input())
lst = list(map(int, input().strip().split(' ')))
c=0
while(len(lst)!=0):
    p=lst[0]
    del lst[0]
    i=lst.index(p)
    c+=i
    del lst[i]
print(c)
",O(n ^ 2)
"n, k = map(int, input().split())
P = map(int, input().split())

parent = list(range(256))
sz = [1] * 256
def rt(x):
    if x != parent[x]:
        parent[x] = rt(parent[x])
    return parent[x]

def u(rx, ry):
    parent[ry] = rx
    sz[rx] += sz[ry]

ans = [0] * n
for i, p in enumerate(P):
    rx = rt(p)
    while rx > 0 and sz[rx] + sz[rt(rx - 1)] <= k:
        u(rt(rx - 1), rx)
        rx = rt(p)
    ans[i] = rt(p)
print(' '.join(map(str, ans)))
",O(n ^ 2)
"class Solution(object):
    def maxDistance(self, colors):
        result = 0
        for i, x in enumerate(colors):
            if x != colors[0]:
                result = max(result, i)
            if x != colors[-1]:
                result = max(result, len(colors)-1-i)
        return result",O(n)
"n,c = map(int,input().split("" ""))
nums = list(map(int,input().split("" "")))

cPast = 0
countC = 0

for value in nums:
	if value == c:
		countC += 1

def sawC(groupsList):
	for key,groups in groupsList.items():
		if groups[-1] < 0:
			groups[-1] -= 1
		else:
			groups += [-1]
	return groupsList

solution = countC

groupsList = {}
for num in nums:
	if num == c:
		groupsList = sawC(groupsList)
	elif num in groupsList.keys():
		if groupsList[num][-1] > 0:
			groupsList[num][-1] += 1
		else:
			groupsList[num] += [1]
	else:
		groupsList[num] = [1]

for key,groups in groupsList.items():

	maxDiff = 1
	currDiff = 0
	newDiff = 0
	for group in groups:
		currDiff += group
		if group > currDiff:
			currDiff = group
		if currDiff > maxDiff:
			maxDiff = currDiff
	if maxDiff + countC > solution:
		solution = countC + maxDiff
print(solution)
",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import Counter

import heapq

from collections import Counter

from bisect import  bisect_right

import bisect

def find(x,y,z):
    if dp[x][y][z]!=-1:
        return dp[x][y][z]
    ans=0
    if x<r and y<g:
        ans=max(ans,rl[x]*gl[y]+find(x+1,y+1,z))
    if x<r and z<b:
        ans=max(ans,rl[x]*bl[z]+find(x+1,y,z+1))
    if y<g and z<b:
        ans=max(ans,gl[y]*bl[z]+find(x,y+1,z+1))

    dp[x][y][z]=ans
    return ans
r,g,b = map(int, input().split())
rl=sorted(list(map(int, input().split())),reverse=True)
gl=sorted(list(map(int, input().split())),reverse=True)
bl=sorted(list(map(int, input().split())),reverse=True)
dp=[[[-1]*(b+1) for i in range(g+1)]for i in range(r+1)]
print(find(0,0,0))
",O(n ^ 3)
"class Solution2(object):
    def numOfUnplacedFruits(self, fruits, baskets):
        result = 0
        for x in fruits:
            i = next((i for i in range(len(baskets)) if baskets[i] >= x), -1)
            if i ==-1:
                result += 1
            else:
                baskets[i] = 0
        return result",O(n ^ 2)
"def func(mid,s):
    p=0
    q=mid
    while (mid>0):
        p+=mid%10
        mid=mid//10

    if (q-p)>=s:
        return True
    else:
        return False
n,s=map(int,input().split())
do=1
up=10**18
an=n+1
while (up>=do):
    mid=(up+do)//2
    if func(mid,s):
        up=mid-1
        an=mid
    else:
        do=mid+1
if an>n:
    print(0)
else:
    print(n-an+1)",O(logn)
"a = list(map(int,input().split()))
b = list(map(int,input().split()))
c = list(map(int,input().split()))
a,b,c= sorted([a,b,c])

path = []
for i in range(min(a[1],b[1],c[1]) , max(a[1],b[1],c[1]) + 1):
    path.append((b[0],i))
for i in range(a[0],b[0]+1):
    path.append((i,a[1]))
for i in range(b[0],c[0]+1):
    path.append((i,c[1]))

print(len(set(path)))
for i in set(path):
    print(*i)
",O(1)
"def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]

n = INT()
arr = LIST()

i = 0
p = []
while 2**i <= 10**18:
    p.append(2**i)
    i = i+1

d = {}
s1= set()
for i in arr:
    s1.add(i)
    if i not in d :
        d[i] = 1
    else:
        d[i]+=1

s2 = set()
for i in s1 :
    flag = False
    for j in p :
        x = j - i
        k = -1
        try:
            k = d[x]
        except :
            k = -1
        if k != -1:
            if x == i and d[i] == 1 :
                continue
            else:
                flag = True
                break
    if flag == False:
        s2.add(i)

res = 0
for i in s2 :
    res+=d[i]
print(res)
",O(nlogn)
"import collections


class Solution(object):
    def leastBricks(self, wall):
        widths = collections.defaultdict(int)
        result = len(wall)
        for row in wall:
            width = 0
            for i in range(len(row)-1):
                width += row[i]
                widths[width] += 1
                result = min(result, len(wall) - widths[width])
        return result",O(n)
"def main():
    n = int(input())

    s = []

    for i in range(n):
        s.append(input())

    for i in s:
        for j in s:
            if (i not in j) and (j not in i):
                print('NO')
                return

    print('YES')
    s = sorted(s, key=lambda x : len(x))
    for pal in s:
        print(pal)

main()
",O(nlogn)
"from sys import stdin
from collections import deque
n=int(stdin.readline())
g=dict()
for i in range(n-1):
    a,b=map(int,stdin.readline().strip().split())
    g.setdefault(a, set()).add(b)
    g.setdefault(b, set()).add(a)
a=[int(x) for x in stdin.readline().strip().split()]
ans = True
if n > 1 and a[0] == 1:
    q=deque()
    m=[0]*(n+1)
    q.append(1)
    m[1]=1
    right=1
    while len(q) > 0 and ans:
        first = q.popleft()
        cnt = 0
        for v in g[first]:
            if m[v] == 0:
                cnt += 1
        for i in range(right, right+cnt):
            if m[a[i]] == 0 and a[i] in g[first]:
                m[a[i]] = 1
                q.append(a[i])
            else:
                ans = False
                break
        right += cnt
else:
    ans = a[0] == 1
if ans:
    print(""Yes"")
else:
    print(""No"")
",O(n)
"cnt = [0]*2
class Solution(object):
    def countKReducibleNumbers(self, s, k):
        MOD = 10**9+7
        def popcount(x):
            return bin(x).count('1')

        while len(s)-1 >= len(cnt): 
            cnt.append(cnt[popcount(len(cnt))]+1)
        dp = [0]*len(s)
        curr = 0
        for i in range(len(s)):
            for j in reversed(list(range(i))):
                dp[j+1] = (dp[j+1]+dp[j])%MOD
            if s[i] != '1':
                continue
            dp[curr] = (dp[curr]+1)%MOD
            curr += 1
        return reduce(lambda accu, x: (accu+x)%MOD, (dp[i] for i in range(1, len(s)) if cnt[i] < k), 0)",O(n ^ 2)
"
import collections



class Solution(object):
    def destroyTargets(self, nums, space):
        cnt = collections.Counter(x%space for x in nums)
        mx = max(cnt.values())
        return min(x for x in nums if cnt[x%space] == mx)
",O(n)
"import collections
import itertools


class Solution(object):
    def movesToChessboard(self, board):
        N = len(board)
        result = 0
        for count in (collections.Counter(list(map(tuple, board))), \
                      collections.Counter(zip(*board))):
            if len(count) != 2 or \
               sorted(count.values()) != [N/2, (N+1)/2]:
                return -1

            seq1, seq2 = count
            if any(x == y for x, y in zip(seq1, seq2)):
                return -1
            begins = [int(seq1.count(1) * 2 > N)] if N%2 else [0, 1]
            result += min(sum(int(i%2 != v) for i, v in enumerate(seq1, begin)) \
                          for begin in begins) / 2
        return result",O(n ^ 2)
"v = input().split()
n = int(v[0])
k = int(v[1])

s = input()
ap = 0

i = 1
while i < n:
    if s[:i] == s[-i:]:
        ap = i

    i += 1

print(s + s[ap:]*(k-1))
",O(n ^ 2)
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math

alphabets = list('abcdefghijklmnopqrstuvwxyz')

def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))
def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def power_set(L):

    cardinality=len(L)
    n=2 ** cardinality
    powerset = []

    for i in range(n):
        a=bin(i)[2:]
        subset=[]
        for j in range(len(a)):
            if a[-j-1]=='1':
                subset.append(L[j])
        powerset.append(subset)
    powerset_orderred=[]
    for k in range(cardinality+1):
        for w in powerset:
            if len(w)==k:
                powerset_orderred.append(w)

    return powerset_orderred
def fastPlrintNextLines(a):

    print('\n'.join(map(str,a)))

def sortByFirstAndSecond(A):
    A = sorted(A,key = lambda x:x[0])
    A = sorted(A,key = lambda x:x[1])
    return list(A)

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"")
else:
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

def solve():
    n,k = li()
    p = li()
    groups = [-1]*256
    newar = [-1]*n
    for i in range(n):

        color  = p[i]
        j = color

        if groups[color]!=-1:
            newar[i]=groups[color]
            continue

        while(j>0) :
            if groups[j]!=-1:
                break
            if color-j+1==k:
                break
            j-=1

        if groups[j]==-1:
            for h in range(j,color+1):
                groups[h]=j
            newar[i]=groups[color]
            continue
        if color-j<k:
            alreadySize = j-groups[j]+1

            if alreadySize+color-j<=k:
                for h in range(j+1,color+1):
                    groups[h]=groups[h-1]
                newar[i]=groups[color]
                continue
            else:
                for h in range(j+1,color+1):
                    groups[h]=j+1
                newar[i]=groups[color]
                continue
        else:
            for h in range(j+1,color+1):
                groups[h]=j+1
            newar[i]=groups[color]
            continue
    print(*newar)

t = 1

for _ in range(t):
    solve()
",O(n ^ 2)
"from collections import defaultdict
import sys
import bisect
input=sys.stdin.readline

n,m=map(int,input().split())
a=[int(i) for i in input().split()if i!='\n']
rem=[[] for i in range(m)]
req=n//m
ans=0
for i in range(n):
    rem[a[i]%m].append([a[i],i])
ind=m-1
for i in range(m):
    size=len(rem[i])
    if size>req:
        ind=i
    if size<req:
        ok=False
        for j in range(ind,ind-m,-1):
            while len(rem[j])>req:
                pop,_=rem[j].pop()
                rem[i].append([pop+(i-j)%m,_])
                if len(rem[i])==req:
                    ok=True
                    break
            if ok:
                break
            ind-=1

out=[0]*(n)
for i in rem:
    for j in i:
        out[j[1]]=j[0]
print(sum(out)-sum(a))
out=' '.join(map(str,out))
print(out)
",O(n)
"def main():
    n, m = map(int,raw_input().split())
    r = []
    rappend = r.append
    for i in range(1, (n >> 1) + 1):
        for j in range(1, m + 1):
            rappend(str(i) + ' ' + str(j))
            rappend(str(n + 1 - i) + ' ' + str(m + 1 - j))
    if n & 1:
        for i in range(1, (m >> 1) + 1):
            rappend(str((n + 1) >> 1) + ' ' + str(i))
            rappend(str((n + 1) >> 1) + ' ' + str(m + 1 - i))
        if m & 1:
            rappend(str((n + 1) >> 1) + ' ' + str((m + 1) >> 1))
    print('\n'.join(r))
main()",O(n ^ 2)
"class Solution(object):
    def isValidPalindrome(self, s, k):
        if s == s[::-1]: 
            return True

        dp = [[1] * len(s) for _ in range(2)]
        for i in reversed(range(len(s))):
            for j in range(i+1, len(s)):
                if s[i] == s[j]:
                    dp[i%2][j] = 2 + dp[(i+1)%2][j-1] if i+1 <= j-1 else 2
                else:
                    dp[i%2][j] = max(dp[(i+1)%2][j], dp[i%2][j-1])
        return len(s) <= k + dp[0][-1]",O(n ^ 2)
"n, l, r, x = map(int, input().split())
C = sorted(list(map(int, input().split())))
ANS = 0
for i in range(2 ** n):
    s = bin(i)[2:]
    s = '0' * (n - len(s)) + s
    L = []
    for j in range(n):
        if s[j] == '1':
            L.append(C[j])
    if len(L) < 2 or not (l <= sum(L) <= r) or L[-1] - L[0] < x:
        continue
    ANS += 1
print(ANS)
",np
"n, k = [int(i) for i in input().split()]
d = dict()
d[0] = 1
x = 0
for i in [int(i) for i in input().split()]:
    x ^= i
    v = min(x, (1 << k) - x - 1)
    if v not in d.keys():
        d[v] = 0
    d[v] += 1
ans = 0
for k, v in d.items():
    c1 = v // 2
    c2 = v - c1
    ans += c1 * (c1 - 1) // 2 + c2 * (c2 - 1) // 2
print(n * (n - 1) // 2 + n - ans)
",O(n)
"f=input
D,E={},[eval(f())for _ in range(int(f()))]
for e in E:D[e]=D.get(e,0)+1
for e in E:print(D[e])",O(n)
"digit = int(input())

if int(digit) <= 9:
    print(digit)
    exit()

start_range = 1
end_range = 9

power = 1
digit_count = 2
while not (start_range <= digit and digit <= end_range):
    start_range = end_range + 1
    end_range = 9 * 10**power * digit_count + start_range - 1
    power += 1
    digit_count += 1

offset_number = (digit - start_range) // (digit_count - 1)

number = str(10**(power - 1) + offset_number)

offset_digit = (digit - start_range) % (digit_count - 1)

print(f""{number[offset_digit]}"")
",O(logn)
"class Solution(object):
    def maxMatrixSum(self, matrix):
        abs_total = sum(abs(x) for row in matrix for x in row)
        min_abs_val = min(abs(x) for row in matrix for x in row)
        neg_cnt = sum(x < 0 for row in matrix for x in row)
        return abs_total if neg_cnt%2 == 0 else abs_total - 2*min_abs_val",O(n ^ 2)
"s=[list(input()) for i in range(2)]
n=len(s[0])
cnt=0
for i in range(n-1):
  if s[0][i]==s[1][i]==s[0][i+1]==""0"":
    cnt+=1
    s[0][i]=s[1][i]=s[0][i+1]=""X""
  elif s[0][i]==s[1][i]==s[1][i+1]==""0"":
    cnt+=1
    s[0][i]=s[1][i]=s[1][i+1]=""X""
  elif s[0][i]==s[1][i+1]==s[0][i+1]==""0"":
    cnt+=1
    s[0][i]=s[1][i+1]=s[0][i+1]=""X""
  elif s[0][i+1]==s[1][i]==s[1][i+1]==""0"":
    cnt+=1
    s[0][i+1]=s[1][i]=s[1][i+1]=""X""
print(cnt)",O(1)
"R = lambda: map(int, input().split())
n, m, k = R()
cls = [list(i for i, x in enumerate(map(int, input())) if x) for _ in range(n)]
dp = [[n * m] * (k + 1) for i in range(n + 1)]
dp.append([0] * (k + 1))
for i in range(n):
    row = cls[i]
    c2l = [m + 1] * (m + 1)
    c2l[0] = row[-1] - row[0] + 1 if row else 0
    c2l[len(row)] = 0
    for r in range(len(row)):
        for l in range(r + 1):
            c2l[len(row) - (r - l + 1)] = min(c2l[len(row) - (r - l + 1)], row[r] - row[l] + 1)
    for j in range(k + 1):
        for c, l in enumerate(c2l):
            if j + c <= k and l < m + 1:
                dp[i][j] = min(dp[i][j], dp[i - 1][j + c] + l)
print(min(dp[n - 1]))",O(n ^ 3)
"class Solution(object):
    def findMaxLength(self, nums):
        result, count = 0, 0
        lookup = {0: -1}
        for i, num in enumerate(nums):
            count += 1 if num == 1 else -1
            if count in lookup:
                result = max(result, i - lookup[count])
            else:
                lookup[count] = i

        return result",O(n)
"n, m=[int(k) for k in input().split()]
res=[]
for j in range(n//2):
    for k in range(m):
        res.append(str(j+1)+"" ""+str(k+1))
        res.append(str(n-j)+"" ""+str(m-k))
if n%2:
    for j in range(m//2):
        res.append(f""{n//2+1} {j+1}"")
        res.append(f""{n//2+1} {m-j}"")
    if m%2:
        res.append(f""{n//2+1} {m//2+1}"")
print(""\n"".join(res))",O(n ^ 2)
"try:
    n,k=list(map(int,input().split("" "")))
    s=input()
    s=list(s)
    if len(s)>k:
        p='('*(k//2)
        p=list(p)
        c=0
        for i in range(0,len(s)):
            if s[i]==')':
                p.insert(i,')')
                c+=1
                if c==k//2:
                    break
        print("""".join(p))

    else:
        print("""".join(s))

except:
    pass",O(n)
"input = __import__('sys').stdin.readline

n,m,k = map(int, input().split())
hor = [[int(x) for x in input().split()] for _ in ' ' * n]
ver = [[int(x) for x in input().split()] for _ in ' ' * (n - 1)]

if k % 2:
  for i in ' ' * n: print('-1 ' * m)
  exit()

mtx_old = [[0] * m for _ in ' ' * n]

def neighbours(x, y):
  a = 1e18
  b = 1e18
  c = 1e18
  d = 1e18
  if x > 0: a = hor[y][x - 1] * 2 + mtx_old[y][x - 1]
  if x < m - 1: b = hor[y][x] * 2 + mtx_old[y][x + 1]
  if y > 0: c = ver[y - 1][x] * 2 + mtx_old[y - 1][x]
  if y < n - 1: d = ver[y][x] * 2 + mtx_old[y + 1][x]
  return min(a, b, c, d)

for i in range(k // 2):
  mtx_new = [[0] * m for _ in ' ' * n]

  for x in range(m):
    for y in range(n):
      mtx_new[y][x] = neighbours(x, y)

  mtx_old = mtx_new

for row in mtx_old: print(*row)",O(n ^ 3)
"import sys
input = sys.stdin.readline

testcase=int(input())
T=[list(map(int,input().split())) for i in range(testcase*3)]

def COMMON(WHITE,BLACK):
    x1,y1,x2,y2=WHITE
    x3,y3,x4,y4=BLACK
    return (max(x1,x3),max(y1,y3),min(x2,x4),min(y2,y4))

def BtoW(WHITE):
    x1,y1,x2,y2=WHITE
    if (x1+y1)%2==0:
        return (x2-x1+1)*(y2-y1+1)//2
    else:
        return (x2-x1+1)*(y2-y1+1)-(x2-x1+1)*(y2-y1+1)//2

def WtoB(BLACK):
    x1,y1,x2,y2=BLACK
    if (x1+y1)%2==1:
        return (x2-x1+1)*(y2-y1+1)//2
    else:
        return (x2-x1+1)*(y2-y1+1)-(x2-x1+1)*(y2-y1+1)//2

for test in range(testcase):
    n,m=T[test*3]
    WHITE=T[test*3+1]
    BLACK=T[test*3+2]

    ANSB=n*m//2
    ANSW=n*m-ANSB

    WHITE2=COMMON(WHITE,BLACK)

    k=BtoW(WHITE)
    ANSB-=k
    ANSW+=k

    if WHITE2[0]>WHITE2[2] or WHITE2[1]>WHITE2[3]:
        True
    else:
        l=BtoW(WHITE2)
        ANSB+=l
        ANSW-=l

    m=WtoB(BLACK)

    ANSB+=m
    ANSW-=m

    print(ANSW,ANSB)
",O(1)
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush

from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time

starttime = time.time()

mod = int(pow(10, 9) + 7)
mod2 = 998244353
def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]

try:

    sys.stdin = open(""input.txt"", ""r"")

except:
    pass
global ans
ans=0

def rec(i,j,k):
    if dp[i][j][k]!=-1:
        return dp[i][j][k]
    x1=x2=x3=0
    if i<R and j<G:
        x1=r[i]*g[j]+rec(i+1,j+1,k)
    if i<R and k<B:
        x2=r[i]*b[k]+rec(i+1,j,k+1)
    if j<G and k<B:
        x3=g[j]*b[k]+rec(i,j+1,k+1)
    dp[i][j][k]=max(x1,x2,x3)
    global ans
    ans=max(ans,dp[i][j][k])
    return dp[i][j][k]

for _ in range(1):
    R,G,B=L()
    r=L()
    g=L()
    b=L()
    r.sort(reverse=True)
    g.sort(reverse=True)
    b.sort(reverse=True)
    dp=[[[-1 for k in range(B+1)] for j in range(G+1)] for i in range(R+1)]
    rec(0,0,0)
    print(ans)

endtime = time.time()
",O(n ^ 3)
"n, k = map(int, input().split())
c = 1
while c * (c + 1) // 2 < k:
    c += 1
while c * (c + 1) // 2 - (n - c) != k:
    c += 1
print(n - c)
",O(n)
"import sys
def countR(ip):
    c=0
    for i in ip:
        if(i=='R'):
            c+=1
    return c

def countB(ip):
    c=0
    for i in ip:
        if(i=='B'):
            c+=1
    return c

def countG(ip):
    c=0
    for i in ip:
        if(i=='G'):
            c+=1
    return c

t=int(sys.stdin.readline())
x='RGB'*680
y='GBR'*680
z='BRG'*680
for i in range(t):
    n,k=list(map(int,sys.stdin.readline().strip().split()))
    a=sys.stdin.readline().strip()
    xk=x[:k]
    yk=y[:k]
    zk=z[:k]

    op=2001
    for j in range(n-k+1):
        b=a[j:j+k]

        xd=0
        yd=0
        zd=0

        for jj in range(len(b)):
            if(b[jj]!=xk[jj]):
                xd+=1
            if(b[jj]!=yk[jj]):
                yd+=1
            if(b[jj]!=zk[jj]):
                zd+=1

        op=min(op,xd,yd,zd)
    print(op)
",O(n ^ 2)
"class Solution(object):
    def depthSum(self, nestedList):
        def depthSumHelper(nestedList, depth):
            res = 0
            for l in nestedList:
                if l.isInteger():
                    res += l.getInteger() * depth
                else:
                    res += depthSumHelper(l.getList(), depth + 1)
            return res
        return depthSumHelper(nestedList, 1)",O(n)
"n, k = list(map(int, input().split()))
arr = list(map(int, input().split()))

new_arr = []
for i in range(n - 1):
	new_arr.append(arr[i + 1] - arr[i])

new_arr.sort()
print(sum(new_arr[:n - k]))
",O(nlogn)
"T = int(input())
for ti in range(T):
    s, t = input().strip(), input().strip()
    N = len(t)
    for i in range(1, N+1):
        dp = [0]+[-1]*i
        for l, c in enumerate(s):
            for j in range(i, -1, -1):
                tmp = dp[j]
                if dp[j] != -1 and i + dp[j] < N and \
                   t[i + dp[j]] == c:
                    tmp = dp[j] + 1
                if j != 0 and t[j-1] == c:
                    tmp = max(tmp, dp[j-1])
                dp[j] = tmp
        if dp[i] == N-i:
            print(""YES"")
            break
    else:
        print(""NO"")
",O(n ^ 3)
"import collections


class Solution(object):
    def numRabbits(self, answers):
        count = collections.Counter(answers)
        return sum((((k+1)+v-1)//(k+1))*(k+1) for k, v in count.items())",O(n)
"from fractions import Fraction


class Solution(object):
    def isRationalEqual(self, S, T):
        def frac(S):
            if '.' not in S:
                return Fraction(int(S), 1)

            i = S.index('.')
            result = Fraction(int(S[:i]), 1)
            non_int_part = S[i+1:]
            if '(' not in non_int_part:
                if non_int_part:
                    result += Fraction(int(non_int_part), 10**len(non_int_part))
                return result

            i = non_int_part.index('(')
            if i:
                result += Fraction(int(non_int_part[:i]), 10**i)
            repeat_part = non_int_part[i+1:-1]
            result += Fraction(int(repeat_part), 10**i * (10**len(repeat_part)-1))
            return result

        return frac(S) == frac(T)",O(1)
"a,b = input().split()
x = int(a)
k = int(b)
mod = 10**9 + 7
if(x == 0 ):
	print(0)
elif( k == 0):
	print( (2*x)%mod )
else:
	print( (((pow(2,k,mod)*x - pow(2,k-1,mod))%mod)*2 + 3*mod + 1)%mod)",O(logn)
"import sys
I=sys.stdin.readlines()
N,M,K=map(int,I[0].split())
S=[I[i+1][:-1] for i in range(N)]
D=dict()
for i in range(N):
  D[S[i]]=i
T=[I[i+N+1].split() for i in range(M)]
for i in range(M):
  T[i][1]=int(T[i][1])-1
G=[[] for i in range(N)]
C=[0]*N
for i in range(M):
  for j in range(K):
    if S[T[i][1]][j]!='_' and S[T[i][1]][j]!=T[i][0][j]:
      print('NO')
      exit()
  for j in range(1<<K):
    t=''.join(['_' if j&(1<<k) else T[i][0][k] for k in range(K)])
    x=D.get(t,-1)
    if x!=-1 and x!=T[i][1]:
      G[T[i][1]].append(x)
      C[x]+=1
P=[]
Q=[]
F=[1]*N
for i in range(N):
  if C[i]==0 and F[i]:
    Q.append(i)
  while len(Q):
    v=Q.pop()
    F[v]=0
    P.append(v+1)
    for i in range(len(G[v])):
      C[G[v][i]]-=1
      if C[G[v][i]]==0:
        Q.append(G[v][i])
if len(P)==N:
  print('YES')
  print(*P)
else:
  print('NO')
",np
"def f(k):
    res = 1
    a = 2
    while k:
        if k % 2 == 1:
            res *= a
            k -= 1
        else:
            a *= a
            k //= 2
        res = res % (1000000007)
        a = a % (1000000007)
    return res

n, k = map(int, input().split())
if n == 0:
    print(0)
elif k == 0:
    print((n * 2) % 1000000007)
else:
    first = (2 * n - 1) % 1000000007
    first *= f(k)
    first = (first + 1) % 1000000007
    print(first)
",O(logn)
"a = list(input())
b = int(input())
a = sorted(a, reverse=True)
ans = ''
while len(a) > 0:
    for i in range(len(a)):
        tmp = ans + a[i] + ''.join(sorted(a[:i] + a[i + 1:]))
        if int(tmp) <= b:
            ans += a[i]
            a = a[:i] + a[i + 1:]
            break
print(ans)
",O(n ^ 3)
"from collections import defaultdict as dd, deque as dq
import math, string

import sys

def getInts():
    return [int(s) for s in input().split()]

def getInt():
    return int(input())

def getStrs():
    return [s for s in input().split()]

def getStr():
    return input()

def listStr():
    return list(input())

MOD = 10**9+7

def solve():
    N, K = getInts()
    x = (-3 + math.sqrt(9+8*(N+K)))//2
    return int(x*(x+1)//2 - K)

print(solve())",O(logn)
"t=1
for _ in range(t):
    n=int(input())
    l=list(map(int,input().split()))
    dp=[[0 for j in range(n)] for i in range(n)]
    for i in range(n):
        dp[0][i]=l[i]
    for i in range(1,n):
        for j in range(n-i):
            dp[i][j]=dp[i-1][j]^dp[i-1][j+1]

    for i in range(1,n):
        for j in range(n-i):
            dp[i][j]=max(dp[i][j],dp[i-1][j],dp[i-1][j+1])

    q=int(input())
    for __ in range(q):
        x,y=map(int,input().split())
        x-=1
        y-=1
        print(dp[y-x][x])",O(n ^ 2)
"def main():
    from sys import stdin, stdout

    def read():
        return stdin.readline().rstrip('\n')

    def read_array(sep=None, maxsplit=-1):
        return read().split(sep, maxsplit)

    def read_int():
        return int(read())

    def read_int_array(sep=None, maxsplit=-1):
        return [int(a) for a in read_array(sep, maxsplit)]

    def write(*args, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in args) + end)

    def write_array(array, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in array) + end)

    n = read_int()
    nums = read_int_array()
    out = nums[0]
    first = nums[0]
    for i in range(1, n):
        out = min(out, min(nums[i], first) // i)
    last = nums[-1]
    for i in range(n-2, 0, -1):
        out = min(out, min(nums[i], last) // (n-1 - i))
    write(out)

main()
",O(n)
"n = int(input())
l = list(map(int, input().split()))
odd = 0
for i in range(n):
    for j in range(i, n):
        if(l[i]>l[j]): odd ^= 1

m = int(input())
ans = []
for i in range(m):
    ll, r = map(int, input().split())
    k = r-ll+1
    if( (k*(k-1)/2) %2): odd ^= 1
    ans.append( ""odd"" if odd else ""even"")

print('\n'.join(ans))",O(n ^ 2)
"def solution(n, k):
    ret = [['.' for _ in range(n)] for _ in range(4)]
    if 1 == k & 1:
        ret[1][n >> 1] = '
        for i in range(1, n >> 1):
            if k < 2:
                break
            k -= 2
            ret[1][i] = '
            ret[1][n - 1 - i] = '
        for i in range(1, n >> 1):
            if k < 2:
                break
            k -= 2
            ret[2][i] = '
            ret[2][n - 1 - i] = '
    else:
        for i in range(1, n - 1):
            if k < 2:
                break
            k -= 2
            ret[1][i] = '
            ret[2][i] = '

    print('YES')
    for i in range(4):
        print(''.join(ret[i]))

solution(*map(int, input().split()))
",O(n)
"import sys

def chain_reaction(n, beacons):
    table = [0] * n

    for i in range(n):
        position = beacons[i][0]
        power = beacons[i][1]
        destroyed = 0
        r = position - power
        b = 0

        lo = 0
        hi = len(beacons) - 1
        while lo <= hi:
            mid = int(lo + (hi - lo) / 2)
            pos = beacons[mid][0]
            if beacons[mid][0] < r:
                lo = mid + 1
            else:
                hi = mid - 1

        destroyed += table[hi]

        destroyed += (i - (hi + 1))
        table[i] = destroyed

    max_val = max(table)
    ind = 0
    while ind < len(table):
        if table[ind] == max_val:
            break
        ind += 1
    cost = (len(table) - ind) + table[ind - 1]

    options = []
    for i in range(n):
        cost = (n - i) + table[i - 1]
        options.append(cost)
    min_cost = min(options)

    return min(table[n - 1], min_cost)

n = int(sys.stdin.readline().strip())
beacons = []
for i in range(n):
    a, b = [int(x) for x in sys.stdin.readline().strip().split("" "")]
    beacons.append((a, b))
beacons.sort()
print(chain_reaction(n, beacons))",O(n)
"import operator
from functools import reduce


class Solution2(object):
    def subtractProductAndSum(self, n):
        A = list(map(int, str(n)))
        return reduce(operator.mul, A) - sum(A)",O(logn)
"class Solution2(object):
    def deleteString(self, s):
        def getPrefix(pattern, start):
            prefix = [-1]*(len(pattern)-start)
            j = -1
            for i in range(1, len(pattern)-start):
                while j != -1 and pattern[start+j+1] != pattern[start+i]:
                    j = prefix[j]
                if pattern[start+j+1] == pattern[start+i]:
                    j += 1
                prefix[i] = j
            return prefix

        if all(x == s[0] for x in s):
            return len(s)
        dp = [1]*len(s) 
        for i in reversed(range(len(s)-1)):
            prefix = getPrefix(s, i) 
            for j in range(1, len(prefix), 2):
                if 2*(prefix[j]+1) == j+1:
                    dp[i] = max(dp[i], dp[i+(prefix[j]+1)]+1)
        return dp[0]",O(n ^ 2)
"class Solution(object):
    def hIndex(self, citations):
        n = len(citations)
        count = [0] * (n + 1)
        for x in citations:
            if x >= n:
                count[n] += 1
            else:
                count[x] += 1

        h = 0
        for i in reversed(range(0, n + 1)):
            h += count[i]
            if h >= i:
                return i
        return h",O(n)
"import sys
import math

n=int(input())
lista=[int(x) for x in input().strip().split()]
pap=lista[:]
pap.sort()
if(pap[-1]==1):
    pap[-1]=2
else:
    pap=[1]+pap[:-1]
for i in range(n):
    print(pap[i], end="" "")
",O(nlogn)
"class Solution(object):
    def singleNumber(self, nums):
        x_xor_y = reduce(operator.xor, nums)
        bit =  x_xor_y & -x_xor_y
        result = [0, 0]
        for i in nums:
            result[bool(i & bit)] ^= i
        return result",O(n)
"n,m=map(int,input().split())
s=[]
for i in range(n):
	s.append(list(map(str,input().strip())))

t=[]
for i in range(n):
	p=['.']*m
	t.append(p)

for i in range(1,n-1):
	for j in range(1,m-1):
		f=0
		if s[i-1][j-1]=='
			f=1
		if f==1:
			t[i-1][j-1]='
			t[i-1][j]='
			t[i-1][j+1]='
			t[i][j-1]='
			t[i][j+1]='
			t[i+1][j-1]='
			t[i+1][j]='
			t[i+1][j+1]='
f=1

for i in range(n):
	for j in range(m):
		if s[i][j]=='
			f=0
			break
	if f==0:
		break
if f==1:
	print(""YES"")
else:
	print(""NO"")
",O(n ^ 2)
"n, k = map(int, input().split())
arr = list(map(int, input().split()))

rsum = [0]
maxx = 0.0

for i in range(n): rsum.append(rsum[-1] + arr[i])

for ki in range(k, n+1):
    for i in range(n-ki+1):
        tot = 0

        avg = (rsum[i+ki] - rsum[i])/ki

        maxx = max(maxx, avg)
print(maxx)
",O(n ^ 2)
"import itertools

kol1 = {'+': 0, '-': 0, '?': 0}
kol2 = {'+': 0, '-': 0, '?': 0}

s1 = input()
s2 = input()

for s in s1:
    kol1[s] += 1

for s in s2:
    kol2[s] += 1

if (kol1['+']==kol2['+'] and kol1['-']==kol2['-']):
    print('1.0')
    exit()

mod1 = kol1['+'] - kol1['-']
mod2 = kol2['+'] - kol2['-']
mod3 = abs(mod2-mod1)
if (mod3>kol2['?']):
    print(0.0)
    exit()

list_comb = [1, -1]
sum_pos = 0
col = 0

for comb in itertools.product(list_comb, repeat=kol2['?']):
    if sum(comb)==mod3:
        sum_pos += 1
    col+=1

print(sum_pos/col)",np
"n = int(input().strip())
nums = list(map(int, input().strip().split()))
has_dups = (len(nums) > len(set(nums)))
mx = nums.index(max(nums))
if has_dups or nums[:mx+1]!=sorted(nums[:mx+1]) or nums[mx:]!=sorted(nums[mx:], reverse=True):
    print(""NO"")
else:
    print(""YES"")",O(nlogn)
"class Solution(object):
    def maxFrequency(self, nums, k):
        left = 0
        nums.sort()
        for right in range(len(nums)):
            k += nums[right]
            if k < nums[right]*(right-left+1):
                k -= nums[left]
                left += 1
        return right-left+1",O(nlogn)
"n = int(input())
A = list(map(int, input().split()))

INF = 10**3
dp = [[INF]*(n+1) for _ in range(n+1)]

val = [[0]*(n+1) for _ in range(n+1)]

for i in range(n):
    dp[i][i+1] = 1

for i in range(n):
    val[i][i+1] = A[i]

for d in range(2, n+1):
    for i in range(n+1-d):
        j = i+d
        for k in range(i+1, j):
            if dp[i][k] == 1 and dp[k][j] == 1 and val[i][k] == val[k][j]:
                dp[i][j] = min(dp[i][j], 1)
                val[i][j] = val[i][k]+1
            else:
                dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j])

print(dp[0][n])
",O(n ^ 3)
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque

n, k = map(int,input().split())
s = input()

def judge(needed):

    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0

    effect = [[inf]*(n+1) for j in range(k)]

    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
            effect[j][i] = min(effect[j][i+4-4],effect[j][i+3-3],inf)

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index])

        minstate[state] = minimum

    if minstate[-1]<=n:  return True
    return False

front = 0
rear = n//k+1

while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)

    if flag:
        front = mid + 1
    else:
        rear = mid

print(front-1)
",np
"import bisect
n=int(input())
s=list(map(int,input().split()))
c=list(map(int,input().split()))
ans=10**18
for mid in range(1,n-1):
  l1=[c[i] for i in range(mid) if s[i]<s[mid]]+[10**18]
  l2=[c[i] for i in range(mid+1,n) if s[i]>s[mid]]+[10**18]
  ans=min(ans,min(l1)+c[mid]+min(l2))
if ans>=10**18:
  print(-1)
else:
  print(ans)",O(n ^ 2)
"l,r = [int(i) for i in input().split()]
bitafter=-1;
for i in range(60,-1,-1):
    if(l&(1<<i)!=r&(1<<i)):
        bitafter = i
        break
res = 0
while(bitafter>=0):
    res+=1<<bitafter
    bitafter-=1
print(res)",O(logn)
"def solution():
    v = list()

    n = int(input())
    for _ in range(n):
        s = input()
        p = s.find('C')

        if s[0] == 'R' and s[1].isdigit() and p > 1:
            r = int(s[1:p])
            c = int(s[(p + 1):])

            v.clear()
            while c > 0:
                if c % 26 == 0:
                    v.append('Z')
                    c = (c - 1) // 26
                else:
                    v.append(chr(ord('A') + (c % 26 - 1)))
                    c //= 26

            v.reverse()
            print(""%s%d"" % ("""".join(v), r))

        else:
            c = 0
            p = 0
            while p < len(s):
                if s[p].isdigit():
                    break
                c = c * 26 + (ord(s[p]) - ord('A') + 1)
                p += 1

            print(""R%sC%d"" % (s[p:], c))

if __name__ == ""__main__"":
    solution()
",O(n)
"class Solution:
    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:
        if len(hand) % groupSize:
            return False

        count = {}
        for n in hand:
            count[n] = 1 + count.get(n, 0)

        minH = list(count.keys())
        heapq.heapify(minH)
        while minH:
            first = minH[0]
            for i in range(first, first + groupSize):
                if i not in count:
                    return False
                count[i] -= 1
                if count[i] == 0:
                    if i != minH[0]:
                        return False
                    heapq.heappop(minH)
        return True
",O(nlogn)
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))


class Solution(object):
    def reverseList(self, head):
        dummy = ListNode(float(""-inf""))
        while head:
            dummy.next, head.next, head = head, dummy.next, head.next
        return dummy.__next__

",O(n)
"import sys

def bin_ser(arr,curr):
    l=0
    r=len(arr)-1
    ans=-1
    while l<=r:
        mid=(l+r)//2
        if arr[mid]<=curr:
            ans=mid
            l=mid+1
        else:
            r=mid-1
    return ans

def main():
    n,q=map(int,sys.stdin.readline().strip().split())
    arr=list(map(int,sys.stdin.readline().strip().split()))
    brr=list(map(int,sys.stdin.readline().strip().split()))
    su=sum(arr)
    curr=0
    for i in range(1,n):
        arr[i]=arr[i]+arr[i-1]
    for b in brr:
        curr+=b
        pos=n-bin_ser(arr,curr)-1
        if pos==0:
            pos=n
        print(pos)
        if curr>=su:
            curr=0

main()
",O(nlogn)
"n,m,k = map(int,input().split())
a = list(map(int,input().split()))
a.sort(reverse = True)
s = 0
count = 0

i = 0
while k<m and i<n:
    k+=a[i]-1
    i+=1
print(i if k>=m else -1)
",O(nlogn)
"import threading


class Solution(object):
    def __init__(self, n):
        self.__n = n
        self.__curr = 0
        self.__cv = threading.Condition()
    def zero(self, printNumber):
        for i in range(self.__n):
            with self.__cv:
                while self.__curr % 2 != 0:
                    self.__cv.wait()
                self.__curr += 1
                printNumber(0)
                self.__cv.notifyAll()
        
    def even(self, printNumber):
        for i in range(2, self.__n+1, 2):
            with self.__cv:
                while self.__curr % 4 != 3:
                    self.__cv.wait()
                self.__curr += 1
                printNumber(i)
                self.__cv.notifyAll()
        
    def odd(self, printNumber):
        for i in range(1, self.__n+1, 2):
            with self.__cv:
                while self.__curr % 4 != 1:
                    self.__cv.wait()
                self.__curr += 1
                printNumber(i)
                self.__cv.notifyAll()",O(n)
"n, k = map(int, input().split())
a = list(map(int, input().split()))
t = list(map(int, input().split()))
p = [0] * (n + 1)
now = 0
for i in range(0, n):
    if (t[i] == 1):
        now += a[i]
    p[i + 1] = p[i]
    if (t[i] == 0):
        p[i + 1] += a[i]
s = 0
for i in range(n - k + 1):
    s = max(s, p[i + k] - p[i])
print(now + s)
",O(n)
"f = [0 for _ in range(40)]

for i in range(1, 32):
    f[i] = 1 + 4 * f[i - 1]
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    if n >= 32:
        print(""YES %d"" % (n - 1))
        continue

    if f[n] < k:
        print(""NO"")
        continue

    k -= 1
    extra = 1
    way = 3
    size = n - 1
    done = False
    total = f[size]
    ans = True
    while k > total and size > 0:
        if k < way:
            ans = False
            break
        k -= way
        size -= 1
        extra = way * 2 - 1
        way = way * 2 + 1
        total += extra * f[size]

    if ans:
        print(""YES %d"" % size)
    else:
        print(""NO"")
",O(logn)
"n,s=map(int,input().split())
if s>=n:
    print(""0"")
    exit()
for i in range(s,n+2):
    cur=int(0)
    for j in str(i):
        cur+=int(j)
    if i-cur>=s:
        break
print(n-i+1)
",O(logn)
"class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if not p and not q:
            return True
        if p and q and p.val == q.val:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
        else:
            return False
",O(n)
"n=input()
m={}
def podstroka(s:str):
    for i in range(0,len(s)):
        for j in range(i+1,len(s)+1):
            if s[i:j] in m:
                m[s[i:j]] +=1
            else:
                m[s[i:j]] = 1
    return m

podstroka(n)

maxlen = 0
for x in m:
    if m[x]>=2 and len(x)>maxlen:
        maxlen=len(x)
print(maxlen)",O(n ^ 3)
"def mypw2(deg):
    if (deg >= 1500) : return 2 ** 150

    return 2 ** deg

def sol():
    n, k = map(int, input().split())
    if (k == 0):
        print(""YES"", n)
        return
    for side in range(1, n + 1):
        MIN = mypw2(side + 1) - side - 2
        MAX = mypw2(2 * n) - mypw2(2 * n - side + 1) + mypw2(side + 1) + mypw2(2 * n - 2 * side) - 2;
        MAX //= 3

        if (MIN <= k <= MAX):
            print(""YES"", n - side)
            return
    print(""NO"")

def main():
    t = int(input())
    for i in range(t):
        sol()

main()",O(logn)
"class BIT(object): 
    def __init__(self, n):
        self.__bit = [0] * n

    def add(self, i, val):
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def sum(self, i):
        result = 0
        while i > 0:
            result += self.__bit[i]
            i -= (i & -i)
        return result


class Solution(object):
    def processQueries(self, queries, m):
        bit = BIT(2*m+1)
        lookup = {}
        for i in range(1, m+1):
            bit.add(m+i, 1)
            lookup[i] = m+i
        result, curr = [], m
        for q in queries:
            i = lookup.pop(q)
            result.append(bit.sum(i-1))
            bit.add(i, -1)
            lookup[q] = curr
            bit.add(curr, 1)
            curr -= 1
        return result",O(nlogn)
"a = input()
b = input()

if len(a) < len(b):
    a = sorted(a)[::-1]
    print(''.join(a))
    exit(0)

def check(res, j, a):
    added = False
    tmp = """"
    for i in a:
        if i == j and not added:
            added = True
        else:
            tmp += i
    tmp = res + j + tmp[::-1]
    return tmp <= b

res = """"
n = len(a)
a = sorted(list(a))[::-1]
for i in range(n):
    for j in a:
        if check(res, j, a):
            res += j
            a.remove(j)
            break
print(res)
",O(n ^ 3)
"from math import pow
def modularExponentiation(x,n,M):

    if n==0:
        return 1
    elif n%2 == 0:
        return modularExponentiation((x*x)%M,n//2,M)
    else:
        return (x%M*modularExponentiation((x*x)%M,(n-1)//2,M)%M)%M

c=10**9+7
n,k=map(int,input().split())
a=(n%c*(modularExponentiation(2,k+1,c))%c)%c
b=(modularExponentiation(2,k,c)%c-1%c+c)%c
if n==0:
    print(""0"")
else:
    print((a%c-b%c+c)%c)",O(logn)
"from collections import Counter

n, k = map(int, input().split())

for p in range(n+1):
    if p*(p+1)//2 - (n-p) == k:
        print(n-p)
        break
",O(n)
"from sys import stdin, stdout
readline = stdin.readline
write = stdout.write

squareMoves = []

def precompute():
    top = 10 ** 18
    prev = 0

    while prev <= 30*top:
        squareMoves.append(prev)
        prev = 1 + 4 * prev

def getAns(k, n):
    low = 0
    high = 0
    a = 1
    b = 1
    i = 1

    while i <= n:
        low += a
        high += a + b * squareMoves[n-i]

        if high >= k:
            if low > k:
                return -1
            return i

        a = 2 * a + 1
        b = 2 * a - 1
        i += 1

    return -1

if __name__ == ""__main__"":
    precompute()

    t = int(readline().strip())
    for i in range(t):
        [n, k] = list(map(int, readline().strip().split(' ')))
        tmpN = min(n, len(squareMoves))

        ans = getAns(k, tmpN)
        if ans == -1:
            write(""NO\n"")
        else:
            write(""YES "" + str(n - ans) + ""\n"")
",O(logn)
"def main():
  N, M = map(int, input().split())
  L = [tuple(map(int, input().split())) for _ in range(N)]
  maxi = max(max(t) for t in L)+1
  mini, res = max((min(t), i) for i, t in enumerate(L))
  res = res, res
  BITMASK = (1 << M)
  while True:
    mid = (maxi+mini)//2

    if mid == mini:
      break
    masks = [None]*BITMASK
    for i, t in enumerate(L):
      tmask = 0
      for v in t:
        tmask *= 2
        if v >= mid:
          tmask += 1
      if masks[tmask] is not None:
        continue
      masks[tmask] = i
      for k in range(BITMASK):
        if masks[k] is not None and k | tmask == BITMASK-1:
          res = masks[k], i
          mini = mid = min(max(a, b) for a, b in zip(L[res[0]], L[res[1]]))
          break
      else:
        continue
      break
    else:
      maxi = mid

  print(res[0]+1, res[1]+1)

main()
",np
"a, b, c=map(int, input().split())
d=sorted(list(map(int, input().split())))

e=d[c-1]
f=d[c]
print(f-e)
",O(nlogn)
"n=int(input())//2
a=list(map(int,input().split(' ')))
b=[0]*n
a.reverse()
for i in a:
    b.append(i)
mem=b[-1]
c=0
for i in range(n-1):
    if b[-2-i]-c>mem:
        c=b[-2-i]-mem
    b[-2-i]-=c
    b[1+i]+=c
    mem=b[-2-i]
for i in b:
    print(i,end=' ')
",O(n)
"n, m, k, l = map(int, input().split())
if m > n:
    print(-1)
elif l + k > n:
    print(-1)
else:
    s = (l + k) // m + bool((l + k) % m)
    if s * m > n:
        print(-1)
    else:
        print(s)
",O(1)
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping
from itertools import groupby as gb
from fractions import Fraction as fr

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()
def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));
def ceildiv(x,y): return (x+y-1)//y

n=int(input())
if n==0:
    print(0)
else:
    if (n+1)%2:
        print(n+1)
    else:
        print((n+1)//2)
",O(1)
"def main():
    def calc(x1, y1, x2, y2):
        if x1 > x2 or y1 > y2:
            return 0
        if (x2 - x1 + 1) * (y2 - y1 + 1) % 2 == 0:
            return (x2 - x1 + 1) * (y2 - y1 + 1) // 2
        if (x1 + y1) % 2 == 1:
            return (x2 - x1 + 1) * (y2 - y1 + 1) // 2 + 1
        return (x2 - x1 + 1) * (y2 - y1 + 1) // 2
    T = int(input())
    for t in range(T):
        n, m = map(int, input().split())
        a, b, c, d = map(int, input().split())
        e, f, g, h = map(int, input().split())
        j, k, l, q = max(a, e), max(b, f), min(c, g), min(d, h)
        black = calc(1, 1, n, m) - calc(a, b, c, d) - calc(e, f, g, h) + (h - f + 1) * (g - e + 1) + calc(j,k,l,q)
        print(n * m - black, black)

main()
",O(1)
"n = int(input())
l = list(map(int, input().split()))
r = list(map(int, input().split()))
ans = [1 for i in range(n)]

s = [l[i] + r[i] for i in range(n)]
order = [i for i in range(n)]

for i in range(n-1):
    m = i
    for j in range(i+1,n):
        if s[m] < s[j]:
            m = j
    t = s[i]
    s[i] = s[m]
    s[m] = t
    t = order[i]
    order[i] = order[m]
    order[m] = t
cur = 1
for i in range(1,n):
    if s[i-1] > s[i]:
        cur += 1
    ans[order[i]] = cur
for i in range(n):
    k = 0
    for j in range(i):
        if ans[j] > ans[i]:
            k += 1
    if l[i] != k:
        print('NO')
        exit()
    k = 0
    for j in range(i+1,n):
        if ans[j] > ans[i]:
            k += 1
    if r[i] != k:
        print('NO')
        exit()

print('YES')
for i in ans:
    print(i, end=' ')",O(n ^ 2)
"n=int(input())
a=list(map(int,input().split()))
a.sort()

total_money=sum(a)
i_have=0
reaming=total_money-i_have
cnt=0
for i in range(n-1,-1,-1):
    reaming=total_money-i_have
    if i_have>reaming:
        break
    i_have+=a[i]
    cnt+=1
print(cnt)",O(nlogn)
"n = int(input())
a = list(map(int,input().split()))
mod = 10**9+7
b = [0 for i in range(1<<20)]
for i in range(n):
  b[a[i]] += 1
for i in range(20):
  for j in range(1<<20):
    if j&1<<i == 0:
      b[j] += b[j|1<<i]
ans = 0
for i in range(1<<20):
  cnt = str(bin(i)).count(""1"")
  if cnt%2 == 0:
    ans += pow(2,b[i],mod)-1
  else:
    ans -= pow(2,b[i],mod)-1
  ans %= mod
print(ans)",np
"from bisect import bisect_right

n,q=map(int,input().split())
a=[int(X) for X in input().split()]
k=[int(x) for x in input().split()]
for i in range(1,n):
    a[i]+=a[i-1]
an=0
for j in k:
    j+=an
    x=bisect_right(a,j)
    if x==n:
        print(n)
        an=0
    else:

        print(n-x)
        an=j
",O(nlogn)
"import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

n,m = map(int, input().split())
a = []
for i in range(n):
    ai = list(map(int, input().split()))
    a.append(ai)

def check(mid):
    mask = (1<<m)-1
    s = set()
    d = dict()
    for i in range(n):
        state = 0
        for j in range(m):
            if a[i][j] >= mid:
                state += 1<<j

        if state in s:
            continue
        s.add(state)
        k = state
        while k>=0:

            k &= state
            d[k] = i
            k -= 1
        need = mask^state

        if need in d:
            q1, q2 = d[need], i
            if q1 > q2:
                q1, q2 = q2, q1
            return True, (q1, q2)

    return False, (-1, -1)

left = 0
right = 10**9+1
i,j = 0, 0
while right-left>1:
    mid = (right+left)//2
    flag, (q1, q2) = check(mid)

    if flag:
        left = mid
        i,j = q1, q2
    else:
        right = mid
print(i+1, j+1)
",np
"import sys
from heapq import heappush, heappop, heapify
sys.setrecursionlimit(int(1e7))

def main():
    n = int(input().strip())
    a = [int(x) for x in input().split()]
    a = [-x-1 if x>=0 else x for x in a]
    if n%2==1:
        _, i = min((x,i) for i,x in enumerate(a))
        a[i] = -a[i]-1
    print(*a)
    return

while 1:
    try: main()
    except EOFError: break",O(n)
"N = 1010

dp = [[[0] * 4 for j in range(N*2)] for i in range(N)]
dp[0][1][0] = dp[0][1][1] = dp[0][2][2] = dp[0][2][3] = 1
m = 998244353
for i in range(N-1):
    for j in range(1,N*2-5):
        for me in range(4):
            for he in range(4):
                if me <= 1:
                    if he <= 1:
                        dp[i+1][j+(he!=me)][he] = (dp[i+1][j+(he!=me)][he] + dp[i][j][me]) % m
                    else:
                        dp[i+1][j+1][he] = (dp[i+1][j+1][he] + dp[i][j][me]) % m
                else:
                    if he <= 1:
                        dp[i+1][j][he] = (dp[i+1][j][he] + dp[i][j][me]) % m
                    else:
                        dp[i+1][j + (he != me)*2][he] = (dp[i+1][j+(he!=me)*2][he] + dp[i][j][me]) % m
n,k = map(int,input().split())
print(sum(dp[n-1][k])%m)
",np
"import collections



class Solution(object):
    def maximumNumberOfStringPairs(self, words):
        result = 0
        cnt = collections.Counter()
        for w in words:
            result += cnt[w[::-1]]
            cnt[w] += 1
        return result",O(n)
"class Solution2(object):
    def toHexspeak(self, num):
        result = hex(int(num)).upper()[2:].replace('0', 'O').replace('1', 'I')
        return result if all(c in ""ABCDEFOI"" for c in result) else ""ERROR""",O(n)
"arr = [int(i) for i in filter(None, input().split("" ""))]
k_hodov = arr[0]
konf = arr[1]
left = 0
right = k_hodov+100
while(right-left)>1:
    mid = (right+left)//2
    k_give=k_hodov-mid
    if ((k_give+1)*(k_give/2))//1-mid<konf or k_give<0:
        right = mid
    else:
        left = mid

k_give=k_hodov-left
if ((k_give+1)*(k_give/2))//1-left==konf:
    print(left)
else:
    print(left-1)
",O(logn)
"n, m, k, l = map(int, input().split())
cnt = (k + l + m - 1) // m
if cnt * m > n:
    print(-1)
else:
    print(cnt)",O(1)
"class Solution(object):
    def minConnectedGroups(self, intervals, k):
        intervals.sort()
        result = 0
        prefix = [0]*(len(intervals)+1)
        mx = float(""-inf"")
        left = 0
        for right in range(len(intervals)):
            prefix[right+1] = prefix[right]+int(mx < intervals[right][0])
            mx = max(mx, intervals[right][1])
            while intervals[right][0]-intervals[left][1] > k:
                left += 1
            result = max(result, prefix[right+1]-prefix[left+1])
        return prefix[-1]-result",O(nlogn)
"n, values, wrong = int(input()), [int(i) for i in input().split()], 0
sorted_values = list(sorted(values))
for i in range(n):
    if values[i] != sorted_values[i]:
        wrong += 1
if wrong > 2:
    print(""NO"")
else:
    print(""YES"")
",O(nlogn)
"class Solution(object):
    def transformArray(self, nums):
        cnt = 0
        for x in nums:
            if x%2:
                continue
            nums[cnt] = 0
            cnt += 1
        for i in range(cnt, len(nums)):
            nums[i] = 1
        return nums",O(n)
"import sys
import math
from collections import defaultdict,deque

input = sys.stdin.readline
def inar():
    return [int(el) for el in input().split()]
def main():
    n,k=inar()
    arr=inar()
    new=arr.copy()
    new=[]
    ans=0
    for i in range(n):
        new.append((arr[i],i))
    new.sort(reverse=True)
    check=[0]*n
    for i in range(k):
        ans+=new[i][0]
        check[new[i][1]]=1
    count=0
    res=[]

    for i in range(n):
        if check[i]==1:
            count+=1
            res.append(count)
            count=0
        else:
            count+=1
    res[-1]+=count
    print(ans)
    print(*res)

if __name__ == '__main__':
    main()
",O(nlogn)
"from math import gcd
def t_prime(n):
    if n == 1:        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:            return False
    return True
primes = [i for i in range(2,10**5) if t_prime(i)];pset = set(primes);n, k = map(int, input().split());l = list(map(int, input().split()))
if k == 1: print(0);exit()
for i in range(n):
    for j in range(i):
        u, v = l[i], l[j];poss = gcd(u,v);poss2 = max(u,v)//poss;smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:primes.append(smol);pset.add(smol)
powers = set();count = 0;outLs = [];pgood = []
for p in primes:
    curr = [];    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:            v2 //= p
        if v2 == 1:   curr.append(v);   powers.add(v)
    if len(curr) > 1: count += len(curr);     outLs.append(curr);  pgood.append(p)

order = [(len(lis), lis) for lis in outLs];order.sort(key = lambda x: x[0])

if len(order) == 0:    print(0); exit()

if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1
    need = -1
    last = []

    for v in l:
        if v in powers:
            continue

        v2 = v
        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:
                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):
            extra = v
            last = primesn
            need = len(last)
            assert need >= 2

    if need == -1 or 2 * need + 1 > k:
        print(0)
        exit()

    other = []
    out = [extra]

    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:
                works = True
                break
        if works:
            out.append(a)
            out.append(b)
        else:
            other.append(a)
            other.append(b)

    assert len(out) == 2 * need + 1
    assert (k - 2 * need - 1) % 2 == 0

    ret = out + other[:(k - 2*need - 1)]
    assert len(ret) == k

    print(' '.join(map(str,ret)))
    exit()

out = []
need = k
for i in range(len(order)):
    assert need != 1

    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0

assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:        break
    if v in powers:        continue
    v2 = v
    for p in pgood:
        while v2 % p == 0:            v2 //= p
    if v2 == 1:        out.append(v);        need -= 1

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)",np
"import math
num=int(input())
k=math.ceil(num/2)
if num%2==0:
    print(k+1)
else:
    print(k)",O(1)
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

def main():

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc = 1
    for _ in range(tc):
        n,x=ria()
        a=ria()
        d=Counter(a)
        sa=set(a)
        if len(sa)<n:
            print(0)
        else:
            c=0
            for i in a:
                k=i&x
                if k!=i and k in d:
                    c=1
                    print(1)
                    break
            if c==0:
                z=[]
                for i in a:
                    z.append(i&x)
                if len(set(z))<n:
                    print(2)
                else:
                    print(""-1"")

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(n)
"import pandas as pd



def Solution(products: pd.DataFrame) -> pd.DataFrame:
    products[""quantity""].fillna(0, inplace=True)
    return products",O(n)
"class Solution4(object):
    def maximumStrongPairXor(self, nums):
        return max(nums[i]^nums[j] for i in range(len(nums)) for j in range(i, len(nums)) if abs(nums[i]-nums[j]) <= min(nums[i], nums[j]))",O(n ^ 2)
"class Solution(object):
    def capitalizeTitle(self, title):
        title = list(title)
        j = 0
        for i in range(len(title)+1):
            if i < len(title) and title[i] != ' ':
                title[i] = title[i].lower()
                continue
            if i-j > 2:
                title[j] = title[j].upper()
            j = i+1
        return """".join(title)",O(n)
"import sys

def solve(n, m, grid):
    for i, row in enumerate(grid):
        for j, cell in enumerate(row):
            if cell == 0:
                continue
            must = cell == 1
            if i >= n - 2 or j >= m - 2:
                if must:
                    return 'NO'
                continue
            for di, dj in [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]:
                if grid[i + di][j + dj] == 0:
                    if must:
                        return 'NO'
                    break
            else:
                for di, dj in [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]:
                    grid[i + di][j + dj] = 2
                grid[i][j] = 2
    return 'YES'

n, m = list(map(int, input().split()))
grid = [['.
print(solve(n, m, grid))
",O(n ^ 2)
"def ints():
 return list(map(int,input().split()))
n,k=ints()
a,t=ints(),ints()
ans=sum(a[ii] for ii in range(n) if t[ii])
bb=[a[ii] if t[ii]==0 else 0 for ii in range(n)]
ll=0
rr=k
tmp=sws=sum(bb[:k])
while rr<n:
 sws-=bb[ll]
 sws+=bb[rr]
 ll+=1
 rr+=1
 tmp=max(tmp,sws)
ans+=tmp
print(ans)
",O(n)
"import sys
input = sys.stdin.readline

N, M = map(int, input().split())
state = [list(map(int, input().split())) for _ in range(N)]

Ans = {}

l = -1
r = 10**9+1
while r-l > 1:
    m = (l+r)//2
    T = {}
    for j, S in enumerate(state):
        bit = 0
        for i, s in enumerate(S):
            if s >= m:
                bit += 1<<i
        T[bit] = j

    ok = False
    for bit1 in range(1<<M):
        for bit2 in range(1<<M):
            if bit1|bit2 == (1<<M)-1 and bit1 in T and bit2 in T:
                ok = True
                Ans[m] = [T[bit1], T[bit2]]
                break
        if ok: break
    if ok:
        l = m
    else:
        r = m
print(Ans[l][0]+1, Ans[l][1]+1)",np
"t=list(map(int,input().split()))
n=t[0]
c=t[1]
a=list(map(int,input().split()))
f=[]
for i in range(0,500001):
	f.append(0)
l=[]
for i in range(0,500001):
	l.append([0])
m=0
for i in range(n):
	l[a[i]].append(f[a[i]]-m)
	if a[i]==c:
		m+=1
	f[a[i]]+=1
	l[a[i]].append(f[a[i]]-m)
ma=0
for i in l:
	mi=0
	for j in i:
		if(j<mi):
			mi=j
		if(ma<j-mi):
			ma=j-mi
print(m+ma)",O(n)
"k = int(input().split()[1])
l = sorted(list(map(int,input().split())))

res = set()
for i in l:
    if i//k  not in res or i%k!=0:
        res.add(i)

print(len(res))",O(nlogn)
"def main():
	s = list(input())
	t = list(input())
	if len(s) < len(t):
		s.sort(reverse=True)
		print(''.join(s))
	else:
		count = [0] * 10
		for elm in s:
			count[ord(elm) - ord('0')] += 1
		ans = []
		less = False
		for i in range(len(s)):
			for j in range(9, -1, -1):
				if not less:
					if j <= ord(t[i]) - ord('0') and count[j] > 0:
						if j < ord(t[i]) - ord('0'):
							ans.append(chr(j + ord('0')))
							count[j] -= 1
							less = True
							break
						else:
							curr_num = 0
							for k in range(10):
								if j == k:
									for tmp in range(count[k] - 1):
										curr_num = curr_num * 10 + k
								else:
									for tmp in range(count[k]):
										curr_num = curr_num * 10 + k
							rest_num = 0
							for k in range(i + 1, len(s)):
								rest_num = rest_num * 10 + (ord(t[k]) - ord('0'))
							if rest_num >= curr_num:
								ans.append(chr(j + ord('0')))
								count[j] -= 1
								break
							else:
								continue
				else:
					if count[j] > 0:
						ans.append(chr(j + ord('0')))
						count[j] -= 1
						break
		print(''.join(ans))

if __name__ == '__main__':
	main()
",O(n ^ 3)
"class Solution(object):
    def arraySign(self, nums):
        flag = 0
        for x in nums:
            if not x:
                return 0
            if x < 0:
                flag ^= 1
        return -1 if flag else 1",O(n)
"import sys

a, b = input(), input()

if len(a) < len(b):
    print(*sorted(a, reverse=True), sep='')
    exit()

cnt = [0]*10

for x in a:
    cnt[int(x)] += 1

def rec(res, digit, rem):
    if digit == len(b):
        return res
    if rem[int(b[digit])]:
        r = rem[:]
        r[int(b[digit])] -= 1
        x = rec(res + b[digit], digit+1, r)
        if x:
            return x
    for d in range(int(b[digit])-1, -1, -1):
        if rem[d]:
            res += str(d)
            rem[d] -= 1
            suf = []
            for i in range(10):
                suf += [str(i)] * rem[i]
            return res + ''.join(sorted(suf, reverse=True))
    return ''

ans = rec('', 0, cnt[:])
print(ans)
",O(n ^ 3)
"class Solution(object):
    def furthestDistanceFromOrigin(self, moves):
        curr = cnt = 0
        for x in moves:
            if x == 'L':
                curr -= 1
            elif x == 'R':
                curr += 1
            else:
                cnt += 1
        return abs(curr)+cnt",O(n)
"import sys

def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def rinput():   return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))

n,s=rinput()
maxi=s
for i in range(n):
    f,t=rinput()
    maxi=max(maxi,f+t)

print(maxi)",O(n)
"class Solution(object):
    def racecar(self, target):
        dp = [0] * (target+1)
        for i in range(1, target+1):
            k = i.bit_length()

            if i == 2**k-1:
                dp[i] = k
                continue

            dp[i] = k+1 + dp[2**k-1 - i]

            for j in range(k-1):
                dp[i] = min(dp[i], k+j+1 + dp[i - 2**(k-1) + 2**j])

        return dp[-1]",O(nlogn)
"n, a, b, c, t = map(int, input().split())
l = list(map(int, input().split()))
f = [0] * 1001
for i in l: f[i] -= -1
tmp = 0
tmp2 = 0
for i in range(1, t):
    tmp += (t - i) * f[i]
tmp = n * a + tmp * c - tmp * b
print(max(n * a, tmp))",O(n)
"class Solution(object):
    def minimumLines(self, stockPrices):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a
    
        stockPrices.sort()
        result = 0
        prev = None
        for i in range(1, len(stockPrices)):
            dy, dx = stockPrices[i][1]-stockPrices[i-1][1], stockPrices[i][0]-stockPrices[i-1][0]
            g = gcd(dy, dx)
            if not prev or prev != (dy//g, dx//g):
                prev = (dy//g, dx//g)
                result += 1
        return result",O(nlogn)
"l, r = map(int, input().split(' '))
n1 = bin(l)[2:]
n2 = bin(r)[2:]
if l==r:
    print(0)
elif len(n1) < len(n2):
    print(int(len(n2)*'1', 2))
else:
    index = 0
    for i in range(len(n1)):
        if n1[i] != n2[i]:
            index = i
            break
    print(int((len(n1)-index)*'1', 2))
",O(logn)
"n = int(input())
li = list(map(int, input().split()))
x = li.index(max(li))
if li[:x] == sorted(li[:x]) and li[x:] == sorted(li[x:])[::-1]:
    print(""YES"")
else:
    print(""NO"")",O(nlogn)
"x, k = map(int, input().split())

md = 10 ** 9 + 7

res = x * pow(2, k + 1, md) - pow(2, k, md) + 1 if x > 0 else 0
print(res % md)
",O(logn)
"n = int(input())

if n>=2:
    print(25)
",O(1)
"class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        oldToCopy = {None: None}

        cur = head
        while cur:
            copy = Node(cur.val)
            oldToCopy[cur] = copy
            cur = cur.next
        cur = head
        while cur:
            copy = oldToCopy[cur]
            copy.next = oldToCopy[cur.next]
            copy.random = oldToCopy[cur.random]
            cur = cur.next
        return oldToCopy[head]
",O(n)
"n = int(input())
p = list(map(lambda x: int(x) - 1, input().split()))

vis = [False] * n
odd = 0
for x in range(n):
    if vis[x]:
        continue
    odd ^= 1
    while not vis[x]:
        odd ^= 1
        vis[x] = True
        x = p[x]

print('Petr' if (n + odd) % 2 == 0 else 'Um_nik')
",O(nlogn)
"class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        if head is None:
            return None

        l1 = head
        while l1 is not None:
            l2 = Node(l1.val)
            l2.next = l1.next
            l1.next = l2
            l1 = l2.next

        newHead = head.next

        l1 = head
        while l1 is not None:
            if l1.random is not None:
                l1.next.random = l1.random.next
            l1 = l1.next.next

        l1 = head
        while l1 is not None:
            l2 = l1.next
            l1.next = l2.next
            if l2.next is not None:
                l2.next = l2.next.next
            l1 = l1.next

        return newHead
",O(n)
"n, m = map(int, input().split())
x = list(list(map(int , input())) for i in range(n))
res = [0] * m
for i in range(n):
	for j in range(m):
		res[j] += x[i][j]

for i in range(n):
	ok = 1
	for j in range(m):
		if res[j] == 1 and x[i][j] == 1:
			ok = 0
			break
	if ok:
		print(""YES"")
		exit()
print(""NO"")
",O(n ^ 2)
"n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
left = 0
right = 10**9+1
ans = (0, 0)
while left < right:
    mid = (left + right) // 2
    masks = {}
    for i in range(n):
        mask = 0
        for j in a[i]:
            mask <<= 1
            if j >= mid:
                mask += 1
        masks[mask] = i
    ok = False
    for m1 in masks:
        for m2 in masks:
            if m1 | m2 == ((1 << m) - 1):
                ok = True
                ans = (masks[m1]+1, masks[m2]+1)
                break
        if ok:
            break
    if ok:
        left = mid+1
    else:
        right = mid
print(ans[0], ans[1])
",np
"class Solution(object):
    def minCost(self, nums, x):
        def accumulate(a):
            for i in range(len(a)-1):
                a[i+1] += a[i]
            return a

        i = min(range(len(nums)), key=lambda x: nums[x])
        nums = nums[i:]+nums[:i]
        left, right = [-1]*len(nums), [len(nums)]*len(nums)
        stk = []
        for i in range(len(nums)):
            while stk and nums[stk[-1]] > nums[i]:
                right[stk.pop()] = i
            if stk:
                left[i] = stk[-1]
            stk.append(i)
        diff2 = [0]*(len(nums)+1)
        diff2[0] = (+1)*sum(nums)            
        diff2[1] = x                         
        diff2[-1] += (-1)*nums[0]            
        for i in range(1, len(nums)):
            l, r = i-left[i], right[i]-i
            diff2[min(l, r)] += (-1)*nums[i] 
            diff2[max(l, r)] += (-1)*nums[i] 
            diff2[l+r] += (+1)*nums[i]       
        return min(accumulate(accumulate(diff2)))",O(n)
"n = int(input())
for i in range(n):
    a,b = map(int, input().split())
    a1 = a
    if a % 2 == 0:
        a1 += 1
    b1 = b
    if b % 2 == 0:
        b1 -= 1
    n = 0
    if a1 <= b1:
        num = (b1 - a1) // 2 + 1
        n = num * (b1 + a1) // 2
        n *= -1
    b2 = b
    a2 = a
    if a % 2 == 1:
        a2 += 1
    if b % 2 == 1:
        b2 -= 1
    n2 = 0
    if a2 <= b2:
        num = (b2 - a2) // 2 + 1
        n2 = num * (b2 + a2) // 2
    print(n + n2)
",O(1)
"class Solution3(object):
    def countDistinct(self, nums, k, p):
        MOD, P = 10**9+7, 200
        result = 0
        cnt, h = [0]*len(nums), [0]*len(nums)
        for l in range(1, len(nums)+1):
            lookup = set()
            for i in range(len(nums)-l+1):
                cnt[i] += (nums[i+l-1]%p == 0)
                if cnt[i] > k:
                    continue
                h[i] = (h[i]*P+nums[i+l-1])%MOD
                lookup.add(h[i])
            result += len(lookup)
        return result",O(n ^ 2)
"n, m = map(int,input().split())
r=0
c=0
f= 1
for i in range(n):
    s = input()
    if  f and ""B"" in s:
        f = 0
        ci = s.index('B')
        cc = s.count(""B"")
        r = i+1+cc//2
        c = ci+cc//2+1
print(r,c)",O(n ^ 2)
"class Solution(object):
    def preorder(self, root):
        if not root:
            return []
        result, stack = [], [root]
        while stack:
            node = stack.pop()
            result.append(node.val)
            for child in reversed(node.children):
                if child:
                    stack.append(child)
        return result

",O(n)
"def make_number(b,chars):
	if len(chars) == 0:
		return """"
	target = chars[0]
	for i in chars:
		if int(b[0]) <= int(i):
			break
		target = i
	chars.remove(target)
	return target + """".join(chars[::-1])

def find_number(b,chars):
	backup_chars = list(chars)
	if len(b) == 1:
		return chars[0]
	elif b[0] in chars:
		chars.remove(b[0])
		num = b[0] + find_number(b[1:],chars)
		if min(num,b) == b and b != num:
			return make_number(b,backup_chars)
		else:
			return num

	else:
		return make_number(b,backup_chars)

a,b = str(input()), str(input())
chars = [i for i in a]
chars.sort()

if len(a) < len(b):
	print("""".join(chars[::-1]))
else:
	print(find_number(b,chars))",O(n ^ 3)
"class Solution2(object):
    def countRangeSum(self, nums, lower, upper):
        def countAndMergeSort(sums, start, end, lower, upper):
            if end - start <= 0: 
                return 0

            mid = start + (end - start) / 2
            count = countAndMergeSort(sums, start, mid, lower, upper) + \
                    countAndMergeSort(sums, mid + 1, end, lower, upper)
            j, k, r = mid + 1, mid + 1, mid + 1
            tmp = []
            for i in range(start, mid + 1):
                while k <= end and sums[k] - sums[i] < lower:
                    k += 1
                while j <= end and sums[j] - sums[i] <= upper:
                    j += 1
                count += j - k

                while r <= end and sums[r] < sums[i]:
                    tmp.append(sums[r])
                    r += 1
                tmp.append(sums[i])

            sums[start:start+len(tmp)] = tmp
            return count

        sums = [0] * (len(nums) + 1)
        for i in range(len(nums)):
            sums[i + 1] = sums[i] + nums[i]
        return countAndMergeSort(sums, 0, len(sums) - 1, lower, upper)",O(nlogn)
"class Solution(object):
    def countUnivalSubtrees(self, root):
        [is_uni, count] = self.isUnivalSubtrees(root, 0)
        return count

    def isUnivalSubtrees(self, root, count):
        if not root:
            return [True, count]

        [left, count] = self.isUnivalSubtrees(root.left, count)
        [right, count] = self.isUnivalSubtrees(root.right, count)
        if self.isSame(root, root.left, left) and \
           self.isSame(root, root.right, right):
                count += 1
                return [True, count]

        return [False, count]

    def isSame(self, root, child, is_uni):
        return not child or (is_uni and root.val == child.val)",O(n)
"from bisect import *
from collections import *
from itertools import *
import functools
import sys
import math
from decimal import *
from copy import *
from heapq import *
getcontext().prec = 30
MAX = sys.maxsize
MAXN = 10**5+10
MOD = 10**9+7
def isprime(n):
    n = abs(int(n))
    if n < 2:
        return False
    if n == 2:
        return True
    if not n & 1:
        return False
    for x in range(3, int(n**0.5) + 1, 2):
        if n % x == 0:
            return False
    return True

def mhd(a,b):
    return abs(a[0]-b[0])+abs(b[1]-a[1])

def charIN(x= ' '):
    return(sys.stdin.readline().strip().split(x))

def arrIN(x = ' '):
    return list(map(int,sys.stdin.readline().strip().split(x)))

def eld(x,y):
    a = y[0]-x[0]
    b = x[1]-y[1]
    return (a*a+b*b)**0.5

def lgcd(a):
    g = a[0]
    for i in range(1,len(a)):
        g = math.gcd(g,a[i])
    return g

def ms(a):
    msf = -MAX
    meh = 0
    st = en = be = 0
    for i in range(len(a)):
        meh+=a[i]
        if msf<meh:
            msf = meh
            st = be
            en = i
        if meh<0:
            meh = 0
            be = i+1
    return msf,st,en

def ncr(n,r):
    num=den=1
    for i in range(r):
        num = (num*(n-i))%MOD
        den = (den*(i+1))%MOD

    return (num*(pow(den,MOD-2,MOD)))%MOD

def flush():
    return sys.stdout.flush()

def fac(n):
    ans = 1
    for i in range(1,n+1):
        ans*=i
        ans%=MOD
    return ans

n = int(input())
a = arrIN()
a.sort()
f = [1]*n
cnt = 0
for i in range(n):
    if f[i]:
        cnt+=1
        for j in range(i,n):
            if f[j] and a[j]%a[i]==0:
                f[j] = 0
        f[i] = 0
print(cnt)
",O(n ^ 2)
"n = int(input())
a = list(map(int, input().split()))
m = int(input())
parity = 0
for i in range(n):
    for j in range(i + 1, n):
        if a[i] > a[j]:
            parity ^= 1
res = []
for _ in range(m):
    l, r = map(int, input().split())
    s = r - l + 1
    parity ^= (s * (s - 1) // 2) % 2
    res.append(""odd"" if parity else ""even"")
print(""\n"".join(res))",O(n ^ 2)
"import collections



class Solution(object):
    def verticalOrder(self, root):
        cols = collections.defaultdict(list)
        queue = [(root, 0)]
        for node, i in queue:
            if node:
                cols[i].append(node.val)
                queue += (node.left, i - 1), (node.right, i + 1)
        return [cols[i] for i in range(min(cols.keys()),
                                        max(cols.keys()) + 1)] if cols else []",O(n)
"class Solution(object):
    def isReachableAtTime(self, sx, sy, fx, fy, t):
        diff1, diff2 = abs(sx-fx), abs(sy-fy)
        mn = min(diff1, diff2)+abs(diff1-diff2)
        return t >= mn if mn else t != 1",O(1)
print((int(input()))//2+1),O(1)
"n,queries = list(map(int,input().split()))
l = list(map(int,input().split()))
if(queries==0):
	exit()
maxval = max(l)
pairs = []
count = 0
f = l[0]
secix = 1
while(f!=maxval):

	count+=1
	f = l[0]
	s = l[secix]
	pairs.append([f,s])
	f,s= max(f,s), min(f,s)
	l[0] = f
	l.append(s)
	secix+=1

l = [l[0]]+l[secix:]

for i in range(n-1):
	pairs.append([maxval,l[1+i]])

for m in range(queries):
	q = int(input())
	if(q<=count):
		print(str(pairs[q-1][0]),str(pairs[q-1][1]))
	else:
		q-=(count+1)
		pos = count+(q%(n-1))
		print(str(pairs[pos][0]),str(pairs[pos][1]))",O(n)
"from sys import stdin
input=stdin.readline
def check(mid,a,limit):
	res=[]
	s=0
	for r,t,id in a:
		if r>=mid and t+s<=limit:
			res.append(id+1)
			s+=t
		elif t+s>limit:
			break
		if len(res)==mid:
			break

	return res

def f(a,limit):
	a.sort(key=lambda s:s[1])
	ans=None
	lo=0
	hi=10**9
	while lo<=hi:
		mid=(lo+hi)//2
		res=check(mid,a,limit)
		if len(res)>=mid:
			lo=mid+1
			ans=(res,mid)
		else:
			hi=mid-1
	print(ans[1])
	print(ans[1])
	print(*ans[0])

n,limit=map(int,input().strip().split())
q=[]
for i in range(n):
	x,y=map(int,input().strip().split())
	q.append((x,y,i))
f(q,limit)",O(nlogn)
"
class Solution(object):
    def containsNearbyDuplicate(self, nums, k):
        lookup = {}
        for i, num in enumerate(nums):
            if num not in lookup:
                lookup[num] = i
            else:
                if i - lookup[num] <= k:
                    return True
                lookup[num] = i
        return False

",O(n)
"import atexit
import io
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER

@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())

def main():
    n, a, b = [int(x) for x in input().split()]
    dc = {}
    for i in range(n):
        x, vx, vy = [int(x) for x in input().split()]
        nx = x + vx
        ny = a * x + b + vy
        dd = a * nx - ny + b
        if dd not in dc:
            dc[dd] = {}
        if (vx, vy) not in dc[dd]:
            dc[dd][(vx, vy)] = 0
        dc[dd][(vx, vy)] += 1

    tot = 0
    for v, k in dc.items():
        tt = 0
        pp = 0
        for _, cc in k.items():
            tt -= cc * (cc + 1) // 2
            pp += cc
        tt += pp * (pp + 1) // 2
        tot += tt * 2
    print(tot)

if __name__ == '__main__':
    main()",O(n)
"class Solution(object):
    def checkValidString(self, s):
        lower, upper = 0, 0 
        for c in s:
            lower += 1 if c == '(' else -1
            upper -= 1 if c == ')' else -1
            if upper < 0: break
            lower = max(lower, 0)
        return lower == 0",O(n)
"class Solution2(object):
    def missingRolls(self, rolls, mean, n):
        MAX_V = 6
        MIN_V = 1
        total = sum(rolls)
        missing = mean*(n+len(rolls))-total
        if missing < MIN_V*n or missing > MAX_V*n:
            return []
        q, r = divmod(missing-MIN_V*n, (MAX_V-MIN_V))
        return [MAX_V if i < q else MIN_V+r if i == q else MIN_V  for i in range(n)]",O(n)
"class Solution(object):
    def mostWordsFound(self, sentences):
        return 1+max(s.count(' ') for s in sentences)",O(n)
"import math
s1 = input()
s2 = input()
x = 0
y = 0
p = 0
for i in range(len(s1)):
    if s1[i] == '+': x+=1
    elif s1[i] == '-': y+=1
    if s2[i] == '+': x-=1
    elif s2[i] == '-': y-=1
    else: p+=1
if x<0 or y<0:
    print(float(0))
else:
    q = math.factorial(x+y)/(math.factorial(x)*math.factorial(y))
    r = q/math.pow(2,p)
    print(r)
",np
"class Solution(object):
    def countHomogenous(self, s):
        MOD = 10**9+7
        result = cnt = 0
        for i in range(len(s)):
            if i and s[i-1] == s[i]:
                cnt += 1
            else:
                cnt = 1
            result = (result+cnt)%MOD
        return result",O(n)
"import sys, math
import io, os

from bisect import bisect_left as bl, bisect_right as br, insort

from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n')
def out(var): sys.stdout.write(str(var) + '\n')
from decimal import Decimal

INF = 10001
mod = int(1e9) + 7

n=int(data())
a=mdata()
dp1=[[0]*n for i in range(n)]
dp2=[[n]*n for i in range(n)]
for i in range(n-1,-1,-1):
    dp1[i][i]=a[i]
    dp2[i][i]=1
    for j in range(i+1,n):
        for k in range(i,j):
            if dp1[i][k] == dp1[k+1][j] != 0:
                dp1[i][j] = dp1[i][k] + 1
                dp2[i][j] = 1
                break
            dp2[i][j] = min(dp2[i][j], dp2[i][k] + dp2[k + 1][j])
out(dp2[0][n-1])",O(n ^ 3)
"import os
import sys
from io import BytesIO, IOBase

def check(mid: int) -> bool:
    global ans
    dic = {}
    for i in range(n):
        bit = 0
        for j in range(m):
            if a[i][j] >= mid:
                bit += 1
            bit <<= 1
        dic[bit >> 1] = i
    for x, idx in dic.items():
        for y, idy in dic.items():
            if x | y == 2**m-1:
                ans = idx + 1, idy + 1
                return True
    return False

n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]
ans = []
le = 0
ri = int(1e9)
while le <= ri:
    mid = (le + ri) >> 1
    if check(mid):
        le = mid + 1
    else:
        ri = mid - 1
print(ans[0], ans[1])

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")
",np
"import math

n, r = map(float, input().split())
a = math.pi / n
s = math.sin(a)
R = (r * s) / (1 - s)
print(R)
",O(1)
"class Solution(object):
    def halvesAreAlike(self, s):
        vowels = set(""aeiouAEIOU"")
        cnt1 = cnt2 = 0
        left, right = 0, len(s)-1
        while left < right:
            cnt1 += s[left] in vowels
            cnt2 += s[right] in vowels
            left += 1
            right -= 1
        return cnt1 == cnt2",O(n)
"n = int(input())
dicta = {}
dictb = {}
for i in range(n):
    a, x = map(int, input().split())
    dicta[a] = x
m = int(input())
for i in range(m):
    b, y = map(int, input().split())
    dictb[b] = y
ans = 0
for i in dicta.keys():
    if i in dictb.keys():
        ans += max(dicta[i], dictb[i])
        del dictb[i]
    else :
        ans += dicta[i]
for i in dictb.values():
    ans += i
print(ans)
",O(nlogn)
"a, b, c, n = map(int, input().split())
t = a + b - c
if a >= n or b >= n or c > a or c > b or t >= n:
    print(-1)
else:
    print(n - t)
",O(1)
"def my_pow(a, n, m):
	if (n == 0) : return 1
	ans = my_pow(a, n // 2, m)
	if (n % 2 == 0):
		return ans * ans % m
	else:
		return (ans * ans * a) % m

x, k = map(int, input().split())
if (x == 0):
	print(0)
else:
	mod = 10**9 + 7
	x *= 2
	ans = (x - 1) * my_pow(2, k, mod) + 1
	ans %= mod
	ans += 2 * mod
	print(ans % mod)",O(logn)
"a, b = map(int, input().split())
x, y, z = map(int, input().split())
print(max((0,2*x+y-a))+max((0,3*z+y-b)))",O(1)
"l ,r = map(int,input().split())
for i in range(63,-1,-1):
    mx, mn= r,l
    if (1<<i)&l and (1<<i)&r :
        mx= (1<<i)-1
        mx= r^(1<<i)|mx
    elif ((1<<i)&l)==0 and ((1<<i)&r)==0 :
        mn = (1<<i)-1
        mn=(l&mn)^(l|(1<<i))
    if mx>=l and mx <=r and mn>=l and mn<=r:
        r,l=mx,mn
print(l^r)
",O(logn)
print(int(input())//2*3),O(1)
"class Solution(object):
    def checkIfCanBreak(self, s1, s2):
        def is_break(count1, count2):
            curr1, curr2 = 0, 0
            for c in string.ascii_lowercase:
                curr1 += count1[c]
                curr2 += count2[c]
                if curr1 < curr2:
                    return False
            return True

        count1, count2 = collections.Counter(s1), collections.Counter(s2)
        return is_break(count1, count2) or is_break(count2, count1)
import itertools",O(n)
"def BIG(NUM):
    X=NUM
    SM=0
    while X!=0:
        M=X%10
        SM+=M
        X//=10
    if NUM-SM>=S:
        return True

import sys
sys.setrecursionlimit(int(1e5))
input=sys.stdin.readline
N,S=map(int,input().split())
F=0;L=N+1;MN=1<<64
while L>=F:
    M=(L+F)>>1
    if BIG(M):L=M-1;MN=min(MN,M)
    else:F=M+1
if MN==1<<64:
    print(0)
else:
    print(N-MN+1)",O(logn)
"n=int(input())
for i in range(n):
	a,b = map( int, input().split() )
	if a>b:
	    a,b=b,a
	ans=0
	while a>0:
		ans+=b//a
		b%=a
		a,b=b,a
	print(ans)",O(1)
"class Solution(object):
    def maxNonOverlapping(self, nums, target):
        lookup = {0:-1}
        result, accu, right = 0, 0, -1
        for i, num in enumerate(nums):
            accu += num
            if accu-target in lookup and lookup[accu-target] >= right:
                right = i
                result += 1 
            lookup[accu] = i
        return result",O(n)
"import bisect



class Solution(object):
    def maximumBeauty(self, flowers, newFlowers, target, full, partial):
        flowers.sort()
        n = bisect.bisect_left(flowers, target)
        prefix, suffix = 0, sum(flowers[i] for i in range(n))
        result = left = 0
        for right in range(n+1):
            if right:
                suffix -= flowers[right-1]
            total = newFlowers-((n-right)*target-suffix)
            if total < 0:
                continue
            while not (left == right or (left and (total+prefix)//left <= flowers[left])):
                prefix += flowers[left]
                left += 1
            mn = min((total+prefix)//left if left else 0, target-1)
            result = max(result, mn*partial+(len(flowers)-right)*full)
        return result",O(nlogn)
"from sys import stdin

add = lambda a, b: (a % mod + b % mod) % mod
mod, bits = 998244353, ['00', '01', '10', '11']
pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]

n, k = map(int, stdin.readline().split())
mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]

for i in range(4):
    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)
    if val <= k:
        mem[0][val][i] = 1

for i in range(1, n):
    for j in range(1, i * 2 + 1):
        for k1 in range(4):
            for k2 in range(4):
                val = j + pat[k1][k2]
                if val <= k:
                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])

print(sum(mem[-1][k]) % mod)
",np
"import sys, math, cmath, time, collections
from collections import deque, Counter, OrderedDict, defaultdict
from heapq import nsmallest, nlargest, heapify, heappop, heappush, heapreplace
from math import ceil, floor, log, log2, sqrt, gcd, factorial, pow, pi
from bisect import bisect_left, bisect_right

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

def print(*args, **kwargs):

    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()

if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

start_time = time.time()

def solve(s):

    mx = 0
    visited = set()
    for left in range(len(s)):
        for right in range(left, len(s)):
            substring = s[left : right + 1]
            if substring not in visited:
                visited.add(substring)
            elif substring in visited:
                mx = max(mx, len(substring))
    print(mx)

def main():

    s = input()
    solve(s)

if __name__ == ""__main__"":
    LOCAL = False

    if LOCAL:
        sys.stdin = open(""../io/data.in"", ""r"")
        sys.stdout = open(""../io/data.out"", ""w"")

    testcases = 1
    for i in range(testcases):
        main()

    if LOCAL:
        print(f""Time Elapsed: {time.time() - start_time} seconds"")
        sys.stdout.close()
",O(n ^ 3)
"n, M = map(int, input().split())
A = list(map(int, input().split()))
A = [0]+A+[M]
D = []
for i in range(n+1):
    D.append(A[i+1]-A[i])

E = []
O = []
for i, d in enumerate(D):
    if i%2 == 0:
        E.append(d)
        O.append(0)
    else:
        O.append(d)
        E.append(0)
from itertools import accumulate
CE = [0]+E
CE = list(accumulate(CE))
CO = [0]+O
CO = list(accumulate(CO))

ans = CE[-1]
for i in range(n+1):
    if D[i] == 1:
        continue
    temp = CE[i]+(D[i]-1)+CO[-1]-CO[i+1]

    ans = max(ans, temp)
print(ans)
",O(n)
"
import collections


class Solution(object):
    def anagramMappings(self, A, B):
        lookup = collections.defaultdict(collections.deque)
        for i, n in enumerate(B):
            lookup[n].append(i)
        result = []
        for n in A:
            result.append(lookup[n].popleft())
        return result

",O(n)
"from sys import stdin

n, m = map(int, stdin.readline().split())
be, en, ans = 1, n, n + 1
while be <= en:
    md = (be + en) >> 1
    if md - sum(int(x) for x in str(md)) >= m:
        en = md - 1
        ans = md
    else:
        be = md + 1

print(n - ans + 1)
",O(logn)
"n=int(input())
dict1={}
dict2={}
for i in range(n):
    s=input()
    s=s.split('/')
    c=int(s[1])
    s=s[0].strip('(').strip(')').split('+')
    a=int(s[0])
    b=int(s[1])
    ans=(a+b)/c
    try:
        dict2[ans] += 1
    except:
        dict2[ans] = 1
    dict1[i] = ans
for i in range(n):
    print(dict2[dict1[i]],end=' ')
",O(n)
"n = int(input())
arr = list(map(int,input().strip().split()))[:n]

new = sorted(arr)
count = 0

for i in range(n):
    if arr[i] != new[i]:
        count += 1

if count <= 2:
    print('YES')
else:
    print('NO')
",O(nlogn)
"lst = []
ans = {'purple' : 'Power', 'green' : 'Time', 'blue': 'Space', ""orange"" : ""Soul"", ""red"" : ""Reality"", ""yellow"" : ""Mind""}
for i in range(int(input())):
    lst.append(input())
a = []
for i in ans.keys():
    if i not in lst:
        a.append(ans[i])
print(len(a))
for i in a:
    print(i)",O(1)
"n = int(input())
m = int(input())
print(m%2**n)",O(1)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, self.__next__)


class Solution(object):
    def mergeTwoLists(self, l1, l2):
        curr = dummy = ListNode(0)
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.__next__
            else:
                curr.next = l2
                l2 = l2.__next__
            curr = curr.__next__
        curr.next = l1 or l2
        return dummy.__next__",O(n)
"class Solution(object):
    def maxIncreasingSubarrays(self, nums):
        result = 0
        curr, prev = 1, 0
        for i in range(len(nums)-1):
            if nums[i] < nums[i+1]:
                curr += 1
            else:
                prev = curr
                curr = 1
            result = max(result, curr//2, min(prev, curr))
        return result",O(n)
"class Solution2(object):
    def minMeetingRooms(self, intervals):
        starts, ends = [], []
        for start, end in intervals:
            starts.append(start)
            ends.append(end)

        starts.sort()
        ends.sort()

        s, e = 0, 0
        min_rooms, cnt_rooms = 0, 0
        while s < len(starts):
            if starts[s] < ends[e]:
                cnt_rooms += 1 
                min_rooms = max(min_rooms, cnt_rooms)
                s += 1
            else:
                cnt_rooms -= 1 
                e += 1

        return min_rooms",O(nlogn)
"class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                if numbers[i] + numbers[j] == target:
                    return [i + 1, j + 1]
        return []
",O(n ^ 2)
"def mp():
    return map(int, input().split())

def f(i):
    return (10 ** i - 10 ** (i - 1)) * i

n = int(input())

i = 1
sum = 0
while n - f(i) >= 0:
    n -= f(i)
    sum += f(i) // i
    i += 1

print(str(sum + (n + i - 1) // i)[n % i - 1])",O(1)
"import sys

n = int(input())
prob = [list(map(float, input().split())) for _ in range(n)]
dp = [[0.0]*(1 << n) for _ in range(n)]
dp[0][1] = 1.0

for mask in range(3, 1 << n):
    for i in range(n):
        if not (mask & (1 << i)):
            continue
        for j in range(n):
            if i != j and mask & (1 << j):
                dp[i][mask] = max(
                    dp[i][mask],
                    dp[i][mask - (1 << j)] * prob[i][j]
                    + dp[j][mask - (1 << i)] * prob[j][i]
                )

print(max(dp[i][-1] for i in range(n)))
",np
"n, U = list(map(int, input().split()))
E = list(map(int, input().split()))

ind_i = 0
prev_ind_k = ind_i + 2

maxi_efficiency = -1
turn = 0
for ind_i in range(0, n - 2):
    ind_j = ind_i + 1
    prev_ind_k = max(prev_ind_k, ind_i + 2)
    Ei = E[ind_i]
    Ej = E[ind_j]
    for ind_k in range(prev_ind_k, n + 1):

        if ind_k == n:
            prev_ind_k = n - 1
            break
        Ek = E[ind_k]
        if (Ek - Ei) > U:
            prev_ind_k = ind_k - 1
            break

        efficiency = (Ek - Ej) / (Ek - Ei)

        if efficiency > maxi_efficiency:

            maxi_efficiency = efficiency

print(maxi_efficiency)
",O(nlogn)
"dic = {'purple':'Power', 'green':'Time','blue':'Space','orange':'Soul','red':'Reality','yellow':'Mind'}
n = int(input())
a = []
for i in range(n):
    a.append(input())
print(6-len(a))
for i in dic:
    if i not in a:
        print(dic[i])",O(1)
"def mus(x):
    c = 0
    while(x>0):
        c += x%10
        x = x//10
    return c
n,s=map(int,input().split())
ans = s + 10 - s%10
while(ans - mus(ans) < s):
    ans += 10
if ans > n:
    print(0)
else:
    print(n-ans+1)
",O(logn)
"from sys import  stdin
input=stdin.readline
from  collections import defaultdict
def num(s):
    l,r=0,0
    for i in s:
        if l==0 and i=="")"":
            r+=1
        elif i==""("":
            l+=1
        elif l and i=="")"":
            l-=1
    return (l,r)

def f(mp,cnt):
    ans=0
    for l in cnt:
        if l.count(0)<1:
            continue
        t=mp[l[::-1]]
        ans+=t
        if t and l!=l[::-1]:
            mp[l]-=1
    return ans

cnt=[]
mp=defaultdict(int)
for i in range(int(input())):
    s=input()
    l=num(s)
    cnt.append(l)
    mp[l]+=1
print(f(mp,cnt))",O(n)
"import collections



class Solution(object):
    def mostFrequentEven(self, nums):
        cnt = collections.Counter(x for x in nums if x%2 == 0)
        return max(iter(cnt.keys()), key=lambda x: (cnt[x], -x)) if cnt else -1",O(n)
"import math
n,r = list(map(int,input().split()))
angle = math.pi/(n)
c = math.sin(angle)
k = c/(1-c)
R = k*r
R = float(format(R,'.7f'))
print(R)",O(1)
"import sys

def ask(x):
    print('? %d'%x)
    sys.stdout.flush()
    x=int(input())
    return x

n=int(input())
t=n//2
if t&1:
    print('! -1')
    sys.stdout.flush()
    sys.exit()
l=1
r=n
while l<r:
    mid=(l+r)>>1
    if ask(mid)>=ask((mid+t-1)%n+1):
        r=mid
    else:
        l=mid+1
print('! %d'%l)
sys.stdout.flush()
",O(logn)
"from collections import deque


class Solution(object):
    def maxSlidingWindow(self, nums, k):
        result, dq = [], deque()
        for i in range(len(nums)):
            if dq and i-dq[0] == k:
                dq.popleft()
            while dq and nums[dq[-1]] <= nums[i]:
                dq.pop()
            dq.append(i)
            if i >= k-1:
                result.append(nums[dq[0]])
        return result",O(n)
"from math import gcd
import sys
input=sys.stdin.readline
from collections import defaultdict as dd
m=int(input())
d=dd(int)
l=[]
for i in range(m):
    s=input().split()[0]
    a=0
    b=0
    c=0
    n=len(s)
    ind=0
    for i in range(1,n):
        if(s[i]=='+'):
            ind=i+1
            break
        a=a*10+int(s[i])
    for i in range(ind,n):
        if(s[i]==')'):
            ind1=i+2
            break
        b=b*10+int(s[i])
    for i in range(ind1,n):
        c=c*10+int(s[i])
    a=a+b
    g=gcd(a,c)
    a=a//g
    c=c//g
    d[(a,c)]+=1
    l.append((a,c))
for i in l:
    print(d[i],end="" "")
",O(n)
"import random



class Solution(object):
    def maxStarSum(self, vals, edges, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        adj = [[] for _ in range(len(vals))]
        for u, v in edges:
            if vals[v] > 0:
                adj[u].append(v)
            if vals[u] > 0:
                adj[v].append(u)
        result = float(""-inf"")
        for u in range(len(vals)):
            if 1 <= k <= len(adj[u]):
                nth_element(adj[u], k-1, lambda a, b: vals[a] > vals[b])
            result = max(result, vals[u]+sum(vals[adj[u][i]] for i in range(min(k, len(adj[u])))))
        return result",O(n)
"
import collections


class Solution(object):
    def uniqueOccurrences(self, arr):
        count = collections.Counter(arr)
        lookup = set()
        for v in count.values():
            if v in lookup:
                return False
            lookup.add(v)
        return True


",O(n)
"
class Solution(object):
    def defangIPaddr(self, address):
        result = []
        for c in address:
            if c == '.':
                result.append(""[.]"")
            else:
                result.append(c)
        return """".join(result)
",O(n)
"import functools
import time
from collections import Counter

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:

    def __init__(self):
        pass

    def __call__(self):
        n = int(input())
        minv = n + 1
        mini = n
        for l in range(1, n + 1):
            v = l + (n + l - 1) // l
            if v < minv:
                minv = v
                mini = l

        ref = [i + 1 for i in range(n)]
        l = mini
        res = list()
        p = n - 1
        while p >= 0:
            pp = max(0, p - l + 1)
            res.extend(ref[pp:p + 1])
            p = pp - 1
        print(' '.join(map(str, res)))

solver()()",O(n)
"class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        heap = []
        output = []
        for i in range(len(nums)):
            heapq.heappush(heap, (-nums[i], i))
            if i >= k - 1:
                while heap[0][1] <= i - k:
                    heapq.heappop(heap)
                output.append(-heap[0][0])
        return output
",O(nlogn)
"n, m = map(int, input().split())
res = 0
mx = (n-1)*n//2
mn = 0
if n&1:
    mn = (n//2)*(n//2+1)
else:
    mn = n*n//4
for i in range(m):
    x, d = map(int, input().split())
    res += x*n
    if d > 0:
        res += mx*d
    else:
        res += mn*d
print('%.10f'%(res/n))
",O(n)
"def readline(): return map(int, input().split())

def main():
    n, a, b = readline()
    if a > 1 and b > 1:
        print('NO')
        return

    if n in [2, 3] and a == 1 and b == 1:
        print('NO')
        return

    matrix = [[i in [j + 1, j -1] for i in range(n)] for j in range(n)]

    a, b = n + 1 - a, n + 1 - b
    if a != n:
        matrix = [[False for i in range(n)] for j in range(n)]
        for i in range(n):
            for j in range(n):
                if i < a and j < a and i != j:
                    matrix[i][j] = True
    elif b != n:
        matrix = [[False for i in range(n)] for j in range(n)]
        for i in range(n):
            for j in range(n):
                if i >= b or j >= b:
                    matrix[i][j] = True
                if i == j:
                    matrix[i][j] = False

    print('YES')
    for row in matrix:
        print("""".join(map(lambda x: '1' if x else '0', row)), flush=False)

if __name__ == '__main__':
    main()
",O(n ^ 2)
"people,n=map(int,input().split())
a=list(map(int,input().split()))
a.sort()
d={}
tmp=[]
for i in range(n):
    if a[i] in d:
        d[a[i]]+=1
    else:
        d[a[i]]=1
d1={}
for i in d:
    if d[i] in d1:
        d1[d[i]]+=1
    else:
        d1[d[i]]=1
    tmp.append(d[i])
tmp.sort()
ans=0
for i in range(1,10001):
    x=people
    try:
        x-=d1[i]
    except:
        pass
    for j in d1:
        if j>i:
            x-=(j//i)*d1[j]
    if x<=0:
        ans=max(ans,i)
print(ans)",O(nlogn)
"n,p = map(int,input().split())
a  = list(map(int,input().split()))
forward = [a[0]]
for i in range(1,n):
    forward.append(forward[-1] + a[i])
sm = sum(a)
mx = -float('inf')
for i in range(n-1):
    mx = max(mx,(forward[i]%p) + ((sm -forward[i] )%p))
print(mx)",O(n)
"s = input().split()
hand = {'m': [], 'p': [], 's':[]}

for item in s:
	hand[item[1]].append(int(item[0]))

min_steps_needed = 10

for symb in ['m', 'p', 's']:
	hand[symb] = sorted(hand[symb])
	for start in range(1, 10):
		a_needed = 10
		b_needed = 10

		a_needed = 3 - hand[symb].count(start)

		b1, b2, b3 = 0, 0, 0
		if hand[symb].count(start) > 0:
			b1 = 1
		if hand[symb].count(start+1) > 0:
			b2 = 1
		if hand[symb].count(start+2) > 0:
			b3 = 1

		b_needed = 3 - b1 - b2 - b3

		if a_needed < min_steps_needed:
			min_steps_needed = a_needed
		if b_needed < min_steps_needed:
			min_steps_needed = b_needed

print(min_steps_needed)",O(n)
"class Solution(object):
    def largestNumber(self, num):
        num = [str(x) for x in num]
        num.sort(cmp=lambda x, y: cmp(y + x, x + y))
        largest = ''.join(num)
        return largest.lstrip('0') or '0'",O(nlogn)
"from sys import stdin,stdout
from itertools import accumulate
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):
    n,x=lst()
    a=lst()
    ans=0
    s=set(a)
    if len(s) != n:
        print(0)
        continue
    for i in range(n):
        v=a[i]
        a[i]&=x
        if a[i] in s and v!=a[i]:

            ans=1
            break
    if ans==1:print(1)
    elif len(set(a))==n:print(-1)
    else:print(2)",O(n)
"n,k = map(int,input().split())
a = list(map(int,input().split()))

count = 0
b = {}
for i in range(n):
    if a[i] in b:
        b[a[i]] += 1
    else:
        b[a[i]] =1
    if b[a[i]] == 1:
        count += 1
    if count == k:
        break

for j in range(n):
  if a[j] in b:
    b[a[j]] -= 1

  if b[a[j]] == 0:
    break

if count != k:
    print(""-1 -1"")
else:
  if n == 1:
    print(1,1)
  elif n == 2 and count == 2:
    print(1,2)
  else:
    print(j+1,i+1)",O(n)
"class Solution(object):
    def countBits(self, num):
        res = [0]
        for i in range(1, num + 1):
            res.append((i & 1) + res[i >> 1])
        return res

    def countBits2(self, num):
        s = [0]
        while len(s) <= num:
            s.extend([x + 1 for x in s])
        return s[:num + 1]",O(n)
"n = int(input())

print(n//2 + 1)
",O(1)
"import math
import collections
import bisect
import heapq
import time
import random
import itertools
import sys
from typing import List

def check(s, a, b, after):
    ns, na, nb = len(s), len(a), len(b)
    if ns < na + nb:
        return False

    dp = [[0 for _ in range(nb+1)] for _ in range(na+1)]
    for i in range(na+1):
        for j in range(nb+1):
            if i == 0 and j == 0:
                continue
            dp[i][j] = min(after[dp[i-1][j]][a[i-1]] if i > 0 else ns, after[dp[i][j-1]][b[j-1]] if j > 0 else ns) + 1

    return dp[na][nb] <= ns

def solve(s, t):
    ns = len(s)
    after = [[ns for _ in range(26)] for _ in range(ns+2)]
    for i in range(ns-1, -1, -1):
        for j in range(26):
            after[i][j] = after[i+1][j]
        after[i][s[i]] = i

    for i in range(len(t)):
        a, b = t[:i], t[i:]
        if check(s, a, b, after):
            return 'YES'

    return 'NO'

T = int(input())
ans = []
for i in range(T):
    s = input()
    t = input()
    s = [ord(v) - ord('a') for v in s]
    t = [ord(v) - ord('a') for v in t]
    ans.append(solve(s, t))

print('\n'.join(ans))",O(n ^ 3)
"class Solution2(object):
    def isDecomposable(self, s):
        found, i = False, 0
        while i < len(s):
            l = 1
            for j in range(i+1, min(i+3, len(s))):
                if s[j] != s[i]:
                    break
                l += 1
            if l < 2:
                return False
            if l == 2:
                if found:
                    return False
                found = True
            i += l  
        return found",O(n)
"class Solution(object):
    def hasTrailingZeros(self, nums):
        return sum(x%2 == 0 for x in nums) >= 2",O(n)
"class Solution:
    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:
        good = set()

        for t in triplets:
            if t[0] > target[0] or t[1] > target[1] or t[2] > target[2]:
                continue
            for i, v in enumerate(t):
                if v == target[i]:
                    good.add(i)
        return len(good) == 3
",O(n)
"import collections



class Solution(object):
    def minimumCoins(self, prices):
        dp = [float(""inf"")]*(len(prices)+1)
        dp[0] = 0
        dq = collections.deque()
        j = 0
        for i in range(len(prices)):
            while dq and dp[dq[-1]]+prices[dq[-1]] >= dp[i]+prices[i]:
                dq.pop()
            dq.append(i)
            while j+(j+1) < i:
                assert(len(dq) != 0)
                if dq[0] == j:
                    dq.popleft()
                j += 1
            dp[i+1] = dp[dq[0]]+prices[dq[0]]
        return dp[-1]",O(n)
"mod=1000000007
import math
def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m
def modInverse(b,m):
    g = math.gcd(b, m)
    if (g != 1):

        return -1
    else:

        return pow(b, m - 2, m)

def modDivide(a,b,m):
    a = a % m
    inv = modInverse(b,m)
    a=(a*inv)%m
    return a
n,k=map(int,input().split())
ans=(powm(4,k,mod)*n)%mod
r=powm(2,k,mod)
r=(powm(r,2,mod)-r)%mod
w=modDivide(r,2,mod)
ans=(ans-w)
er=powm(2,k,mod)
ans=modDivide(ans,er,mod)
ans=(ans*2)%mod
if n==0:
    ans=0
print(ans)",O(logn)
"class Solution3(object):
    def pancakeSort(self, A):
        def reverse(l, begin, end):
            for i in range((end-begin) // 2):
                l[begin+i], l[end-1-i] = l[end-1-i], l[begin+i]

        result = []
        for n in reversed(range(1, len(A)+1)):
            i = A.index(n)
            reverse(A, 0, i+1)
            result.append(i+1)
            reverse(A, 0, n)
            result.append(n)
        return result",O(n ^ 2)
"class Solution(object):
    def buttonWithLongestTime(self, events):
        return -max((events[i][1]-(events[i-1][1] if i-1 >= 0 else 0), -events[i][0])for i in range(len(events)))[1]",O(n)
"import sys
input=sys.stdin.readline
from collections import defaultdict
graph=defaultdict(list)
n=int(input())
par=[ int(i) for i in input().split() if i!='\n']
bulb=[1]*(n+1)
for i in range(n-1):
    bulb[par[i]]=0
    graph[par[i]].append(i+2)

zero=bulb.count(0)
for  i in range(n,0,-1):
    if bulb[i]==0:
        count=0
        for j in graph[i]:
            count+=bulb[j]
        bulb[i]=count
bulb=bulb[1:]
bulb.sort()
sys.stdout.write(' '.join(map(str,bulb)))
",O(n ^ 2)
"import sys

def ints():
    return map(int, input().split())

n, m, k = ints()
right = []
for i in range(n):
    right.append(list(ints()))
down = []
for i in range(n-1):
    down.append(list(ints()))

INF = int(1e8)

def around(r, c):
    a = []
    for i, j in [[r-1, c], [r, c+1], [r+1, c], [r, c-1]]:
        if not (i < 0 or i >= n or j < 0 or j >= m):
            a.append([i, j])
    return a

def mink(dist, si, sj):
    minn = INF
    for i in range(max(0, si-k//2), min(n, si+k//2+1)):
        for j in range(max(0, sj-k//2), min(m, sj+k//2+1)):
            if dist[i][j] < minn:
                minn = dist[i][j]
    return minn

def solve():
    pdist = [[0] * m for i in range(n)]
    if k & 1:
        return [[-1] * m for i in range(n)]
    for step in range(k//2):
        dist = [[0] * m for i in range(n)]
        for i in range(n):
            for j in range(m):
                adist = []
                for ip, jp in around(i, j):
                    if ip == i:
                        if jp > j:
                            w = right[i][j]
                        else:
                            w = right[i][jp]
                    else:
                        if ip > i:
                            w = down[i][j]
                        else:
                            w = down[ip][j]
                    adist.append(pdist[ip][jp] + w)
                dist[i][j] = min(adist)
        pdist = dist
    for i in range(n):
        for j in range(m):
            pdist[i][j] *= 2
    return pdist

for row in solve():
    print(*row)",O(n ^ 3)
"class Solution(object):
    def maxSumMinProduct(self, nums):
        MOD = 10**9+7
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        stk, result = [-1], 0
        for i in range(len(nums)+1):
            while stk[-1] != -1 and (i == len(nums) or nums[stk[-1]] >= nums[i]):
                result = max(result, nums[stk.pop()]*(prefix[(i-1)+1]-prefix[stk[-1]+1]))
            stk.append(i) 
        return result%MOD",O(n)
"from collections import deque
def bfs(n):
    global c,nd,ans,s
    while len(b)>0 and len(s)>0:
        aux=0
        for i in l[s[0]]:
            if not visited[i]:
                visited[i]=True
                dp[i]=1
                aux+=1
        for i in range(aux):
            x=b.popleft()
            if dp[x]==1:
                s.append(x)
                dp[x]=-1
            else:
                ans=""No""
                return
        s.popleft()

n=int(input())
visited=[False for i in range(n+2)]
dp=[-1 for i in range(n+2)]
l=[[] for i in range(n+2)]
for i in range(n-1):
    a,b=map(int,input().split())
    l[a].append(b)
    l[b].append(a)
b=deque(map(int,input().split()))
b.popleft()
s=deque([1])
ans=""Yes""
visited[1]=True
bfs(1)
print(ans)
",O(nlogn)
"import sys
input=sys.stdin.readline
n,m,k=map(int,input().strip().split("" ""))

lr=[]
for i in range(n):
	lr.append([100000001]+list(map(int,input().strip().split("" "")))+[100000001])
ud=[[100000001]*m]
for i in range(n-1):
	ud.append(list(map(int,input().strip().split("" ""))))
ud.append([100000001]*m)
o=[[1000000001]*(m+2)]
from copy import deepcopy
if k%2:
	for i in range(n):
		sys.stdout.write("" "".join([""-1""]*m)+""\n"")
	sys.exit()
for _ in range(n):
	oo=[100000001]
	for _ in range(m):
		oo.append(0)
	oo.append(100000001)
	o.append(oo)
o.append([100000001]*(m+2))
for _ in range(k//2):
	oo=deepcopy(o)
	for i in range(1,n+1):
		for j in range(1,m+1):
			oo[i][j]=min(lr[i-1][j-1]+o[i][j-1],lr[i-1][j]+o[i][j+1],ud[i-1][j-1]+o[i-1][j],ud[i][j-1]+o[i+1][j])
	o=deepcopy(oo)
for i in o[1:n+1]:
	sys.stdout.write("" "".join(map(str,[j*2 for j in i[1:m+1]]))+""\n"")
",O(n ^ 3)
"input_arr = [int(i) for i in input().split()]
a,b = input_arr

def dec_to_bin(N):
    res=[0]*64

    pos=0
    while N!=0:
        last_bit = N & 1
        res[pos] = last_bit
        pos+=1
        N=N>>1
    return res

def max_xor(a,b):
    a_bin = dec_to_bin(a)
    b_bin = dec_to_bin(b)

    res = """"
    x = """"
    y = """"
    diff_pt_found = False

    for i in range(len(a_bin)-1,-1,-1):

        if diff_pt_found == False and a_bin[i] == b_bin[i]:
            x+=str(a_bin[i])
            y+=str(b_bin[i])

        if diff_pt_found == False and a_bin[i] != b_bin[i]:
            diff_pt_found = True
            x+=str(a_bin[i])
            y+=str(b_bin[i])

            res+=""1""
            continue

        if diff_pt_found == True:
            if a_bin[i] != b_bin[i]:
                res+=""1""
                x+=str(a_bin[i])
                y+=str(b_bin[i])
            elif b_bin[i]==1:
                res+=""1""

                x+=str(a_bin[i])
                y+=str(0)
            elif a_bin[i]==0:
                res+=""1""

                x+=str(1)
                y+=str(b_bin[i])

    return x,y,res

def bin_to_dec(bin):
    bin = str(bin)
    mul = 1
    res=0
    for i in range(len(bin)-1,-1,-1):
        if bin[i]=='1':
            res+=mul

        mul=mul*2

    return res

x,y,res = max_xor(a,b)

print(bin_to_dec(res))",O(logn)
"from sys import stdin
from itertools import combinations
n, l, r , x = map(int, stdin.readline().rstrip().split("" ""))
li = list(map(int, stdin.readline().rstrip().split("" "")))
z = []
ans = 0
for i in range(2, n+1):
    z += list(combinations(li, i))

for i in z:
    a = sorted(i)
    if a[-1]-a[0]>=x and r >= sum(a) >= l:
        ans+=1

print(ans)",np
"class Solution:
    def isNStraightHand(self, hand, groupSize):
        if len(hand) % groupSize != 0:
            return False

        count = Counter(hand)
        q = deque()
        last_num, open_groups = -1, 0

        for num in sorted(count):
            if ((open_groups > 0 and num > last_num + 1) or
                open_groups > count[num]
            ):
                return False

            q.append(count[num] - open_groups)
            last_num = num
            open_groups = count[num]

            if len(q) == groupSize:
                open_groups -= q.popleft()

        return open_groups == 0
",O(nlogn)
"class Solution:
    def getSum(self, a: int, b: int) -> int:
        return a + b
",O(1)
"class Solution(object):
    def minSkips(self, dist, speed, hoursBefore):
        def ceil(a, b):
            return (a+b-1)//b

        dp = [0]*((len(dist)-1)+1) 
        for i, d in enumerate(dist):
            for j in reversed(range(len(dp))):
                dp[j] = ceil(dp[j]+d, speed)*speed if i < len(dist)-1 else dp[j]+d
                if j-1 >= 0:
                    dp[j] = min(dp[j], dp[j-1]+d)
        target = hoursBefore*speed
        for i in range(len(dist)):
            if dp[i] <= target:
                return i
        return -1",O(n ^ 2)
"import math


class Solution(object):
    def arrangeCoins(self, n):
        return int((math.sqrt(8*n+1)-1) / 2)",O(1)
"from collections import deque


class Solution(object):

    def __init__(self, vec2d):
        self.stack = deque((len(v), iter(v)) for v in vec2d if v)

    def __next__(self):
        length, iterator = self.stack.popleft()
        if length > 1:
            self.stack.appendleft((length-1, iterator))
        return next(iterator)

    def hasNext(self):
        return bool(self.stack)",O(1)
"import collections



class Solution(object):
    def finalString(self, s):
        dq = collections.deque()
        parity = 0
        for x in s:
            if x == 'i':
                parity ^= 1
            else:
                dq.appendleft(x) if parity else dq.append(x)
        if parity:
            dq.reverse()
        return """".join(dq)",O(n)
"def bin_search(n):
    if n==1:
        return 1
    l = 0;r = n;
    while(r - 1 > l):

        mid = (l+r)//2

        val = mid*(mid+1)//2
        if val == n:
            return mid
        elif val > n:
            r = mid
        else:
            l = mid

    return l

n,k = [int(i) for i in input().split()]

if k*(k-1)//2 < n - 1:
    print(-1)

elif n == 1:
    print(0)
elif n <= k:
    print(1)

else:
    print(k - 1 - bin_search(k*(k-1)//2 - n + 1))",O(logn)
"class Solution(object):
    def firstMissingPositive(self, A):
        i = 0
        while i < len(A):
            if A[i] > 0 and A[i] - 1 < len(A) and A[i] != A[A[i]-1]:
                A[A[i]-1], A[i] = A[i], A[A[i]-1]
            else:
                i += 1

        for i, integer in enumerate(A):
            if integer != i + 1:
                return i + 1
        return len(A) + 1",O(n)
"s = input()
sLen, ans = len(s), 0

for i in range(sLen - 1):
    for till1 in range(i + 1, sLen):
        till2 = till1 + 1
        for j in range(i + 1, sLen):
            if till2 > sLen:
                break;
            sub1 = s[i:till1]
            sub2 = s[j:till2]
            subLen = len(sub1)
            if sub1 == sub2 and subLen > ans:
                ans = subLen
            till2 += 1

print(ans)
",O(n ^ 3)
"from bisect import bisect,bisect_left

from collections import *
from heapq import *
from math import gcd,ceil,sqrt,floor,inf

from itertools import *
from operator import add,mul,sub,xor,truediv,floordiv
from functools import *

import os
import sys

from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def RL(): return map(int, sys.stdin.readline().split())
def RLL(): return list(map(int, sys.stdin.readline().split()))
def N(): return int(input())
def A(n):return [0]*n
def AI(n,x): return [x]*n
def A2(n,m): return [[0]*m for i in range(n)]
def G(n): return [[] for i in range(n)]
def GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]

from types import GeneratorType

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

mod=10**9+7
farr=[1]
ifa=[]

def fact(x,mod=0):
    if mod:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr)%mod)
    else:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr))
    return farr[x]

def ifact(x,mod):
    global ifa
    fact(x,mod)
    ifa.append(pow(farr[-1],mod-2,mod))
    for i in range(x,0,-1):
        ifa.append(ifa[-1]*i%mod)
    ifa.reverse()

def per(i,j,mod=0):
    if i<j: return 0
    if not mod:
        return fact(i)//fact(i-j)
    return farr[i]*ifa[i-j]%mod

def com(i,j,mod=0):
    if i<j: return 0
    if not mod:
        return per(i,j)//fact(j)
    return per(i,j,mod)*ifa[j]%mod

def catalan(n):
    return com(2*n,n)//(n+1)

def isprime(n):
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return False
    return True

def floorsum(a,b,c,n):
    if a==0:return b//c*(n+1)
    if a>=c or b>=c: return floorsum(a%c,b%c,c,n)+b//c*(n+1)+a//c*n*(n+1)//2
    m=(a*n+b)//c
    return n*m-floorsum(c,c-b-1,a,m-1)

def inverse(a,m):
    a%=m
    if a<=1: return a
    return ((1-inverse(m,a)*m)//a)%m

def lowbit(n):
    return n&-n

class BIT:
    def __init__(self,arr):
        self.arr=arr
        self.n=len(arr)-1

    def update(self,x,v):
        while x<=self.n:
            self.arr[x]+=v
            x+=x&-x

    def query(self,x):
        ans=0
        while x:
            ans+=self.arr[x]
            x&=x-1
        return ans

class ST:
    def __init__(self,arr):
        n=len(arr)
        mx=n.bit_length()
        self.st=[[0]*mx for i in range(n)]
        for i in range(n):
            self.st[i][0]=arr[i]
        for j in range(1,mx):
            for i in range(n-(1<<j)+1):
                self.st[i][j]=max(self.st[i][j-1],self.st[i+(1<<j-1)][j-1])
    def query(self,l,r):
        if l>r:return -inf
        s=(r+1-l).bit_length()-1
        return max(self.st[l][s],self.st[r-(1<<s)+1][s])

class DSU:
    def __init__(self,n):
        self.c=[-1]*n

    def same(self,x,y):
        return self.find(x)==self.find(y)

    def find(self,x):
        if self.c[x]<0:
            return x
        self.c[x]=self.find(self.c[x])
        return self.c[x]

    def union(self,u,v):
        u,v=self.find(u),self.find(v)
        if u==v:
            return False
        if self.c[u]>self.c[v]:
            u,v=v,u
        self.c[u]+=self.c[v]
        self.c[v]=u
        return True

    def size(self,x): return -self.c[self.find(x)]

class UFS:
    def __init__(self,n):
        self.parent=[i for i in range(n)]
        self.ranks=[0]*n

    def find(self,x):
        if x!=self.parent[x]:
            self.parent[x]=self.find(self.parent[x])
        return self.parent[x]

    def union(self,u,v):
        pu,pv=self.find(u),self.find(v)
        if pu==pv:
            return False
        if self.ranks[pu]>=self.ranks[pv]:
            self.parent[pv]=pu
            if self.ranks[pv]==self.ranks[pu]:
                self.ranks[pu]+=1
        else:
            self.parent[pu]=pv

class UF:
    def __init__(self,n):
        self.parent=[i for i in range(n)]
        self.ranks=[0]*n
        self.size=AI(n,1)
        self.edge=A(n)

    def find(self,x):
        if x!=self.parent[x]:
            self.parent[x]=self.find(self.parent[x])
        return self.parent[x]

    def union(self,u,v):
        pu,pv=self.find(u),self.find(v)
        if pu==pv:
            self.edge[pu]+=1
            return False
        if self.ranks[pu]>=self.ranks[pv]:
            self.parent[pv]=pu
            self.edge[pu]+=self.edge[pv]+1
            self.size[pu]+=self.size[pv]
            if self.ranks[pv]==self.ranks[pu]:
                self.ranks[pu]+=1
        else:
            self.parent[pu]=pv
            self.edge[pv]+=self.edge[pu]+1
            self.size[pv]+=self.size[pu]

def Prime(n):
    c=0
    prime=[]
    flag=[0]*(n+1)
    for i in range(2,n+1):
        if not flag[i]:
            prime.append(i)
            c+=1
        for j in range(c):
            if i*prime[j]>n: break
            flag[i*prime[j]]=prime[j]
            if i%prime[j]==0: break
    return flag

def dij(s,graph):
    d=AI(n,inf)
    d[s]=0
    heap=[(0,s)]
    vis=A(n)
    while heap:
        dis,u=heappop(heap)
        if vis[u]:
            continue
        vis[u]=1
        for v,w in graph[u]:
            if d[v]>d[u]+w:
                d[v]=d[u]+w
                heappush(heap,(d[v],v))
    return d

def bell(s,g):
    dis=AI(n,inf)
    dis[s]=0
    for i in range(n-1):
        for u,v,w in edge:
            if dis[v]>dis[u]+w:
                dis[v]=dis[u]+w
    change=A(n)
    for i in range(n):
        for u,v,w in edge:
            if dis[v]>dis[u]+w:
                dis[v]=dis[u]+w
                change[v]=1
    return dis

def lcm(a,b): return a*b//gcd(a,b)
def lis(nums):
    res=[]
    for k in nums:
        i=bisect.bisect_left(res,k)
        if i==len(res):
            res.append(k)
        else:
            res[i]=k
    return len(res)

def RP(nums):
    n = len(nums)
    s=set(nums)
    d={}
    for i,k in enumerate(sorted(s),1):
        d[k]=i
    bi=BIT([0]*(len(s)+1))
    ans=0
    for i in range(n-1,-1,-1):
        ans+=bi.query(d[nums[i]]-1)
        bi.update(d[nums[i]],1)
    return ans

class DLN:
    def __init__(self,val):
        self.val=val
        self.pre=None
        self.next=None

def nb(i,j,n,m):
    for ni,nj in [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]:
        if 0<=ni<n and 0<=nj<m:
            yield ni,nj

def topo(n):
    q=deque()
    res=[]
    for i in range(1,n+1):
        if ind[i]==0:
            q.append(i)
            res.append(i)
    while q:
        u=q.popleft()
        for v in g[u]:
            ind[v]-=1
            if ind[v]==0:
                q.append(v)
                res.append(v)
    return res

@bootstrap
def gdfs(r,p):
    for ch in g[r]:
        if ch!=p:
            yield gdfs(ch,r)
    yield None

t=1
for i in range(t):
    n,mod=RL()

    ma=(n+1)//2
    ifact(n,mod)
    dp=A2(n+1,ma+1)
    f=A(n+1)
    f[1]=1
    f[2]=2
    f[3]=4
    for i in range(4,n+1):
        f[i]=f[i-1]*2%mod
    dp[1][1]=1
    dp[2][1]=2
    dp[3][1]=4
    dp[3][2]=2
    for i in range(4,n+1):
        dp[i][1]=f[i]
        for k in range(2,(i+1)//2+1):
            for x in range(1,i-2*k+3):

                dp[i][k]+=dp[i-x-1][k-1]*f[x]%mod*ifa[x]%mod*fact(i-k+1,mod)%mod*ifa[i-k-x+1]%mod
                dp[i][k]%=mod
    ans=0
    for k in range(1,ma+1):
        ans=(ans+dp[n][k])%mod
    print(ans)
",O(n ^ 3)
"class Solution2(object):
    def maxAbsValExpr(self, arr1, arr2):
        return max(max(c1*arr1[i] + c2*arr2[i] + i for i in range(len(arr1))) -
                   min(c1*arr1[i] + c2*arr2[i] + i for i in range(len(arr1)))
                   for c1 in [1, -1] for c2 in [1, -1])",O(n)
"class Solution(object):
    def smallestNumber(self, n):
        return (1<<n.bit_length())-1",O(1)
"def isValid(field, y, x):
	for i in range(3):
		for j in range(3):
			if i == 1 and j == 1:
				continue
			if field[y + i][x + j] == '.':
				return False
	return True
def fill(field, y, x):
	for i in range(3):
		for j in range(3):
			if i == 1 and j == 1:
				continue
			cur[y + i][x + j] = '
n, m = list(map(int, input().split()))
sig = []
cur = []
for i in range(n):
	sig += [list(input())]
	cur += [["".""] * m]

for i in range(n - 2):
	for j in range(m - 2):
		if isValid(sig, i, j):
			fill(cur, i, j)

if sig == cur:
	print(""YES"")
else:
	print(""NO"")",O(n ^ 2)
"def nr(): return nrs()[0]
def nrs(): return [int(i) for i in input().split()]

def get_prime(n):
	res = []
	for i in range(2,n):
		is_prime = True
		for x in res:
			if i % x == 0:
				is_prime = False
				break
		if is_prime: res.append(i)
	return res

prime = get_prime(3162)

cache = {}
def get_mask (num):
	key = num
	if key in cache: return cache[key]
	dv = []
	for p in prime:
		c = 0
		while num % p == 0:
			c += 1
			num = num // p
		if c % 2 == 1:
			dv.append(p)
		if num < p * p:
			break

	for x in dv:
		num *= x

	cache[key] = num
	return num

for _ in range(nr()):
	N, K = nrs()
	A = nrs()
	dp = [N] * (K + 1)
	dp[0] = 1
	used = [{}] * (K + 1)
	for a in A:
		a = get_mask(a)
		for j in range(K, -1, -1):
			if dp[j] == N: continue
			if a in used[j]:
				if j < K and dp[j + 1] > dp[j]:
					dp[j + 1] = dp[j]
					used[j + 1] = used[j]
				dp[j] += 1
				used[j] = {}
			used[j][a] = 1
	print(min(dp))
",O(n ^ 3)
"n, k = map(int, input().split())
if n == 1:
    print(0)
elif (k*k -k)//2 +1 < n:
    print(-1)
else:
    g, b = 0, k//2
    while b != 0:
        while g +b <= k and (k*k -k)//2 +1 -((g +b)**2 -(g +b))//2 >= n:
            g += b
        b //= 2
    print(k -g)
",O(logn)
"class Solution2(object):
    def maximumScoreAfterOperations(self, edges, values):
        def dfs(u, p):
            if len(adj[u]) == (1 if u else 0):
                return values[u]
            return min(sum(dfs(v, u) for v in adj[u] if v != p), values[u]) 

        adj = [[] for _ in range(len(values))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return sum(values)-dfs(0, -1)",O(n)
"n=int(input())
m=int(input())
a=list(map(int, input().split()))
b=list(map(int, input().split()))
curr=m
f=0
if b[0]!=1:
    curr+=(curr)/(b[0]-1)
else:
    f=1
for i in range(n-1,-1,-1):
    if a[i]!=1:
        curr+=(curr)/(a[i]-1)
    else:
        f=1
    if i>0:
        if b[i]!=1:
            curr+=(curr)/(b[i]-1)
        else:
            f=1
if f:
    print(-1)
else:
    print(curr-m)
",O(n)
"class Solution(object):
    def parseBoolExpr(self, expression):
        def parse(expression, i):
            if expression[i[0]] not in ""&|!"":
                result = expression[i[0]] == 't'
                i[0] += 1
                return result
            op = expression[i[0]]
            i[0] += 2
            stk = []
            while expression[i[0]] != ')':
                if expression[i[0]] == ',': 
                    i[0] += 1
                    continue
                stk.append(parse(expression, i))
            i[0] += 1
            if op == '&':
                return all(stk)
            if op == '|':
                return any(stk)
            return not stk[0]

        return parse(expression, [0])",O(n)
"n = int(input())
a = str(input())
b = str(input())
k = True
result = 0
for i in range(n):
    if a[i] == b[i]:
        if k == False:
            result += 1
        k = True
    else:
        if k == False and z != a[i]:
            result += 1
            k = True
        elif k == False and z == a[i]:
            result += 1
        else:
            k = False
            z = a[i]
if k == False:
    result += 1
print(result)",O(n)
"class Solution(object):
    def minimumDeletions(self, s):
        result = b_cnt = 0
        for c in s:
            if c == 'b':
                b_cnt += 1
            elif b_cnt:
                b_cnt -= 1
                result += 1
        return result",O(n)
"class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        seen = [0] * len(nums)
        for num in nums:
            if seen[num - 1]:
                return num
            seen[num - 1] = 1
        return -1
",O(n)
"import math

str1 = input()
str2 = input()
value = 0
value_2 = 0
unknown = 0
for x in str1:
    if x == '+':
        value += 1
    else:
        value -= 1
for x in str2:
    if x == '+':
        value_2 += 1
    elif x == '-':
        value_2 -= 1
    else:
        unknown += 1
plus_count = 0
minus_count = 0
rav = 0
x = value - value_2
if abs(x)<= unknown:
    if x >= 0:
        plus_count += x
        rav = unknown - plus_count
    else:
        minus_count += x
        rav = unknown - minus_count

    if plus_count == 0 and minus_count == 0 and rav == 0:
        print('1.000000000000')
    else:
        if rav % 2 == 0:
            rav = int(rav / 2)
            plus_count += rav
            minus_count += rav

            k = max(plus_count, minus_count)
            C = math.factorial(unknown) / (math.factorial(unknown - k) * math.factorial(k))
            O = math.pow(2, unknown)
            res = C / O
            print(f'{res:.12f}')
        else:
            print('0.000000000000')
else:
    print('0.000000000000')
",np
"def main():
    q = int(input())
    for i in range(q):
        n, k = map(int, input().split())
        s = input()
        min_ans = 10 ** 9
        for i in range(n - k + 1):
            count1 = 0
            count2 = 0
            count3 = 0
            for j in range(k):
                if (i + j) % 3 == 0:
                    if s[i + j] != ""R"":
                        count1 += 1
                    if s[i + j] != ""G"":
                        count2 += 1
                    if s[i + j] != ""B"":
                        count3 += 1
                if (i + j) % 3 == 1:
                    if s[i + j] != ""G"":
                        count1 += 1
                    if s[i + j] != ""B"":
                        count2 += 1
                    if s[i + j] != ""R"":
                        count3 += 1
                if (i + j) % 3 == 2:
                    if s[i + j] != ""B"":
                        count1 += 1
                    if s[i + j] != ""R"":
                        count2 += 1
                    if s[i + j] != ""G"":
                        count3 += 1
            min_ans = min(min_ans, count1, count2, count3)
        print(min_ans)
main()",O(n ^ 2)
"def get(g):
    s = [str(i) for i in g]
    num = int("""".join(s))
    return num

a = input()
b = input()
bb = int(b)
mark = [0 for i in range(len(a))]
c = a
f = []
g = []

for i in range(0 , len(a)):
    g.append(a[i])

g.sort()
g.reverse()
num = get(g)

index = []

if num <= bb:
    print(num)
    exit(0)

for i in range(0 , min(len(a) , len(b))):
    mx = '-1'
    idx = 0
    for j in range(0 , len(a)):
        if mark[j] == 0 and a[j] <= b[i]:
            if a[j] > mx:
                mx = a[j]
                idx = j

    if mx == '-1':
        rem = []

        while True and len(f) > 0:
            ma = '-1'
            id = 0
            for j in range(0 , len(a)):
                if mark[j] == 0 and a[j] < f[-1]:
                    if a[j] > ma:
                        ma = a[j]
                        id = j

            if ma == '-1':
                mark[index.pop()] = 0
                f.pop()
                continue
            else:
                mark[index.pop()] = 0
                f.pop()
                f.append(ma)
                mark[id] = 1
                break

        for j in range(0, len(a)):
            if mark[j] == 0:
                rem.append(a[j])

        rem.sort()
        rem.reverse()

        for j in rem:
            f.append(j)

        print(get(f))
        exit(0)

    f.append(mx)
    mark[idx] = 1
    index.append(idx)

    if mx < b[i] and mx != '-1':
        break

rem = []

for i in range(0 , len(a)):
    if mark[i] == 0:
        rem.append(a[i])

rem.sort()
rem.reverse()
for i in rem:
    f.append(i)

print(get(f))",O(n ^ 3)
"class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow, fast = 0, 0
        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow == fast:
                break

        slow2 = 0
        while True:
            slow = nums[slow]
            slow2 = nums[slow2]
            if slow == slow2:
                return slow
",O(n)
"t=int(input())
for i in range(t):
    n=int(input())
    g=list(map(int,input().split()))
    m1=max(g)
    g.remove(m1)
    m2=max(g)
    dl=len(g)-1
    print(min(dl,m2-1))",O(1)
"def bin(num):
    i=9*num*11
    count=0
    add=0
    for j in range(100):
        add=0
        a=str(i)
        for k in range(10):
            add+=(a.count(str(k))*k)
        if i-add>=s:
            return i
        i+=1
    return -1

n,s=map(int,input().split())
i=0
j=10**30
limit=0
while i<j:
    m=(i+j)//2
    if bin(m) == -1:
        i=m+1
    else:
        j=m
print(max(0,n-bin(i)+1))",O(logn)
"class Solution(object):
    def numberOfPairs(self, points):
        points.sort(key=lambda x: (x[0], -x[1]))
        result = 0
        for i in range(len(points)):
            y = float(""-inf"")
            for j in range(i+1, len(points)):
                if points[i][1] < points[j][1]:
                    continue
                if points[j][1] > y:
                    y = points[j][1]
                    result += 1
        return result",O(n ^ 2)
"for _ in range(int(input())):
    a,b=map(int,input().split())
    ans=int(0)
    while a and b:
        a,b=min(a,b),max(a,b)
        ans,b=ans+b//a,b%a
    print(ans)
",O(1)
"a, b, c, n= map(int, input().split())
p = a + b - c
if p <= n-1 and a - c >= 0 and b - c >= 0:
    print(n - p)
else :
    print(-1)
",O(1)
"class Solution(object):
    def minSwaps(self, s):
        result = curr = 0
        for c in s:
            if c == ']':
                curr += 1
                result = max(result, curr)
            else:
                curr -= 1
        return (result+1)//2",O(n)
"from collections import namedtuple
import sys

HS = namedtuple('HS', 'x1 x2 y')

n, m = [int(w) for w in input().split()]
vs = [int(input()) for _ in range(n)]
hs = [HS(*[int(w) for w in input().split()]) for _ in range(m)]

vs.sort()

hr = len([s for s in hs if s.x1 == 1 and s.x2 == 10**9])
hs = [s.x2 for s in hs if s.x1 == 1 and s.x2 < 10**9]
hs.sort()

r = hc = len(hs)
hi = vi = 0
for hi in range(hc):
    while vi < n and hs[hi] >= vs[vi]:
        vi += 1
    c = (hc - hi - 1) + vi
    if c < r:
        r = c

print(r + hr)
",O(nlogn)
"class Solution(object):
    def minimumSwap(self, s1, s2):
        x1, y1 = 0, 0
        for i in range(len(s1)):
            if s1[i] == s2[i]:
                continue
            x1 += int(s1[i] == 'x')
            y1 += int(s1[i] == 'y')
        if x1%2 !=  y1%2: 
            return -1
        return (x1//2 + y1//2) + (x1%2 + y1%2)",O(n)
"A=[9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889]
k=int(input())
if k<10:
    print(k)
else:
    for n in range (0,12):
        if k>A[n+1]:
            continue
        else:
            a=10**(n+1)+(k-A[n]-1)//(n+2)
            b=(k-A[n]-1)%(n+2)
            print(str(a)[b])
            break",O(logn)
"class Solution5(object):
    def lastMarkedNodes(self, edges):
        def increase(x):
            return (x[0]+1, x[1])

        def dfs1(u, p):
            for v in adj[u]:
                if v == p:
                    continue
                dfs1(v, u)
                curr = increase(dp[v][0])
                for i in range(len(dp[u])):
                    if curr > dp[u][i]:
                        curr, dp[u][i] = dp[u][i], curr

        def dfs2(u, p, curr):
            for v in adj[u]:
                if v == p:
                    continue
                dfs2(v, u, increase(max(dp[u][dp[u][0][1] == dp[v][0][1]], curr)))
            result[u] = max(dp[u][0], curr)[1]
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = [[(0, u)]*2 for u in range(len(adj))]
        dfs1(0, -1)
        result = [-1]*len(adj)
        dfs2(0, -1, (0, -1))
        return result",O(n)
"def get_answer(arr):
    current_sum = 0
    total = sum(arr)
    for index, val in enumerate(arr):
        current_sum += val
        if current_sum >= total / 2:
            return index + 1

nonsense = input()
input_values = input()
values = [int(v) for v in input_values.split()]

print(get_answer(values))
",O(n)
"x, k = map(int,input().split())
if x == 0:
    print(0)
    exit()
b = pow(2,k,1000000007)
a = (2*x - 1)%(1000000007)
print((a*b + 1) % 1000000007)",O(logn)
"import random


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def kthLargestLevelSum(self, root, k):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        arr = []
        q = [root]
        while q:
            new_q = []
            for u in q:
                if u.left:
                    new_q.append(u.left)
                if u.right:
                    new_q.append(u.right)
            arr.append(sum(x.val for x in q))
            q = new_q
        if k-1 >= len(arr):
            return -1
        nth_element(arr, k-1, compare=lambda a, b: a > b)
        return arr[k-1]",O(n)
"class Solution(object):
    def minSwapsCouples(self, row):
        N = len(row)//2
        couples = [[] for _ in range(N)]
        for seat, num in enumerate(row):
            couples[num//2].append(seat//2)
        adj = [[] for _ in range(N)]
        for couch1, couch2 in couples:
            adj[couch1].append(couch2)
            adj[couch2].append(couch1)

        result = 0
        for couch in range(N):
            if not adj[couch]: continue
            couch1, couch2 = couch, adj[couch].pop()
            while couch2 != couch:
                result += 1
                adj[couch2].remove(couch1)
                couch1, couch2 = couch2, adj[couch2].pop()
        return result",O(n)
"class Solution(object):
    def encode(self, s):
        def encode_substr(dp, s, i, j):
            temp = s[i:j+1]
            pos = (temp + temp).find(temp, 1) 
            if pos >= len(temp):
                return temp
            return str(len(temp)/pos) + '[' + dp[i][i + pos - 1] + ']'

        dp = [["""" for _ in range(len(s))] for _ in range(len(s))]
        for length in range(1, len(s)+1):
            for i in range(len(s)+1-length):
                j = i+length-1
                dp[i][j] = s[i:i+length]
                for k in range(i, j):
                    if len(dp[i][k]) + len(dp[k+1][j]) < len(dp[i][j]):
                        dp[i][j] = dp[i][k] + dp[k+1][j]
                encoded_string = encode_substr(dp, s, i, j)
                if len(encoded_string) < len(dp[i][j]):
                    dp[i][j] = encoded_string
        return dp[0][len(s) - 1]",O(n ^ 3)
"

class Solution(object):
    def repeatedCharacter(self, s):
        lookup = set()
        for c in s:
            if c in lookup:
                break
            lookup.add(c)
        return c
",O(n)
"import math as ma
import sys
from sys import exit
from decimal import Decimal as dec
from itertools import permutations

def li():
	return list(map(int , input().split()))

def num():
	return map(int , input().split())

def nu():
	return int(input())

n,s=num()
cc=0
for i in range(n,0,-1):
	cc+=s//i
	s=s%i
print(cc)",O(1)
"import itertools


class Solution(object):
    def compareVersion(self, version1, version2):
        n1, n2 = len(version1), len(version2)
        i, j = 0, 0
        while i < n1 or j < n2:
            v1, v2 = 0, 0
            while i < n1 and version1[i] != '.':
                v1 = v1 * 10 + int(version1[i])
                i += 1
            while j < n2 and version2[j] != '.':
                v2 = v2 * 10 + int(version2[j])
                j += 1
            if v1 != v2:
                return 1 if v1 > v2 else -1
            i += 1
            j += 1

        return 0",O(n)
"class Solution(object):
    def maximumWhiteTiles(self, tiles, carpetLen):
        tiles.sort()
        result = right = gap = 0
        for left, (l, _) in enumerate(tiles):
            if left-1 >= 0:
                gap -= tiles[left][0]-tiles[left-1][1]-1
            r = l+carpetLen-1
            while right+1 < len(tiles) and r+1 >= tiles[right+1][0]:
                right += 1
                gap += tiles[right][0]-tiles[right-1][1]-1
            result = max(result, min(tiles[right][1]-tiles[left][0]+1, carpetLen)-gap)
        return result",O(nlogn)
"import collections



class Solution(object):
    def countCompleteSubarrays(self, nums):
        nums_set = set(nums)
        result = left = 0
        cnt = collections.Counter()
        for right in range(len(nums)):
            cnt[nums[right]] += 1
            while len(cnt) == len(nums_set):
                cnt[nums[left]] -= 1
                if cnt[nums[left]] == 0:
                    del cnt[nums[left]]
                left += 1
            result += left
        return result",O(n)
"n = int(input())
dp = [1]
for IND in range(n):
    c = input()
    if c == ""f"":
        dp.insert(0,0)
    else:
        for i in range(len(dp)-2, -1, -1): dp[i] = (dp[i] + dp[i+1]) % 1000000007
print(dp[0])",O(n ^ 2)
"n=int(input())
a=list(map(int,input().split()))
l=list(set(a))
l.sort()
if len(l) >=2:
    print(l[1])
else:
    print(""NO"")",O(nlogn)
"class Solution(object):
    def countPairsOfConnectableServers(self, edges, signalSpeed):
        def iter_dfs(u, p, dist):
            result = 0
            stk = [(u, p, dist)]
            while stk:
                u, p, dist = stk.pop()
                if dist%signalSpeed == 0:
                    result += 1
                for v, w in reversed(adj[u]):
                    if v == p:
                        continue
                    stk.append((v, u, dist+w))
            return result
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        result = [0]*(len(edges)+1)
        for u in range(len(result)):
            curr = 0
            for v, w in adj[u]:
                cnt = iter_dfs(v, u, w)
                result[u] += curr*cnt
                curr += cnt
        return result",O(n ^ 2)
"class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        if not head:
            return

        nodes = []
        cur = head
        while cur:
            nodes.append(cur)
            cur = cur.next

        i, j = 0, len(nodes) - 1
        while i < j:
            nodes[i].next = nodes[j]
            i += 1
            if i >= j:
                break
            nodes[j].next = nodes[i]
            j -= 1

        nodes[i].next = None
",O(n)
"def findSet(u, parent):
    if parent[u] != u:
        parent[u] = findSet(parent[u], parent)
    return parent[u]

def unionSet(u, v, parent):
    up = findSet(u, parent)
    vp = findSet(v, parent)
    parent[up] = vp

if __name__ == '__main__':
    n, a, b = map(int, input().split())
    lst = list(map(int, input().split()))
    parent = [i for i in range(n + 2)]
    temp = {lst[i]: i for i in range(n)}
    for i in range(n):
        if a - lst[i] in temp:
            unionSet(i, temp[a - lst[i]], parent)
        else:
            unionSet(i, n, parent)
        if b - lst[i] in temp:
            unionSet(i, temp[b - lst[i]], parent)
        else:
            unionSet(i, n + 1, parent)

    pa = findSet(n, parent)
    pb = findSet(n + 1, parent)
    if pa == pb:
        print('NO')
    else:
        print('YES')
        lst = [0 if findSet(i, parent) == pb else 1 for i in range(n)]
        print(*lst)",O(n)
"import sys
def power(x, y, p) :
    res = 1

    x = x % p

    while (y > 0) :

        if ((y & 1) == 1) :
            res = (res * x) % p

        y = y >> 1
        x = (x * x) % p

    return res
mod=(10**9)+7
r,k=map(int,input().split())
if r==0:
    print(0)
    sys.exit()
print((((((power(2,k+1,mod)%mod)*(r%mod))%mod)-power(2,k,mod)+1))%mod)
",O(logn)
"n = int(input())
a = list(map(int, input().split()))
b = sorted(a,reverse=True)
total = sum(a)
gain = 0
num = 0
for x in range(len(b)):
    gain += b[x]
    num += 1
    if gain>total/2:
        break
print(num)",O(nlogn)
"from bisect import bisect_left as bl, bisect_right as br, insort
import sys
import heapq

from collections import defaultdict as dd, deque
def data(): return sys.stdin.readline().strip()
def mdata(): return map(int, data().split())

mod=int(1e9+7)

def bfs(x):
    cnt=0
    for i in tree[x]:
        bfs(i)
        cnt+=a[i]
    if len(tree[x])==0:
        cnt=1
    a[x]=cnt

n=int(data())
tree=[{} for i in range(n)]
if n>1:
    P=list(mdata())
    for i in range(n-1):
        tree[P[i]-1][i+1]=0
    a=[0]*n
    for i in range(n-1,-1,-1):
        if len(tree[i])==0:
            a[i]=1
        else:
            for j in tree[i]:
                a[i]+=a[j]
    a.sort()
else:
    a=[1]
print(*a)",O(nlogn)
"class Solution(object):
    def splitBST(self, root, V):
        if not root:
            return None, None
        elif root.val <= V:
            result = self.splitBST(root.right, V)
            root.right = result[0]
            return root, result[1]
        else:
            result = self.splitBST(root.left, V)
            root.left = result[1]
            return result[0], root",O(n)
"import os,sys
from io import BytesIO,IOBase
from math import inf

def main():
    n = int(input())
    a = [0]+list(map(int,input().split()))
    dp = [[[-1,0]for _ in range(n+1)]for _ in range(n+1)]

    for i in range(1,n+1):
        dp[i][i][0],dp[i][i][1] = a[i],1
    for i in range(n-1,0,-1):
        for j in range(i+1,n+1):
            for k in range(j-i):
                a,b = dp[i][i+k],dp[i+k+1][j]
                if a[1] and b[1] and a[0] == b[0]:
                    dp[i][j][0],dp[i][j][1] = a[0]+1,1
                    break
    val = [0,0]+[inf]*n
    for i in range(1,n+1):
        for j in range(1,n+1):
            if dp[i][j][1]:
                val[j+1] = min(val[j+1],val[i]+1)
    print(val[-1])

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(n ^ 3)
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n = inp()
a = inpl()
res = 0
for i in range(n):
    for j in range(i+1,n):
        if a[i] > a[j]:
            res = 1-res
for _ in range(inp()):
    l,r = inpl(); m = r-l+1
    swap = m*(m-1)//2
    if swap%2: res = 1-res
    print('odd' if res else 'even')",O(n ^ 2)
"class Solution(object):
    def waysToSplitArray(self, nums):
        total = sum(nums)
        result = curr = 0
        for i in range(len(nums)-1):
            curr += nums[i]
            result += int(curr >= total-curr)
        return result",O(n)
"n,x = list(map(int, input().split()))
a = set(map(int, input().split()))

if len(a) < n :
    print(0)
else :
    d = set()
    p = 0
    for i in a :
        d.add(i&x)
        if i&x != i and i&x in a :
            print(1)
            p = 1
            break
    if len(d) < n and p == 0 :
        print(2)
    elif p != 1 :
        print(-1)",O(n)
"import os
from sys import stdin
from math import inf

dx = [1, 0, -1, 0]
dy = [0, 1, 0, -1]

def solve(tc):
    N, M, K = map(int, stdin.readline().split())

    wx = [[] for j in range(N)]
    for i in range(N):
        wx[i] = list(map(int, stdin.readline().split()))

    wy = [[] for i in range(N-1)]
    for i in range(N-1):
        wy[i] = list(map(int, stdin.readline().split()))

    if K & 1:
        for i in range(N):
            for j in range(M):
                print(-1, end=' ')
            print()
        return

    mem = [[[0 for i in range(M)] for j in range(N)] for k in range(K+1)]

    half = K // 2
    for kk in range(1, half+1):
        for yy in range(N):
            for xx in range(M):
                mem[kk][yy][xx] = inf

                for d in range(4):
                    y = yy + dy[d]
                    x = xx + dx[d]

                    if y < 0 or y >= N or x < 0 or x >= M:
                        continue

                    if d == 0:
                        mem[kk][yy][xx] = min(
                            mem[kk][yy][xx], mem[kk-1][y][x] + wx[yy][xx]*2)
                    elif d == 1:
                        mem[kk][yy][xx] = min(
                            mem[kk][yy][xx], mem[kk-1][y][x] + wy[yy][xx]*2)
                    elif d == 2:
                        mem[kk][yy][xx] = min(
                            mem[kk][yy][xx], mem[kk-1][y][x] + wx[yy][x]*2)
                    else:
                        mem[kk][yy][xx] = min(
                            mem[kk][yy][xx], mem[kk-1][y][x] + wy[y][xx]*2)

    for yy in range(N):
        for xx in range(M):
            print(mem[half][yy][xx], end=' ')
        print()

tcs = 1

tc = 1
while tc <= tcs:
    solve(tc)
    tc += 1
",O(n ^ 3)
"def main():
    import sys
    read = sys.stdin.read
    readline = sys.stdin.readline
    INF = 1 << 60
    MOD = 10 ** 9 + 7
    sys.setrecursionlimit(10 ** 5)

    def new_dp():
        return [[INF] * M for _ in range(N)]

    def solve():
        if K % 2 == 1:
            for row in range(N):
                print(*[-1] * M)
            return

        dp_prev = [[0] * M for _ in range(N)]

        for _ in range(K // 2):
            dp_cur = new_dp()
            for row in range(N):
                for col in range(M - 1):
                    cost = e1[row][col]
                    dp_cur[row][col] = min(dp_cur[row][col], dp_prev[row][col + 1] + cost)
                    dp_cur[row][col + 1] = min(dp_cur[row][col + 1], dp_prev[row][col] + cost)
            for row in range(N - 1):
                for col in range(M):
                    cost = e2[row][col]
                    dp_cur[row][col] = min(dp_cur[row][col], dp_prev[row + 1][col] + cost)
                    dp_cur[row + 1][col] = min(dp_cur[row + 1][col], dp_prev[row][col] + cost)
            dp_prev = dp_cur

        for row in range(N):
            _r = [2 * x for x in dp_prev[row]]
            print(*_r)

    N, M, K = map(int, readline().split())

    e1 = []
    for _ in range(N):
        r = tuple(map(int, readline().split()))
        e1.append(r)
    e2 = []

    for _ in range(N - 1):
        r = tuple(map(int, readline().split()))
        e2.append(r)
    solve()

if __name__ == '__main__':
    main()
",O(n ^ 3)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')

def main():
    for _ in range(N()):
        n, m = RL()
        arr = []
        for _ in range(n): arr.append(RLL())

        larr = [list(i) for i in zip(*arr)]
        larr.sort(key = lambda a: max(a), reverse=1)
        larr = larr[:n]

        res = 0

        def dfs(lst, pos=0):
            nonlocal res
            if pos==min(n, len(larr)):
                res = max(res, sum(lst))
                return

            for i in range(n):
                now = larr[pos][i:n]+larr[pos][0:i]
                nex = [max(now[j], lst[j]) for j in range(n)]
                dfs(nex, pos+1)

        dfs([0]*n)
        print(res)

if __name__ == ""__main__"":
    main()
",np
"import collections
from functools import reduce



class Solution(object):
    def sumOfGoodSubsequences(self, nums):
        MOD = 10**9+7
        dp = collections.defaultdict(int)
        cnt = collections.defaultdict(int)
        for x in nums:
            c = cnt[x-1]+cnt[x+1]+1
            cnt[x] = (cnt[x]+c)%MOD
            dp[x] = (dp[x]+(dp[x-1]+dp[x+1]+x*c))%MOD
        return reduce(lambda accu, x: (accu+x)%MOD, iter(dp.values()))",O(n)
"import bisect
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        index = bisect.bisect_left(nums, target)
        return index if index < len(nums) and nums[index] == target else -1
",O(logn)
"class Solution(object):
    def findValueOfPartition(self, nums):
        nums.sort()
        return min(nums[i+1]-nums[i] for i in range(len(nums)-1))",O(nlogn)
"n, k = map(int, input().split())
a = input().split()
mods = [dict() for i in range(10)]
l = [0] * n
for i in range(n):
    l[i] = len(a[i])
    a[i] = int(a[i]) % k
    cur = a[i]
    for j in range(10):
        cur = cur * 10 % k
        mods[j][cur] = mods[j].get(cur, 0) + 1
ans = 0
for i in range(n):
    mod = (k - a[i]) % k
    ans += mods[l[i] - 1].get(mod, 0)
    cur = a[i]
    for j in range(l[i]):
        cur = cur * 10 % k
    if cur == mod:
        ans -= 1
print(ans)",O(nlogn)
"from heapq import *
import sys

int1 = lambda x: int(x) - 1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.readline())
def MI(): return map(int, sys.stdin.readline().split())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def SI(): return sys.stdin.readline()[:-1]

def main():
    inf=10**9
    n=II()
    aa=LI()
    dp1=[[-1]*(n+1) for _ in range(n)]
    to=[[i+1] for i in range(n)]
    for i in range(n):dp1[i][i+1]=aa[i]
    for w in range(2,n+1):
        for l in range(n-w+1):
            r=l+w
            for m in range(l+1,r):
                if dp1[l][m]!=-1 and dp1[l][m]==dp1[m][r]:
                    dp1[l][r]=dp1[l][m]+1
                    to[l].append(r)
    hp=[]
    heappush(hp,(0,0))
    dist=[-1]*(n+1)
    while hp:
        d,i=heappop(hp)
        if i==n:
            print(d)
            break
        if dist[i]!=-1:continue
        dist[i]=d
        for j in to[i]:
            if dist[j]!=-1:continue
            heappush(hp,(d+1,j))

main()",O(n ^ 3)
"from itertools import *
n,least,highest,x = map(int,input().split())
l = [*map(int,input().split())]
cnt = 0
for i in range(2,n + 1):
    combination = [*map(list,combinations(l,i))]
    for j in range(len(combination)):
        combination[j].sort()

        total = sum(combination[j])
        if(total >= least and total <= highest and combination[j][-1] - combination[j][0] >= x):
            cnt += 1
print(cnt)",np
"def get(g):
    s = [str(i) for i in g]
    num = int("""".join(s))
    return num

a = input()
b = input()
bb = int(b)
mark = [0 for i in range(len(a))]
c = a
f = []
g = []

for i in range(0 , len(a)):
    g.append(a[i])

g.sort()
g.reverse()
num = get(g)

index = []
if num <= bb:
    print(num)
    exit(0)

for i in range(0 , min(len(a) , len(b))):
    mx = '-1'
    idx = 0
    for j in range(0 , len(a)):
        if mark[j] == 0 and a[j] <= b[i]:
            if a[j] > mx:
                mx = a[j]
                idx = j

    if mx == '-1':
        rem = []

        while True and len(f) > 0:
            ma = '-1'
            id = 0
            for j in range(0 , len(a)):
                if mark[j] == 0 and a[j] < f[-1]:
                    if a[j] > ma:
                        ma = a[j]
                        id = j

            if ma == '-1':
                mark[index.pop()] = 0
                f.pop()
                continue
            else:
                mark[index.pop()] = 0
                f.pop()
                f.append(ma)
                mark[id] = 1
                break

        for j in range(0, len(a)):
            if mark[j] == 0:
                rem.append(a[j])

        rem.sort()
        rem.reverse()

        for j in rem:
            f.append(j)

        print(get(f))
        exit(0)

    elif mx < b[i] and mx != '-1':
        f.append(mx)
        mark[idx] = 1
        index.append(idx)
        break
    elif mx == b[i] and mx != '-1':
        f.append(mx)
        mark[idx] = 1
        index.append(idx)

rem = []

for i in range(0 , len(a)):
    if mark[i] == 0:
        rem.append(a[i])

rem.sort()
rem.reverse()

for i in rem:
    f.append(i)

print(get(f))
",O(n ^ 3)
"class Solution(object):
    def duplicateNumbersXOR(self, nums):
        return reduce(lambda x, y: x^y, nums, 0)^reduce(lambda x, y: x^y, set(nums), 0)",O(n)
"import collections
import itertools



class Solution(object):
    def equalPairs(self, grid):
        cnt1 = collections.Counter(tuple(row) for row in grid)
        cnt2 = collections.Counter(tuple(col) for col in zip(*grid))
        return sum(cnt1[k]*cnt2[k] for k in cnt1.keys() if k in cnt2)",O(n ^ 2)
"MOD = 998244353

def pop_count(x) :
    ans = 0
    while (x > 0) :
        ans = ans + x % 2
        x = x // 2
    return ans

def check(x, k) :
    mask = 0
    nx = int(x)
    while (nx > 0) :
        mask = mask | (1 << (nx % 10))
        nx = nx // 10
    if (pop_count(mask) <= k) :
        return x
    return 0

pop = []
p10 = []
f = [[0 for j in range(1 << 10)] for i in range(20)]
w = [[0 for j in range(1 << 10)] for i in range(20)]
def prepare() :
    p10.append(1)
    for i in range(20) :
        p10.append(p10[i] * 10 % MOD)
    for i in range(1 << 10) :
        pop.append(pop_count(i))
    w[0][0] = 1
    for i in range(1, 20) :
        for j in range(1 << 10) :
            for use in range(10) :
                w[i][j | (1 << use)] = (w[i][j | (1 << use)] + w[i - 1][j]) % MOD
                f[i][j | (1 << use)] = (f[i][j | (1 << use)] + w[i - 1][j] * use * p10[i - 1] + f[i - 1][j]) % MOD

def solve(x, k) :
    sx = [int(d) for d in str(x)]
    n = len(sx)
    ans = 0
    for i in range(1, n) :
        for use in range(1, 10) :
            for mask in range(1 << 10) :
                if (pop[(1 << use) | mask] <= k) :
                    ans = (ans + f[i - 1][mask] + use * w[i - 1][mask] % MOD * p10[i - 1]) % MOD
    cmask = 0
    csum = 0
    for i in range(n) :
        cdig = sx[i]
        for use in range(cdig) :
            if (i == 0 and use == 0) :
                continue
            nmask = cmask | (1 << use)
            for mask in range(1 << 10) :
                if (pop[nmask | mask] <= k) :
                    ans = (ans + f[n - i - 1][mask] + (csum * 10 + use) * w[n - i - 1][mask] % MOD * p10[n - i - 1]) % MOD
        cmask |= 1 << cdig
        csum = (10 * csum + cdig) % MOD
    return ans

prepare()
l, r, k = map(int, input().split())
ans = (check(r, k) + solve(r, k) - solve(l, k) + MOD) % MOD
print(ans)
",O(n ^ 3)
"fast=lambda:stdin.readline().strip()
zzz=lambda:[int(i) for i in fast().split()]
z,zz=input,lambda:list(map(int,z().split()))
szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())
from re import *
from sys import *
from math import *
from heapq import *
from queue import *
from bisect import *
from string import *
from itertools import *
from collections import *
from math import factorial as f
from bisect import bisect as bs
from bisect import bisect_left as bsl
from collections import Counter as cc
from itertools import accumulate as ac
def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))
def prime(x):
    p=ceil(x**.5)+1
    for i in range(2,p):
        if (x%i==0 and x!=2) or x==0:return 0
    return 1
def dfs(u,visit,graph):
    visit[u]=1
    for i in graph[u]:
        if not visit[i]:
            dfs(i,visit,graph)
def output(answer):
    stdout.write(str(answer))

n,k=zzz()

arr1=zzz()
arr2=zzz()
ans=0

new_arr=[0]*n

for i in range(n):
    if arr2[i]==0:
        new_arr[i]=arr1[i]
    else:
        ans+=arr1[i]

total=sum(new_arr[:k])
mx=total

j=0
for i in range(k,n):
    total-=new_arr[j]
    total+=new_arr[i]
    mx=max(mx,total)
    j+=1

print(mx+ans)
",O(n)
"n = int(input())

arr = list(map(int, input().split(' ')))
arr.sort()

stop = 0
equal = -1
tempcounter = 0

for i in range(1, n):
    if arr[i] == arr[i-1]:
        equal = arr[i]
        tempcounter += 1
        if tempcounter == 2:
            break

if tempcounter == 1 and equal != 0:
    for j in range(n):
        if arr[j] == equal-1:
            print(""cslnb"")
            stop = 1

if tempcounter == 1 and equal == 0:
    print(""cslnb"")

elif tempcounter < 2 and stop == 0:
    moves = arr[0]
    counter = 0

    for i in range(1, n):
        moves += arr[i] - i

    if counter == 0:
        if moves%2 == 0:
            print(""cslnb"")

        else:
            print(""sjfnb"")

elif stop == 0:
    print(""cslnb"")
",O(nlogn)
"n = int(input())
print(n + n // 2)",O(1)
"from sys import stdin

def read_lines(sep=' ', input_type=None):

    _lines = stdin.readlines()
    cast = input_type is not None
    lines = []
    for line in _lines:
        line = line[:-1].split(sep)
        if cast:
            line = [input_type(x) for x in line]
        lines.append(line)
    return lines

import collections

def numz(a,b):
    if a and b:
        if b > a:
            a,b=b,a
        d,m = divmod(a,b)
        return d + numz(b,m)
    else:
        return 0

if __name__ == '__main__':

    lines = read_lines(input_type=int)

    lines = lines[1:]
    for line in lines:
        print(numz(*line))
",O(1)
"import sys, math
from sys import stdin, stdout

rem = 10 ** 9 + 7
inf=10**18
sys.setrecursionlimit(10 ** 6 + 7)

take = lambda: map(int, stdin.readline().split())
from heapq import heappush, heappop, heapify
from collections import deque
from bisect import *

n,m=take()
arr=take()
check=take()
cnt=[0 for i in range(n+m)]

left=[-1 for i in range(n+m)]
right=[-1 for i in range(n+m)]
prev=-1
for i in range(n+m):
    if check[i]==0:
        left[i]=prev
    else:
        prev=i
prev=-1
for i in range(n+m-1,-1,-1):
    if check[i]==0:
        right[i]=prev
    else:
        prev=i
for i in range(n+m):
    if check[i]==1:
        continue
    a=left[i]
    b=right[i]
    if a==-1 and b==-1:
        continue
    if a==-1 and b!=-1:
        cnt[b]+=1
    if a!=-1 and b==-1:
        cnt[a]+=1
    if a!=-1 and b!=-1:
        if abs(arr[i]-arr[a])<=abs(arr[i]-arr[b]):
            cnt[a]+=1
        else:
            cnt[b]+=1
ans=[]
for i in range(n+m):
    if check[i]==1:
        ans.append(str(cnt[i]))
stdout.write(' '.join(ans))
",O(n)
"import bisect



class Solution(object):
    def maxPathLength(self, coordinates, k):
        def longest_increasing_subsequence(arr):
            result = []
            for x in arr:
                i = bisect.bisect_left(result, x)
                if i == len(result):
                    result.append(x)
                else:
                    result[i] = x
            return len(result)

        target = coordinates[k]
        coordinates.sort(key=lambda x: (x[0], -x[1]))
        left, right = [], []
        for x, y in coordinates:
            if x < target[0] and y < target[1]:
                left.append(y)
            elif x > target[0] and y > target[1]:
                right.append(y)
        return longest_increasing_subsequence(left)+1+longest_increasing_subsequence(right)",O(nlogn)
"MOD = 10**9+7
MAX_N = 1000
fact = [0]*(2*MAX_N-1+1)
inv = [0]*(2*MAX_N-1+1)
inv_fact = [0]*(2*MAX_N-1+1)
fact[0] = inv_fact[0] = fact[1] = inv_fact[1] = inv[1] = 1
for i in range(2, len(fact)):
    fact[i] = fact[i-1]*i % MOD
    inv[i] = inv[MOD%i]*(MOD-MOD//i) % MOD 
    inv_fact[i] = inv_fact[i-1]*inv[i] % MOD

class Solution(object):
    def numberOfSets(self, n, k):
        def nCr(n, k, mod):
            return (fact[n]*inv_fact[n-k] % mod) * inv_fact[k] % mod
        return nCr(n+k-1, 2*k, MOD)",O(1)
"n=int(input())
c=0
lst=[4,7,47,74,447,474,744,477,747,774]
if n in lst:
    print(""YES"")
else:
    for i in lst:
        if n%i==0:
            print(""YES"")
            c=c+1
            break
        else:
            continue
    if c==0:
        print(""NO"")
",O(1)
"import sys

n = int(sys.stdin.readline().rstrip())
nums = list(map(int, sys.stdin.readline().split()))

swaps = 0
visited = set()
for index in range(n):
    if index in visited:
        continue
    else:
        visited.add(index)
        length = 0
        value = nums[index]
        while (value != index + 1):
           visited.add(value - 1)
           value = nums[value - 1]
           length += 1
        swaps += length

if ((3 * n - swaps) % 2):
    print(""Um_nik"")
else:
    print(""Petr"")
",O(nlogn)
"class Solution(object):
    def countOfSubstrings(self, word, k):
        VOWELS = set(""aeiou"")
        def update(i, d):
            if word[i] not in VOWELS:
                curr2[0] += d
                return
            x = ord(word[i])-ord('a')
            if cnt1[x] == 0:
                curr1[0] += 1
            cnt1[x] += d
            if cnt1[x] == 0:
                curr1[0] -= 1

        result = 0
        cnt1, cnt2 = [0]*26, [0]*26
        curr1, curr2 = [0], [0]
        mid = left = 0
        for right in range(len(word)):
            update(right, +1)
            while curr2[0] > k:
                update(left, -1)
                if left < mid:
                    assert(word[left] in VOWELS)
                    cnt2[ord(word[left])-ord('a')] -= 1
                left += 1
                mid = max(mid, left)
            if not (curr1[0] == len(VOWELS) and curr2[0] == k):
                continue
            while word[mid] in VOWELS and cnt1[ord(word[mid])-ord('a')]-(cnt2[ord(word[mid])-ord('a')]+1) >= 1:
                cnt2[ord(word[mid])-ord('a')] += 1
                mid += 1
            result += mid-left+1
        return result",O(n)
"n, q = map(int, input().split())
A = list(map(int, input().split()))
K = list(map(int, input().split()))
from itertools import accumulate
C = [0]+A
C = list(accumulate(C))
total = 0
ans = [0]*q
import bisect
for i, k in enumerate(K):
    total += k
    j = bisect.bisect_right(C, total)
    if j != n+1:
        ans[i] = n-(j-1)
    else:
        ans[i] = n
        total = 0
print(*ans, sep='\n')
",O(nlogn)
"m=int(1e9+7)

def solve(x, k):
    return (m+(pow(2, k, m)*x%m)%m-((pow(2, k, m)-1)%m*pow(2, m-2, m)%m)%m)%m;

x,k=[int(x) for x in input().split()]

if x==0:
    print(0)
elif k==0:
    print((m+2*(x%m))%m)
else:
    print((m+2*solve(x, k))%m)
",O(logn)
"class Solution2(object):
    def findSecretWord(self, wordlist, master):
        def solve(H, possible):
            min_max_group, best_guess = possible, None
            for guess in possible:
                groups = [[] for _ in range(7)]
                for j in possible:
                    if j != guess:
                        groups[H[guess][j]].append(j)
                max_group = max(groups, key=len)
                if len(max_group) < len(min_max_group):
                    min_max_group, best_guess = max_group, guess
            return best_guess

        H = [[sum(a == b for a, b in zip(wordlist[i], wordlist[j]))
                  for j in range(len(wordlist))]
                  for i in range(len(wordlist))]
        possible = list(range(len(wordlist)))
        n = 0
        while n < 6:
            guess = solve(H, possible)
            n = master.guess(wordlist[guess])
            possible = [j for j in possible if H[guess][j] == n]",O(n ^ 2)
"import collections


class ListNode(object):
    def __init__(self, key, value, freq):
        self.key = key
        self.val = value
        self.freq = freq
        self.next = None
        self.prev = None


class LinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None

    def append(self, node):
        node.next, node.prev = None, None 
        if self.head is None:
            self.head = node
        else:
            self.tail.next = node
            node.prev = self.tail
        self.tail = node

    def delete(self, node):
        if node.prev:
            node.prev.next = node.__next__
        else:
            self.head = node.__next__
        if node.__next__:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        node.next, node.prev = None, None 


class Solution2(object):

    def __init__(self, capacity):
        self.__capa = capacity
        self.__size = 0
        self.__min_freq = float(""inf"")
        self.__freq_to_nodes = collections.defaultdict(LinkedList)
        self.__key_to_node = {}

    def get(self, key):
        if key not in self.__key_to_node:
            return -1
        value = self.__key_to_node[key].val
        self.__update(key, value)
        return value

    def put(self, key, value):
        if self.__capa <= 0:
            return

        if key not in self.__key_to_node and self.__size == self.__capa:
            del self.__key_to_node[self.__freq_to_nodes[self.__min_freq].head.key]
            self.__freq_to_nodes[self.__min_freq].delete(self.__freq_to_nodes[self.__min_freq].head)
            if not self.__freq_to_nodes[self.__min_freq].head:
                del self.__freq_to_nodes[self.__min_freq]
            self.__size -= 1
        self.__update(key, value)
        
    def __update(self, key, value):
        freq = 0
        if key in self.__key_to_node:
            old_node = self.__key_to_node[key]
            freq = old_node.freq
            self.__freq_to_nodes[freq].delete(old_node)
            if not self.__freq_to_nodes[freq].head:
                del self.__freq_to_nodes[freq]
                if self.__min_freq == freq:
                    self.__min_freq += 1
            self.__size -= 1

        freq += 1
        self.__min_freq = min(self.__min_freq, freq)
        self.__key_to_node[key] = ListNode(key, value, freq)
        self.__freq_to_nodes[freq].append(self.__key_to_node[key])
        self.__size += 1",O(1)
"class Solution(object):
    def largestSubarray(self, nums, k):
        left, right, l = 0, 1, 0
        while right+k-1 < len(nums) and right+l < len(nums):
            if nums[left+l] == nums[right+l]:
                l += 1
                continue
            if nums[left+l] > nums[right+l]:
                right += l+1
            else:
                left = max(right, min(left+l+1, len(nums)-k))
                right = left+1
            l = 0
        return nums[left:left+k]",O(n)
"class Solution(object):
    def canCross(self, stones):
        if stones[1] != 1:
            return False

        last_jump_units = {s: set() for s in stones}
        last_jump_units[1].add(1)
        for s in stones[:-1]:
            for j in last_jump_units[s]:
                for k in (j-1, j, j+1):
                    if k > 0 and s+k in last_jump_units:
                        last_jump_units[s+k].add(k)
        return bool(last_jump_units[stones[-1]])",O(n ^ 2)
"n = int(input())
x = 1
n -= 1
y = 9
while n > x * y:
    n -= x * y
    y *= 10
    x += 1
a = (8 + 2) ** (x - 1)
a += n // x
print(str(a)[n % x])",O(logn)
"class Solution2(object):
    def continuousSubarrays(self, nums):
        mn, mx = collections.deque(), collections.deque()
        result = left = 0
        for right in range(len(nums)):
            while mn and nums[mn[-1]] > nums[right]:
                mn.pop()
            mn.append(right)
            while mx and nums[mx[-1]] < nums[right]:
                mx.pop()
            mx.append(right)
            while not nums[right]-nums[mn[0]] <= 2:
                left = max(left, mn.popleft()+1)
            while not nums[mx[0]]-nums[right] <= 2:
                left = max(left, mx.popleft()+1)
            result += right-left+1
        return result",O(n)
"n = int(input())

if n==1:
    a = input()
    print(a)
else:
    a = list(map(int, input().split()))
    b = [abs(i) for i in a]
    if min(a)*max(a) > 0:
        print(sum(b)-2*min(b))
    else:
        print(sum(b))
",O(n)
"def prime(n):
    if n < 2:
        return False
    elif n % 2 == 0 and n != 2:
        return False
    for j in range(3, int(pow(n, 0.5) + 1), 2):
        if n % j == 0:
            return False
    return True
n = int(input())
for j in range(2, int(n / 2) + 1):
    if prime(j) == False and prime(n - j) == False:
        print(j, n - j)
        break
",O(1)
"S = input()
best = 0
for i in range(len(S)):
    for j in range(i+1, len(S)+1):
        s = S[i:j]
        c = 0
        for k in range(len(S)):
            if S[k:].startswith(s): c += 1
        if c >= 2:
            best = max(best, len(s))
print(best)",O(n ^ 3)
"class Solution:
    def countSubstrings(self, s: str) -> int:

        def manacher(s):
            t = '
            n = len(t)
            p = [0] * n
            l, r = 0, 0
            for i in range(n):
                p[i] = min(r - i, p[l + (r - i)]) if i < r else 0
                while (i + p[i] + 1 < n and i - p[i] - 1 >= 0
                       and t[i + p[i] + 1] == t[i - p[i] - 1]):
                    p[i] += 1
                if i + p[i] > r:
                    l, r = i - p[i], i + p[i]
            return p

        p = manacher(s)
        res = 0
        for i in p:
            res += (i + 1) // 2
        return res
",O(n)
"class Solution2(object):
    def minimumTime(self, s):
        result, right = len(s), [0]*(len(s)+1)
        for i in reversed(range(len(s))):
            right[i] = min(right[i+1]+2*(s[i] == '1'), len(s)-i)
        left = 0
        result = left+right[0]
        for i in range(1, len(s)+1):
            left = min(left+2*(s[i-1] == '1'), i)     
            result = min(result, left+right[i])
        return result",O(n)
"import collections



class Solution(object):

    def __init__(self, capacity):
        self.__capa = capacity
        self.__size = 0
        self.__min_freq = float(""inf"")
        self.__freq_to_nodes = collections.defaultdict(collections.OrderedDict)
        self.__key_to_freq = {}

    def get(self, key):
        if key not in self.__key_to_freq:
            return -1
        value = self.__freq_to_nodes[self.__key_to_freq[key]][key]
        self.__update(key, value)
        return value

    def put(self, key, value):
        if self.__capa <= 0:
            return

        if key not in self.__key_to_freq and self.__size == self.__capa:
            del self.__key_to_freq[self.__freq_to_nodes[self.__min_freq].popitem(last=False)[0]]
            if not self.__freq_to_nodes[self.__min_freq]:
                del self.__freq_to_nodes[self.__min_freq]
            self.__size -= 1
        self.__update(key, value)
        
    def __update(self, key, value):
        freq = 0
        if key in self.__key_to_freq:
            freq = self.__key_to_freq[key]
            del self.__freq_to_nodes[freq][key]
            if not self.__freq_to_nodes[freq]:
                del self.__freq_to_nodes[freq]
                if self.__min_freq == freq:
                    self.__min_freq += 1
            self.__size -= 1

        freq += 1
        self.__min_freq = min(self.__min_freq, freq)
        self.__key_to_freq[key] = freq
        self.__freq_to_nodes[freq][key] = value
        self.__size += 1",O(1)
"import sys
input = sys.stdin.readline

def binary_search(c1, c2):
    m = (c1 + c2 + 1) // 2
    while abs(c1 - c2) > 1:
        m = (c1 + c2 + 1) // 2
        if ok(m):
            c2 = m
        else:
            c1 = m
    ans = check(m)
    return ans

def ok(m):
    s0 = m
    for i in list(str(m)):
        s0 -= int(i)
    return True if s0 > s else False

def check(m):
    for i in range(max(0, m - 5), m + 6):
        if ok(i):
            return max(0, n - i + 1)
    return 0

n, s = map(int, input().split())
if not s % 9:
    s -= 1
ans = binary_search(0, n + 1)
print(ans)",O(logn)
"from math import log
import random
spaces = ("" "",""\n"",""\t"")
stops = ("""","" "",""\n"",""\t"")
extendedPoints = set()
startingPoints = set()
interestPoints = []

class TPoint:
	def __init__(self,x,y):
		self.x=x
		self.y=y
	def __str__(self):
		return ""(""+str(self.x)+"",""+str(self.y)+"")""
	def __eq__(self, other):
		return self.x == other.x and self.y == other.y
	def __hash__(self):
		return self.x*20000 + self.y
	x=0
	y=0
	h=0
def sortKey(p):
	return p.h
def heuristic(p, otherPoints):
	minH = float(""inf"")
	for point in otherPoints:
		currentH = abs(point.x - p.x) + abs(point.y - p.y)
		if currentH < minH:
			minH = currentH
	return minH

def addPoint(p,pointList):
	if not p in extendedPoints:
		p.h = heuristic(p,startingPoints)
		extendedPoints.add(p)
		pointList.append(p)

		return True
	else:
		return False

def extend(point,n,m,poinList):
	ok = False
	if point.x>1:
		ok = addPoint(TPoint(point.x-1,point.y),poinList) or ok
		if point.y>1:
			ok = addPoint(TPoint(point.x-1,point.y-1),poinList) or ok
		if point.y<m:
			ok = addPoint(TPoint(point.x-1,point.y+1),poinList) or ok
	if point.x<n:
		ok = addPoint(TPoint(point.x+1,point.y),poinList) or ok
		if point.y>1:
			ok = addPoint(TPoint(point.x+1,point.y-1),poinList) or ok
		if point.y<m:
			ok = addPoint(TPoint(point.x+1,point.y+1),poinList) or ok
	if point.y>1:
		ok = addPoint(TPoint(point.x,point.y-1),poinList) or ok
	if point.y<m:
		ok = addPoint(TPoint(point.x,point.y+1),poinList) or ok

	return ok

def ReadNext(fileObject):
	currentBuffer = """"
	currentRead=fileObject.read(1)
	while currentRead in spaces:
		currentRead=fileObject.read(1)
	currentBuffer = currentBuffer + currentRead
	while not currentRead in stops:
		currentRead=fileObject.read(1)
		currentBuffer = currentBuffer + currentRead
	return currentBuffer.strip()

w, r= open('output.txt', 'w'), open('input.txt', 'r')

n = int(ReadNext(r))
m = int(ReadNext(r))
k = int(ReadNext(r))
mscale = 5

for i in range(k):
	x = int(ReadNext(r))
	y = int(ReadNext(r))
	p = TPoint(x,y)
	startingPoints.add(p)
	extendedPoints.add(p)

tmpPoints = []
tmpPoints.append(TPoint(1,1))
tmpPoints.append(TPoint(1,m))
tmpPoints.append(TPoint(n,1))
tmpPoints.append(TPoint(n,m))
if n>2 and m>2:
	tmpPoints.append(TPoint(int(n/2),1))
	tmpPoints.append(TPoint(1,int(m/2)))
	tmpPoints.append(TPoint(int(n/2),m))
	tmpPoints.append(TPoint(n,int(m/2)))
	tmpPoints.append(TPoint(int(n/2),int(m/2)))

for p in tmpPoints:
	addPoint(p,interestPoints)

for p in startingPoints:
	extend(p,n,m,interestPoints)

interestPoints.sort(reverse=True, key=sortKey)
while len(interestPoints) > 3*mscale:
	interestPoints.pop(len(interestPoints)-1)

random.seed()

if(len(interestPoints)>0):
	maxPoint = interestPoints[0]
	for p in interestPoints:
		currentBeam = [p]
		canExtend = True
		while canExtend:
			addPoint(TPoint(random.randint(1,n),random.randint(1,m)),currentBeam)
			canExtend = False
			for i in range(len(currentBeam)):
				if extend(currentBeam[i],n,m,currentBeam):
					canExtend = True
			currentBeam.sort(reverse=True, key=sortKey)
			while len(currentBeam) > mscale:
				currentBeam.pop(len(currentBeam)-1)
		if currentBeam[0].h>maxPoint.h:
			maxPoint = currentBeam[0]

	w.write(str(maxPoint.x)+"" ""+str(maxPoint.y)+""\n"")
else:
	w.write(str(n)+"" ""+str(m)+""\n"")
",O(n ^ 3)
"l, r=map(int, input().split())
def cntbit(n):
  ans=0
  while(n):
    ans+=1
    n//=2
  return ans
c1=cntbit(l)
c2=cntbit(r)
if(c2>c1):
  print(2**c2-1)
else:
  x=l^r
  c=cntbit(x)
  print(2**c-1)",O(logn)
"import io, sys, atexit, os
import math as ma
from sys import exit
from decimal import Decimal as dec
from itertools import permutations
from itertools import combinations

def li ():
	return list (map (int, input ().split ()))

def num ():
	return map (int, input ().split ())

def nu ():
	return int (input ())

def find_gcd ( x, y ):
	while (y):
		x, y = y, x % y
	return x

def lcm ( x, y ):
	gg = find_gcd (x, y)
	return (x * y // gg)

mm = 1000000007
yp = 0

def isPrime ( n ):

	if (n <= 1):
		return False
	if (n <= 3):
		return True

	if (n % 2 == 0 or n % 3 == 0):
		return False

	i = 5
	while (i * i <= n):
		if (n % i == 0 or n % (i + 2) == 0):
			return False
		i = i + 6

	return True

def solve ():
	t = 1
	for tt in range (t):
		n,k=num()
		d=ma.sqrt(9+8*(n+k))
		gp=(-3+d)/2
		print(int(n-gp))

if __name__ == ""__main__"":
	solve ()",O(logn)
"inf=10000000000
n,m,k=(int(i) for i in input().split())
h=[[int(i) for i in input().split()]for i in range(n)]
z=[[int(i) for i in input().split()]for i in range(n-1)]
dh=lambda x,y:h[x][y] if 0<=x<len(h) and 0<=y<len(h[0]) else inf
dz=lambda x,y:z[x][y] if 0<=x<len(z) and 0<=y<len(z[0]) else inf
dp=[[[0 for iii in range(m)] for ii in range(n)] for i in range(2)]
ddp=lambda x,y,z:dp[x][y][z] if 0<=y<n and 0<=z<m else inf
if k%2!=0:
    for i in dp[0]:
        for j in i:
            print(-1,end=' ')
        print()
else:
    for kk in range(int(k/2)):
        for i in range(n):
            for j in range(m):
                dp[1][i][j]=min(ddp(0,i-1,j)+dz(i-1,j),ddp(0,i+1,j)+dz(i,j),ddp(0,i,j-1)+dh(i,j-1),ddp(0,i,j+1)+dh(i,j))
        dp.reverse()
    for i in dp[0]:
        for j in i:
            print(2*j,end=' ')
        print()
",O(n ^ 3)
"n,m,k = map(int,input().split())
wh=[]

for j in range(n):
    l=list(map(int,input().split()))
    wh.append(l)

wv=[]

for j in range(n-1):
    l=list(map(int,input().split()))
    wv.append(l)

if(k%2!=0):
    ans = [[-1 for _ in range(m)]for j in range(n)]
    for res in ans:
        print(*res)
else:
    dp = [[[0 for i in range(25)]for j in range(505)]for q in range(505)]
    for x in range(1,21):
        for i in range(1,n+1):
            for j in range(1,m+1):
                dp[i][j][x]=1234567890
                if(i!=n):
                    dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-1]+wv[i-1][j-1])
                if(i!=1):
                    dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-1]+wv[i-2][j-1])
                if(j!=m):
                    dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-1]+wh[i-1][j-1])
                if(j!=1):
                    dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-1]+wh[i-1][j-2])
    for i in range(1,n+1):
        for j in range(1,m+1):
            ans = 1234567890
            for x in range(1,k+1):
                if(k%x==0 and (k//x)%2==0 ):
                    ans = min(ans,dp[i][j][x]*(k//x))
            print(ans,end="" "")
        print()",O(n ^ 3)
"
class TrieNode(object):
    def __init__(self):
        self.is_string = False
        self.leaves = {}


class Solution(object):

    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        cur = self.root
        for c in word:
            if not c in cur.leaves:
                cur.leaves[c] = TrieNode()
            cur = cur.leaves[c]
        cur.is_string = True

    def search(self, word):
        node = self.childSearch(word)
        if node:
            return node.is_string
        return False

    def startsWith(self, prefix):
        return self.childSearch(prefix) is not None

    def childSearch(self, word):
        cur = self.root
        for c in word:
            if c in cur.leaves:
                cur = cur.leaves[c]
            else:
                return None
        return cur


",O(n)
"import math
EPS = 1e-6

hhh = None

def solve():
    n, M = [int(x) for x in input().split()]

    if out_of_solution_bounds(n, M):
        print('No')
        return

    b = find_optimal_b(n, M)

    heights = fast_find_optimal_height_distribution(n, M, b)
    parents = build_tree(n, b, heights)
    print('Yes')
    print(*parents[1:])

def out_of_solution_bounds(n, M):
    return M < 2*n - 1 or (n * (n+1)) // 2 < M

def find_optimal_b(n, M):
    begin = 1
    end = n
    while begin != end:
        mid = (begin + end) // 2
        if get_min_H_given_b(n, mid) <= M:
            end = mid
        else:
            begin = mid + 1
    b = end
    return b

def get_min_H_given_b(n, b):
    if b == 1: return (n*(n+1)) // 2
    m = math.floor(math.log((b-1)*n+1) / math.log(b) + EPS)
    nl = round((b**m - 1) / (b - 1))
    return (m*b**(m+1) - (m+1)*b**m + 1) // (b - 1)**2 + (m+1) * (n - nl)

def fast_find_optimal_height_distribution(n, M, b):
    begin = 0
    end = n+1
    H_fn = lambda L : (L*(L+1))//2 + get_min_H_given_b(n - L, b) + (L > 0)*(n - L)

    while begin != end:
        mid = (begin + end) // 2
        if H_fn(mid) <= M:
            begin = mid + 1
        else:
            end = mid
    L = begin - 1

    if L == n:
        return [1 for _ in range(n)]

    unif_branch_h = uniform_height_distribution(n - L, b)
    if L == 0:
        h = unif_branch_h
    else:
        h = [int(i < L) for i in range(n)]
        for i, x in enumerate(unif_branch_h, 1):
            h[i] += x

    return locally_increase_H(h, M, b)

def uniform_height_distribution(n, b):
    h = [0 for _ in range(n)]
    h[0] = 1
    i = 0
    to_fill = n-1
    while to_fill > 0:
        i += 1
        h[i] = min(b*h[i-1], to_fill)
        to_fill -= h[i]
    return h

def locally_increase_H(h, M, b):
    i = 1
    while not (b * (h[i-1]) >= (h[i] - 1) and b * (h[i] - 1) >= (h[i+1] + 1)):
        i += 1

    H = sum(i*x for i, x in enumerate(h, 1))
    while H < M:
        if b * (h[i-1] - 1) >= (h[i] + 1):
            i -= 1
        else:
            while not b * (h[i] - 1) >= (h[i+1] + 1):
                i += 1
        h[i] -= 1
        h[i+1] += 1
        H += 1

    return h

def build_tree(n, b, h):
    p = [None for _ in range(n)]
    p[0] = 1

    i = 1
    j = 0
    for k in range(1, n):
        if j == h[i]:
            i += 1
            j = 0
        p[k] = k - j - h[i-1] + (j // b) + 1
        j += 1
    return p

if __name__ == '__main__':
    solve()
",O(n)
"from math import factorial
s1,s2=input(),input()
a=s1.count('+')-s2.count('+')
b=s1.count('-')-s2.count('-')
if(a<0 or b<0):
    print(0)
    exit(0)
ans=factorial(a+b)/factorial(a)/factorial(b)
ans/=(2**(a+b))
print(""%.10f""%ans)
",np
"def ch_x(stri, n):
    res = ''
    for i in range(len(stri)):
        if i != n:
            res += stri[i]
        else:
            res += 'x'
    return res

a = input()
b = input()
n = 0
for i in range(0, len(a)):
    if a[i] == '0' and b[i] == '0':
        c = [i-1, i+1]
        for e in c:
            if 0 <= e < len(a):
                if a[e] == '0':
                    n += 1
                    a = ch_x(a, e)
                    break
                if b[e] == '0':
                    n += 1
                    b = ch_x(b, e)
                    break
        a = ch_x(a, i)
        b = ch_x(b, i)
print(n)",O(1)
"from itertools import combinations

def findsum(comb):
    sum = 0
    for song in comb:
        sum += song[0]
    return sum

def finda(a,b,c):
    if a == 0:
        return 0
    if a == 1 and b == 0 and c == 0:
        return 1
    else:
        return (a * findb(a-1,b,c)+ a*findc(a-1,b,c))

def findb(a,b,c):
    if b == 0:
        return 0
    if b == 1 and a == 0 and c == 0:
        return 1
    else:
        return (b * finda(a,b-1,c)+ b*findc(a,b-1,c))

def findc(a,b,c):
    if c == 0:
        return 0
    if c == 1 and a == 0 and b == 0:
        return 1
    else:
        return (c * finda(a,b,c-1)+ c*findb(a,b,c-1))

n, T = map(int,input().split())
songs = []
total_combinations = 0
for i in range(n):
    t, g = map(int,input().split())
    songs.append([t,g])

for i in range(1, n+1):
    allcomb = list(combinations(songs,i))
    for comb in allcomb:
        sum = findsum(comb)

        if sum == T:
            a = 0
            b = 0
            c = 0
            for song in comb:
                if song[1] == 1:
                    a += 1
                elif song[1] == 2:
                    b += 1
                else:
                    c += 1
            total_combinations += finda(a,b,c)+findb(a,b,c)+findc(a,b,c)
total_combinations = total_combinations%1000000007
print(total_combinations)",np
"import sys
import math
import collections
import bisect
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n=int(input())
    string=[]
    for i in range(100):
        string.append([])
    for i in range(n):
        val=((get_string()))
        size=len(val)
        string[size-1].append(val)
    for i in range(100):
        if len(string[i])>0:
            string[i].sort()
    ans=[]
    poss=True
    for i in range(100):
        if len(string[i])==0:
            continue
        else:
            row=string[i]
            if len(set(row))>1:
                poss=False
    if poss==False:
        print(""NO"")
    else:
        for i in range(100):
            if len(string[i])==0:
                continue
            for j in range(i+1,100):
                if len((string[j]))==0:
                    continue
                sub_string=(string[i][0])
                main=(string[j][0])
                if sub_string in main:
                    res=True
                else:
                    res=False
                if res==False:
                    poss=False
                    break
                else:
                    break
        if poss==False:
            print(""NO"")
        else:
            print(""YES"")
            for i in range(100):
                if len(string[i])==0:
                    continue
                for j in range(len(string[i])):
                    print(string[i][j])",O(nlogn)
"import collections


class Solution(object):
    def countPoints(self, rings):
        bits = {'R':0b001, 'G':0b010, 'B':0b100}
        rods = collections.defaultdict(int)
        for i in range(0, len(rings), 2):
            rods[int(rings[i+1])] |= bits[rings[i]]
        return sum(x == 0b111 for x in rods.values())",O(n)
"def mp():return map(int,input().split())
def it():return int(input())

n,k=mp()
l=list(mp())
ans=0
for i in range(n):
	avg,count=0,0
	for j in range(i,n):
		count+=l[j]
		if j-i+1>=k:
			avg=count/(j-i+1)
		ans=max(avg,ans)
print(ans)
",O(n ^ 2)
"(x, y) = list(map(int, input().split(' ')))

a = 0
b = x * y
pos = True

for t in reversed(range(b)):
    b -= 1
    print(str(int(a / y + 1)) + ' '+ str(int(a % y + 1)))
    a += b * (1 if pos else -1)
    pos = not pos
",O(n ^ 2)
"a , b = list(map(int, input().split()))
x, y, z = list(map(int, input().split()))
ans = 0
p = a - ((x*2) + y)
q = b - ((z*3) + y)

if (p < 0 and q < 0):
    print(abs(p) + abs(q))
elif (p < 0):
    print(abs(p))
elif (q < 0):
    print(abs(q))
else:
    print(0)",O(1)
"n,m=map(int,input().split())
MAP=[list(input()) for i in range(n)]

ANSMAP=[[""."" for i in range(m)] for j in range(n)]

for i in range(1,n-1):
    for j in range(1,m-1):
        if MAP[i-1][j-1]==""
            ANSMAP[i-1][j-1] =""
            ANSMAP[i-1][j]=""
            ANSMAP[i-1][j+1]=""
            ANSMAP[i][j-1]=""
            ANSMAP[i][j+1]=""
            ANSMAP[i+1][j-1]=""
            ANSMAP[i+1][j]=""
            ANSMAP[i+1][j+1]=""

if MAP==ANSMAP:
    print(""YES"")

else:
    print(""NO"")
",O(n ^ 2)
"def comp(arr):
    for i in range(len(arr)-1):
        for j in range(0, len(arr)-i-1):
            if(arr[j] in arr[j+1]):
                arr[j], arr[j+1] = arr[j+1], arr[j]

    return arr[::-1]

t = int(input())
ans = 1
arr = []
for j in range(t):
    arr.append(input())

arr = comp(arr);

for j in range(0,t-1):
    if arr[j] not in arr[j+1]:
        ans = 0
        break;

if(ans == 0):
    print(""NO"")

else:
    print(""YES"")
    for j in arr:
        print(j)",O(nlogn)
"import bisect


class Solution(object):
    def isMajorityElement(self, nums, target):
        if len(nums) % 2:
            if nums[len(nums)//2] != target:
                return False
        else:
            if not (nums[len(nums)//2-1] == nums[len(nums)//2] == target):
                return False

        left = bisect.bisect_left(nums, target)
        right= bisect.bisect_right(nums, target)
        return (right-left)*2 > len(nums)",O(logn)
"n,k=input().split()
n=int(n)
k=int(k)

m = 1000000007

z = pow(2,k,m)

ans = (((2*z)*(n%m))%m - (z-1))%m
if n==0:
	print(0)
else:
	print(ans)",O(logn)
"x,k=map(int,input().split())
if x==0:
  print(0)
  exit()
mod=10**9+7
p=pow(2,k,mod)
print((2*p*x-p+1)%mod)",O(logn)
"n = int(input())
ans = 0
mod = 998244353
a = list(map(int, input().split()))
p = 1 / 2

for i in range(n):
    ans = (ans + (i + 2) * (p * a[n - i - 1] % mod) % mod) % mod
    p = (2 * p) % mod

print(int(ans) % mod)",O(n)
"from heapq import heappush, heappop
n,k = map(int, input().split())
powers = list(map(int, input().split()))
coins = list(map(int, input().split()))

A = []
ans = [0] * n
for i in range(n):
    A.append((powers[i], coins[i], i))
A.sort()
h = []
total = 0
for i in range(n):
    _,c,idx = A[i]
    ans[idx] = total + c
    if len(h) < k:
        heappush(h, c)
        total += c
    elif h and h[0] < c:
        total -= heappop(h)
        heappush(h, c)
        total += c

for x in ans:
    print(x, end="" "")
print()
",O(nlogn)
"import collections


class Solution(object):
    def totalFruit(self, tree):
        count = collections.defaultdict(int)
        result, i = 0, 0
        for j, v in enumerate(tree):
            count[v] += 1
            while len(count) > 2:
                count[tree[i]] -= 1
                if count[tree[i]] == 0:
                    del count[tree[i]]
                i += 1
            result = max(result, j-i+1)
        return result",O(n)
"class Solution(object):
    def maxSumOfThreeSubarrays(self, nums, k):
        n = len(nums)
        accu = [0]
        for num in nums:
            accu.append(accu[-1]+num)

        left_pos = [0] * n
        total = accu[k]-accu[0]
        for i in range(k, n):
            if accu[i+1]-accu[i+1-k] > total:
                left_pos[i] = i+1-k
                total = accu[i+1]-accu[i+1-k]
            else:
                left_pos[i] = left_pos[i-1]

        right_pos = [n-k] * n
        total = accu[n]-accu[n-k]
        for i in reversed(range(n-k)):
            if accu[i+k]-accu[i] > total:
                right_pos[i] = i
                total = accu[i+k]-accu[i]
            else:
                right_pos[i] = right_pos[i+1]

        result, max_sum = [], 0
        for i in range(k, n-2*k+1):
            left, right = left_pos[i-1], right_pos[i+k]
            total = (accu[i+k]-accu[i]) + \
                    (accu[left+k]-accu[left]) + \
                    (accu[right+k]-accu[right])
            if total > max_sum:
                max_sum = total
                result = [left, i, right]
        return result",O(n)
"
import collections


class Solution(object):
    def frequencySort(self, nums):
        count = collections.Counter(nums)
        return sorted(nums, key=lambda x: (count[x], -x))
",O(nlogn)
"import math
n,k = [int(x) for x in input().split(' ')]
ans = ((2*n + 3) - int(math.sqrt(8*n + 8*k + 9)))//2
print(ans);",O(1)
"import heapq




class Solution3(object):
    def minOperations(self, nums, target):
        total = sum(nums)
        if total < target:
            return -1

        result = 0
        max_heap = [-x for x in nums]
        heapq.heapify(max_heap)
        while target:
            x = -heapq.heappop(max_heap)
            if x <= target:
                target -= x
                total -= x
            elif total-x >= target:
                total -= x
            else:
                heapq.heappush(max_heap, -x//2)
                heapq.heappush(max_heap, -x//2)
                result += 1
        return result",O(nlogn)
"l,r=map(int,input().split())
z=l^r
c=0
if(z==0):
    print(0)
    exit()
while(z):
	c+=1;
	z>>=1;
x='1'*c
print(int(x,2))
",O(logn)
"import collections


class Solution:
    def invalidTransactions(self, transactions):
        AMOUNT, MINUTES = 1000, 60
        trans = [(x[0], int(x[1]), int(x[2]), x[3]) for x in (transaction.split(',') for transaction in transactions)]
        trans.sort(key=lambda t: t[1])
        trans_indexes = collections.defaultdict(list)
        for i, t in enumerate(trans):
            trans_indexes[t[0]].append(i)
        result = []
        for name, indexes in trans_indexes.items():
            left, right = 0, 0
            for i, t_index in enumerate(indexes):
                t = trans[t_index]
                if (t[2] > AMOUNT):
                    result.append(""{},{},{},{}"".format(*t))
                    continue
                while left+1 < len(indexes) and trans[indexes[left]][1] < t[1]-MINUTES:
                    left += 1
                while right+1 < len(indexes) and trans[indexes[right+1]][1] <= t[1]+MINUTES:
                    right += 1
                for i in range(left, right+1):
                    if trans[indexes[i]][3] != t[3]:
                        result.append(""{},{},{},{}"".format(*t))
                        break
        return result",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase

def main():
    n,m,k=map(int,input().split())
    left=[list(map(int,input().split())) for _ in range(n)]
    down=[list(map(int,input().split())) for _ in range(n-1)]
    dp=[[(-1 if k&1 else 0) for _ in range(m)] for _ in range(n)]
    if k&1==0:
        for l in range(k//2):
            dp1=[[10**8 for _ in range(m)] for _ in range(n)]
            for i in range(n):
                for j in range(m):
                    if j>0:
                        dp1[i][j]=min(dp1[i][j],dp[i][j-1]+2*left[i][j-1])
                    if j<m-1:
                        dp1[i][j]=min(dp1[i][j],dp[i][j+1]+2*left[i][j])
                    if i>0:
                        dp1[i][j]=min(dp1[i][j],dp[i-1][j]+2*down[i-1][j])
                    if i<n-1:
                        dp1[i][j]=min(dp1[i][j],dp[i+1][j]+2*down[i][j])
            dp=dp1
    for i in dp:
        print(*i)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(n ^ 3)
"from collections import defaultdict
from sys import stdin

input = stdin.readline

dct = defaultdict(int)
n = int(input())
lst = [0] * n
for i in range(n):
    t = input().strip()
    a, b, c = map(int, (t[1:t.index('+')], t[t.index('+') + 1:t.index(')')], t[t.index('/') + 1:]))
    x = (a + b) / c
    lst[i] = x
    dct[x] += 1
for i in lst:
    print(dct[i], end=' ')
",O(n)
"x,k=map(int,input().split())
if x==0:print(""0"")
else:
    ans=(x*pow(2,k+1,10**9+7)-pow(2,k,10**9+7)+1)%(10**9+7)
    print(ans)
",O(logn)
"n,l,r,x = map(int,input().split())
nums = sorted(list(map(int,input().split())))
ans = 0
def recurse(i,sum, dif, cnt):
    global ans
    if i == n:
        if not cnt:
            return
        if sum>=l and sum <= r and abs(cnt[-1]-cnt[0]) >=x:
            ans += 1
        return
    recurse(i+1,sum,dif,cnt[:])
    cnt.append(nums[i])
    recurse(i+1,sum+nums[i],dif,cnt[:])
recurse(0,0,0,[])
print(ans)",np
"class Solution(object):
    def isValidSerialization(self, preorder):
        def split_iter(s, tok):
            start = 0
            for i in range(len(s)):
                if s[i] == tok:
                    yield s[start:i]
                    start = i + 1
            yield s[start:]

        if not preorder:
            return False

        depth, cnt = 0, preorder.count(',') + 1
        for tok in split_iter(preorder, ','):
            cnt -= 1
            if tok == 
                depth -= 1
                if depth < 0:
                    break
            else:
                depth += 1
        return cnt == 0 and depth < 0",O(n)
"I = lambda: map(int,input().split())
n,l,r,x=I()
C,k=[*I()],0
for i in range(2**n):
    W = [w for w,b in zip(C, bin(i)[2:].zfill(n)) if b=='1']

    if l <= sum(W) <= r and max(W)-min(W) >= x:
        k += 1
print(k)",np
"class edge(object):
	def __init__(self,ne,to,fl):
		self.ne=ne
		self.to=to
		self.fl=fl

def add(x,y,z):
	global tot
	tot+=1
	e.append(edge(he[x],y,z))
	he[x]=tot

def addedge(x,y,z):
	add(x,y,z)
	add(y,x,0)

def bfs():
	global deep
	deep=[0 for i in range(T+1)]
	q=[]
	q.append(S)
	deep[S]=1
	lp=0
	while (len(q)>lp):
		x=q[lp]
		lp+=1
		i=he[x]
		while (i):
			y=e[i].to
			if ((deep[y]==0)and(e[i].fl!=0)):
				deep[y]=deep[x]+1
				q.append(y)
			i=e[i].ne
	return deep[T]!=0

def dfs(x,flow):
	global deep
	if ((x==T)or(flow==0)):
		return flow
	used=0
	i=he[x]
	while (i):
		y=e[i].to
		if ((deep[y]==deep[x]+1)and(e[i].fl!=0)):
			now=dfs(y,min(flow-used,e[i].fl))
			used+=now
			e[i].fl-=now
			e[i^1].fl+=now
			if (flow==used):
				break;
		i=e[i].ne
	if (used==0):
		deep[x]=-1
	return used

def dinic():
	res=0
	while (bfs()):
		res+=dfs(S,INF)
	return res

n,m=map(int,input().split())
ans=0
weight=[0]+list(map(int,input().split()))

e=[0,0]
tot=1
S=n+m+1
T=S+1
he=[0 for i in range(T+1)]
INF=1000000007

for i in range(1,n+1):
	addedge(S,i,weight[i]);
for i in range(1,m+1):
	x,y,w=map(int,input().split())
	addedge(n+i,T,w)
	addedge(x,n+i,INF)
	addedge(y,n+i,INF)
	ans+=w
ans-=dinic()
print(ans)",O(n ^ 3)
"n = int(input())
p = list(map(int, input().split()))
gr = [[] for i in range(n)]
for i in range(n - 1):
    gr[p[i] - 1].append(i + 1)

q = [0]
after = []
i = 0
s = [0 for i in range(n)]
used = set()
used.add(0)
while q:
    cur = q.pop()
    after.append(cur)
    for el in gr[cur]:
        if el not in used:
            used.add(el)
            q.append(el)
            i += 1

q = after
for j in range(i, -1, -1):
    if len(gr[q[j]]) == 0:
        s[q[j]] = 1
    else:
        ans = 0
        for c in gr[q[j]]:
            ans += s[c]
        s[q[j]] = ans
s.sort()
print(' '.join(list(map(str, s))))
",O(nlogn)
"
class Solution(object):
    def minMoves(self, nums):
        return sum(nums) - len(nums) * min(nums)

",O(n)
"n=int(input())
arr=list(map(int,input().split()))
arr=sorted(arr)
if arr[-1]==1:arr[-1]=2
else:arr=[1]+arr[:n-1]
print(*arr)
",O(nlogn)
"n=int(input())
s=list(input())
t=list(input())
d={}
ans=0
x,y=-1,-1
for i in range(n):
	if s[i]!=t[i]:
		d[(s[i],t[i])]=i
		ans+=1
l=[chr(i+97) for i in range(26)]
for i in l:
	for j in l:
		if (i,j) in d and (j,i) in d:
			ans-=2
			x=d[(i,j)]+1
			y=d[(j,i)]+1
			break
	if x!=-1:
		break
if x==y==-1:
	for i in l:
		for j in l:
			for k in l:
				if (i,j) in d and (j,k) in d:
					ans-=1
					x=d[(i,j)]+1
					y=d[(j,k)]+1
					break
		if x!=-1:
			break
print(ans)
print(x,y)",O(n)
"

class CategoryHandler:
    def haveSameCategory(self, a, b):
        pass



class Solution(object):
    def numberOfCategories(self, n, categoryHandler):
        return sum(all(not categoryHandler.haveSameCategory(j, i) for j in range(i)) for i in range(n))
",O(n ^ 2)
"n = int(input())
l = [input() for _ in range(n)]
l.sort(key=lambda x: len(x))

ok = True
for i in range(n-1):
  if l[i] not in l[i+1]:
    ok = False
    break

if ok:
  print(""YES"")
  print(*l, sep='\n')
else:
  print(""NO"")
",O(nlogn)
"class Solution(object):
    def isBoomerang(self, points):
        return (points[0][0] - points[1][0]) * (points[0][1] - points[2][1]) - \
               (points[0][0] - points[2][0]) * (points[0][1] - points[1][1]) != 0",O(1)
"class Solution(object):
    def judgeCircle(self, moves):
        v, h = 0, 0
        for move in moves:
            if move == 'U':
                v += 1
            elif move == 'D':
                v -= 1
            elif move == 'R':
                h += 1
            elif move == 'L':
                h -= 1
        return v == 0 and h == 0",O(n)
"class Solution(object):
    def titleToNumber(self, s):
        result = 0
        for i in range(len(s)):
            result *= 26
            result += ord(s[i]) - ord('A') + 1
        return result",O(n)
"import random



class Solution(object):
    def maximizeSumOfWeights(self, edges, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target):
                i = left
                while i <= right:
                    if compare(nums[i], target):
                        nums[i], nums[left] = nums[left], nums[i]
                        left += 1
                        i += 1
                    elif compare(target, nums[i]):
                        nums[i], nums[right] = nums[right], nums[i]
                        right -= 1
                    else:
                        i += 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx])
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def iter_dfs():
            cnt = [[0]*2 for _ in range(len(adj))]
            stk = [(1, 0, -1)]
            while stk:
                step, u, p = stk.pop()
                if step == 1:
                    stk.append((2, u, p))
                    for v, w in reversed(adj[u]):
                        if v == p:
                            continue
                        stk.append((1, v, u))
                elif step == 2:
                    curr = 0
                    diff = []
                    for v, w in adj[u]:
                        if v == p:
                            continue
                        curr += cnt[v][0]
                        diff.append(max((cnt[v][1]+w)-cnt[v][0], 0))
                    if k-1 < len(diff):
                        nth_element(diff, k-1, lambda a, b: a > b)
                    cnt[u][0] = curr+sum(diff[i] for i in range(min(k, len(diff))))
                    cnt[u][1] = curr+sum(diff[i] for i in range(min(k-1, len(diff))))
            return cnt[0][0]
    
        adj = [[] for _ in range(len(edges)+1)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        return iter_dfs()",O(n)
"class Solution(object):
    def hIndex(self, citations):
        n = len(citations)
        left, right = 0, n - 1
        while left <= right:
            mid = (left + right) / 2
            if citations[mid] >= n - mid:
                right = mid - 1
            else:
                left = mid + 1
        return n - left",O(logn)
"class Solution2(object):
    def fallingSquares(self, positions):
        index = set()
        for left, size in positions:
            index.add(left)
            index.add(left+size-1)
        index = sorted(list(index))
        tree = SegmentTree(len(index), max, max, 0)
        max_height = 0
        result = []
        for left, size in positions:
            L, R = bisect.bisect_left(index, left), bisect.bisect_left(index, left+size-1)
            h = tree.query(L, R) + size
            tree.update(L, R, h)
            max_height = max(max_height, h)
            result.append(max_height)
        return result",O(nlogn)
"class Solution(object):
    def hasAlternatingBits(self, n):
        n, curr = divmod(n, 2)
        while n > 0:
            if curr == n % 2:
                return False
            n, curr = divmod(n, 2)
        return True",O(1)
"class Solution2(object):
    def getImportance(self, employees, id):
        result, q = 0, collections.deque([id])
        while q:
            curr = q.popleft()
            employee = employees[curr-1]
            result += employee.importance
            for id in employee.subordinates:
                q.append(id)
        return result",O(n)
"from sys import stdin
from array import array
def recSolve(dp,r,g,b,rx,gx,bx, R, G, B):
	if rx == R:
		return sum(a * b for a, b in zip(g[gx:], b[bx:]))
	if gx == G:
		return sum(a * b for a, b in zip(r[rx:], b[bx:]))
	if bx == B:
		return sum(a * b for a, b in zip(g[gx:], r[rx:]))
	if dp[rx * G * B + gx * B + bx] != -1:
		return dp[rx * G * B + gx * B + bx]
	rg = recSolve(dp, r, g, b, rx + 1, gx + 1, bx, R, G, B) + r[rx] * g[gx]
	bg = recSolve(dp, r, g, b, rx, gx + 1, bx + 1, R, G, B) + b[bx] * g[gx]
	rb = recSolve(dp, r, g, b, rx + 1, gx, bx + 1, R, G, B) + r[rx] * b[bx]
	ans = max(rg, bg, rb)
	dp[rx * G * B + gx * B + bx] = ans
	return ans
input = stdin.readline
R, G, B = map(int, input().split())
r = sorted([*map(int, input().split())], reverse = True)
g = sorted([*map(int, input().split())], reverse = True)
b = sorted([*map(int, input().split())], reverse = True)
dp = array('q', (-1 for x in range(R * G * B)))
print(recSolve(dp, r, g, b, 0, 0, 0, R, G, B))",O(n ^ 3)
"n,pos,l,r = map(int, input().split())
dl,dr = abs(pos-l) + 1, abs(pos-r) + 1
print(dr*(r<n) if l==1 else dl if r==n else min(dl,dr)+r-l+1)",O(1)
"
class Solution(object):
    def oddEvenList(self, head):
        if head:
            odd_tail, cur = head, head.__next__
            while cur and cur.__next__:
                even_head = odd_tail.__next__
                odd_tail.next = cur.__next__
                odd_tail = odd_tail.__next__
                cur.next = odd_tail.__next__
                odd_tail.next = even_head
                cur = cur.__next__
        return head

",O(n)
"import collections



class Solution2(object):
    def canReach(self, s, minJump, maxJump):
        q = collections.deque([0])
        reachable = 0
        while q:
            i = q.popleft()
            for j in range(max(i+minJump, reachable+1), min(i+maxJump+1, len(s))):
                if s[j] != '0':
                    continue
                q.append(j)
            reachable = i+maxJump
        return i == len(s)-1",O(n)
"s = input()
ans = 0
for i in range(len(s)):
    for j in range(i + 1, len(s)):
        cur = s[i:j]
        if cur in s[:(j - 1)] or cur in s[(i + 1):]:
            ans = max(ans, j - i)
print(ans)
",O(n ^ 3)
"class Solution(object):
    def compress(self, chars):
        anchor, write = 0, 0
        for read, c in enumerate(chars):
            if read+1 == len(chars) or chars[read+1] != c:
                chars[write] = chars[anchor]
                write += 1
                if read > anchor:
                    n, left = read-anchor+1, write
                    while n > 0:
                        chars[write] = chr(n%10+ord('0'))
                        write += 1
                        n /= 10
                    right = write-1
                    while left < right:
                        chars[left], chars[right] = chars[right], chars[left]
                        left += 1
                        right -= 1
                anchor = read+1
        return write",O(n)
"n,m,a,b=map(int, input().split())
print(min(n%m*b, (m-n%m)*a))",O(n)
"from sys import stdin
x, k = map(int, stdin.readline().split())
if x == 0:
	print(0)
else:
	mod = 1000000007
	a = pow(2,k,mod)%mod
	b = (2*a)%mod
	print((((((x%mod)*(b%mod))%mod)-(a%mod)+1)+mod)%mod)",O(logn)
"class Solution(object):
    def minOperations(self, nums, target):
        def floor_log2_x(x):
            return x.bit_length()-1

        total = sum(nums)
        if total < target:
            return -1

        cnt = [0]*(floor_log2_x(max(nums))+1)
        for x in nums:
            cnt[floor_log2_x(x)] += 1
        result = 0
        for i in reversed(range(len(cnt))):
            for _ in range(cnt[i]):
                x = 1<<i
                if x <= target:
                    target -= x
                    total -= x
                elif total-x >= target:
                    total -= x
                else:
                    cnt[i-1] += 2
                    result += 1
        return result",O(n)
"def lvl(val):
    tot=1
    curr=-1
    while(val%tot==0):
        curr+=1
        tot*=2
    return [curr,val*2//(tot),tot//2]

n,q=map(int,input().split())
for _ in range(q):
    curr=int(input())
    l,v,pw=lvl(curr)
    s=input()
    for j in s:

        if j==""U"":
            if v%4==3:
                curr=curr-pw
            else:
                if curr+pw<=n:
                    curr=curr+pw

        elif j==""R"":
            if l>0:
                curr=curr+pw//2

        elif j == ""L"":
            if l > 0:
                curr = curr - pw // 2

        l, v, pw = lvl(curr)

    print(curr)
",np
"class Solution(object):
    def coloredCells(self, n):
        return n**2+(n-1)**2",O(1)
"class Solution(object):
    def largestPalindrome(self, n, k):
        def inv(x, p):
            return pow(x, p-2, p)

        def f(l):
            p = 7
            result = ['9']*l
            if l:                
                curr = reduce(lambda accu, x: (accu*10+(ord(x)-ord('0')))%p, result, 0)
                i = 9-(curr*inv(11 if l%2 == 0 else 1, p)*inv(pow(10, l//2-int(l%2 == 0), p), p))%p
                if i <= 2:
                    i += p
                result[l//2] = result[l//2-int(l%2 == 0)] = str(i)
            return """".join(result)

        if k in (1, 3, 9):
            return '9'*n
        if k in (2, 4, 8):
            k = min(k, 6)
            if n <= k:
                return '8'*n
            l = k//2
            return '8'*l+'9'*(n-k)+'8'*l
        if k == 5:
            if n <= 2:
                return '5'*n
            return '5'+'9'*(n-2)+'5'
        if k == 6:
            if n <= 2:
                return '6'*n
            if n%2:
                l = n//2-1
                return '8'+'9'*l+'8'+'9'*l+'8'
            l = n//2-2
            return '8'+'9'*l+""77""+'9'*l+'8'
        l, r = divmod(n, 12)
        return ""999999""*l+f(r)+""999999""*l",O(n)
"class Solution(object):
    def canVisitAllRooms(self, rooms):
        lookup = set([0])
        stack = [0]
        while stack:
            node = stack.pop()
            for nei in rooms[node]:
                if nei not in lookup:
                    lookup.add(nei)
                    if len(lookup) == len(rooms):
                        return True
                    stack.append(nei)
        return len(lookup) == len(rooms)",O(n)
"import itertools



class Solution(object):
    def minOperations(self, nums1, nums2):
        cnt = [0]*2
        for x, y in zip(nums1, nums2):
            if not (min(x, y) <= min(nums1[-1], nums2[-1]) and max(x, y) <= max(nums1[-1], nums2[-1])):
                return -1
            if not (x <= nums1[-1] and y <= nums2[-1]):
                cnt[0] += 1
            if not (x <= nums2[-1] and y <= nums1[-1]):
                cnt[1] += 1
        return min(cnt)",O(n)
"class Solution(object):
    def wonderfulSubstrings(self, word):
        ALPHABET_SIZE = 10
        count = [0]*(2**ALPHABET_SIZE)
        count[0] = 1
        result = curr = 0
        for c in word:
            curr ^= 1<<(ord(c)-ord('a'))
            result += count[curr]
            result += sum(count[curr^(1<<i)] for i in range(ALPHABET_SIZE))
            count[curr] += 1
        return result",O(n)
"n=int(input())

ax, ay = map(int,input().split())
bx, by = map(int,input().split())

cx, cy = map(int,input().split())

if ((bx<ax and cx<ax) or (bx>ax and cx>ax)) and ((by<ay and cy<ay) or (by>ay and cy>ay)):
	print('YES')

else:
	print('NO')",O(1)
"class Solution(object):
    def maximumGroups(self, grades):
        return int(((1+8*len(grades))**0.5-1)/2.0)",O(1)
"class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        n = len(matrix)
        rotated = [[0] * n for _ in range(n)]

        for i in range(n):
            for j in range(n):
                rotated[j][n - 1 - i] = matrix[i][j]

        for i in range(n):
            for j in range(n):
                matrix[i][j] = rotated[i][j]
",O(n ^ 2)
"class Solution(object):
    def countElements(self, arr):
        lookup = set(arr)
        return sum(1 for x in arr if x+1 in lookup)",O(n)
"def out_edge(x,y):
    a[x] -= 1
    a[y] -= 1
    print(x,y)

n = int(input())
a =list(map(int, input().split()))
sa = sum(a)
ma = min(a)
if (sa <2*(n-1)) or (ma<1):
    print('NO')
    exit()

verts = sorted(enumerate(a,1), key = lambda x: x[1], reverse= True)
verts = [list(j) for j in verts]
outres = []
for kk in range(1,n):
    if  verts[kk-1][1] >= 1:
        outres.append((verts[kk] [0], verts[kk-1][0]))
        verts[kk][1] -= 1
        verts[kk-1][1] -= 1
    else:
        break
else:
    kk+=1

path_len = kk

print('YES', min(n-1, path_len))

reserve_start = 0
while kk < n:
    if verts[reserve_start][1] >0:
        outres.append((verts[reserve_start][0], verts[kk][0]))
        verts[reserve_start][1] -= 1
        verts[kk][1] -= 1
        kk +=1
    else:
        reserve_start += 1

print(len(outres))
for oo in outres:
    print(*oo)
",O(nlogn)
"import math
def C(a, b):
	return math.factorial(a)//(math.factorial(b)*math.factorial(a-b))

a = list(input())
b = list(input())
x, y, d, ans, power = 0, 0, 0, 0, 0
for i in range(len(a)):
	if a[i] == '+':
		x += 1
	if a[i] == '-':
		x -= 1
	if b[i] == '?':
		d += 1
	if b[i] == '+':
		y += 1
	if b[i] == '-':
		y -= 1
plus, minus = d, 0
for i in range(0, d+1):
	k = C(d, plus)
	if y+(plus-minus) == x:
		ans += k
	power += k
	plus -= 1
	minus += 1
print(""{0:.12f}"".format(ans/power))",np
"def chk(n):
    return int(n**0.5+0.1)**2 == n
for _ in range(int(input())):
    n = int(input())
    if n % 2 == 0 and chk(n//2) or n % 4 == 0 and chk(n//4):
        print(""YES"")
    else:
        print(""NO"")
",O(1)
"def f(l,r,g,b,op):
    if (r==0 and g==0) or (r==0 and b==0) or (b==0 and g==0):
        return 0
    else:
        if op[r][g][b]!=-1:
            return op[r][g][b]
        if r==0:
           op[r][g][b]=l[1][g-1]*l[2][b-1]+f(l,r,g-1,b-1,op)
           return op[r][g][b]
        if g==0:
           op[r][g][b]=l[0][r-1]*l[2][b-1]+f(l,r-1,g,b-1,op)
           return op[r][g][b]
        if b==0:
         op[r][g][b]=l[0][r-1]*l[1][g-1]+f(l,r-1,g-1,b,op)
         return op[r][g][b]
        op[r][g][b]=max(l[1][g-1]*l[2][b-1]+f(l,r,g-1,b-1,op),l[0][r-1]*l[2][b-1]+f(l,r-1,g,b-1,op),l[0][r-1]*l[1][g-1]+f(l,r-1,g-1,b,op))
        return op[r][g][b]

r,g,b=list(map(int,input().split()))
l=[]
l.append(sorted(list(map(int,input().split()))))
l.append(sorted(list(map(int,input().split()))))
l.append(sorted(list(map(int,input().split()))))
op=[[[-1 for i in range(b+1)]for j in range(g+1)]for k in range(r+1)]

print(f(l,r,g,b,op))
",O(n ^ 3)
"n,m,k = list(map(int,input().split()))
a = list(map(int,input().split()))
dp = [[float('-inf')]*m for i in range(n)]
dp[0][0] = a[0]
for i in range(1,n):
    for j in range(1,m):
        dp[i][j] = dp[i-1][j-1] + a[i]
    dp[i][0] = max(dp[i-1][m-1]-k, 0)+a[i]

print(max(max([max(x) for x in dp])-k,0))",O(n ^ 2)
"from sys import stdin
from collections import defaultdict
import heapq

n = int(stdin.readline())
a = [[] for _ in range(n)]
for _ in range(n-1):
    e = stdin.readline().split(' ')
    u, v = int(e[0]), int(e[1])
    a[u-1].append(v-1)
    a[v-1].append(u-1)

leaves = [i for i in range(n) if len(a[i]) == 1]

def dfs_from(root):
    depth = defaultdict(int)
    child = {}
    parent = defaultdict(lambda: -1)
    stack = [root]
    visited = [False for _ in range(n)]
    while len(stack) > 0:
        crt = stack[-1]
        if visited[crt]:
            stack.pop(-1)
            if len(a[crt]) > 1:
                child[crt], depth[crt] = max([(c, depth[c]+1) for c in a[crt]
                                              if c != parent[crt]],
                                             key=lambda x: x[1])
            else:
                child[crt] = -1
                depth[crt] = 0
            continue

        visited[crt] = True
        for next in a[crt]:
            if next != parent[crt]:
                stack.append(next)
                parent[next] = crt

    return depth, child

first_choice = leaves[0]
d1, child1 = dfs_from(first_choice)

root = max([(a[leaf][0], d1[a[leaf][0]]) for leaf in leaves],
           key=lambda leaf_depth: leaf_depth[1])[0]
while child1[root] != -1:
    root = child1[root]
depth, child = dfs_from(root)

solution = [1]
pq = []
for k, v in depth.items():
    heapq.heappush(pq, (-v, k))

seen = [False for _ in range(n)]
seen[root] = True

while len(pq) > 0:
    _, best = heapq.heappop(pq)
    if seen[best]:
        continue
    path = []
    c = best
    s = 0
    while c != -1:
        seen[c] = True
        c = child[c]
        s = s+1
    s = s + solution[-1]
    solution.append(s)

for _ in range(n - min(len(solution), n)):
    solution.append(n)

print(' '.join([str(s) for s in solution]))
",O(nlogn)
"import bisect
from itertools import accumulate
import os
import sys
import math
from decimal import *
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input():
    return sys.stdin.readline().rstrip(""\r\n"")

def isPrime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i = i + 6
    return True

def SieveOfEratosthenes(n):
    prime = []
    primes = [True for i in range(n + 1)]
    p = 2
    while p * p <= n:

        if primes[p] == True:
            prime.append(p)
            for i in range(p * p, n + 1, p):
                primes[i] = False
        p += 1
    return prime

def primefactors(n):
    fac = []
    while n % 2 == 0:
        fac.append(2)
        n = n // 2
    for i in range(3, int(math.sqrt(n)) + 2):
        while n % i == 0:
            fac.append(i)
            n = n // i
    if n > 1:
        fac.append(n)
    return sorted(fac)

def factors(n):
    fac = set()
    fac.add(1)
    fac.add(n)
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            fac.add(i)
            fac.add(n // i)
    return list(fac)

def modInverse(a, m):
    m0 = m
    y = 0
    x = 1
    if m == 1:
        return 0
    while a > 1:
        q = a // m
        t = m
        m = a % m
        a = t
        t = y
        y = x - q * y
        x = t
    if x < 0:
        x = x + m0
    return x

n, k = map(int, input().split())
a = list(sorted(map(int, input().split()), reverse=True))
s = set()

for i in range(len(a)):
    if a[i] * k not in s:
        s.add(a[i])

print(len(s))",O(nlogn)
"import collections



class Solution2(object):
    def minCost(self, nums, x):
        def cost(k):
            w = k+1
            result = x*k
            dq = collections.deque()
            for i in range(len(nums)+w-1):
                if dq and i-dq[0] == w:
                    dq.popleft()
                while dq and nums[dq[-1]%len(nums)] >= nums[i%len(nums)]:
                    dq.pop()
                dq.append(i)
                if i >= w-1:
                    result += nums[dq[0]%len(nums)]
            return result

        def check(x):
            return cost(x) <= cost(x+1)

        left, right = 0, len(nums)
        while left <= right:
            mid = left + (right-left)//2
            if check(mid):
                right = mid-1
            else:
                left = mid+1
        return cost(left)",O(nlogn)
"def read_data():
    n = int(input().strip())
    a = []
    for i in range(n):
        line = tuple(map(int, input().strip().split()))
        a.append(line)
    return n, a

def is_on_line(a,b,c):
    return 1 if (a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1])) == 0 else 0

def solve():
    if n <= 4:
        return 1
    line1 = []
    line2 = []
    ok = 1
    for i in range(n):
        if not is_on_line(a[0],a[1],a[i]):
            if len(line2) < 2:
                line2.append(i)
            else:
                ok *= is_on_line(a[line2[0]], a[line2[1]], a[i])
                if ok == 0:
                    break
    if ok:
        return 1
    line1 = []
    line2 = []
    ok = 1
    for i in range(n):
        if not is_on_line(a[0],a[2],a[i]):
            if len(line2) < 2:
                line2.append(i)
            else:
                ok *= is_on_line(a[line2[0]], a[line2[1]], a[i])
                if ok == 0:
                    break
    if ok:
        return 1
    line1 = []
    line2 = []
    ok = 1
    for i in range(n):
        if not is_on_line(a[1],a[2],a[i]):
            if len(line2) < 2:
                line2.append(i)
            else:
                ok *= is_on_line(a[line2[0]], a[line2[1]], a[i])
                if ok == 0:
                    break
    if ok:
        return 1
    return 0

n, a = read_data()
print(""Yes"" if solve() == 1 else ""No"")",O(nlogn)
"n,l,r,x = map(int,input().split())
c = [int(i) for i in input().split()]
ans = 0
for bit in range(2,1<<n):
    probs = []
    t = 0
    for i in range(n):
        if bit&(1<<i):
            probs.append(c[i])
            t += c[i]

    a = min(probs)
    b = max(probs)

    if t >= l and t <= r and abs(a-b) >= x:
        ans += 1
print(ans)",np
"class Solution:
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0

        l, r = 0, len(height) - 1
        leftMax, rightMax = height[l], height[r]
        res = 0
        while l < r:
            if leftMax < rightMax:
                l += 1
                leftMax = max(leftMax, height[l])
                res += leftMax - height[l]
            else:
                r -= 1
                rightMax = max(rightMax, height[r])
                res += rightMax - height[r]
        return res
",O(n)
"n, k = map(int, input().split())

m = 2 * (n - 1) - k * (k - 1)

if m > 0: print(-1)

else:

    x = int((1 + (1 - 4 * m) ** 0.5) / 2)

    if x * (x - 1) + m > 0: x -= 1

    print(k - x)
",O(logn)
"class Solution(object):
    def isRectangleOverlap(self, rec1, rec2):
        def intersect(p_left, p_right, q_left, q_right):
            return max(p_left, q_left) < min(p_right, q_right)

        return (intersect(rec1[0], rec1[2], rec2[0], rec2[2]) and
                intersect(rec1[1], rec1[3], rec2[1], rec2[3]))",O(1)
"from operator import itemgetter

class CodeforcesTask528BSolution:
    def __init__(self):
        self.result = ''
        self.n = 0
        self.points = []

    def read_input(self):
        self.n = int(input())
        for _ in range(self.n):
            self.points.append([int(x) for x in input().split("" "")])
            self.points[-1].append(sum(self.points[-1]))

    def process_task(self):
        self.points.sort(key=itemgetter(2))
        last = 0
        ans = 1
        for i in range(1, self.n):
            if self.points[i][0] - self.points[i][1] >= self.points[last][0] + self.points[last][1]:
                last = i
                ans += 1
        self.result = str(ans)

    def get_result(self):
        return self.result

if __name__ == ""__main__"":
    Solution = CodeforcesTask528BSolution()
    Solution.read_input()
    Solution.process_task()
    print(Solution.get_result())
",O(nlogn)
"n,m=map(int,input().split())
c=0;ans=str()
for i in range(n):
  ans+=str(c^1)
  c=c^1
print(ans)
",O(n)
"class Solution(object):
    def removeDuplicates(self, s, k):
        stk = [['^', 0]]
        for c in s:
            if stk[-1][0] == c:
                stk[-1][1] += 1
                if stk[-1][1] == k:
                    stk.pop()
            else:
                stk.append([c, 1])
        return """".join(c*k for c, k in stk)",O(n)
"n,m=map(int,input().split())
arr=[ int(x) for x in input().split()]

arr=sorted(arr,reverse=True)
arr.append(0)

isum=sum(arr)
ans=[]
top=arr[0]
for i in range(n):
	if(arr[i]==1):
		ans.append(1)
		arr[i+1]=1
		continue
	if(arr[i+1] >arr[i]):
		arr[i+1]=arr[i]
	if arr[i]-arr[i+1]==0:
		ans.append(1)
		h=1
	else:
		ans.append(arr[i]-arr[i+1])
		h=arr[i]-arr[i+1]

	top=arr[i]-h
	arr[i+1]=top

print(isum-sum(ans))",O(nlogn)
"n,m=[int(x) for x in input().split()]
ans1=""1""*1500
ans2=""8""*1499+""9""
print(ans1)
print(ans2)
",O(1)
"from collections import *
n = int(input())
a = list(map(int,input().split()))
d = Counter(a)
ans = 0
for i in range(n):
    for j in range(31):
        s = 1<<j
        s = s-a[i]
        if d.get(s)!=None and ((d[s]==1 and s!=a[i]) or d[s]>=2):
            break
    else:
        ans+=1
print(ans)
",O(nlogn)
"from collections import defaultdict
n,k=map(int,input().split())
arr=list(map(int,input().split()))
xors=defaultdict(int)
xors[0]=1
comp=(1<<k)-1
xor=0
ans=n*(n+1)//2
for a in arr:
    xor^=a
    if(xors[xor]>xors[comp^xor]):
        xor^=comp
    ans-=xors[xor]
    xors[xor]+=1
print(ans)",O(n)
"import itertools
import string



class Solution2(object):
    def greatestLetter(self, s):
        lookup = set(s)
        return next((C for c, C in zip(reversed(string.ascii_lowercase), reversed(string.ascii_uppercase)) if c in lookup and C in lookup), """")",O(n)
"n, t = [int(item) for item in input().split(' ')]
cont, ans = [], 2
for i in range(n):

    temp = list(map(int, input().split(' ')))
    house_center, house_len = temp[0], temp[1]
    cont.append([house_center - house_len / 2, house_center + house_len / 2])

cont.sort(key=lambda element: element[0])

for i in range(0,n - 1):
    gap = cont[i+1][0] - cont[i][1]
    if gap > t:
        ans += 2
    elif gap == t:
        ans += 1

print(ans)
",O(nlogn)
"n, m, k = map(int, input().split())
arr = [int(x) for x in input().split()]
modulo = 0
tmp = 0
op = 1
cur = (arr[0] - 1) // k
for i in range(m):
    if (arr[i] - 1 - modulo) // k != cur:
        modulo += tmp
        cur = (arr[i] - 1 - modulo) // k
        tmp = 0
        op += 1
    tmp += 1
print(op)",O(n)
"import os,sys
from io import BytesIO,IOBase

def solve(s,t):
    if len(t) == 1:
        if s.count(t[0]):
            return 'YES'
        return 'NO'
    for i in range(1,len(t)):
        dp = [[-1000]*(i+1) for _ in range(len(s)+1)]
        dp[0][0] = 0
        for j in range(len(s)):
            dp[j+1] = dp[j][:]
            for k in range(i+1):
                if k != i and s[j] == t[k]:
                    dp[j+1][k+1] = max(dp[j+1][k+1],dp[j][k])
                if abs(dp[j][k]+i) < len(t) and s[j] == t[dp[j][k]+i]:
                    dp[j+1][k] = max(dp[j+1][k],dp[j][k]+1)
        for l in range(len(s)+1):
            if dp[l][-1] == len(t)-i:
                return 'YES'
    return 'NO'

def main():
    for _ in range(int(input())):
        s = input().strip()
        t = input().strip()
        print(solve(s,t))

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(n ^ 3)
"class Solution3(object):
    def reinitializePermutation(self, n):
        result, i = 0, 1
        while not result or i != 1: 
            i = (i//2 if not i%2 else n//2+(i-1)//2)
            result += 1
        return result",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def minimumOperations(self, root):
        result = 0
        q = [root]
        while q:
            new_q = []
            for node in q:
                if node.left:
                    new_q.append(node.left)
                if node.right:
                    new_q.append(node.right)
            idx = list(range(len(q)))
            idx.sort(key=lambda x: q[x].val)
            for i in range(len(q)):
                while idx[i] != i:
                    idx[idx[i]], idx[i] = idx[i], idx[idx[i]]
                    result += 1
            q = new_q
        return result",O(nlogn)
"import string


class Solution(object):
    def uniqueLetterString(self, S):
        M = 10**9 + 7
        index = {c: [-1, -1] for c in string.ascii_uppercase}
        result = 0
        for i, c in enumerate(S):
            k, j = index[c]
            result = (result + (i-j) * (j-k)) % M
            index[c] = [j, i]
        for c in index:
            k, j = index[c]
            result = (result + (len(S)-j) * (j-k)) % M
        return result",O(n)
"N = int(input())
beg = 0
end = 9
i = 0

while N > end:
    i += 1
    beg, end = end, end + (i + 1) * 9 * 10**i

n = N - beg - 1
lvl = i - n % (i + 1)
period = (i + 1) * 10**lvl

res = n//period % 10
if lvl == i:
    res += 1
print(res)
",O(logn)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import gcd, ceil

def prod(a, mod=10**9+7):
    ans = 1
    for each in a:
        ans = (ans * each) % mod
    return ans

def lcm(a, b): return a * b // gcd(a, b)

def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

for _ in range(int(input()) if not True else 1):
    n = int(input())
    a = list(map(int, input().split()))
    dp = [[False]*(n+2) for i in range(n+2)]

    dp2 = [[600]*(n+2) for i in range(n+2)]
    for i in range(n):
        dp[i][i] = a[i]
        dp2[i][i] = 1
    for diff in range(1, n):
        for i in range(n-diff):

            for j in range(i, i+diff):
                if dp[i][j] == dp[j+1][i+diff] and dp[i][j]:
                    dp[i][i+diff] = dp[i][j] + 1
                    dp2[i][i+diff] = 1
                dp2[i][i+diff] = min(dp2[i][i+diff], dp2[i][j]+dp2[j+1][i+diff])
            if not dp2[i][i+diff]:
                dp2[i][i+diff] = min(dp2[i+1][i+diff]+1, dp2[i][i+diff-1] + 1)
    print(dp2[0][n-1])",O(n ^ 3)
"import collections


class Solution(object):
    def countStudents(self, students, sandwiches):
        count = collections.Counter(students)
        for i, s in enumerate(sandwiches):
            if not count[s]:
                break
            count[s] -= 1
        else:
            i = len(sandwiches)
        return len(sandwiches)-i",O(n)
"from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]

def dp(r1, g1, b1):
    if mem[r1][g1][b1] != -1:
        return mem[r1][g1][b1]

    v1, v2, v3 = 0, 0, 0

    if r1 < r:
        if g1 < g:
            v1 = (ar[r1] * ag[g1]) + dp(r1 + 1, g1 + 1, b1)
        if b1 < b:
            v2 = (ar[r1] * ab[b1]) + dp(r1 + 1, g1, b1 + 1)

    if g1 < g and b1 < b:
        v3 = (ag[g1] * ab[b1]) + dp(r1, g1 + 1, b1 + 1)

    mem[r1][g1][b1] = max(v1, v2, v3)

    return mem[r1][g1][b1]

r, g, b = rints()
ar, ag, ab = [sorted(rints(), reverse=True) for _ in range(3)]
mem = [[[-1 for _ in range(b + 1)] for _ in range(g + 1)] for _ in range(r + 1)]
print(dp(0, 0, 0))
",O(n ^ 3)
"class Solution3(object):
    def checkIfCanBreak(self, s1, s2):
        s1, s2 = sorted(s1), sorted(s2)
        return all(a >= b for a, b in zip(s1, s2)) or \
               all(a <= b for a, b in zip(s1, s2))",O(nlogn)
"z,zz=input,lambda:list(map(int,z().split()))
zzz=lambda:[int(i) for i in stdin.readline().split()]
szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())
from string import *
from re import *
from collections import *
from queue import *
from sys import *
from collections import *
from math import *
from heapq import *
from itertools import *
from bisect import *
from collections import Counter as cc
from math import factorial as f
from bisect import bisect as bs
from bisect import bisect_left as bsl
from itertools import accumulate as ac
def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))
def prime(x):
    p=ceil(x**.5)+1
    for i in range(2,p):
        if (x%i==0 and x!=2) or x==0:return 0

    return 1
def dfs(u,visit,graph):
    visit[u]=True
    for i in graph[u]:
        if not visit[i]:
            dfs(i,visit,graph)

l=z()
n=len(l)
ans=0
for i in range(n):

    for j in range(i+1,n+1):
        p=l[i:j]
        t=len(p)
        x=0

        for k in range( n):
            if l[k:k+t]==p:
                x+=1
        if x>=2:
            ans=max(ans,t)
print(ans)
",O(n ^ 3)
"class Solution(object):
    def isPalindrome(self, x):
        if x < 0:
            return False
        copy, reverse = x, 0

        while copy:
            reverse *= 10
            reverse += copy % 10
            copy //= 10

        return x == reverse",O(logn)
"n,m = map(int,input().split())

a = list(map(int,input().split()))
b = list(map(int,input().split()))

r = []

for i in a:
    if i in b:
        r.append(i)
print(' '.join(map(str, r)))
",O(n ^ 2)
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))
r.sort()
g.sort()
b.sort()

dp = [[[0]*202 for i in range(202)] for j in range(202)]
for i in range(R+1):
       for j in range(G+1):
              for k in range(B+1):
                     if i and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])
                     if i and k:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])
                     if k and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])
print(dp[R][G][B])
",O(n ^ 3)
"class Solution_Wrong_Greedy_SkipList(object):
    def minimumIncompatibility(self, nums, k):
        def greedy(nums, k, is_reversed):
            count = collections.Counter(nums)
            if max(count.values()) > k:
                return -1
            ordered_set = SkipList() if not is_reversed else SkipList(end=float(""-inf""), cmp=lambda x, y: x > y)
            freq_to_nodes = collections.defaultdict(collections.OrderedDict)
            for x in sorted(list(count.keys()), reverse=is_reversed):
                ordered_set.add(x)
                freq_to_nodes[count[x]][x] = count[x]
            stks = [[] for _ in range(k)] 
            curr = 0
            while ordered_set: 
                if len(stks)-curr in freq_to_nodes: 
                    for x in freq_to_nodes[len(stks)-curr].keys(): 
                        for i in range(curr, len(stks)):
                            stks[i].append(x)
                        count.pop(x)
                        ordered_set.remove(ordered_set.find(x))
                    freq_to_nodes.pop(len(stks)-curr)
                it = ordered_set.begin()
                while it != ordered_set.end():
                    x = it.val
                    stks[curr].append(x)
                    freq_to_nodes[count[x]].pop(x)
                    if not freq_to_nodes[count[x]]:
                        freq_to_nodes.pop(count[x])
                    count[x] -= 1 
                    if not count[x]:
                        count.pop(x)
                        it = ordered_set.remove(it) 
                    else:
                        freq_to_nodes[count[x]][x] = count[x]
                        it = it.nexts[0]
                    if len(stks[curr]) == len(nums)//k:
                        curr += 1
                        break
            return sum([max(stk)-min(stk) for stk in stks])

        return min(greedy(nums, k, False), greedy(nums, k, True))",O(nlogn)
"tam,q = [int(i) for i in input().split()]
t = input()
s = t

posi = -1

for j in range(tam-1):
    if(t[:j+1] == t[tam - j -1:]):
        posi = j

add = t[posi+1:]

for j in range(q-1):
    s += add

print(s)
",O(n ^ 2)
"from sys import stdin,stdout
import heapq
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):
    n,k=lst()
    l=sorted(zip(lst(),lst(),range(n)))
    h=[];sm=0
    ans={}
    for i in range(n):
        pwr,cns,ind=l[i]
        sm+=cns
        if len(h)>k:
            sm-=heapq.heappop(h)
        ans[ind]=sm
        heapq.heappush(h,cns)
    for i in range(n):
        stdout.write(str(ans[i])+' ')
    print()",O(nlogn)
"import bisect
import copy
import decimal
import fractions
import heapq
import itertools
import math
import random
import sys
from collections import deque,defaultdict
from functools import lru_cache,reduce
from heapq import heappush,heappop,heapify,_heappop_max,_heapify_max
def _heappush_max(heap,item):
    heap.append(item)
    heapq._siftdown_max(heap,0,len(heap)-1)
from math import gcd as Gcd
read=sys.stdin.read
readline=sys.stdin.readline
readlines=sys.stdin.readlines

def Extended_Euclid(n,m):
    stack=[]
    while m:
        stack.append((n,m))
        n,m=m,n%m
    if n>=0:
        x,y=1,0
    else:
        x,y=-1,0
    for i in range(len(stack)-1,-1,-1):
        n,m=stack[i]
        x,y=y,x-(n//m)*y
    return x,y

class MOD:
    def __init__(self,p,e=1):
        self.p=p
        self.e=e
        self.mod=self.p**self.e

    def Pow(self,a,n):
        a%=self.mod
        if n>=0:
            return pow(a,n,self.mod)
        else:
            assert math.gcd(a,self.mod)==1
            x=Extended_Euclid(a,self.mod)[0]
            return pow(x,-n,self.mod)

    def Build_Fact(self,N):
        assert N>=0
        self.factorial=[1]
        self.cnt=[0]*(N+1)
        for i in range(1,N+1):
            ii=i
            self.cnt[i]=self.cnt[i-1]
            while ii%self.p==0:
                ii//=self.p
                self.cnt[i]+=1
            self.factorial.append((self.factorial[-1]*ii)%self.mod)
        self.factorial_inv=[None]*(N+1)
        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)
        for i in range(N-1,-1,-1):
            ii=i+1
            while ii%self.p==0:
                ii//=self.p
            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod

    def Fact(self,N):
        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod

    def Fact_Inv(self,N):
        if self.cnt[N]:
            return None
        return self.factorial_inv[N]

    def Comb(self,N,K,divisible_count=False):
        if K<0 or K>N:
            return 0
        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod
        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]
        if divisible_count:
            return retu,cnt
        else:
            retu*=pow(self.p,cnt,self.mod)
            retu%=self.mod
            return retu

def Bell_Numbers(N,mod,prime=False):
    bell_numbers=[0]*(N+1)
    bell_numbers[0]=1
    MD=MOD(mod)
    if prime:
        MD.Build_Fact(min(mod-2,N-1))
        for i in range(1,min(mod,N+1)):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
        for i in range(mod,N+1):
            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod
    else:
        MD.Build_Fact(N-1)
        for i in range(1,N+1):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
    return bell_numbers

M,N=map(int,readline().split())
S=[readline().rstrip() for i in range(N)]
dct=defaultdict(int)
for i in range(M):
    tpl=()
    for j in range(N):
        tpl+=(S[j][i],)
    dct[tpl]+=1
ans=1
mod=10**9+7
bell=Bell_Numbers(M,mod)
for c in dct.values():
    ans*=bell[c]
    ans%=mod
print(ans)",O(n ^ 2)
"n = int(input())
arr = list(map(int, input().split()))
dp = [[0] * 5 for i in range(n)]
dp[0] = [1, 1, 1, 1, 1]

for i in range(1, n):
    if arr[i] > arr[i - 1]:
        for j in range(1, 5):
            dp[i][j] = max(dp[i][j - 1], dp[i - 1][j - 1])
    elif arr[i] < arr[i - 1]:
        for j in range(3, -1, -1):
            dp[i][j] = max(dp[i - 1][j + 1], dp[i][j + 1])
    else:
        for j in range(5):
            dp[i][j] += (sum(dp[i - 1]) > 0) * (dp[i - 1][j] == 0 or sum(dp[i - 1]) > 1)
if dp[-1] == [0, 0, 0, 0, 0]:
    print(-1)
else:
    ans = [dp[-1].index(1) + 1]
    for i in range(n - 2, -1, -1):
        for j in range(5):
            if dp[i][j] > 0 and ((j + 1 > ans[-1] and arr[i] > arr[i + 1])
                                 or (j + 1 < ans[-1] and arr[i] < arr[i + 1])
                                 or (j + 1 != ans[-1] and arr[i] == arr[i + 1])):
                ans.append(j + 1)
                break
    print(*reversed(ans))
",O(n ^ 2)
"import sys

def sum_range(l, r):
    if r < l: return 0
    if l == 0: return sum[r]
    return sum[r] - sum[l - 1]

n, k = map(int, input().split())

cards = input()

sum = [0] * n
sum[0] = 1 if cards[0] == '1' else 0
for i in range(1, n):
    sum[i] += sum[i - 1]
    if cards[i] == '1':
        sum[i] += 1

min0 = min1 = n
max0 = max1 = -1
for i in range(0, n):
    if cards[i] == '1':
        min1 = min(min1, i)
        max1 = i
    else:
        min0 = min(min0, i)
        max0 = i

toki = False
qual = True
for i in range(0, n - k + 1):
    if sum_range(0, i - 1) + sum_range(i + k, n - 1) + k == n:
        toki = True
    if sum_range(0, i - 1) + sum_range(i + k, n - 1) + 0 == 0:
        toki = True

    prefix = sum_range(0, i - 1) == 0
    suffix = sum_range(i + k, n - 1) == 0
    if i > 0 and i + k < n and (prefix ^ suffix) == 0:
        qual = False
    if i - min0 > k or i - min1 > k or max0 - (i + k - 1) > k or max1 - (i + k - 1) > k:
        qual = False

if toki == True:
    print('tokitsukaze')
elif qual == True:
    print('quailty')
else:
    print('once again')",O(n)
"class Solution2(object):
    def minMovesToMakePalindrome(self, s):
        s = list(s)
        result = 0
        while s:
            i = s.index(s[-1])
            if i == len(s)-1:
                result += i//2
            else:
                result += i
                s.pop(i)
            s.pop()
        return result",O(n ^ 2)
"R,G,B=list(map(int,input().split()))
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
dp = [[[0 for i in range(B + 1)] for j in range(G + 1)] for k in range(R + 1)]
ans=0
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k]=max(dp[i+1][j+1][k],r[i]*g[j]+dp[i][j][k])
            if i<R and k<B:
                dp[i+1][j][k+1]=max(dp[i+1][j][k+1],r[i]*b[k]+dp[i][j][k])
            if k<B and j<G:
                dp[i][j+1][k+1]=max(dp[i][j+1][k+1],b[k]*g[j]+dp[i][j][k])
            ans=max(ans,dp[i][j][k])
print(ans)",O(n ^ 3)
"a , b , c , d , e , f = map(int,input().split())
n , n1 = 1 , a * b + c * d + e * f
while n ** 2 < n1 :
    n += 1
if n ** 2 > n1 :
    print(-1)
    exit()
l = sorted([[max(a,b),min(a,b),'A'], [max(c,d),min(c,d),'B'], [max(e,f),min(e,f),'C']])
if l[2][0] != n:
    print(-1)
    exit()
v = str(n) + '\n' + (l[2][2] * n + '\n') * l[2][1]
if l[0][0] == n and l[1][0] == n:
    for i in range(2):
        v += (l[i][2] * n + '\n') * l[i][1]
else:
    s = n - l[2][1]
    if s not in l[0] or s not in l[1] :
        print(-1)
        exit()
    x , y = l[0][1] if s == l[0][0] else l[0][0] , l[1][1] if s == l[1][0] else l[1][0]
    v += (l[0][2] * x + l[1][2] * y + '\n') * s
print(v)",np
"class Solution(object):
    def atMostNGivenDigitSet(self, D, N):
        str_N = str(N)
        set_D = set(D)
        result = sum(len(D)**i for i in range(1, len(str_N)))
        i = 0
        while i < len(str_N):
            result += sum(c < str_N[i] for c in D) * (len(D)**(len(str_N)-i-1))
            if str_N[i] not in set_D:
                break
            i += 1
        return result + int(i == len(str_N))",O(logn)
"n=int(input())
print((n//2)+1)
",O(1)
"import sys
input = sys.stdin.readline
q=int(input())
for i in range(q):
  n,k=map(int,input().split())
  s=input()
  a=k
  for j in range(n-k+1):
    a1,a2,a3=0,0,0
    for jj in range(k):
      if jj%3==0:
        if s[j+jj]==""R"":
          a2+=1
          a3+=1
        elif s[j+jj]==""G"":
          a1+=1
          a3+=1
        else:
          a1+=1
          a2+=1
      elif jj%3==1:
        if s[j+jj]==""R"":
          a1+=1
          a2+=1
        elif s[j+jj]==""G"":
          a2+=1
          a3+=1
        else:
          a3+=1
          a1+=1
      else:
        if s[j+jj]==""R"":
          a1+=1
          a3+=1
        elif s[j+jj]==""G"":
          a1+=1
          a2+=1
        else:
          a3+=1
          a2+=1
    a=min(a,a1,a2,a3)
  print(a)
",O(n ^ 2)
"from sys import stdin,stdout
input=stdin.readline
t=1
for _ in range(t):
    n=int(input())
    x=input()
    c=0
    ans=0
    for i in x:
        if i=='x':
            c+=1
        else:
            ans+=max(0,c-2)
            c = 0
    ans+=max(0,c-2)
    print(ans)",O(n)
"class Solution:
    def maxArea(self, heights: List[int]) -> int:
        l, r = 0, len(heights) - 1
        res = 0

        while l < r:
            area = min(heights[l], heights[r]) * (r - l)
            res = max(res, area)
            if heights[l] <= heights[r]:
                l += 1
            else:
                r -= 1
        return res
",O(n)
"n, t = [int(item) for item in input().split(' ')]
cont, ans = list(), 2
for i in range(n):
    hCenter, hLen = [float(item) for item in input().split(' ')]

    cont.append([hCenter - hLen / 2, hCenter + hLen / 2])

cont.sort(key=lambda item: item[0])

for i in range(n - 1):
    gap = cont[i+1][0] - cont[i][1]
    if gap > t:
        ans += 2
    elif gap == t:
        ans += 1

print(ans)
",O(nlogn)
"from sys import stdin, stdout
ti = lambda : stdin.readline().strip()
os = lambda i : stdout.write(str(i) + '\n')
ma = lambda fxn, ti : map(fxn, ti.split())
ol = lambda arr : stdout.write(' '.join(element for element in arr) + '\n')
olws = lambda arr : stdout.write(''.join(element for element in arr) + '\n')

class Digit:
	def __init__(self):
		self.count = {}

	def increment(self, k):
		if self.count.has_key(k):
			got = self.count[k]
			self.count[k] += 1
		else:
			self.count[k] = 1

	def found(self, k):
		if self.count.has_key(k):
			return self.count[k]
		else:
			return 0

n, mod = ma(int, ti())
array = ma(int, ti())

ans = 0
digits = [None]*11
for i in range(11):
	digits[i] = Digit()

for i in range(n):
	temp = array[i]%mod

	for j in range(10):
		temp *= 10
		temp %= mod

		digits[j+1].increment(temp)

for i in range(n):
	temp = array[i]
	count = 0
	while temp>0:
		temp /= 10
		count += 1

	find = mod-array[i]%mod
	find %= mod
	ans += digits[count].found(find)

for i in range(n):
	temp1 = array[i]%mod
	temp2 = array[i]

	while temp2 > 0:
		temp2 /= 10
		temp1 *= 10
		temp1 %= mod

	if ((temp1 + array[i])%mod == 0):
		ans -= 1

os(ans)",O(nlogn)
"import copy
n = int(input())
flg=0
mat1 = []
mat2 = []

mats = []
for i in range(0, n): mat1.append(tuple(input().strip()))
for i in range(0, n): mat2.append(tuple(input().strip()))
mats.append(mat2)
matu = copy.copy(mat2)
matv = copy.copy(mat2)
matv = list(zip(*matv))
mats.append(matv)

mattem = copy.copy(matu)
for i in range(0, 3):
	mattem = list(zip(*list(reversed(mattem))))
	mats.append(mattem)
mattem = copy.copy(matv)
for i in range(0, 3):
	mattem = list(zip(*list(reversed(mattem))))
	mats.append(mattem)

flg = 0
for cmat in mats:
	flg2 = 1
	for ri in range(0, n):
		if cmat[ri]!=mat1[ri]:
			flg2=0
			break
	if flg2==1:
		flg=1
		break
if flg==1: print(""Yes"")
else: print(""No"")
",O(n ^ 2)
"from sys import stdin

line = stdin.readline().rstrip().split()
x = int(line[0])
k = int(line[1])

if x == 0:
    print(0)
else:
    nn = pow(2, k, 1000000007)
    result = (nn*2*x - nn + 1) % 1000000007
    print(result)
",O(logn)
"MAX=10**9
def main():

    n,m=readIntArr()
    arrs=[]
    for _ in range(n):
        arrs.append(readIntArr())

    def checkPossible(minB):
        binRepresentations=set()
        for arr in arrs:
            binRepresentations.add(convertToBinary(arr,minB))
        binList=list(binRepresentations)
        ii=jj=-1
        n=len(binList)
        for i in range(n):
            for j in range(i,n):
                if binList[i]|binList[j]==(1<<m)-1:
                    ii=binList[i]
                    jj=binList[j]
        if ii!=-1:
            ansi=ansj=-1
            for i in range(len(arrs)):
                b=convertToBinary(arrs[i],minB)
                if b==ii:
                    ansi=i
                if b==jj:
                    ansj=i

            return (ansi,ansj)
        else:
            return None

    def convertToBinary(arr,minB):
        b=0
        for i in range(m):
            if arr[i]>=minB:
                b|=(1<<i)
        return b

    minB=-1
    i=j=-1
    b=MAX
    while b>0:
        temp=checkPossible(minB+b)
        if temp==None:
            b//=2
        else:
            minB+=b
            i,j=temp
    i+=1;j+=1
    print('{} {}'.format(i,j))

    return

import sys
input=sys.stdin.buffer.readline

def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))

def readIntArr():
    return [int(x) for x in input().split()]

def makeArr(*args):

    assert len(args) >= 2, ""makeArr args should be (default value, dimension 1, dimension 2,...""
    if len(args) == 2:
        return [args[0] for _ in range(args[1])]
    else:
        return [makeArr(args[0],*args[2:]) for _ in range(args[1])]

def queryInteractive(x,y):
    print('? {} {}'.format(x,y))
    sys.stdout.flush()
    return int(input())

def answerInteractive(ans):
    print('! {}'.format(ans))
    sys.stdout.flush()

inf=float('inf')
MOD=10**9+7

for _abc in range(1):
    main()",np
"def helper(n,m,k):

    if k % 2 == 1:
        res = [[-1] * m for i in range(n)]
        return res

    k = k // 2

    pool = [[[0]*m for i in range(n)] for j in range(k+1)]

    dx = [0,0,1,-1]
    dy = [1,-1,0,0]

    for t in range(1,k+1):
        for i in range(n):
            for j in range(m):
                tres = [9999999] * 4
                for c in range(4):
                    if 0 <= i+dx[c] < n and 0 <= j+dy[c] < m:
                        if c == 0:
                            tres[c] = hedge[i][j]*2 + pool[t-1][i+dx[c]][j+dy[c]]
                        elif c == 1:
                            tres[c] = hedge[i][j-1]*2 + pool[t-1][i+dx[c]][j+dy[c]]
                        elif c == 2:
                            tres[c] = vedge[i][j]*2 + pool[t-1][i+dx[c]][j+dy[c]]
                        else:
                            tres[c] = vedge[i-1][j]*2 + pool[t-1][i+dx[c]][j+dy[c]]
                pool[t][i][j] = min(tres)

    return pool[k]

n,m,k = map(int,input().split("" ""))
hedge = []
vedge = []
for i in range(n):
    hedge.append(list(map(int,input().split("" ""))))
for i in range(n-1):
    vedge.append(list(map(int,input().split("" ""))))

res = helper(n,m,k)
for j in range(len(res)):
    print("" "".join(map(str,res[j])))
",O(n ^ 3)
"from sys import stdin
from bisect import bisect_right as br

from collections import deque
n,m,k=map(int,stdin.readline().strip().split())
s=deque(map(int,stdin.readline().strip().split()))
lim=k
ans=0
while len(s)!=0:
    x=br(s,lim)
    for i in range(x):
        s.popleft()
    if x!=0:
        ans+=1
        lim+=x
    else:
        if len(s)>0:
            x=s[0]-lim
            if x%k==0:
                x=x//k
            else:
                x=(x//k)+1
            lim+=x*k

print(ans)
",O(n)
"n = int(input())
A = [int(a) for a in input().split()]

prefix = [0] * n
prefix[0] = A[0]
for i in range(1, n):
    prefix[i] = prefix[i - 1] + A[i]

target = (sum(A) + 1) // 2

for i in range(n):
    if prefix[i] < target:
        continue
    else:
        print(i + 1)
        break",O(n)
"class Solution(object):
    def searchRange(self, nums, target):
        def binarySearch(n, check): 
            left, right = 0, n-1 
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left 

        def binarySearch2(n, check): 
            left, right = 0, n 
            while left < right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid
                else:
                    left = mid+1
            return left 

        def binarySearch3(n, check): 
            left, right = -1, n-1 
            while left < right:
                mid = right - (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid
            return left+1 

        def binarySearch4(n, check): 
            left, right = -1, n 
            while right-left >= 2:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid
                else:
                    left = mid
            return left+1 

        left = binarySearch(len(nums), lambda i: nums[i] >= target)
        if left == len(nums) or nums[left] != target:
            return [-1, -1]
        right = binarySearch(len(nums), lambda i: nums[i] > target)
        return [left, right-1]",O(logn)
"n = int(input())
a = list(map(int, input().split()))
max1 = float('inf')
for q in range(len(a)):
    if q >= n-q-1:
        max1 = min(max1, min(a[q], a[0])//q)
    if q <= n-q-1:
        max1 = min(max1, min(a[q], a[-1]) // (n-q-1))
print(max1)
",O(n)
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
        memo = {}

        def dfs(i):
            if i in memo:
                return memo[i]
            if i == len(nums) - 1:
                return True
            if nums[i] == 0:
                return False

            end = min(len(nums), i + nums[i] + 1)
            for j in range(i + 1, end):
                if dfs(j):
                    memo[i] = True
                    return True
            memo[i] = False
            return False

        return dfs(0)
",O(n ^ 2)
"n, s = map(int, input().split())

print((s + n - 1) // n)",O(1)
"import math

n, m, k = list(map(int, input().split()))
arr = list(map(int, input().split()))

part_sum = [0]
for i in range(n):
	part_sum.append(part_sum[-1] + arr[i])

part_sum_add = [[] for _ in range(m)]
min_in_part_sum_add = [[] for _ in range(m)]
for shift in range(m):
	count_blocks = math.ceil((n - shift) / m + 1)
	for i in range(n + 1):
		cur_part_sum = part_sum[i] + k * (count_blocks - ((i - shift) // m))
		if i == 0 or cur_part_sum < prev_min_in_part_sum_add:
			cur_min_in_part_sum_add = cur_part_sum
		else:
			cur_min_in_part_sum_add = prev_min_in_part_sum_add

		part_sum_add[shift].append(cur_part_sum)
		min_in_part_sum_add[shift].append(cur_min_in_part_sum_add)
		prev_min_in_part_sum_add = cur_min_in_part_sum_add

max_result = 0
for i in range(1, n + 1):
	current_shift = i % m
	current_min = min_in_part_sum_add[current_shift][i]
	current_ans = part_sum_add[current_shift][i] - current_min

	if current_ans > max_result:
		max_result = current_ans

print(max_result)",O(n ^ 2)
"import math
def main():
    x = input()
    y = input()
    goal = x.count('+') - y.count('+')
    options = y.count('?')
    if options == 0:
        if goal == options:
            print(1)
        else:
            print(0)
    else:
        if (goal > options):
            print(0)
        else:
            if goal < 0:
                print(0)
            else:
                print(math.factorial(options)/math.factorial(goal)/math.factorial(options-goal)/(2**options))
main()
",np
"n,m=map(int,input().split())
l1=list(map(int,input().split()))
l2=list(map(int,input().split()))

for i in l1:
    if i in l2:
        print(i,end="" "")
",O(n ^ 2)
"import sys

num_riders, _ = map(int, next(sys.stdin).split())

houses = map(int, next(sys.stdin).split())
is_rider = map(int, next(sys.stdin).split())

current_left_driver = None
current_citizens = []

result = []

for house, is_rider in zip(houses, is_rider):
    if is_rider:
        if current_left_driver is None:
            result.append(len(current_citizens))
        else:
            result.append(0)
            for citizen in current_citizens:
                if abs(citizen - current_left_driver) <= abs(citizen - house):
                    result[-2] += 1
                else:
                    result[-1] += 1

        current_citizens = []
        current_left_driver = house
    else:
        current_citizens.append(house)

result[-1] += len(current_citizens)

print(' '.join(map(str, result)))
",O(n)
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    if n==1:
        return 0
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[digit[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[digit[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=0):
        self.BIT = [0]*(n+1)
        self.num = n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        mod = self.mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matridigit[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matridigit[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matridigit[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matridigit[i][j]+other._matridigit[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matridigit[i][j]-other._matridigit[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matridigit[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matridigit[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matridigit[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

from collections import deque
class Dinic:
    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap):
        forward = [to, cap, None]
        forward[2] = backward = [fr, 0, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def add_multi_edge(self, v1, v2, cap1, cap2):
        edge1 = [v2, cap1, None]
        edge1[2] = edge2 = [v1, cap2, edge1]
        self.G[v1].append(edge1)
        self.G[v2].append(edge2)

    def bfs(self, s, t):
        self.level = level = [None]*self.N
        deq = deque([s])
        level[s] = 0
        G = self.G
        while deq:
            v = deq.popleft()
            lv = level[v] + 1
            for w, cap, _ in G[v]:
                if cap and level[w] is None:
                    level[w] = lv
                    deq.append(w)
        return level[t] is not None

    def dfs(self, v, t, f):
        if v == t:
            return f
        level = self.level
        for e in self.it[v]:
            w, cap, rev = e
            if cap and level[v] < level[w]:
                d = self.dfs(w, t, min(f, cap))
                if d:
                    e[1] -= d
                    rev[1] += d
                    return d
        return 0

    def flow(self, s, t):
        flow = 0
        INF = 10**9 + 7
        G = self.G
        while self.bfs(s, t):
            *self.it, = map(iter, self.G)
            f = INF
            while f:
                f = self.dfs(s, t, INF)
                flow += f
        return flow

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

N = int(input())
A = li()

dp = [[False for r in range(N)] for l in range(N)]
for l in range(N):
    tmp = [A[l]]
    dp[l][l] = True
    for r in range(l+1,N):
        val = A[r]
        while tmp and tmp[-1]==val:
            val = tmp[-1] + 1
            tmp.pop()
        tmp.append(val)
        if len(tmp)==1:
            dp[l][r] = True

res = [i for i in range(N+1)]
for r in range(1,N+1):
    for l in range(1,r+1):
        if dp[l-1][r-1]:
            res[r] = min(res[r],1+res[l-1])

print(res[N])
",O(n ^ 3)
"from sys import stdin

def solve(tc):
    k = int(stdin.readline().strip())
    cmp = 9
    ndigit = 1

    while k>(cmp*ndigit):
        k -= cmp*ndigit
        cmp *= 10
        ndigit += 1

    num = (10**(ndigit-1)) + ((k-1) // ndigit)
    pos = (k-1) % ndigit

    print(str(num)[pos])
    pass

LOCAL_TEST = not __debug__
if LOCAL_TEST:
    infile = __file__.split('.')[0] + ""-test.in""
    stdin = open(infile, 'r')

tcs = (int(stdin.readline().strip()) if LOCAL_TEST else 1)
tc = 1
while tc <= tcs:
    solve(tc)
    tc += 1",O(logn)
"n,k=list(map(int,input().split()))

arr1=list(map(int,input().split()))
arr2=list(map(int,input().split()))
ans=0

new_arr=[0]*n

for i in range(n):
    if arr2[i]==0:
        new_arr[i]=arr1[i]
    else:
        ans+=arr1[i]

total=sum(new_arr[:k])
mx=total

j=0
for i in range(k,n):
    total-=new_arr[j]
    total+=new_arr[i]
    mx=max(mx,total)
    j+=1

print(mx+ans)
",O(n)
"n = int(input())
a = list(map(int, input().split()))

s = 0
count = dict()
for x in a:
	count[x] = count.get(x, 0) + 1
	s += x

answer = 0
for i in range(n):
	trash = 0
	trash += count.get(a[i] - 1, 0) * (a[i] - 1)
	trash += count.get(a[i]) * a[i]
	trash += count.get(a[i] + 1, 0) * (a[i] + 1)

	xcount = n - i
	xcount -= count.get(a[i] - 1, 0)
	xcount -= count.get(a[i], 0)
	xcount -= count.get(a[i] + 1, 0)

	answer += (s - trash) - (xcount * a[i])

	count[a[i]] -= 1
	s -= a[i]

print(answer)",O(nlogn)
"grid = list(map(int,input().split()))
max_res = 0
for i in range(14):
    g_c = grid.copy()
    Amount = g_c[i]//14
    Amount_r = g_c[i]%14
    if(Amount > 0):
        for j in range(14):
            if i != (i+j+1)%14:
                g_c[(i+j+1)%14]+=Amount
                g_c[i]-=Amount
    if Amount_r > 0:
        for j in range(14):
            if Amount_r > 0:
                if i != (i+j+1)%14:
                    g_c[(i+j+1)%14]+=1
                    Amount_r-=1
                    g_c[i]-=1
            else:
                break

    res = 0
    for i in range(14):
        if g_c[i] % 2 ==0:
            res+=g_c[i]

    max_res = max(max_res,res)

print(max_res)
",O(1)
"class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        count = {}
        freq = [[] for i in range(len(nums) + 1)]

        for num in nums:
            count[num] = 1 + count.get(num, 0)
        for num, cnt in count.items():
            freq[cnt].append(num)

        res = []
        for i in range(len(freq) - 1, 0, -1):
            for num in freq[i]:
                res.append(num)
                if len(res) == k:
                    return res
",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def addOneRow(self, root, v, d):
        if d in (0, 1):
            node = TreeNode(v)
            if d == 1:
                node.left = root
            else:
                node.right = root
            return node
        if root and d >= 2:
            root.left = self.addOneRow(root.left,  v, d-1 if d > 2 else 1)
            root.right = self.addOneRow(root.right, v, d-1 if d > 2 else 0)
        return root",O(n)
"n,k=map(int,input().split())
mod=998244353

NEXT={(0,1):2,(1,2):2}

for i in range(1,n):
    NOW=NEXT
    NEXT=dict()
    for key in NOW:

        if key[0]==0:
            if k-(n-i)*2<=key[1]<=k:
                NEXT[key]=NEXT.get(key,0)+NOW[key]
            if k-(n-i)*2<key[1]+1<=k:
                NEXT[(0,key[1]+1)]=NEXT.get((0,key[1]+1),0)+NOW[key]
                NEXT[(1,key[1]+1)]=NEXT.get((1,key[1]+1),0)+NOW[key]*2%mod

        else:
            if k-(n-i)*2<=key[1]<=k:
                NEXT[key]=NEXT.get(key,0)+NOW[key]
                NEXT[(0,key[1])]=NEXT.get((0,key[1]),0)+NOW[key]*2%mod

            if k-(n-i)*2<key[1]+2<=k:
                NEXT[(1,key[1]+2)]=NEXT.get((1,key[1]+2),0)+NOW[key]

ANS=0
for key in NEXT:
    if key[1]==k:
        ANS=(ANS+NEXT[key])%mod

print(ANS)
",np
"n=int(input())
l=[]
nn=n
while n :
    n-=1
    s=input()
    l.append([len(s),s])
l.sort()
ch=1
i=1

ans=[]
for i in range(nn-1):
    if l[i][1] not in l[i+1][1]:
        ch=0
        break
    else:

        ans.append(l[i][1])

if ch:
    ans.append(l[nn-1][1])
    print(""YES"")

    print(*ans, sep = ""\n"")
else:
    print(""NO"")
",O(nlogn)
"k = 1000001
a = [True] * k
a[0] = a[1] = False

for i in range(k):
    if a[i]:
        for j in range(2*i, k, i):
            a[j] = False

n = int(input())
for i in range(4, n):
    if not a[i] and not a[n-i]:
        print(i, n-i)
        exit()",O(1)
"class Solution2(object):
    def findComplement(self, num):
        i = 1
        while i <= num:
            i <<= 1
        return (i - 1) ^ num",O(1)
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    if n==1:
        return 0
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[digit[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[digit[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=0):
        self.BIT = [0]*(n+1)
        self.num = n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        mod = self.mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matridigit[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matridigit[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matridigit[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matridigit[i][j]+other._matridigit[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matridigit[i][j]-other._matridigit[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matridigit[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matridigit[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matridigit[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

from collections import deque
class Dinic:
    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap):
        forward = [to, cap, None]
        forward[2] = backward = [fr, 0, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def add_multi_edge(self, v1, v2, cap1, cap2):
        edge1 = [v2, cap1, None]
        edge1[2] = edge2 = [v1, cap2, edge1]
        self.G[v1].append(edge1)
        self.G[v2].append(edge2)

    def bfs(self, s, t):
        self.level = level = [None]*self.N
        deq = deque([s])
        level[s] = 0
        G = self.G
        while deq:
            v = deq.popleft()
            lv = level[v] + 1
            for w, cap, _ in G[v]:
                if cap and level[w] is None:
                    level[w] = lv
                    deq.append(w)
        return level[t] is not None

    def dfs(self, v, t, f):
        if v == t:
            return f
        level = self.level
        for e in self.it[v]:
            w, cap, rev = e
            if cap and level[v] < level[w]:
                d = self.dfs(w, t, min(f, cap))
                if d:
                    e[1] -= d
                    rev[1] += d
                    return d
        return 0

    def flow(self, s, t):
        flow = 0
        INF = 10**9 + 7
        G = self.G
        while self.bfs(s, t):
            *self.it, = map(iter, self.G)
            f = INF
            while f:
                f = self.dfs(s, t, INF)
                flow += f
        return flow

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

square = set([i**2 for i in range(10**5)])

for _ in range(int(input())):
    n = int(input())
    if n%2:
        print(""NO"")
    else:
        k = n//2
        if k in square:
            print(""YES"")
        elif k%2:
            print(""NO"")
        else:
            k = k//2
            if k in square:
                print(""YES"")
            else:
                print(""NO"")
",O(1)
"class Solution(object):
    def numRescueBoats(self, people, limit):
        people.sort()
        result = 0
        left, right = 0, len(people)-1
        while left <= right:
            result += 1
            if people[left] + people[right] <= limit:
                left += 1
            right -= 1
        return result",O(nlogn)
"from collections import deque
import sys
input = sys.stdin.readline

n, d, k = map(int, input().split())
if n == 1 or n <= d:
    ans = ""NO""
elif k == 1:
    ans = ""YES"" if n == 2 and d == 1 else ""NO""
    e = [(1, 2)]
else:
    e = [(i + 1, i + 2) for i in range(d)]
    q = deque()
    l, r = 1, d + 1
    if k > 2:
        for i in range(2, d + 1):
            q.append((i, 2, min(i - l, r - i)))
    ans = ""YES""
    for i in range(d + 2, n + 1):
        if not q:
            ans = ""NO""
            break
        j, k0, d0 = q.popleft()
        e.append((j, i))
        if k0 + 1 < k:
            q.append((j, k0 + 1, d0))
        if d0 - 1 > 0:
            q.append((i, 1, d0 - 1))
print(ans)
if ans == ""YES"":
    for u, v in e:
        print(u, v)",O(n ^ 2)
"def arr_inp():
    return [int(x) for x in stdin.readline().split()]

def nCr(n, r):
    f, m = factorial, 1
    for i in range(n, n - r, -1):
        m *= i
    return int(m // f(r))

from math import factorial
from sys import stdin

n, a, ans, tem = int(input()), arr_inp(), [], 0
mem = [0] * (n + 1)

for i in range(n):
    for j in range(a[i] - 1, 0, -1):
        if not mem[j]:
            tem += 1
    mem[a[i]] = 1

for i in range(int(input())):
    l, r = arr_inp()
    tem += nCr(r - l + 1, 2)
    ans.append('odd' if tem % 2 else 'even')

print('\n'.join(ans))
",O(n ^ 2)
"n = int(input())
a = list(map(int, input().split()))
chet = 0
ne_chet = 0
chet1 = []
ne_chet1 = []
for i in range(len(a)):
    if a[i] % 2 == 0:
        chet += 1
        chet1.append(a[i])
    else:
        ne_chet += 1
        ne_chet1.append(a[i])
    if chet >= 1 and ne_chet >= 1 and (chet > 1 or ne_chet > 1):
        break
if chet == 1:
    print(a.index(chet1[0]) + 1)
elif ne_chet == 1:
    print(a.index(ne_chet1[0]) + 1)
",O(n)
"def main():
    n = int(input())
    s = input()
    for i in range(n+1):
        flag = True
        stones = i
        for j in s:
            if j == '-':
                if stones > 0:
                    stones -= 1
                else:
                    flag = False
                    break
            else:
                stones += 1

        if flag:
            n = i
            break

    stones = n
    for i in s:
        if i == '-':
            stones -= 1
        else:
            stones += 1

    print(stones)

main()
",O(n ^ 2)
"n,k=map(int,input().split())
if k>=n-1:
    print(n-1)
else:
    print(k+ ((n-k)*(n-k+1))//2 - 1)",O(1)
"class Solution2(object):
    def getMoneyAmount(self, n):
        dp = [[0]*(n+1) for _ in range(n+1)] 
        for i in reversed(range(n)):
            for j in range(i+2, n+1):
                dp[i][j] = min((k+1) + max(dp[i][k], dp[k+1][j]) for k in range(i, j))
        return dp[0][n]",O(n ^ 3)
"n = int(input())
s = [input() for i in range(n)]
MOD = 10**9 + 7

dps = [[0]*(n + 3) for i in range(n + 1)]
dpf = [[0]*(n + 3) for i in range(n + 1)]

for k in range(n + 1):
    dps[0][k] = 1

for pos, char in enumerate(s):
    if char == ""s"":

        for depth in range(pos + 2):
            dps[pos + 1][depth] = dpf[pos][depth] - \
                dpf[pos][depth - 1] + dps[pos][pos] - dps[pos][depth - 1]

            dps[pos + 1][depth] += dps[pos + 1][depth - 1]
            dps[pos + 1][depth] %= MOD

        for p in range(pos + 2, n+1):
            dpf[pos + 1][p] += dpf[pos + 1][p - 1]
            dpf[pos + 1][p] %= MOD
        continue

    else:

        for depth in range(1, pos + 2):
            dpf[pos + 1][depth] = dpf[pos][depth - 1] - \
                dpf[pos][depth - 2] + dps[pos][pos] - dps[pos][depth - 2]

            dpf[pos + 1][depth] += dpf[pos + 1][depth - 1]
            dpf[pos + 1][depth] %= MOD
        for p in range(pos + 2, n+1):
            dpf[pos + 1][p] += dpf[pos + 1][p - 1]
            dpf[pos + 1][p] %= MOD

ans = dps[n][n] % MOD
print(ans)
",O(n ^ 2)
"import sys
input = sys.stdin.readline

n, mod = map(int, input().split())
fac = [1] + [0] * (n + 1)
inv = [1] + [0] * (n + 1)
C = [[0] * (n + 2) for _ in range(n + 2)]
p2 = [1] + [0] * (n + 1)
for i in range(1, n + 2):
    fac[i] = fac[i - 1] * i % mod
    p2[i] = p2[i - 1] * 2 % mod
inv[-1] = pow(fac[-1], mod - 2, mod)
for i in range(n, 0, -1):
    inv[i] = inv[i + 1] * (i + 1) % mod
for i in range(n + 2):
    for j in range(i + 1):
        C[i][j] = fac[i] * inv[j] % mod * inv[i - j] % mod
dp = [[0] * (n + 2) for _ in range(n + 2)]
dp[0][0] = 1
for i in range(n):
    for j in range(i + 1):
        for k in range(1, n - i + 1):
            dp[i + k + 1][j + k] += dp[i][j] * p2[k - 1] % mod * C[j + k][k] % mod
            dp[i + k + 1][j + k] %= mod
ans = 0
for i in range(n + 1):
    ans = (ans + dp[n + 1][i]) % mod
print(ans)",O(n ^ 3)
"class Solution(object):
    def addBinary(self, a, b):
        result, carry, val = """", 0, 0
        for i in range(max(len(a), len(b))):
            val = carry
            if i < len(a):
                val += int(a[-(i + 1)])
            if i < len(b):
                val += int(b[-(i + 1)])
            carry, val = divmod(val, 2)
            result += str(val)
        if carry:
            result += str(carry)
        return result[::-1]",O(n)
"i=int(input())
d=i%2+8;print(d,i-d)",O(1)
"n = int(raw_input())
a = sorted(list(map(int, raw_input().split())))
duplicates = {}
d = None
delta = 0
for i, el in enumerate(a, 1):
    if el not in duplicates:
        duplicates[el] = 0
    else:
        d = el
        duplicates[el] += 1
    min_value = i-1
    delta += el - min_value
if sum(duplicates.values()) > 1 or duplicates.get(0, 0) >= 1 or (d is not None and d-1 in duplicates):
    print('cslnb')
elif delta == 0:
    print('cslnb')
elif delta % 2 == 1:
    print('sjfnb')
else:
    print('cslnb')",O(n)
"import collections



class Solution(object):
    def beautifulSubarrays(self, nums):
        cnt = collections.Counter()
        cnt[0] = 1
        result = curr = 0
        for x in nums:
            curr ^= x
            result += cnt[curr]
            cnt[curr] += 1
        return result",O(n)
"n,m=[int(x) for x in input().split()]
a=sorted([int(x) for x in input().split()])
b=[int(x) for x in input().split()]
if max(a)<min(b):
    print(sum(a)*m+sum(b)-a[-1]*(m-1)-a[-2])
elif max(a)==min(b):
    print(sum(a)*m+sum(b)-a[-1]*m)
else:
    print(-1)
",O(nlogn)
"from itertools import combinations

[n,l,r,x] = [int(x) for x in input().split()]
c = [int(x) for x in input().split()]
c.sort()
k = 0

from itertools import combinations

for i in range(n) :
	for j in range(i+1,n) :
		if ( c[j] - c[i] ) >= x :
			if sum(c[i:j+1]) < l :
				continue
			elif  (c[i] + c[j]) > r :
				continue
			else :
				if (c[i] + c[j]) >= l and (c[i] + c[j]) <= r :
					k += 1
				for p in range(1,j-i) :
					for m in combinations(c[i+1:j],p) :
						if (sum(m)+c[i] +c[j]) >= l and (sum(m)+c[i] +c[j]) <= r :
							k+=1

print(k)
",np
"import collections



class Solution(object):
    def mostFrequent(self, nums, key):
        return collections.Counter(nums[i+1] for i in range(len(nums)-1) if nums[i] == key).most_common(1)[0][0]",O(n)
"def luckynumber(n):
    a=[]
    for i in range(4,n+1):
        r=i
        c=0
        while(r>0):
            x=r%10
            if x!=4 and x!=7:
                c=1
                break
            r=r//10
        if c==0:
            a.append(i)
    return a
n=int(input())
a=luckynumber(n)
for i in a:
    if n==i or n%i==0:
        print(""YES"")
        break
else:
    print(""NO"")
",O(1)
"import itertools



class Solution(object):
    def isAcronym(self, words, s):
        return len(words) == len(s) and all(w[0] == c for w, c in zip(words, s))",O(n)
"import os
import sys
import math
from io import BytesIO, IOBase
import io
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
from collections import Counter
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: max(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=0, func=lambda a, b: a+b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

prime = [True for i in range(11)]
prime[0]=prime[1]=False

def SieveOfEratosthenes(n=10):
    p = 2
    c=0
    while (p <= n):

        if (prime[p] == True):
            c+=1
            for i in range(p, n+1, p):

                prime[i] = False
        p += 1

class DSU:
    def __init__(self, R, C):

        self.par = range(R*C + 1)
        self.rnk = [0] * (R*C + 1)
        self.sz = [1] * (R*C + 1)

    def find(self, x):
        if self.par[x] != x:
            self.par[x] = self.find(self.par[x])
        return self.par[x]

    def union(self, x, y):
        xr, yr = self.find(x), self.find(y)
        if xr == yr: return
        if self.rnk[xr] < self.rnk[yr]:
            xr, yr = yr, xr
        if self.rnk[xr] == self.rnk[yr]:
            self.rnk[xr] += 1

        self.par[yr] = xr
        self.sz[xr] += self.sz[yr]

    def size(self, x):
        return self.sz[self.find(x)]

    def top(self):

        return self.size(len(self.sz) - 1) - 1

class LazySegTree:
    def __init__(self, _op, _e, _mapping, _composition, _id, v):
        def set(p, x):
            assert 0 <= p < _n
            p += _size
            for i in range(_log, 0, -1):
                _push(p >> i)
            _d[p] = x
            for i in range(1, _log + 1):
                _update(p >> i)

        def get(p):
            assert 0 <= p < _n
            p += _size
            for i in range(_log, 0, -1):
                _push(p >> i)
            return _d[p]

        def prod(l, r):
            assert 0 <= l <= r <= _n

            if l == r:
                return _e

            l += _size
            r += _size

            for i in range(_log, 0, -1):
                if ((l >> i) << i) != l:
                    _push(l >> i)
                if ((r >> i) << i) != r:
                    _push(r >> i)

            sml = _e
            smr = _e
            while l < r:
                if l & 1:
                    sml = _op(sml, _d[l])
                    l += 1
                if r & 1:
                    r -= 1
                    smr = _op(_d[r], smr)
                l >>= 1
                r >>= 1

            return _op(sml, smr)

        def apply(l, r, f):
            assert 0 <= l <= r <= _n
            if l == r:
                return

            l += _size
            r += _size

            for i in range(_log, 0, -1):
                if ((l >> i) << i) != l:
                    _push(l >> i)
                if ((r >> i) << i) != r:
                    _push((r - 1) >> i)

            l2 = l
            r2 = r
            while l < r:
                if l & 1:
                    _all_apply(l, f)
                    l += 1
                if r & 1:
                    r -= 1
                    _all_apply(r, f)
                l >>= 1
                r >>= 1
            l = l2
            r = r2

            for i in range(1, _log + 1):
                if ((l >> i) << i) != l:
                    _update(l >> i)
                if ((r >> i) << i) != r:
                    _update((r - 1) >> i)

        def _update(k):
            _d[k] = _op(_d[2 * k], _d[2 * k + 1])

        def _all_apply(k, f):
            _d[k] = _mapping(f, _d[k])
            if k < _size:
                _lz[k] = _composition(f, _lz[k])

        def _push(k):
            _all_apply(2 * k, _lz[k])
            _all_apply(2 * k + 1, _lz[k])
            _lz[k] = _id

        _n = len(v)
        _log = _n.bit_length()
        _size = 1 << _log
        _d = [_e] * (2 * _size)
        _lz = [_id] * _size
        for i in range(_n):
            _d[_size + i] = v[i]
        for i in range(_size - 1, 0, -1):
            _update(i)

        self.set = set
        self.get = get
        self.prod = prod
        self.apply = apply

MIL = 1 << 20

def makeNode(total, count):

    return (total * MIL) + count

def getTotal(node):
    return math.floor(node / MIL)

def getCount(node):
    return node - getTotal(node) * MIL

nodeIdentity = makeNode(0.0, 0.0)

def nodeOp(node1, node2):
    return node1 + node2

    return makeNode(
        getTotal(node1) + getTotal(node2), getCount(node1) + getCount(node2)
    )

identityMapping = -1

def mapping(tag, node):
    if tag == identityMapping:
        return node

    count = getCount(node)
    return makeNode(tag * count, count)

def composition(mapping1, mapping2):

    return mapping1 if mapping1 != identityMapping else mapping2

def memodict(f):

    class memodict(dict):
        def __missing__(self, key):
            ret = self[key] = f(key)
            return ret

    return memodict().__getitem__

def pollard_rho(n):

    if n & 1 == 0:
        return 2
    if n % 3 == 0:
        return 3

    s = ((n - 1) & (1 - n)).bit_length() - 1
    d = n >> s
    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:
        p = pow(a, d, n)
        if p == 1 or p == n - 1 or a % n == 0:
            continue
        for _ in range(s):
            prev = p
            p = (p * p) % n
            if p == 1:
                return math.gcd(prev - 1, n)
            if p == n - 1:
                break
        else:
            for i in range(2, n):
                x, y = i, (i * i + 1) % n
                f = math.gcd(abs(x - y), n)
                while f == 1:
                    x, y = (x * x + 1) % n, (y * y + 1) % n
                    y = (y * y + 1) % n
                    f = math.gcd(abs(x - y), n)
                if f != n:
                    return f
    return n

@memodict
def prime_factors(n):

    if n <= 1:
        return Counter()
    f = pollard_rho(n)
    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)

def distinct_factors(n):

    factors = [1]
    for p, exp in prime_factors(n).items():
        factors += [p**i * factor for factor in factors for i in range(1, exp + 1)]
    return factors

def all_factors(n):

    small, large = [], []
    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):
        if not n % i:
            small.append(i)
            large.append(n // i)
    if small[-1] == large[-1]:
        large.pop()
    large.reverse()
    small.extend(large)
    return small

def binarySearch(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res = n
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] > key):
            res=mid
            right = mid-1
        else:
            left = mid + 1
    return res

def binarySearch1(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=-1
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] > key):
            right = mid-1
        else:
            res=mid
            left = mid + 1
    return res

t=1

for _ in range (t):
    n=int(input())

    a=list(map(int,input().split()))

    twopow = [1]*(10**5+69)
    for i in range(1, 10**5+69):
        twopow[i] = (twopow[i-1] * 2) % mod
    count = [0]*100069
    for i in a:
        count[i] += 1
    multiples = [0]*100069
    for i in range(1, 10**5+1):
        for j in range(i, 10**5+1, i):
            multiples[i] += count[j]
    gcd_of = [0]*100069
    for i in range(10**5, 0, -1):
        gcd_of[i] = (twopow[multiples[i]] - 1) % mod
        for j in range(2*i, 10**5+1, i):
            gcd_of[i] -= gcd_of[j]
    print(gcd_of[1] % mod)",np
"n=int(input())
d={}
for _ in range(n):
    a,x=map(int,input().split())
    if a in d:
        d[a][0]+=1
        d[a][1].append(x)
    else:
        d[a]=[1,[x]]

m=int(input())
for _ in range(m):
    a,x=map(int,input().split())
    if a in d:
        d[a][0]+=1
        d[a][1].append(x)
    else:
        d[a]=[1,[x]]

s=0
for x in d:
    if d[x][0]==1:
        s+=d[x][1][0]
    else:
        s+=max(d[x][1])
print(s)",O(nlogn)
"m = int(input())

b = []
k = []
for i in range(m):
    x = int(input())
    c = 0
    for j in range(len(b)):
        v = b[j]
        d = k[j]
        if (x ^ v) < x:
            x ^= v
            c ^= d

    if x != 0:
        print(0)
        c ^= 2 ** i
        b.append(x)
        k.append(c)
    else:
        a = []
        for j in range(m):
            if c & 1 == 1:
                a.append(j)
            c >>= 1
        print(len(a), end='')
        for v in a:
            print(' ', v, sep='', end='')
        print()
",np
"from collections import deque
from sys import stdin, stderr
lines = deque(line.strip() for line in stdin.readlines())

def nextline():
    return lines.popleft()

def types(cast, sep=None):
    return tuple(cast(x) for x in strs(sep=sep))

def ints(sep=None):
    return types(int, sep=sep)

def strs(sep=None):
    return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep))

def signum(n):
    return 1 if n > 0 else 0 if n == 0 else -1

def range_includes(i, j):
    s = signum(j - i)
    return range(i, j + s, s)

def main():

    first = ints()
    aCoords = tuple(first[i:i+2] for i in range(0, 8, 2))
    minX = min(aCoord[0] for aCoord in aCoords)
    minY = min(aCoord[1] for aCoord in aCoords)
    maxX = max(aCoord[0] for aCoord in aCoords)
    maxY = max(aCoord[1] for aCoord in aCoords)
    def inFirst(x, y):
        return x >= minX and x <= maxX and y >= minY and y <= maxY

    second = ints()
    bCoords = tuple(second[i:i+2] for i in range(0, 8, 2))
    minSum = min(sum(bCoord) for bCoord in bCoords)
    maxSum = max(sum(bCoord) for bCoord in bCoords)
    minDiff = min(bCoord[0] - bCoord[1] for bCoord in bCoords)
    maxDiff = max(bCoord[0] - bCoord[1] for bCoord in bCoords)
    def inSecond(x, y):
        return x + y >= minSum and x + y <= maxSum and x - y >= minDiff and x - y <= maxDiff

    for aCoord in aCoords:
        if inSecond(*aCoord):
            return True
    for i in range(-1, 3):
        c1 = bCoords[i]
        c2 = bCoords[i + 1]
        for x, y in zip(range_includes(c1[0], c2[0]), range_includes(c1[1], c2[1])):
            if inFirst(x, y):
                return True
    return False

if __name__ == '__main__':
    print(""YES"" if main() else ""NO"")
",O(1)
"a,b = map(int,input().split())
ans = 0
if(a > b):
    ans += int(a//b)
    a = a%b
while(b!=0):
    ans += int(a//b)
    a,b = b,a%b
print(ans)",O(1)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import Counter, defaultdict
import bisect
import math

for _ in range(1):
    n = int(input())

    arr = list(map(int, input().split()))
    t=[0]*n
    cur=0
    for i in range(n-1,-1,-1):
        cur=max(cur-1,0,arr[i]+1)
        t[i]=cur
    ans=0
    for i in range(n):
        cur=max(cur,t[i])
        ans+=cur
    for i in range(n):
        ans-=(arr[i]+1)
    print(ans)
",O(n)
"class Solution(object):
    def judgeCircle(self, moves):
        count = collections.Counter(moves)
        return count['L'] == count['R'] and count['U'] == count['D']
",O(n)
"class Solution(object):
    def lastRemaining(self, n):
        start, step, direction = 1, 2, 1
        while n > 1:
            start += direction * (step * (n//2) - step//2)
            n //= 2
            step *= 2
            direction *= -1
        return start",O(logn)
"def cal(r, g, b):
	if dp[r][g][b] != -1:
		return dp[r][g][b]

	area = 0
	if r<R and g<G:
		area = max(area, rl[r] * gl[g] + cal(r+1, g+1, b))
	if r<R and b<B:
		area = max(area, rl[r] * bl[b] + cal(r+1, g, b+1))
	if g<G and b<B:
		area = max(area, gl[g] * bl[b] + cal(r, g+1, b+1))
	dp[r][g][b] = area
	return area

if __name__ == ""__main__"":
	R, G, B = map(int,input().split())
	rl = sorted(list(map(int,input().split())), reverse=True)
	gl = sorted(list(map(int,input().split())), reverse=True)
	bl = sorted(list(map(int,input().split())), reverse=True)
	dp = [[[-1]*(B+1) for i in range(G+1)] for i in range(R+1)]
	print(cal(0,0,0))
",O(n ^ 3)
"s = [list(input()), list(input())]
ans = 0
l = len(s[0])
i = 0
while i < l - 1:
    a = (s[0][i], s[0][i + 1], s[1][i], s[1][i + 1])
    if a.count(""0"") == 4:
        ans += 1
        s[0][i + 1] = ""X""
        i+=1
    elif a.count(""0"") == 3:
        ans += 1
        i += 2
    else:
        i += 1
print(ans)
",O(1)
"class Solution2(object):
    def largestMultipleOfThree(self, digits):
        def candidates_gen(r):
            if r == 0:
                return
            for i in range(10):
                yield [i]
            for i in range(10):
                for j in range(i+1):
                    yield [i, j]

        count, r = collections.Counter(digits), sum(digits)%3
        for deletes in candidates_gen(r):
            delete_count = collections.Counter(deletes)
            if sum(deletes)%3 == r and \
               all(count[k] >= v for k, v in delete_count.items()):
                for k, v in delete_count.items():
                    count[k] -= v
                break
        result = """".join(str(d)*count[d] for d in reversed(range(10)))
        return ""0"" if result and result[0] == '0' else result",O(n)
"class Solution(object):
    def __init__(self):
        self.min = None
        self.stack = []

    def push(self, x):
        if not self.stack:
            self.stack.append(0)
            self.min = x
        else:
            self.stack.append(x - self.min)
            if x < self.min:
                self.min = x

    def pop(self):
        x = self.stack.pop()
        if x < 0:
            self.min = self.min - x

    def top(self):
        x = self.stack[-1]
        if x > 0:
            return x + self.min
        else:
            return self.min

    def getMin(self):
        return self.min",O(1)
"n, k = list(map(int, input().split()))
arr = list(map(int, input().split()))

count = [0]*(int(1e5+1))

for i in arr:
    count[i] += 1

s = sum([1 if i>0 else 0 for i in count])
if s < k:
    print('-1 -1')
    exit()

r = n-1
while True:
    if count[arr[r]] == 1:
        s -= 1
        if s < k:
            s += 1
            break
    count[arr[r]] -= 1
    r -= 1

l=0
while True:
    if count[arr[l]] == 1:
        s -= 1
        if s < k:
            s += 1
            break
    count[arr[l]] -= 1
    l += 1

print(l+1, r+1)
",O(n)
"import math

types_of_toy , toy_pair = map(int,input().split())

if(toy_pair <= types_of_toy ):
    print(math.floor( ( toy_pair - 1 ) /2))
elif( toy_pair <= 2*types_of_toy - 1):
    print(math.floor( ( types_of_toy +1 -(toy_pair - types_of_toy) )/ 2))
else:
    print(0)
",O(1)
"import sys,io,os,time
from collections import defaultdict
from collections import OrderedDict
from collections import deque
from itertools import combinations
from itertools import permutations
import bisect,math,heapq
alphabet = ""abcdefghijklmnopqrstuvwxyz""

input = sys.stdin.readline

def solve():
  r, g, b = map(int, input().split());R,G,B = sorted(list(map(int, input().split()))),sorted(list(map(int, input().split()))),sorted(list(map(int, input().split())));dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
  for i in range(r+1):
    for j in range(g+1):
      for k in range(b+1):
        if i+j+k<2:continue
        if i>0 and j>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1])
        if i>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1])
        if j>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1])
  return dp[r][g][b]
print(solve())
",O(n ^ 3)
"a = sorted(input())
b = int(input())
a = a[::-1]
p = ''
cnt = [0]*10

while a :
    for i, d in enumerate(a):
        n = p + d + """".join(sorted(a[:i]+a[i+1:]))
        if int(n) <= b :
            p += d
            a.pop(i)
            break

print(p)",O(n ^ 3)
"import sys
from collections import deque

from copy import *
from bisect import *

from math import gcd,ceil,sqrt
from itertools import permutations as prm,product

def eprint(*args):
    print(*args, file=sys.stderr)
zz=1

if zz:
	input=sys.stdin.readline
else:
	sys.stdin=open('input.txt', 'r')
	sys.stdout=open('all.txt','w')
di=[[-1,0],[1,0],[0,1],[0,-1]]

def string(s):
	return """".join(s)
def fori(n):
	return [fi() for i in range(n)]
def inc(d,c,x=1):
	d[c]=d[c]+x if c in d else x
def bo(i):
	return ord(i)-ord('A')
def li():
	return [int(xx) for xx in input().split()]
def fli():
	return [float(x) for x in input().split()]
def comp(a,b):
	if(a>b):
		return 2
	return 2 if a==b else 0
def gi():
	return [xx for xx in input().split()]
def gtc(tc,ans):
	print(""Case
def cil(n,m):
	return n//m+int(n%m>0)
def fi():
	return int(input())
def pro(a):
	return reduce(lambda a,b:a*b,a)
def swap(a,i,j):
	a[i],a[j]=a[j],a[i]
def si():
	return list(input().rstrip())
def mi():
	return 	map(int,input().split())
def gh():
	sys.stdout.flush()
def isvalid(i,j,n,m):
	return 0<=i<n and 0<=j<m
def bo(i):
	return ord(i)-ord('a')
def graph(n,m):
	for i in range(m):
		x,y=mi()
		a[x].append(y)
		a[y].append(x)

t=1

while t>0:
	t-=1
	l,r=mi()
	if len(bin(l))<len(bin(r)):
		print(2**len(bin(r)[2:])-1)
	else:
		p=bin(l)[2:]
		q=bin(r)[2:]
		r=0
		for i in range(len(q)):
			if p[i]!=q[i]:
				r=len(p)-i
				break
		print(2**r-1)
",O(logn)
"string = str(input())
length = len(string)

counter = 0
li = []
match_li = []

for i in range(length):
    letter = string[i]
    letters = letter
    if letter in li:
        match_li.append(letter)
    li.append(letter)
    for j in range(i+1, length):
        letters += string[j]
        if letters in li:
            match_li.append(letters)
        li.append(letters)

longest = 0
for k in match_li:
    if len(k) > longest:
        longest = len(k)

print(longest)
",O(n ^ 3)
"n, m = int(input()), int(input())
print(m % (2 ** n) if n < 30 else m)",O(1)
"n = int(input())
ans = 1
for i in range(1, n):
    ans += i * 4
print(ans)",O(n)
"class Solution(object):
    def maximumUniqueSubarray(self, nums):
        lookup = {}
        prefix = [0]*(len(nums)+1)
        result, left = 0, 0
        for right, num in enumerate(nums):
            prefix[right+1] = prefix[right]+num
            if num in lookup:
                left = max(left, lookup[num]+1)
            lookup[num] = right
            result = max(result, prefix[right+1]-prefix[left])
        return result",O(n)
"MOD = 998244353

def main():
    n = int(input())
    a = [int(x) for x in input().split(' ')]

    p, sp, s, ss = 0, 0, 0, 0
    for x in a:
        ss = (2 * ss + s) % MOD
        s = (s + x) % MOD
        p = (ss + sp + s) % MOD
        sp = (sp + p) % MOD
    print(p)

if __name__ == '__main__':
    main()
",O(n)
"class Solution2(object):
    def flipEquiv(self, root1, root2):
        stk1, stk2 = [root1], [root2]
        while stk1 and stk2:
            node1, node2 = stk1.pop(), stk2.pop()
            if not node1 and not node2:
                continue 
            if not node1 or not node2 or node1.val != node2.val:
                return False
            if (not node1.left and not node2.right) or \
               (node1.left and node2.right and node1.left.val == node2.right.val):
                stk1.extend([node1.right, node1.left])
            else:
                stk1.extend([node1.left, node1.right])
            stk2.extend([node2.left, node2.right])
        return not stk1 and not stk2",O(n)
"class Solution(object):
    def kthLuckyNumber(self, k):
        result = []
        k += 1
        while k != 1:
            result.append('7' if k&1 else '4')
            k >>= 1
        result.reverse()
        return """".join(result)",O(logn)
"
import pandas as pd



def Solution(weather: pd.DataFrame) -> pd.DataFrame:
    return weather.pivot(index=""month"", columns=""city"", values=""temperature"")
",O(n)
"from math import factorial
drazil = input()
dreamoon = input()
net_drazil = 0
net_dreamoon = 0
uncretain_count = 0
for i in drazil:
    if i == '-':
        net_drazil -= 1
    else:
        net_drazil += 1
for i in dreamoon:
    if i == '-':
        net_dreamoon -= 1
    elif i == '+':
        net_dreamoon += 1
    else:
        uncretain_count += 1
x = (uncretain_count + (net_drazil - net_dreamoon)) // 2
y = (uncretain_count - (net_drazil - net_dreamoon)) // 2

if abs(x) + abs(y) != uncretain_count:
    print(0.0)
else:
    out = factorial(uncretain_count)//(factorial(x)*factorial(uncretain_count-x))
    print(out/2**uncretain_count)
",np
"def solve():
  l, r = map(int, input().split())
  if l==r:
    print(0)
    return
  mx = str(bin(l^r))
  x = len(mx[2:])
  print(2**x-1)
solve()",O(logn)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def sortLinkedList(self, head):
        tail, curr, head.next = head, head.next, None
        while curr:
            if curr.val > 0:
                curr.next, tail.next, tail, curr = None, curr, curr, curr.next
            else:
                curr.next, head, curr = head, curr, curr.next
        return head",O(n)
"from collections import defaultdict, deque, Counter
from sys import stdin, stdout
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

def mapin():
    return map(int, input().split())

a, b, c, n = mapin()
d = a+b-c

if(d > n-1 or c > a or c > b):
    print(-1)
else:
    print(n-d)",O(1)
"class Solution(object):
    def maxBuilding(self, n, restrictions):
        restrictions.extend([[1, 0], [n, n-1]])
        restrictions.sort()
        for i in reversed(range(len(restrictions)-1)):
            restrictions[i][1] = min(restrictions[i][1], restrictions[i+1][1]+(restrictions[i+1][0]-restrictions[i][0]))
        result = 0
        for i in range(1, len(restrictions)):
            restrictions[i][1] = min(restrictions[i][1], restrictions[i-1][1]+(restrictions[i][0]-restrictions[i-1][0]))
            left, h1 = restrictions[i-1]
            right, h2 = restrictions[i]
            result = max(result, max(h1, h2)+((right-left)-abs(h1-h2))//2)
        return result",O(nlogn)
"class Solution2(object):
    def getConcatenation(self, nums):
        return nums+nums",O(n)
"class Solution(object):
    def minArrayLength(self, nums, k):
        if 0 in nums:
            return 1
        result = len(nums)
        curr = nums[0]
        for i in range(1, len(nums)):
            if curr*nums[i] > k:
                curr = nums[i]
            else:
                curr *= nums[i]
                result -= 1
        return result",O(n)
"ii=lambda:int(input())
kk=lambda:map(int, input().split())
ll=lambda:list(kk())

n,k=kk()
pre,post = [],[]
k-=1
v = 1
for i in range(n-2,-1,-1):
	if k&(2**i):
		post.append(v)
	else:
		pre.append(v)
	v+=1
print(*pre,n,*reversed(post))",np
"import sys, os

numbs = [int(x) for x in sys.stdin.buffer.read().split()]
n = numbs.pop(0)

base = []
out = []

for i in range(n):
    x = numbs[i]
    how = 0

    for b,rep in base:
        if x.bit_length() == b.bit_length():
            x ^= b
            how ^= rep

    if x:
        how |= 1 << i

        a = 0
        b = len(base)
        while a < b:
            c = a + b >> 1
            if base[c][0] > x:
                a = c + 1
            else:
                b = c
        base.insert(a, (x, how))

        out.append(0)
    else:
        outind = len(out)
        out.append(-1)

        y = bin(how).encode('ascii')
        ylen = len(y)
        for i in range(2,len(y)):
            if y[i] == 49:
                out.append(ylen - 1 - i)
        out[outind] = len(out) - 1 - outind

os.write(1, b'\n'.join(str(x).encode('ascii') for x in out))",np
"class Solution:
    def isHappy(self, n: int) -> bool:
        slow, fast = n, self.sumOfSquares(n)

        while slow != fast:
            fast = self.sumOfSquares(fast)
            fast = self.sumOfSquares(fast)
            slow = self.sumOfSquares(slow)
        return True if fast == 1 else False

    def sumOfSquares(self, n: int) -> int:
        output = 0

        while n:
            digit = n % 10
            digit = digit ** 2
            output += digit
            n = n // 10
        return output
",O(logn)
"class Solution(object):
    def gardenNoAdj(self, N, paths):
        result = [0]*N
        G = [[] for i in range(N)]
        for x, y in paths:
            G[x-1].append(y-1)
            G[y-1].append(x-1)
        for i in range(N):
            result[i] = ({1, 2, 3, 4} - {result[j] for j in G[i]}).pop()
        return result",O(n)
"import itertools



class Solution3(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")
        class BIT(object): 
            def __init__(self, n, default=0, fn=lambda x, y: x+y):
                self.__bit = [NEG_INF]*(n+1) 
                self.__default = default
                self.__fn = fn

            def update(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = self.__fn(self.__bit[i], val)
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = self.__default
                while i > 0:
                    ret = self.__fn(ret, self.__bit[i])
                    i -= (i & -i)
                return ret

        price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))}
        result = NEG_INF
        bit1, bit2 = BIT(len(price_to_idx), default=NEG_INF, fn=max), BIT(len(price_to_idx), default=NEG_INF, fn=max)
        for price, profit in zip(prices, profits):
            result = max(result, bit2.query(price_to_idx[price]-1)+profit)
            bit1.update(price_to_idx[price], profit)
            bit2.update(price_to_idx[price], bit1.query(price_to_idx[price]-1)+profit)
        return result if result != NEG_INF else -1",O(nlogn)
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n,m = inpl()
s = [inpsl(m) for _ in range(n)]
lampcnt = [0]*m
for i in range(n):
    for j in range(m):
        if s[i][j] == '1':
            lampcnt[j] += 1
res = False
for i in range(n):
    only = False
    for j in range(m):
        if s[i][j] == '1' and lampcnt[j] == 1:
            only = True
    if not only: res = True
print('YES' if res else 'NO')",O(n ^ 2)
"class Solution(object):
    def numSubarrayProductLessThanK(self, nums, k):
        if k <= 1: return 0
        result, start, prod = 0, 0, 1
        for i, num in enumerate(nums):
            prod *= num
            while prod >= k:
                prod /= nums[start]
                start += 1
            result += i-start+1
        return result",O(n)
"class Solution:
    def reverse(self, x: int) -> int:
        def rec(n: int, rev: int) -> int:
            if n == 0:
                return rev

            rev = rev * 10 + n % 10
            return rec(n // 10, rev)

        sign = -1 if x < 0 else 1
        x = abs(x)
        reversed_num = rec(x, 0)
        reversed_num *= sign
        if reversed_num < -(1 << 31) or reversed_num > (1 << 31) - 1:
            return 0

        return reversed_num
",O(1)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right



class Solution(object):
    def isValidSequence(self, root, arr):
        q = [root]
        for depth in range(len(arr)):
            new_q = []
            while q:
                node = q.pop()
                if not node or node.val != arr[depth]:
                    continue
                if depth+1 == len(arr) and node.left == node.right:
                    return True
                new_q.extend(child for child in (node.left, node.right))
            q = new_q
        return False",O(n)
"class Solution2(object):
    def convertToBase7(self, num):
        if num < 0:
            return '-' + self.convertToBase7(-num)
        if num < 7:
            return str(num)
        return self.convertToBase7(num // 7) + str(num % 7)",O(1)
"import sys;input = sys.stdin.readline
inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]

r,g,b = ip()
R = [0]+ip()
G = [0]+ip()
B = [0]+ip()
R.sort()
G.sort()
B.sort()
dp = [[[0]*201 for i in range(201)] for j in range(201)]
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            x = dp[i-1][j-1][k] + R[i]*G[j] if i*j else 0
            y = dp[i][j-1][k-1] + G[j]*B[k] if j*k else 0
            z = dp[i-1][j][k-1] + R[i]*B[k] if i*k else 0
            dp[i][j][k] = max(dp[i][j][k],x,y,z)
print(dp[r][g][b])
",O(n ^ 3)
"import collections
import heapq


class Solution(object):
    def scheduleCourse(self, courses):
        courses.sort(key=lambda t_end: t_end[1])
        max_heap = []
        now = 0
        for t, end in courses:
            now += t
            heapq.heappush(max_heap, -t)
            if now > end:
                now += heapq.heappop(max_heap)
        return len(max_heap)",O(nlogn)
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
        goal = len(nums) - 1

        for i in range(len(nums) - 2, -1, -1):
            if i + nums[i] >= goal:
                goal = i
        return goal == 0
",O(n)
"M = 10 ** 9 + 7
x, k = map(int, input().split())
if x == 0: print(0); exit(0)
P = pow(2, k, M)
r = (P * x) % M - (0.5 * (-1 + P)) % M
print(int((2 * r + M) % M))
",O(logn)
"from itertools import chain, combinations
from random import randint
def powerset(iterable):
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))

n,l,r,x=map(int,input().split())
ll=list(map(int,input().split()))
subsets=powerset(ll)
res=0
for i in subsets:
    if len(i) >= 2 and l<= sum(i) <=r and max(i)-min(i) >= x:
        res+=1
print(res)
",np
"class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return None

        newHead = head
        if head.next:
            newHead = self.reverseList(head.next)
            head.next.next = head
        head.next = None

        return newHead
",O(n)
"class Solution(object):
    def lastVisitedIntegers(self, words):
        PREV = ""prev""
        result, stk = [], []
        i = -1
        for x in words:
            if x == PREV:
                result.append(stk[i] if i >= 0 else -1)
                i -= 1
                continue
            stk.append(int(x))
            i = len(stk)-1
        return result",O(n)
"import sys,os,io,time,copy
if os.path.exists('input.txt'):
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

import math

def main():

    n=int(input())
    print(0,0,n)

main()",O(1)
"from bisect import bisect,bisect_left

from collections import *
from math import gcd,ceil,sqrt,floor,inf
from heapq import *
from itertools import *
from operator import add,mul,sub,xor,truediv,floordiv
from functools import *

import os
import sys

from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def RL(): return map(int, sys.stdin.readline().split())
def RLL(): return list(map(int, sys.stdin.readline().split()))
def N(): return int(input())
def A(n):return [0]*n
def AI(n,x): return [x]*n
def A2(n,m): return [[0]*m for i in range(n)]
def G(n): return [[] for i in range(n)]
def GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]

from types import GeneratorType

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

mod=10**9+7
farr=[1]
ifa=[]

def fact(x,mod=0):
    if mod:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr)%mod)
    else:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr))
    return farr[x]

def ifact(x,mod):
    global ifa
    fact(x,mod)
    ifa.append(pow(farr[-1],mod-2,mod))
    for i in range(x,0,-1):
        ifa.append(ifa[-1]*i%mod)
    ifa.reverse()

def per(i,j,mod=0):
    if i<j: return 0
    if not mod:
        return fact(i)//fact(i-j)
    return farr[i]*ifa[i-j]%mod

def com(i,j,mod=0):
    if i<j: return 0
    if not mod:
        return per(i,j)//fact(j)
    return per(i,j,mod)*ifa[j]%mod

def catalan(n):
    return com(2*n,n)//(n+1)

def isprime(n):
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return False
    return True

def floorsum(a,b,c,n):
    if a==0:return b//c*(n+1)
    if a>=c or b>=c: return floorsum(a%c,b%c,c,n)+b//c*(n+1)+a//c*n*(n+1)//2
    m=(a*n+b)//c
    return n*m-floorsum(c,c-b-1,a,m-1)

def inverse(a,m):
    a%=m
    if a<=1: return a
    return ((1-inverse(m,a)*m)//a)%m

def lowbit(n):
    return n&-n

class BIT:
    def __init__(self,arr):
        self.arr=arr
        self.n=len(arr)-1

    def update(self,x,v):
        while x<=self.n:
            self.arr[x]+=v
            x+=x&-x

    def query(self,x):
        ans=0
        while x:
            ans+=self.arr[x]
            x&=x-1
        return ans

class ST:
    def __init__(self,arr):
        n=len(arr)
        mx=n.bit_length()
        self.st=[[0]*mx for i in range(n)]
        for i in range(n):
            self.st[i][0]=arr[i]
        for j in range(1,mx):
            for i in range(n-(1<<j)+1):
                self.st[i][j]=max(self.st[i][j-1],self.st[i+(1<<j-1)][j-1])
    def query(self,l,r):
        if l>r:return -inf
        s=(r+1-l).bit_length()-1
        return max(self.st[l][s],self.st[r-(1<<s)+1][s])

class DSU:
    def __init__(self,n):
        self.c=[-1]*n

    def same(self,x,y):
        return self.find(x)==self.find(y)

    def find(self,x):
        if self.c[x]<0:
            return x
        self.c[x]=self.find(self.c[x])
        return self.c[x]

    def union(self,u,v):
        u,v=self.find(u),self.find(v)
        if u==v:
            return False
        if self.c[u]>self.c[v]:
            u,v=v,u
        self.c[u]+=self.c[v]
        self.c[v]=u
        return True

    def size(self,x): return -self.c[self.find(x)]

class UFS:
    def __init__(self,n):
        self.parent=[i for i in range(n)]
        self.ranks=[0]*n

    def find(self,x):
        if x!=self.parent[x]:
            self.parent[x]=self.find(self.parent[x])
        return self.parent[x]

    def union(self,u,v):
        pu,pv=self.find(u),self.find(v)
        if pu==pv:
            return False
        if self.ranks[pu]>=self.ranks[pv]:
            self.parent[pv]=pu
            if self.ranks[pv]==self.ranks[pu]:
                self.ranks[pu]+=1
        else:
            self.parent[pu]=pv

def Prime(n):
    c=0
    prime=[]
    flag=[0]*(n+1)
    for i in range(2,n+1):
        if not flag[i]:
            prime.append(i)
            c+=1
        for j in range(c):
            if i*prime[j]>n: break
            flag[i*prime[j]]=prime[j]
            if i%prime[j]==0: break
    return flag

def dij(s,graph):
    d={}
    d[s]=0
    heap=[(0,s)]
    seen=set()
    while heap:
        dis,u=heappop(heap)
        if u in seen:
            continue
        seen.add(u)
        for v,w in graph[u]:
            if v not in d or d[v]>d[u]+w:
                d[v]=d[u]+w
                heappush(heap,(d[v],v))
    return d

def bell(s,g):
    dis=AI(n,inf)
    dis[s]=0
    for i in range(n-1):
        for u,v,w in edge:
            if dis[v]>dis[u]+w:
                dis[v]=dis[u]+w
    change=A(n)
    for i in range(n):
        for u,v,w in edge:
            if dis[v]>dis[u]+w:
                dis[v]=dis[u]+w
                change[v]=1
    return dis

def lcm(a,b): return a*b//gcd(a,b)
def lis(nums):
    res=[]
    for k in nums:
        i=bisect.bisect_left(res,k)
        if i==len(res):
            res.append(k)
        else:
            res[i]=k
    return len(res)

def RP(nums):
    n = len(nums)
    s=set(nums)
    d={}
    for i,k in enumerate(sorted(s),1):
        d[k]=i
    bi=BIT([0]*(len(s)+1))
    ans=0
    for i in range(n-1,-1,-1):
        ans+=bi.query(d[nums[i]]-1)
        bi.update(d[nums[i]],1)
    return ans

class DLN:
    def __init__(self,val):
        self.val=val
        self.pre=None
        self.next=None

def nb(i,j,n,m):
    for ni,nj in [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]:
        if 0<=ni<n and 0<=nj<m:
            yield ni,nj

def topo(n):
    q=deque()
    res=[]
    for i in range(1,n+1):
        if ind[i]==0:
            q.append(i)
            res.append(i)
    while q:
        u=q.popleft()
        for v in g[u]:
            ind[v]-=1
            if ind[v]==0:
                q.append(v)
                res.append(v)
    return res

@bootstrap
def gdfs(r,p):
    for ch in g[r]:
        if ch!=p:
            yield gdfs(ch,r)
    yield None

t=1
for i in range(t):
    n,m,k=RL()
    h=[]
    v=[]
    for i in range(n):
        h.append(RLL())
    for i in range(n-1):
        v.append(RLL())
    if k&1:
        for i in range(n):
            print(*AI(m,-1))
        exit()
    k//=2
    dp=[[[inf]*m for i in range(n)]for j in range(k+1)]
    for i in range(n):
        for j in range(m):
            dp[0][i][j]=0
    for i in range(1,k+1):
        for j in range(n):
            for a in range(m):
                if j:
                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j-1][a]+2*v[j-1][a])
                if j+1<n:
                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j+1][a]+2*v[j][a])
                if a:
                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j][a-1]+2*h[j][a-1])
                if a+1<m:
                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j][a+1]+2*h[j][a])
    for i in range(n):
        res=[]
        for j in range(m):
            res.append(dp[k][i][j])
        print(*res)
",O(n ^ 3)
"class Solution(object):
    def secondGreaterElement(self, nums):
        result, stk1, stk2 = [-1]*len(nums), [], []
        for i, x in enumerate(nums):
            while stk2 and nums[stk2[-1]] < x:
                result[stk2.pop()] = x
            tmp = []
            while stk1 and nums[stk1[-1]] < x:
                tmp.append(stk1.pop())
            stk1.append(i)
            for x in reversed(tmp):
                stk2.append(x)
        return result",O(n)
"import math

inp = input().strip()
dec = input().strip()
inp_dict = {""+"":0,""-"":0}
dec_dict = {""+"":0,""-"":0,""?"":0}

for i in range(len(inp)):
	if inp[i]==""+"":
		inp_dict[""+""] += 1
	elif inp[i]==""-"":
		inp_dict[""-""] += 1

for i in range(len(dec)):
	if dec[i]==""+"":
		dec_dict[""+""] += 1
	elif dec[i]==""-"":
		dec_dict[""-""] += 1
	elif dec[i] == ""?"":
		dec_dict[""?""] += 1

if(dec_dict[""+""] == inp_dict[""+""] and dec_dict[""-""] == inp_dict[""-""]):
	print(1.0000000000)
else:
	temp = inp_dict[""+""] - dec_dict[""+""]
	temp1 = inp_dict[""-""] - dec_dict[""-""]

	if temp + temp1 == dec_dict[""?""] and temp>=0 and temp1 >= 0:
		temp2 = math.factorial(temp+temp1)/(math.factorial(temp)*math.factorial(temp1))
		for i in range(temp1+temp):
			temp2 = temp2 * 0.5
		print(temp2)
	else:
		print(0.000000000)
",np
"import os
import sys
from math import *
from collections import *

from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M=998244353
EPS=1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]

n = Int()
a = array()
C = Counter(a)
a = set(a)

ans = 0

for x in a:
    ok = True

    for i in range(65):

        need = 2**i - x
        if(need == x and C[need] > 1): ok = False
        if(need != x and C[need] > 0): ok = False

    ans += C[x]*ok

print(ans)
",O(nlogn)
"n,m=map(int,input().split())
s=[]
st=set()
cst=set()
for i in range(n):
    s.append(input())
    for j in range(len(s[i])):
        if s[i][j]=='
            st.add((i,j))
for i in range(1,n-1):
    for j in range(1,m-1):
        if s[i-1][j-1]!='
            continue
        if s[i - 1][j ] != '
            continue
        if s[i-1][j+1]!='
            continue
        if s[i][j-1]!='
            continue
        if s[i][j+1]!='
            continue
        if s[i+1][j-1]!='
            continue
        if s[i+1][j]!='
            continue
        if s[i+1][j+1]!='
            continue
        cst.add((i-1,j))
        cst.add((i - 1, j-1))
        cst.add((i - 1, j+1))
        cst.add((i + 1, j))
        cst.add((i + 1, j-1))
        cst.add((i + 1, j+1))
        cst.add((i , j+1))
        cst.add((i , j-1))
if len(cst)==len(st):
    print('YES')
else:
    print('NO')",O(n ^ 2)
"import math
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def print(self):
        print(self.x, self.y)

class Line:
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2

    def on(self, p):
        return distance(self.p1, p) + distance(self.p2, p) == distance(self.p1, self.p2)

    def print(self):
        self.p1.print()
        self.p2.print()

class Square:
    def __init__(self, points):
        self.points = points

    def area(self):
        return distance(self.points[0], self.points[1]) ** 2

    def lines(self):
        l = []
        for i in range(3):
            l.append(Line(self.points[i], self.points[i + 1]))
        l.append(Line(self.points[3], self.points[0]))
        return l

    def midpoint(self):
        return Point(self.points[0].x / 2 + self.points[2].x / 2, self.points[0].y / 2 + self.points[2].y / 2)

    def print(self):
        for point in self.points:
            point.print()

def distance(p1, p2):
    return ((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2) ** .5

def tri_area(p1, p2, p3):
    a = distance(p1, p2)
    b = distance(p2, p3)
    c = distance(p3, p1)
    s = a + b + c
    s /= 2
    return (s * (s - a) * (s - b) * (s - c)) ** .5

def inter(p, s):
    a = s.area()
    area_sum = tri_area(s.points[0], s.points[1], p) + tri_area(s.points[1], s.points[2], p)
    area_sum += tri_area(s.points[2], s.points[3], p) + tri_area(s.points[3], s.points[0], p)
    if abs(a - area_sum) < 0.000001:
        return True
    return False

c1 = input().split("" "")
c2 = input().split("" "")
for i in range(8):
    c1[i] = int(c1[i])
    c2[i] = int(c2[i])
c1p = []
c2p = []
for i in range(0, 8, 2):
    c1p.append(Point(c1[i], c1[i + 1]))
    c2p.append(Point(c2[i], c2[i + 1]))
s1 = Square(c1p)
s2 = Square(c2p)
yes = False
for point in s1.points:
    if inter(point, s2):
        if not yes:
            print(""YES"")
            yes = True
for point in s2.points:
    if inter(point, s1):
        if not yes:
            print(""YES"")
            yes = True
if inter(s1.midpoint(), s2):
    if not yes:
        print(""YES"")
        yes = True
if inter(s2.midpoint(), s1):
    if not yes:
        print(""YES"")
if not yes:
    print(""NO"")",O(1)
"import itertools



class Solution(object):
    def minOperations(self, nums1, nums2, k):
        cnt1 = cnt2 = 0
        for x, y in zip(nums1, nums2):
            if y == x:
                continue
            if k == 0 or (y-x)%k:
                return -1
            if x < y:
                cnt1 += (y-x)//k
            else:
                cnt2 += (x-y)//k
        return cnt1 if cnt1 == cnt2 else -1",O(n)
"n, k = map(int, input().split())
l = list(map(int, input().split()))

o = 2
for i in range(n):
    if i+1 == n:
        break

    d = abs(l[i] - l[i+1]) / k
    if d ==  2:
        o += 1
    elif d > 2:
        o += 2

print(o)",O(n)
"class Solution(object):
    def buildTree(self, preorder, inorder):
        lookup = {}
        for i, num in enumerate(inorder):
            lookup[num] = i
        return self.buildTreeRecu(lookup, preorder, inorder, 0, 0, len(inorder))

    def buildTreeRecu(self, lookup, preorder, inorder, pre_start, in_start, in_end):
        if in_start == in_end:
            return None
        node = TreeNode(preorder[pre_start])
        i = lookup[preorder[pre_start]]
        node.left = self.buildTreeRecu(lookup, preorder, inorder, pre_start + 1, in_start, i)
        node.right = self.buildTreeRecu(lookup, preorder, inorder, pre_start + 1 + i - in_start, i + 1, in_end)
        return node",O(n)
"class Solution2(object):
    def sumIndicesWithKSetBits(self, nums, k):
        def popcount(x):
            return bin(x)[1:].count('1')
        
        return sum(x for i, x in enumerate(nums) if popcount(i) == k)",O(n)
"from math import sqrt

a, v = map(int, input().split())
l, d, w = map(int, input().split())

def findt(u, v, a, dist):
	front = (v*v-u*u)/(2*a)
	if front > dist:
		return (sqrt(u*u+2*a*dist)-u)/a
	return (v-u)/a + (dist-front)/v

def solve(a, v, l, d, w):
	if v <= w or 2*a*d <= w*w:
		return findt(0, v, a, l)
	after = findt(w, v, a, l-d)
	peak = sqrt(a*d + w*w/2)
	if peak > v:
		travel = (v*v-w*w/2)/a
		before = (2*v-w)/a + (d-travel)/v
	else:
		before = (2*peak-w)/a
	return before + after

print(f'{solve(a, v, l, d, w):.8f}')",O(1)
"n, k = [int(a) for a in input().split()]
power = [int(a) for a in input().split()]
coins = [int(a) for a in input().split()]

dp = [0 for i in range(n)]

def takeSecond(elem):
    return elem[1]

def takeFirst(elem):
    return elem[0]

people = [(power[i], coins[i], i) for i in range(n)]

people.sort(key=takeFirst)

dp[0] = []

for i, p in enumerate(people):
    if i == 0:
        continue
    kills = [i for i in dp[i - 1]]
    kills.append(people[i - 1][1])
    x = []

    if len(kills) > k:
        kills.remove(min(kills))

    dp[i] = kills

x = [(people[i][2], str(sum(dp[i]) + people[i][1])) for i in range(n)]

x.sort(key=takeFirst)

print("" "".join([z[1] for z in x]))
",O(nlogn)
"import collections



class Queue(object):
    def __init__(self):
        self.data = collections.deque()

    def push(self, x):
        self.data.append(x)

    def peek(self):
        return self.data[0]

    def pop(self):
        return self.data.popleft()

    def size(self):
        return len(self.data)

    def empty(self):
        return len(self.data) == 0








class Solution(object):
    def invertTree(self, root):
        if root is not None:
            nodes = Queue()
            nodes.push(root)
            while not nodes.empty():
                node = nodes.pop()
                node.left, node.right = node.right, node.left
                if node.left is not None:
                    nodes.push(node.left)
                if node.right is not None:
                    nodes.push(node.right)

        return root",O(n)
"from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]

r, g, b = rints()
ar, ag, ab = [sorted(rints(), reverse=True) for _ in range(3)]
mem = [[[0 for _ in range(b + 1)] for _ in range(g + 1)] for _ in range(r + 1)]
ans = 0

for r1 in range(r + 1):
    for g1 in range(g + 1):
        for b1 in range(b + 1):
            if r1 < r:
                if g1 < g:
                    mem[r1 + 1][g1 + 1][b1] = max(mem[r1 + 1][g1 + 1][b1], (ar[r1] * ag[g1]) + mem[r1][g1][b1])
                if b1 < b:
                    mem[r1 + 1][g1][b1 + 1] = max(mem[r1 + 1][g1][b1 + 1], (ar[r1] * ab[b1]) + mem[r1][g1][b1])

            if g1 < g and b1 < b:
                mem[r1][g1 + 1][b1 + 1] = max(mem[r1][g1 + 1][b1 + 1], (ag[g1] * ab[b1]) + mem[r1][g1][b1])

            ans = max(ans, mem[r1][g1][b1])

print(ans)",O(n ^ 3)
"class Solution(object):
    def getMinimumDifference(self, root):
        def inorderTraversal(root, prev, result):
            if not root:
                return (result, prev)

            result, prev = inorderTraversal(root.left, prev, result)
            if prev: result = min(result, root.val - prev.val)
            return inorderTraversal(root.right, root, result)

        return inorderTraversal(root, None, float(""inf""))[0]",O(n)
"class Solution2(object):
    def alienOrder(self, words):
        nodes, ancestors = set(), {}
        for i in range(len(words)):
            for c in words[i]:
                nodes.add(c)
        for node in nodes:
            ancestors[node] = []
        for i in range(1, len(words)):
            if (len(words[i-1]) > len(words[i]) and
                    words[i-1][:len(words[i])] == words[i]):
                return """"
            self.findEdges(words[i - 1], words[i], ancestors)

        result = []
        visited = {}
        for node in nodes:
            if self.topSortDFS(node, node, ancestors, visited, result):
                return """"

        return """".join(result)

    def findEdges(self, word1, word2, ancestors):
        min_len = min(len(word1), len(word2))
        for i in range(min_len):
            if word1[i] != word2[i]:
                ancestors[word2[i]].append(word1[i])
                break

    def topSortDFS(self, root, node, ancestors, visited, result):
        if node not in visited:
            visited[node] = root
            for ancestor in ancestors[node]:
                if self.topSortDFS(root, ancestor, ancestors, visited, result):
                    return True
            result.append(node)
        elif visited[node] == root:
            return True
        return False",O(n)
"import math
n=int(input())
if(n%2==0):
   x=math.floor(n/2+1)*(math.floor(n/2))
if(n%2!=0):
   x=(math.ceil(n/2)*(math.ceil(n/2)))
print(x)",O(n)
"def solve(rn,gn,bn,r,g,b):
    r = sorted(r,reverse=True)
    g = sorted(g, reverse=True)
    b = sorted(b, reverse=True)

    dp = [[[0 for k in range(bn+1)] for j in range(gn+1)] for i in range(rn+1)]

    ans = 0
    for i in range(rn+1):
        for j in range(gn+1):
            for k in range(bn+1):
                if i < rn and j < gn:
                    dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
                if i < rn and k < bn:
                    dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])
                if j < gn and k <bn:
                    dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])

                ans = max(ans,dp[i][j][k])

    print(ans)

if __name__ == '__main__':
    rn, gn, bn = map(int,input().split())

    r = list(map(int,input().split()))
    g = list(map(int, input().split()))
    b = list(map(int, input().split()))

    solve(rn,gn,bn,r,g,b)",O(n ^ 3)
"n = int(input())
s = input()
maxn = 0
now = 0
for i in s:
    if i == '+':
        now += 1
    else:
        now -= 1
    maxn = max(maxn, -now)
print(now + maxn)",O(n)
"import sys,os,io
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

maxbits = 22
maxmask = 1<<maxbits
dp = [-1]*(maxmask)
n = int(input())
a = [int(x) for x in input().split()]
b = a[:]
P = [0]*n
for i in a:
    dp[i]=i

for exp in range(maxbits):
    for i in range(maxmask):
        if i&(1<<exp):
            if dp[i]==-1:
                dp[i]=dp[i-(1<<exp)]

for i in range(n):
    maxx = maxmask-1
    print(dp[maxx^a[i]],end="" "")",np
"class Solution2(object):
    def longestValidParentheses(self, s):
        longest, last, indices = 0, -1, []
        for i in range(len(s)):
            if s[i] == '(':
                indices.append(i)
            elif not indices:
                last = i
            else:
                indices.pop()
                if not indices:
                    longest = max(longest, i - last)
                else:
                    longest = max(longest, i - indices[-1])
        return longest",O(n)
"import math

l1 = input().split()

l1 = [int(i) for i in l1]

l2 = l1[1]
l1 = l1[0]

x=l1^l2;
y=1;
while(y<=x):
  y=y*2;

print(y-1);
",O(logn)
"n=int(input())
S=[]
for i in range(n):
    A=[int(i) for i in input().split()]
    S.append(sum(A))
if S[0]==max(S):
    print(""1"")
    exit()
thomas=S[0]
rank=1
S.sort(reverse=True)
for i in S:
    if i == thomas:
        print(rank)
        exit()
    else:
        rank+=1",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
n, k = map(int, input().split())
b = []
d=dict()
e=dict()
for i in range(n):
    a, t = map(int, input().split())
    b.append([a,t,i+1])
b.sort(key= lambda x:x[1])
ans = 0
j = 0
curr = 1
currsum = 0
l=0
while(curr<=n):
    if curr-1 in d.keys():
        currsum-=d[curr-1]
        l-=e[curr-1]

    p=0
    while (j < n):
        if b[j][0] >= curr:
            currsum += b[j][1]
            if b[j][0] in d.keys():
                d[b[j][0]]+=b[j][1]
                e[b[j][0]]+=1
            else:
                d[b[j][0]] = b[j][1]
                e[b[j][0]] = 1

            l+=1
        if l==curr:
            j+=1
            break
        j+=1

    if j<=n and l==curr and currsum<=k:
        ans+=1
    else:
        break
    curr+=1
c=[]
j=0
l=0
while(j<n):
    if l==ans:
        break
    if b[j][0] >= ans:
        c.append(b[j][2])
        l+=1
    j+=1

print(ans)
print(ans)
print(*c)
",O(nlogn)
"n, s = map(int, input().split())

big = s // n
r = s - big * n
if r > 0:
    print(big + 1)
else:
    print(big)
",O(1)
"class Solution(object):
    def getSum(self, nums):
        MOD = 10**9+7
        def count(d):
            result = total = l = 0
            for i in range(len(nums)):
                l += 1
                total = (total+nums[i]*l)%MOD
                result = (result+total)%MOD
                if i+1 < len(nums) and nums[i+1]-nums[i] == d:
                    continue
                total = l = 0
            return result
    
        return (count(1)+count(-1)-reduce(lambda accu, x: (accu+x)%MOD, nums, 0))%MOD",O(n)
"import os, sys
from io import BytesIO, IOBase

def main():
    n = rint()
    deg = [0] * n
    if n == 2:
        exit(print(f'Yes\n1\n1 2'))

    for i in range(n - 1):
        u, v = rints()
        deg[u - 1] += 1
        deg[v - 1] += 1

    ix = deg.index(max(deg))

    if deg[ix] < 3 or deg.count(1) + deg.count(2) == n - 1:
        print(f'Yes\n{deg.count(1)}')

        for i in range(n):
            if deg[i] == 1:
                print(i + 1, ix + 1)
    else:
        print('No')

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [rstr() for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",O(n)
"x, k = map(int, input().split())

if x == 0:
    print(0)
    exit()

mod = 10 ** 9 + 7

a = ((x % mod) * pow(2, k + 1, mod)) % mod

print((a - (pow(2, k, mod) - 1)) % mod)",O(logn)
"l, r = map(int, input().split())
masks = []
for i in range(64, -1, -1):
    if (1 << i) > r:
        continue
    masks.append(1 << i)
    x, y = 0, 0
    for k in masks:
        if x < y:
            x += k
        else:
            y += k
    for j in range(64, -1, -1):
        if ((x >> j) & 1) or ((y >> j) & 1):
            continue
        if x + (1 << j) <= r:
            x += (1 << j)
        if y + (1 << j) <= r:
            y += (1 << j)
    if min(x, y) < l or max(x, y) > r:
        masks.pop()
print(sum(masks))",O(logn)
"class Solution(object):
    def discountPrices(self, sentence, discount):
        result = []
        i = 0
        while i < len(sentence):
            j = sentence.find(' ', i)
            if j == -1: j = len(sentence)
            if sentence[i] == '$' and j-(i+1) > 0 and all(sentence[k].isdigit() for k in range(i+1, j)):
                cnt = reduce(lambda x, y: x*10+int(y), (sentence[k] for k in range(i+1, j)), 0)
                result.append(""${:d}.{:02d}"".format(*divmod(cnt*(100-discount), 100)))
            else:
                for k in range(i, j):
                    result.append(sentence[k])
            if j != len(sentence):
                result.append(' ')
            i = j+1
        return """".join(result)",O(n)
"class Solution(object):
    def maxBoxesInWarehouse(self, boxes, warehouse):
        boxes.sort(reverse=True)
        left, right = 0, len(warehouse)-1
        for h in boxes:
            if h <= warehouse[left]:
                left += 1
            elif h <= warehouse[right]:
                right -= 1
            if left > right:
                break
        return left + (len(warehouse)-1-right)",O(nlogn)
"import math
import random
import heapq, bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
import threading
from collections import defaultdict
threading.stack_size(10**8)
mod = 10 ** 9 + 7
mod1 = 998244353

import os
import sys
from io import BytesIO, IOBase
sys.setrecursionlimit(300000)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class TreeNode:
    def __init__(self, k, v):
        self.key = k
        self.value = v
        self.left = None
        self.right = None
        self.parent = None
        self.height = 1
        self.num_left = 1
        self.num_total = 1

class AvlTree:

    def __init__(self):
        self._tree = None

    def add(self, k, v):
        if not self._tree:
            self._tree = TreeNode(k, v)
            return
        node = self._add(k, v)
        if node:
            self._rebalance(node)

    def _add(self, k, v):
        node = self._tree
        while node:
            if k < node.key:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(k, v)
                    node.left.parent = node
                    return node.left
            elif node.key < k:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(k, v)
                    node.right.parent = node
                    return node.right
            else:
                node.value = v
                return

    @staticmethod
    def get_height(x):
        return x.height if x else 0

    @staticmethod
    def get_num_total(x):
        return x.num_total if x else 0

    def _rebalance(self, node):

        n = node
        while n:
            lh = self.get_height(n.left)
            rh = self.get_height(n.right)
            n.height = max(lh, rh) + 1
            balance_factor = lh - rh
            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)
            n.num_left = 1 + self.get_num_total(n.left)

            if balance_factor > 1:
                if self.get_height(n.left.left) < self.get_height(n.left.right):
                    self._rotate_left(n.left)
                self._rotate_right(n)
            elif balance_factor < -1:
                if self.get_height(n.right.right) < self.get_height(n.right.left):
                    self._rotate_right(n.right)
                self._rotate_left(n)
            else:
                n = n.parent

    def _remove_one(self, node):

        replacement = node.left or node.right
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = replacement
            else:
                node.parent.right = replacement
            replacement.parent = node.parent
            node.parent = None
        else:
            self._tree = replacement
            replacement.parent = None
        node.left = None
        node.right = None
        node.parent = None
        self._rebalance(replacement)

    def _remove_leaf(self, node):
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = None
            else:
                node.parent.right = None
            self._rebalance(node.parent)
        else:
            self._tree = None
        node.parent = None
        node.left = None
        node.right = None

    def remove(self, k):
        node = self._get_node(k)
        if not node:
            return
        if AvlTree._is_leaf(node):
            self._remove_leaf(node)
            return
        if node.left and node.right:
            nxt = AvlTree._get_next(node)
            node.key = nxt.key
            node.value = nxt.value
            if self._is_leaf(nxt):
                self._remove_leaf(nxt)
            else:
                self._remove_one(nxt)
            self._rebalance(node)
        else:
            self._remove_one(node)

    def get(self, k):
        node = self._get_node(k)
        return node.value if node else -1

    def _get_node(self, k):
        if not self._tree:
            return None
        node = self._tree
        while node:
            if k < node.key:
                node = node.left
            elif node.key < k:
                node = node.right
            else:
                return node
        return None

    def get_at(self, pos):
        x = pos + 1
        node = self._tree
        while node:
            if x < node.num_left:
                node = node.left
            elif node.num_left < x:
                x -= node.num_left
                node = node.right
            else:
                return (node.key, node.value)
        raise IndexError(""Out of ranges"")

    @staticmethod
    def _is_left(node):
        return node.parent.left and node.parent.left == node

    @staticmethod
    def _is_leaf(node):
        return node.left is None and node.right is None

    def _rotate_right(self, node):
        if not node.parent:
            self._tree = node.left
            node.left.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.left
            node.left.parent = node.parent
        else:
            node.parent.right = node.left
            node.left.parent = node.parent
        bk = node.left.right
        node.left.right = node
        node.parent = node.left
        node.left = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    def _rotate_left(self, node):
        if not node.parent:
            self._tree = node.right
            node.right.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.right
            node.right.parent = node.parent
        else:
            node.parent.right = node.right
            node.right.parent = node.parent
        bk = node.right.left
        node.right.left = node
        node.parent = node.right
        node.right = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    @staticmethod
    def _get_next(node):
        if not node.right:
            return node.parent
        n = node.right
        while n.left:
            n = n.left
        return n

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a+b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m

def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z

def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por

def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        if (arr[mid] <= key):
            count = mid + 1
            left = mid + 1

        else:
            right = mid - 1

    return count

def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    leftGreater = n

    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        else:
            l = m + 1

    return (n - leftGreater)

n=int(input())
l=list(map(int,input().split()))
dp=[[0 for i in range(n)]for i in range(n)]
for i in range(n):
    dp[i][i]=l[i]
for i in range(n-1,-1,-1):
    for j in range(i+1,n):
        dp[i][j]=max(dp[i][j],dp[i][j-1]^dp[i+1][j])
for i in range(n-1,-1,-1):
    for j in range(i+1,n):
        dp[i][j]=max(dp[i][j],dp[i][j-1],dp[i+1][j])
for i in range(int(input())):
    l,r=map(int,input().split())
    l-=1
    r-=1
    print(dp[l][r])",O(n ^ 2)
"a,b,c,d,e,f,g,h,i,j,k,l= [9*1, 90*2, 900*3, 9000*4, 90000*5, 900000*6, 9000000*7, 90000000*8, 900000000*9, 9000000000*10, 90000000000*11, 900000000000*12]
a=a; b= a+b; c= b+c; d=c+d; e=d+e; f= e+f; g= f+g; h=g+h; i=h+i; j= i+j
k= j+k; l= k+l
li1=[0,a,b,c,d,e,f,g,h,i,j,k,l]
n= int(input()); nn=0
for ii in range(1,12):
    if li1[ii-1]<n and li1[ii+1]>n:
        nn= ii

n= n-li1[nn-1]
r1= 10**(nn-1)
n1= n//nn
r1+= n1-1
n2= n-(n1*nn)
if n2==0:
    print(str(r1)[-1])
else:

    print(str(r1+1)[n2-1])",O(logn)
"class Solution2(object):
    def rotateString(self, A, B):
        def strStr(haystack, needle):
            def KMP(text, pattern):
                prefix = getPrefix(pattern)
                j = -1
                for i in range(len(text)):
                    while j > -1 and pattern[j + 1] != text[i]:
                        j = prefix[j]
                    if pattern[j + 1] == text[i]:
                        j += 1
                    if j == len(pattern) - 1:
                        return i - j
                return -1

            def getPrefix(pattern):
                prefix = [-1] * len(pattern)
                j = -1
                for i in range(1, len(pattern)):
                    while j > -1 and pattern[j + 1] != pattern[i]:
                        j = prefix[j]
                    if pattern[j + 1] == pattern[i]:
                        j += 1
                    prefix[i] = j
                return prefix

            if not needle:
                return 0
            return KMP(haystack, needle)

        if len(A) != len(B):
            return False
        return strStr(A*2, B) != -1",O(n)
print('25'),O(1)
"n = int(input())
l = [0]+list(map(int,input().split()))
from collections import defaultdict
ans = ['A','B']
x = defaultdict(int)
table = [-1]*(n+1)
for i in range(1,n+1):
	x[l[i]] = i

table[x[n]] = 1
for i in range(n-1,0,-1):
	if(x[i]-i>0):
		for j in range(x[i],0,-i):
			if(l[j]>i):
				if(table[j]==1):
					table[x[i]] = 0
					break
	if(n-i>0 and table[x[i]]==-1):
		for j in range(x[i],n+1,i):
			if(l[j]>i):
				if(table[j]==1):
					table[x[i]] = 0
					break

	if(table[x[i]]==-1):
		table[x[i]] = 1

for i in table[1:]:
	print(ans[i],end='')",O(n)
"class Solution(object):
    def minEdgeReversals(self, n, edges):
        def iter_dfs1():
            result = 0
            stk = [(0, -1)]
            while stk:
                u, p = stk.pop()
                for v in adj[u].keys():
                    if v == p:
                        continue
                    result += adj[u][v]
                    stk.append((v, u))
            return result

        def iter_dfs2(curr):
            result = [-1]*n
            stk = [(0, curr)]
            while stk:
                u, curr = stk.pop()
                result[u] = curr
                for v in adj[u].keys():
                    if result[v] == -1:
                        stk.append((v, curr-adj[u][v]+adj[v][u]))
            return result
    
        adj = collections.defaultdict(dict)
        for u, v in edges:
            adj[u][v] = 0
            adj[v][u] = 1
        return iter_dfs2(iter_dfs1())",O(n)
"import functools
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:

    def __init__(self):
        pass

    def __call__(self):
        n, m = map(int, input().strip().split())

        y = 0
        for _ in range(m):
            x, d = map(int, input().strip().split())
            if d >= 0:
                y += d * (n - 1) * n // 2
            else:
                if n % 2 != 0:
                    l = (n - 1) // 2
                    y += d * l * (l + 1)
                else:
                    l = n // 2
                    y += d * (l * (l + 1) - l)
            y += x * n
        y /= n
        print(f'{y:.9f}')

solver()()",O(n)
"n = int(input())

l = []
for i in range(n):
    c = list(map(int, input().split()))
    l.append(sum(c))

m = l[0]
l.sort(reverse=True)
for i in range(len(l)):
    if m == l[i]:
        print(i+1)
        break
",O(n)
"n, m = map(int, input().split())
a = sorted(map(int, input().split()))
ans = 0
cur = 0
for b in a:
  if b > cur:
    ans += 1
    cur += 1
  else:
    ans += 1
print(sum(a) - (ans + max(a) - cur))
",O(nlogn)
"import collections


class Solution(object):
    def maxConsecutiveAnswers(self, answerKey, k):
        result = max_count = 0
        count = collections.Counter()
        for i in range(len(answerKey)):
            count[answerKey[i]] += 1
            max_count = max(max_count, count[answerKey[i]])
            if result-max_count >= k:
                count[answerKey[i-result]] -= 1
            else:
                result += 1
        return result",O(n)
"import sys
import heapq
input = sys.stdin.readline

n,x,y = map(int,input().split())
MOD_NUM = 10**9+7

events = dict()
for i in range(n):
    l,r = map(int,input().split())
    if l not in events:
        events[l] = []
    events[l].append(r)

tv = []
pq = []
cost = 0

for t in sorted(events):
    while tv and tv[0] < t:
        heapq.heappush(pq, -(x + heapq.heappop(tv)*y))

    for ri in sorted(events[t],reverse=True):
        if pq and -pq[0] > t*y:
            val = -heapq.heappop(pq)
            rj = (val-x)//y

            cost += (ri-rj)*y
            heapq.heappush(tv, ri)
        else:
            cost += x + (ri-t)*y
            heapq.heappush(tv, ri)
    cost %= MOD_NUM

print(cost)
",O(nlogn)
"import math
n=int(input())
if(n==4): print(12)
elif(n<=2): print(n)
else:
    if(n%2==0):
        a=n*(n-1)*(n-3)
        if(n%3==0): a=a//3
        b=n*(n-1)*(n-2)
        b=b//2
        print(max(a,b,(n-1)*(n-2)*(n-3)))
    else: print(n*(n-1)*(n-2))",O(1)
"class Solution2(object):
    dp = {}

    def getKth(self, lo, hi, k):
        def power_value(x):
            y, result = x, 0
            while x > 1 and x not in Solution2.dp:
                result += 1
                if x%2:
                    x = 3*x + 1
                else:
                    x //= 2
            Solution2.dp[y] = result + (Solution2.dp[x] if x > 1 else 0)
            return Solution2.dp[y], y
        
        return sorted(list(range(lo, hi+1)), key=power_value)[k-1]",O(nlogn)
"class Solution(object):
    def modifyString(self, s):
        s = list(s)
        for i in range(len(s)):
            if s[i] != '?':
                continue
            for c in ('a', 'b', 'c'):
                if (i == 0 or s[i-1] != c) and (i == len(s)-1 or c != s[i+1]):
                    break
            s[i] = c
        return """".join(s)",O(n)
"from math import *
n,k=map(int,input().split())
val=int(sqrt(9+(8*(n+k))))
ans=(-3+val)//2
print(n-ans)
",O(1)
"import math
temp=list(map(int,input().split()))
N,q=temp[0],temp[1]
for j in range(0,q):
    u=int(input())
    S=input()
    k=(N+1)//2
    n=int(math.log((N+1),10)/math.log(2,10))-1
    dup_n=n
    store=[k]
    while u!=k:
        n-=1
        if u>k:
            k+=2**(n)
        else:
            k-=2**(n)
        store.append(k)
    for i in range(0,len(S)):
        if S[i]=='R':
            n-=1
            if n==-1:
                n=0
                continue
            k+=2**(n)
        elif S[i]=='L':
            n-=1
            if n==-1:
                n=0
                continue
            k-=2**(n)
        else:
            if n==dup_n:
                continue
            store.pop()
            k=store[len(store)-1]
            n+=1
            continue
        store.append(k)

    print(k)",np
"class Solution(object):
    def findNthDigit(self, n):
        digit_len = 1
        while n > digit_len * 9 * (10 ** (digit_len-1)):
            n -= digit_len  * 9 * (10 ** (digit_len-1))
            digit_len += 1

        num = 10 ** (digit_len-1) + (n-1)/digit_len

        nth_digit = num / (10 ** ((digit_len-1) - ((n-1)%digit_len)))
        nth_digit %= 10

        return nth_digit",O(logn)
"line = input()
n = len(line)
temp = [0]
for i in range(1, n):
    for j in range(n-i):
        for k in range(1, n-i-j+1):

            if line[j:j+i] == line[j+k:j+k+i]:
                temp.append(i)
print(max(temp))",O(n ^ 3)
"from collections import defaultdict
n, k = map(int, input().split())
a = [0] + list(map(int, input().split()))
h = defaultdict(int)
for i in range(n):
	a[i + 1] ^= a[i]
for i in range(n + 1):
	h[min(a[i] ^ ((1 << k) - 1), a[i])] += 1
ans = 0
for x, t in h.items():
	a = t // 2
	b = t - a
	ans += a * (a - 1) // 2 + b * (b - 1) // 2
ans = (n * (n + 1)) // 2 - ans
print(ans)
",O(n)
"class Solution(object):
    def findCenter(self, edges):
        return edges[0][edges[0][1] in edges[1]]",O(1)
"from sys import stdin, stdout
n = int(stdin.readline())
m = int(stdin.readline())
stdout.write(str(m%(1<<n)))",O(1)
"n = int(input())

gems = {'purple':'Power', 'green':'Time', 'blue': 'Space',
    'orange': 'Soul', 'red': 'Reality', 'yellow': 'Mind'}

gems_in = []
for _ in range(n):
    gems_in.append(input())

print(6-len(gems_in))
r = list(set(gems) - set(gems_in))
for gem in r:
    print(gems[gem])
",O(1)
"def if_spruce(n,l,m):
    d=[0]*(n+1)
    for i in range(1,n+1):
        if m[i]==0:
            d[l[i]]+=1
    for i in range(1,n+1):
        if m[i]>0 and d[i]<3:
            return ""No""
    return ""Yes""

n=int(input())
l,m,a=[0]*2,[0]*(n+1),0
for _ in range(n-1):
    a=int(input())
    l.append(a)
    m[a]+=1
print(if_spruce(n,l,m))",O(n)
"class Solution4(object):
    def canReachCorner(self, X, Y, circles):
        def check(x1, y1, r1, x2, y2, r2):
            return (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2

        def bfs(src, dst):
            lookup = [False]*len(adj)
            lookup[src] = True
            q = [src]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.append(v)
                q = new_q
            return lookup[dst]

        adj = [[] for _ in range(len(circles)+2)]
        for u in range(len(circles)):
            x1, y1, r1 = circles[u]
            if x1-r1 <= 0 or y1+r1 >= Y:
                adj[u].append(len(circles))
                adj[len(circles)].append(u)
            if x1+r1 >= X or y1-r1 <= 0:
                adj[u].append(len(circles)+1)
                adj[len(circles)+1].append(u)
            for v in range(u):
                x2, y2, r2 = circles[v]
                if not check(x1, y1, r1, x2, y2, r2):
                    continue
                adj[u].append(v)
                adj[v].append(u)
        return not bfs(len(circles), len(circles)+1)",O(n ^ 2)
"class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        closeToOpen = { "")"" : ""("", ""]"" : ""["", ""}"" : ""{"" }

        for c in s:
            if c in closeToOpen:
                if stack and stack[-1] == closeToOpen[c]:
                    stack.pop()
                else:
                    return False
            else:
                stack.append(c)

        return True if not stack else False
",O(n)
"import sys
sss='RGB'*700
def check(ss,p):
    i=0
    m=10**5
    ans=0
    while i<len(p):
        if p[i]!=sss[i]:
            ans+=1
        i+=1
    m=min(m,ans)
    ans=0
    i=1
    while i<len(p)+1:
        if p[i-1]!=sss[i]:
            ans+=1
        i+=1
    m=min(m,ans)
    ans=0
    i=2
    while i<len(p)+2:
        if p[i-2]!=sss[i]:
            ans+=1
        i+=1
    m=min(m,ans)

    return m

for _ in range(int(input())):
    n,k=(list(map(int,sys.stdin.readline().split())))
    s=input()
    m=10**5
    for i in range(n-k+1):
        m=min(m,(check(sss,s[i:i+k])))
    print(m)",O(n ^ 2)
"f = [0 for _ in range(40)]

for i in range(1, 32):
    f[i] = 1 + 4 * f[i - 1]
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    if n >= 32:
        print(""YES %d"" % (n - 1))
        continue

    if f[n] < k:
        print(""NO"")
        continue

    k -= 1
    extra = 1
    way = 3
    size = n - 1
    done = False
    total = f[size]
    ans = True
    while k > total and size > 0:
        if k < way:
            ans = False
            break
        k -= way
        size -= 1
        extra = way * 2 - 1
        way = way * 2 + 1
        total += extra * f[size]

    if ans:
        print(""YES %d"" % size)
    else:
        print(""NO"")
",O(1)
"from sys import stdin, gettrace

if not gettrace():
    def input():
        return next(stdin)[:-1]

INF = 10000

def main():
    n = int(input())
    aa = [int(a) for a in input().split()]

    dp = [[0] * (n+1) for _ in range(n)]

    def calc_dp(i, j):
        if i + 1 == j:
            dp[i][j] = aa[i]
        if dp[i][j] != 0:
            return dp[i][j]
        dp[i][j] = -1
        for k in range(i+1, j):
            lf = calc_dp(i, k)
            rg = calc_dp(k, j)
            if lf > 0 and lf == rg:
                dp[i][j] = lf + 1
                break
        return dp[i][j]

    dp2 = list(range(0,n+1))
    for i in range(n):
        for j in range(i+1, n+1):
            if calc_dp(i, j) > 0:
                dp2[j] = min(dp2[j], dp2[i] + 1)
    print(dp2[n])

if __name__ == ""__main__"":
    main()",O(n ^ 3)
"class Solution2(object):
    def isValidBST(self, root):
        return self.isValidBSTRecu(root, float(""-inf""), float(""inf""))

    def isValidBSTRecu(self, root, low, high):
        if root is None:
            return True

        return low < root.val and root.val < high \
            and self.isValidBSTRecu(root.left, low, root.val) \
            and self.isValidBSTRecu(root.right, root.val, high)",O(n)
"class Solution2(object):
    def numberOfAlternatingGroups(self, colors):
        return sum(colors[i] != colors[(i+1)%len(colors)] != colors[(i+2)%len(colors)] for i in range(len(colors)))",O(n)
"n = int(input())
A = list(map(int, input().split()))
if n == 1:
    if A[0] >= 0:
        print(A[0])
    else:
        print(-A[0]-1)
    exit(0)
for i in range(n):
    if A[i] < 0:
        pass
    else:
        A[i] = -A[i]-1
if n % 2 == 0:
    print(*A)
    exit(0)
mim = 0
indmim = 0
for i in range(n):
    if A[i] < mim:
        mim = A[i]
        indmim = i
A[indmim] = -A[indmim]-1
print(*A)
",O(n)
"from sys import  stdin
input=stdin.readline
from  collections import defaultdict
def num(s):
    l,r=0,0
    for i in s:
        if l==0 and i=="")"":
            r+=1
        elif i==""("":
            l+=1
        elif l and i=="")"":
            l-=1
    return (l,r)

def f(mp,cnt):
    ans=0

    for l in cnt:

        if l.count(0)<1:
            continue
        if l!=(0,0) and l==l[::-1]:
            continue

        t=mp[l[::-1]]
        t2=mp[l[::-1]]
        ans+=t
        if t and l!=l[::-1]:
            mp[l]-=1
    return ans

cnt=[]
mp=defaultdict(int)
for i in range(int(input())):
    s=input()
    l=num(s)

    cnt.append(l)
    mp[l]+=1
print(f(mp,cnt))",O(n)
"s0=input()
k=int(input())
s1=s0[::-1]
lens1=len(s1)
maxnum=1005
mod=1000000007
dp=[[0]*maxnum for tmpi in range(maxnum)]
f=[0]*maxnum
c=[[0]*maxnum for tmpi in range(maxnum)]

def cntone(num):
    tmps=bin(num)[2:]
    cnt=0
    for i in range(len(tmps)):
        if(tmps[i]=='1'):
            cnt+=1
    return cnt

for i in range(1,maxnum):
    if(i==1):
        f[i]=0
    else:
        f[i]=f[cntone(i)]+1

for i in range(maxnum):
    if(i==0):
        c[i][0]=1
        continue
    for j in range(i+1):
        if(j==0):
            c[i][j]=1
        else:
            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod

for i in range(lens1):
    if(i==0):
        dp[i][0] = 1
        if(s1[i]=='1'):
            dp[i][1]=1
        else:
            dp[i][1]=0
        continue
    else:
        for j in range(0,i+2):
            if(j==0):
                dp[i][j]=1
                continue
            if(s1[i]=='1'):
                dp[i][j]=(dp[i-1][j-1]+c[i][j])%mod
            else:
                dp[i][j]=dp[i-1][j]%mod

ans=0

for i in range(1,lens1+1):
    if(f[i]==k-1):
        ans=(ans+dp[lens1-1][i])%mod

if(k==0):
    ans=1
elif(k==1):
    ans-=1
else:
    ans=ans
print(ans)
",O(n)
"class Solution(object):
    def maxAdjacentDistance(self, nums):
        return max(abs(nums[i]-nums[i-1]) for i in range(len(nums)))",O(n)
"import sys
import math
import collections
import bisect
import string
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n=int(input())
    s1=list(get_string())
    s2=list(get_string())
    count=0
    ans=[]
    lower=string.ascii_lowercase
    np=0
    for i in lower:
        if s1.count(i)!=s2.count(i):
            np+=1
            break
    if np>0:
        print(-1)
        continue
    pos=dict()
    for i in range(n):
        if s1[i] in pos:
            pos[s1[i]].append(i)
        else:
            pos[s1[i]]=[i]
    for i in range(n):
        if s1[i]==s2[i]:
            continue
        else:
            row=pos[s2[i]]
            no=0
            for j in range(len(row)):
                if row[j]>i:
                    no=row[j]
                    break
            for j in range(no,i,-1):
                ans.append(j)
            s1.pop(no)
            s1.insert(i,s2[i])

            pos = dict()
            for j in range(n):
                if s1[j] in pos:
                    pos[s1[j]].append(j)
                else:
                    pos[s1[j]] = [j]
    print(len(ans))
    print(*ans)",O(n ^ 2)
"from sys import stdin,stdout
for _ in range(1):

    moves,left=list(map(int,stdin.readline().split()))

    l=1;r=10**9+1
    while l<=r:
        mid=(l+r)>>1
        fx=(mid*(mid+1))//2-left+mid

        if fx<=moves:l=mid+1
        else:r=mid-1
    print(moves-r)",O(logn)
"s=int(input())
u=True
for i in [4,7,47,74,447,474,477,747,774]:
    if s%i==0:
        u=False
        print(""YES"")
        break
if u:
    print(""NO"")
",O(1)
"class Solution2(object):
    def rangeBitwiseAnd(self, m, n):
        i, diff = 0, n-m
        while diff:
            diff >>= 1
            i += 1
        return n & m >> i << i",O(1)
"class Solution(object):
    def longestCycle(self, edges):
        result = -1
        lookup = [-1]*len(edges)
        idx = 0
        for i in range(len(edges)):
            if lookup[i] != -1:
                continue
            start = idx
            while i != -1:
                if lookup[i] != -1:
                    break
                lookup[i] = idx
                idx += 1
                i = edges[i]
            if i != -1 and lookup[i] >= start:
                result = max(result, idx-lookup[i])
        return result",O(n)
"class Solution2(object):
    def numberOfWeakCharacters(self, properties):
        lookup = collections.defaultdict(list)
        for a, d in properties:
            lookup[a].append(d)
        result = max_d = 0
        for a in sorted(iter(lookup.keys()), reverse=True):
            result += sum(d < max_d for d in lookup[a])
            max_d = max(max_d, max(lookup[a]))
        return result",O(nlogn)
"class Solution(object):
    def findIntegers(self, num):
        dp = [0] * 32
        dp[0], dp[1] = 1, 2
        for i in range(2, len(dp)):
            dp[i] = dp[i-1] + dp[i-2]
        result, prev_bit = 0, 0
        for i in reversed(range(31)):
            if (num & (1 << i)) != 0:
                result += dp[i]
                if prev_bit == 1:
                    result -= 1
                    break
                prev_bit = 1
            else:
                prev_bit = 0
        return result + 1",O(1)
"import itertools
import re


class Solution(object):
    def summaryRanges(self, nums):
        ranges = []
        if not nums:
            return ranges

        start, end = nums[0], nums[0]
        for i in range(1, len(nums) + 1):
            if i < len(nums) and nums[i] == end + 1:
                end = nums[i]
            else:
                interval = str(start)
                if start != end:
                    interval += ""->"" + str(end)
                ranges.append(interval)
                if i < len(nums):
                    start = end = nums[i]

        return ranges",O(n)
"class Solution3(object):
    def shortestPalindrome(self, s):
        def preProcess(s):
            if not s:
                return ['^', '$']
            string = ['^']
            for c in s:
                string +=  [
            string += [
            return string

        string = preProcess(s)
        palindrome = [0] * len(string)
        center, right = 0, 0
        for i in range(1, len(string) - 1):
            i_mirror = 2 * center - i
            if right > i:
                palindrome[i] = min(right - i, palindrome[i_mirror])
            else:
                palindrome[i] = 0

            while string[i + 1 + palindrome[i]] == string[i - 1 - palindrome[i]]:
                palindrome[i] += 1

            if i + palindrome[i] > right:
                center, right = i, i + palindrome[i]

        max_len = 0
        for i in range(1, len(string) - 1):
            if i - palindrome[i] == 1:
                max_len = palindrome[i]
        return s[len(s)-1:max_len-1:-1] + s",O(n)
"
import itertools



class Solution(object):
    def minCost(self, arr, brr, k):
        def cost():
            return sum(abs(x-y) for x, y in zip(arr, brr))

        result = cost()
        arr.sort()
        brr.sort()
        result = min(result, k+cost())
        return result
",O(nlogn)
"import itertools
import operator


class Solution(object):
    def minProductSum(self, nums1, nums2):
        def inner_product(vec1, vec2):
            return sum(map(operator.mul, vec1, vec2))


        nums1.sort()
        nums2.sort(reverse=True)
        return inner_product(nums1, nums2)",O(nlogn)
"import collections


class Solution(object):
    def maxNumberOfFamilies(self, n, reservedSeats):
        lookup = collections.defaultdict(lambda: [False]*3)
        for r, c in reservedSeats:
            if 2 <= c <= 5:
                lookup[r][0] = True
            if 4 <= c <= 7:
                lookup[r][1] = True
            if 6 <= c <= 9:
                lookup[r][2] = True
        result = 2*n
        for a, b, c in lookup.values():
            if not a and not c:
                continue
            if not a or not b or not c:
                result -= 1
                continue
            result -= 2
        return result",O(n)
"def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]

n = INT()
l  = []
d = {}
sm = 0

for i in range(n):
    indx , y  = MAP()

    d[indx] = y
    sm += y

m = INT()
for i in range(m):
    indx , y = MAP()
    if indx in d :
        sm -= d[indx]
        sm += max(y , d[indx])
    else:
        sm += y

print(sm)
",O(nlogn)
"n,v = map(int, input().split())
ans = min(v, n-1)
for i in range(n - v - 1):
    ans += i+2
print(ans)",O(n)
"n  = int(input())

a  = list(map(int, input().strip()))
b  = list(map(int, input().strip()))

res = 0

for j in range(n-1):
    if (a[j]== 0) and (a[j+1 ] == 1 ) and (b[j] == 1) and (b[j+1 ] == 0):
        res +=1
        a[j ] = 1
        a[j+1] = 0

    elif  (a[j]== 1) and (a[j+1] ==0 ) and (b[j] == 0) and (b[j+1 ] == 1):
        res +=1
        a[j ] = 0
        a[j+ 1] = 1

for j in range(n):
    if a[j] != b[j]:
        res += 1

print(res)",O(n)
"class Solution(object):
    def numDupDigitsAtMostN(self, N):
        def P(m, n):
            result = 1
            for _ in range(n):
                result *= m
                m -= 1
            return result

        digits = list(map(int, str(N+1)))
        result = 0

        for i in range(1, len(digits)):
            result += P(9, 1)*P(9, i-1)
        prefix_set = set()
        for i, x in enumerate(digits):
            for y in range(1 if i == 0 else 0, x):
                if y in prefix_set:
                    continue
                result += P(9-i, len(digits)-i-1)
            if x in prefix_set:
                break
            prefix_set.add(x)
        return N-result",O(logn)
"from collections import defaultdict
import sys
input = sys.stdin.readline

n, m, k = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
b = [list(map(int, input().split())) for _ in range(n - 1)]
if k % 2:
    ans = [-1] * m
    for _ in range(n):
        print(*ans)
    exit()

G = [[] for _ in range(n * m + 1)]
for i in range(n):
    a0 = a[i]
    for j in range(m - 1):
        x = a0[j]
        G[i * m + j].append((i * m + j + 1, x))
        G[i * m + j + 1].append((i * m + j, x))

for i in range(n - 1):
    b0 = b[i]
    for j in range(m):
        x = b0[j]
        G[i * m + j].append(((i + 1) * m + j, x))
        G[(i + 1) * m + j].append((i * m + j, x))

dp = [[0] * m for _ in range(n)]
dp0 = [[0] * m for _ in range(n)]
dp, dp0 = [0] * (n * m), [0] * (n * m)
v = [(1, 0), (-1, 0), (0, 1), (0, -1)]
inf = 1145141919
for i in range(n):
    for j in range(m):
        s = i * m + j
        dps = inf
        for t, x in G[s]:
            dps = min(dps, 2 * x)
        dp[s] = dps
        dp0[s] = dps
for _ in range((k - 2) // 2):
    dp1 = [0] * (n * m)
    for i in range(n):
        for j in range(m):
            s = i * m + j
            dps = dp0[s] + 2 * dp[s]
            for t, x in G[s]:
                dps = min(dps, 2 * x + dp0[t])
            dp1[s] = dps
    dp0 = dp1
for i in range(n):
    ans = dp0[(m * i):(m * (i + 1))]
    print(*ans)",O(n ^ 3)
"n, m = map(int, input().split())

l=[]
s1 = s2 = 0
for i in range(n):
    a, b = map(int, input().split())
    s1+=a
    s2+=b
    l.append(a-b)

if s1<=m: print(0)
elif s2>m: print(-1)
else:
    r=0
    l.sort(reverse=True)
    for i in l:
        r+=1
        s1-=i
        if s1<=m:
            print(r)
            break",O(nlogn)
"__author__ = 'ruckus'

n = int(input())
s = input()
t = input()
dif = {}
hem = 0
for i in range(n):
    if s[i] != t[i]:
        dif[i] = [s[i], t[i]]
        hem += 1

change = []
probed = []
k = 0
for i in dif.keys():
    if dif[i] in probed:
        continue
    probed.append(dif[i])
    k += 1
    for j in list(dif.keys())[k:]:
        if dif[i] == dif[j][::-1]:
            print(hem - 2)
            print(i + 1, j + 1)
            quit()
        if not change and (dif[i][0] == dif[j][1] or dif[j][0] == dif[i][1]):
            change = [i, j]

if change:
    print(hem - 1)
    print(change[0] + 1, change[1] + 1)
else:
    print(hem)
    print('-1 -1')",O(n)
"x, k = map(int, input().strip().split())
MOD = 10**9 + 7

def pow2(k):
    if k == 0:
        return 1
    if k == 1:
        return 2
    r = pow2(k // 2)
    r = r * r
    if k % 2 != 0:
        r *= 2
    return r % MOD

def calc(x, k):
    if x == 0:
        return 0
    if k == 0:
        return (2 * x) % MOD
    r = pow2(k) * (2 * x - 1) + 1
    return r % MOD

print(calc(x, k))",O(logn)
"n = int(input())
xs = [int(x) for x in input().split()]
prefix = [-1 for i in range(n)]
suffix = [-1 for i in range(n)]
prefix[0] = 0
pre_has_neg = [False for i in range(n)]
suffix[-1] = 0
suf_has_neg = [False for i in range(n)]
for i in range(n):
	if i == 0:
		prefix[i] = xs[i]
	else:
		prefix[i] = prefix[i-1] + xs[i]
for i in reversed(range(n)):
	if i == n-1:
		suffix[i] = xs[i]
	else:
		suffix[i] = suffix[i+1] + xs[i]
for i in range(n):
	if i == 0:
		pre_has_neg[i] = xs[i] <= 0
	else:
		pre_has_neg[i] = pre_has_neg[i-1] or xs[i] <= 0
for i in reversed(range(n)):
	if i == n-1:
		suf_has_neg[i] = xs[i] <= 0
	else:
		suf_has_neg[i] = suf_has_neg[i+1] or xs[i] <= 0

prebignum = [None for i in range(n)]
sufbignum = [None for i in range(n)]
for i in range(n):
	if i == 0:
		prebignum[i] = xs[i]
	else:
		prebignum[i] = min(prebignum[i-1], xs[i])
for i in reversed(range(n)):
	if i == n-1:
		sufbignum[i] = xs[i]
	else:
		sufbignum[i] = min(sufbignum[i+1], xs[i])

neg_pre = [100000 for i in range(n)]
neg_suf = [100000 for i in range(n)]

for i in range(n):
	if i == 0:
		neg_pre[i] = min(xs[i], -xs[i])
	else:
		neg_pre[i] = neg_pre[i-1] + min(xs[i], -xs[i])

for i in reversed(range(n)):
	if i == n-1:
		neg_suf[i] = min(xs[i], -xs[i])
	else:
		neg_suf[i] = neg_suf[i+1] + min(xs[i], -xs[i])

ans = -100000000000000000
for i in range(n):

	tans = xs[i]
	if i == 0:
		pass
	elif pre_has_neg[i-1]:
		tans -= neg_pre[i-1]
	else:
		tans += prefix[i-1]
		tans -= prebignum[i-1]*2

	if i == n-1:
		pass
	elif suf_has_neg[i+1]:
		tans -= neg_suf[i+1]
	else:
		tans += suffix[i+1]
		tans -= sufbignum[i+1]*2

	ans = max(ans, tans)

print(ans)",O(n)
"x,n=map(int,input().split())
mod=10**9+7
if x>0: ans=pow(2,n+1,mod)*x-pow(2,n,mod)+1
else: ans=0
print(ans%mod)",O(logn)
"r, g, b = map(int, input().split())
red = list(map(int, input().split()))
green = list(map(int, input().split()))
blue = list(map(int, input().split()))
red.sort()
green.sort()
blue.sort()
red = red[::-1]
green = green[::-1]
blue = blue[::-1]

dp = []
for i in range(r + 1):
    temp = [[0] * (b + 1) for j in range(g + 1)]
    dp.append(temp)

answer = 0

for i in range(0, r + 1):
    for j in range(0, g + 1):
        for k in range(0, b + 1):
            if i > 0 and j > 0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + red[i - 1] * green[j - 1])
            if i > 0 and k > 0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + red[i - 1] * blue[k - 1])
            if j > 0 and k > 0:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + green[j - 1] * blue[k - 1])

            answer = max(answer, dp[i][j][k])
print(answer)",O(n ^ 3)
"n,k=map(int,input().split())
print(max(min(n,k-1)-k//2,0))",O(1)
"class Solution2(object):
    def numberOfSpecialSubstrings(self, s):
        result = left = 0
        lookup = [False]*26
        for right in range(len(s)):
            while lookup[ord(s[right])-ord('a')]:
                lookup[ord(s[left])-ord('a')] = False
                left += 1
            lookup[ord(s[right])-ord('a')] = True
            result += (right-left+1)
        return result",O(n)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self is None:
            return ""Nil""
        else:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def removeNthFromEnd(self, head, n):
        dummy = ListNode(-1)
        dummy.next = head
        slow, fast = dummy, dummy

        for i in range(n):
            fast = fast.__next__

        while fast.__next__:
            slow, fast = slow.__next__, fast.__next__

        slow.next = slow.next.__next__

        return dummy.__next__",O(n)
"
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        if root in (None, p, q):
            return root

        left, right = [self.lowestCommonAncestor(child, p, q) \
                         for child in (root.left, root.right)]
        return root if left and right else left or right

",O(n)
"sum = [0 for i in range(12)]
i = 0
while sum[i] < 10 ** 12:
    i += 1
    sum[i] = sum[i - 1] + i * (10 ** i - 10 ** (i - 1))
k = int(input())
i = 0
while k > sum[i]:
    i += 1
ans = 10 ** (i - 1) - 1
ans += (k - sum[i - 1]) // i
if (k - sum[i - 1]) % i != 0:
    ans += 1
print(str(ans)[(k - sum[i - 1]) % i - 1])",O(logn)
"leng = 0
s = input()
for i in range(len(s)):
    for j in range(i + 1, len(s) + 1):
        sub = s[i:j]
        if s.count(sub) >= 2 and len(sub) > leng:
            leng = len(sub)
        elif s.count(sub) == 1:
            for k in range(1, len(sub)):
                if s[i - k:j - k] == sub and len(sub) > leng:
                    leng = len(sub)
print(leng)
",O(n ^ 3)
"def solve(i, j, k):
    if dp[i][j][k]!=-1:
        return dp[i][j][k]
    call = 0
    if i>0 and j>0:
        call = max(call, R[i]*G[j]+solve(i-1, j-1, k))
    if j>0 and k>0:
        call = max(call, G[j]*B[k]+solve(i, j-1, k-1))
    if k>0 and i>0:
        call = max(call, B[k]*R[i]+solve(i-1, j, k-1))
    dp[i][j][k] = call
    return call

nr, ng, nb = map(int,input().split())
R = [0]+list(map(int,input().split()))
G = [0]+list(map(int,input().split()))
B = [0]+list(map(int,input().split()))
R.sort()
G.sort()
B.sort()
dp = [[[-1]*(nb+1) for j in range(ng+1)] for i in range(nr+1)]
ans = solve(nr, ng, nb)
print(ans)",O(n ^ 3)
"import sys, os
from io import BytesIO, IOBase
from math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log
from collections import defaultdict as dd, deque
from heapq import merge, heapify, heappop, heappush, nsmallest
from bisect import bisect_left as bl, bisect_right as br, bisect

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

mod = pow(10, 9) + 7
mod2 = 998244353

def inp(): return stdin.readline().strip()
def iinp(): return int(inp())
def out(var, end=""\n""): stdout.write(str(var)+""\n"")
def outa(*var, end=""\n""): stdout.write(' '.join(map(str, var)) + end)
def lmp(): return list(mp())
def mp(): return map(int, inp().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]
def ceil(a, b): return (a+b-1)//b
S1 = 'abcdefghijklmnopqrstuvwxyz'
S2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
def isprime(x):
    if x<=1: return False
    if x in (2, 3): return True
    if x%2 == 0: return False
    for i in range(3, int(sqrt(x))+1, 2):
        if x%i == 0: return False
    return True

n, k = mp()
if n==0:
    print(0)
    exit()
x = (n*pow(2, k+1, mod))%mod
print((x-pow(2, k, mod)+1)%mod)",O(logn)
"import sys
n = int(input())

a = list(map(int,input().split()))

for i in range(n):
    a[i] = [i,a[i]]

a.sort(key=lambda x: x[1],reverse=True)

ans = []

index = 0
cnt = 0
tmp = 1
right_bool = False
left_bool = False

for i in range(1,n):
    if a[index][1] == 0:
        print('NO')
        sys.exit()
    if a[i][1] >= 2:
        ans.append([a[i-1][0],a[i][0]])
        cnt += 1
        a[i-1][1] -= 1
        a[i][1] -= 1
    else:
        if right_bool == False:
            ans.append([a[i-1][0],a[i][0]])
            a[i-1][1] -= 1
            a[i][1] -= 1
            cnt += 1
            right_bool = True
        else:
            ans.append([a[index][0],a[i][0]])
            a[index][1] -= 1
            a[i][1] -= 1
            if left_bool == False:
                cnt += 1
                left_bool = True
            if a[index][1] == 0:
                index += 1

print('YES', cnt)
print(n-1)
for i in range(n-1):
    print(ans[i][0]+1,ans[i][1]+1)",O(nlogn)
"class Solution2(object):
    def isPowerOfThree(self, n):
        return n > 0 and (math.log10(n)/math.log10(3)).is_integer()",O(1)
"def main():
    t = int(input())
    for _ in range(t):
        n, m = map(int, input().split())
        l = []; board = []
        for i in range(n):
            li = list(map(int, input().split()))
            board.append(li)
            for j in range(m):
                l.append((li[j], j))
        l.sort(key = lambda x : x[0], reverse = True)
        idxs = set()
        z = 0
        while len(idxs) < min(n, m):
            curr = l[z]
            idxs.add(curr[1])
            z += 1
        idxs = list(idxs)
        total = 0
        for i in range(n ** n):
            rotations = []; num = i
            for j in range(n - 1, -1, -1):
                nj = n ** j
                q = num // nj
                num -= q * nj
                rotations.append(q)
            subtotal = 0

            for k in range(n):

                subtotal += max(board[(k + rotations[col]) % n][idxs[col]] for col in range(min(n, m)))
            total = max(total, subtotal)
        print(total)
main()",np
"def check(n,p):
    k=str(n)
    k=k[::-1]
    s=0
    for j in range(len(k)):
        s+=(int(k[j])*(10**j-1))
    if s>=p:
        return 1
    else:
        return 0

n,s=map(int,input().split())
l=1
h=n
k=0
while(l<=h):
    m=(l+h)//2
    if check(m,s)==0:
        l=m+1
    else:
        h=m-1
    k+=1
print(n-l+1)
",O(logn)
"k = int(input())
a = 9
for i in range(1,12):
    if k<=a*i:
        a = (a//9)+(k//i)-1
        if k%i!=0:
            b = str(a+1)
            c = (k%i)-1
            print(b[c])
        else:
            b = str(a)
            print(b[-1])
        break
    else:
        k = k-a*i
        a = a*10
",O(logn)
"class Solution(object):
    def maxEnergyBoost(self, energyDrinkA, energyDrinkB):
        dp = [0]*2
        for i in range(len(energyDrinkA)):
            dp = [max(dp[0]+energyDrinkA[i], dp[1]), max(dp[1]+energyDrinkB[i], dp[0])]
        return max(dp)",O(n)
"n_extnson, n_dvics, n_sokts = list(map(int, input().split()))
extensions = list(map(int, input().split()))
extensions.sort(reverse=True)
devices_left = n_dvics - n_sokts
extnson_used = 0
i = 0
while devices_left > 0 and n_extnson > 0:
    devices_left += 1
    extnson_siez = extensions[i]
    devices_left -= extnson_siez
    extnson_used += 1
    n_extnson -= 1
    i += 1

if devices_left > 0:
    print(-1)
else:
    print(extnson_used)
",O(nlogn)
"import os, sys
from io import BytesIO, IOBase

def main():
    n = rint()
    deg, edges = [0] * n, rints_2d(n - 1)
    if n == 2:
        exit(print(f'Yes\n1\n1 2'))

    for u, v in edges:
        deg[u - 1] += 1
        deg[v - 1] += 1

    ix = deg.index(max(deg))

    if deg[ix] < 3 or deg.count(1) + deg.count(2) == n - 1:
        print(f'Yes\n{deg.count(1)}')

        for i in range(n):
            if deg[i] == 1:
                print(i + 1, ix + 1)
    else:
        print('No')

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [rstr() for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",O(n)
"import collections

n = int(input())
a = [0, 0] + list(map(int, input().split()))

G = collections.defaultdict(list)
for i in range(2, len(a)):
    G[a[i]].append(i)

nodes = []
q = collections.deque([1])
while q:
    node = q.popleft()
    nodes.append(node)
    for v in G[node]:
        q.append(v)

nodes.reverse()

dp = {}
for u in nodes:
    count = 0
    if len(G[u]) == 0: count += 1
    for v in G[u]:
        count += dp[v]
    dp[u] = count

res = sorted(dp.values())
print(' '.join(map(str, res)))
",O(nlogn)
"def s(k):
	if k % 2 == 0:
		return k // 2
	else:
		return - (k + 1) // 2

for i in range(int(input())):
	l, r = map(int, input().split())
	print(s(r) - s(l - 1))
",O(1)
"z,zz=input,lambda:list(map(int,z().split()))
fast=lambda:stdin.readline().strip()
zzz=lambda:[int(i) for i in fast().split()]
szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())
from string import *
from re import *
from collections import *
from queue import *
from sys import *
from collections import *
from math import *
from heapq import *
from itertools import *
from bisect import *
from collections import Counter as cc
from math import factorial as f
from bisect import bisect as bs
from bisect import bisect_left as bsl
from itertools import accumulate as ac
def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))
def prime(x):
    p=ceil(x**.5)+1
    for i in range(2,p):
        if (x%i==0 and x!=2) or x==0:return 0
    return 1
def dfs(u,visit,graph):
    visit[u]=1
    for i in graph[u]:
        if not visit[i]:
            dfs(i,visit,graph)
def output(answer):
    stdout.write(str(answer))

num=int(z())

arr=zzz()

new_arr=[(i,j+1) for j,i in enumerate(arr)]
new_arr=sorted(new_arr)

passenger=fast()

que=deque()

ans=[0]*2*num

left=0
right=num-1
le=0

for i in range(2*num):
    if passenger[i]=='0':
        ans[i]=new_arr[left][1]
        que.append(new_arr[left][1])
        left+=1
        le+=1

    else:
        if le>=1:
            ans[i]=que[-1]
            que.pop()
            le-=1
        else:
            ans[i]=new_arr[right][1]
            que.append(new_arr[right][1])
            right-=1
            le+=1
print(*ans)
",O(nlogn)
"class Solution(object):
    def longestUnivaluePath(self, root):
        result = [0]
        def dfs(node):
            if not node:
                return 0
            left, right = dfs(node.left), dfs(node.right)
            left = (left+1) if node.left and node.left.val == node.val else 0
            right = (right+1) if node.right and node.right.val == node.val else 0
            result[0] = max(result[0], left+right)
            return max(left, right)

        dfs(root)
        return result[0]",O(n)
"from math import factorial
a = input()
b = input()
plus, minus, ques = '+', '-', '?'
ops1 = {plus:0, minus:0}
ops2 = {plus:0, minus:0, ques:0}
for ai,bi in zip(a,b):
    ops1[ai] += 1
    ops2[bi] += 1
final_pos = ops1[plus]-ops1[minus]
initial_pos = ops2[plus]-ops2[minus]
diff = final_pos-initial_pos
abs_diff = abs(diff)
if abs_diff > ops2[ques]:
    print(0.0)
elif (ops2[ques]-abs_diff) % 2 != 0:
    print(0.0)
else:
    total = 2**(ops2[ques])
    one_type = (ops2[ques]-abs_diff) // 2
    other_type = abs_diff + one_type
    numerator = factorial(ops2[ques])/(factorial(one_type)*factorial(other_type))
    print(numerator/total)",np
"import sys
input = sys.stdin.readline

max_val = 0
n, m = [int(item) for item in input().split()]
array = []
for i in range(n):
    line = [int(item) for item in input().split()]
    array.append(line)
    max_val = max(max_val, max(line))

good = (1 << m) - 1
l = 0; r = max_val + 1
a = 0; b = 0
while r - l > 1:
    mid = (l + r) // 2
    bit_array = dict()
    for k, line in enumerate(array):
        val = 0
        for i, item in enumerate(line):
            if item >= mid:
                val |= 1 << i
        bit_array[val] = k
    ok = False
    for key1 in bit_array.keys():
        for key2 in bit_array.keys():
            if key1 | key2 == good:
                ok = True
                i = bit_array[key1]
                j = bit_array[key2]
                break
    if ok:
        a = i; b = j
        l = mid
    else:
        r = mid
print(a+1, b+1)",np
"from sys import stdin

n, m = map(int, stdin.readline().split())
ans, p, all = [], [1 << i for i in range(n - 2, -1, -1)] + [1], set(range(1, n + 1))
num, cur, i = 1, 0, 0

while i < len(p) and m > 0 and num <= n:
    cur += p[i]
    if cur >= m:
        m -= (cur - p[i])
        cur = 0
        ans.append(num)
        all.discard(num)
    num += 1
    i += 1

print(' '.join(map(str, ans + sorted(all)[::-1])))
",np
"class Solution2(object):
    def maxOutput(self, n, edges, price):
        def dfs(u, p):
            dp = [price[u], 0] 
            for v in adj[u]:
                if v == p:
                    continue
                new_dp = dfs(v, u)
                result[0] = max(result[0], dp[0]+new_dp[1], dp[1]+new_dp[0])
                dp[0] = max(dp[0], new_dp[0]+price[u])
                dp[1] = max(dp[1], new_dp[1]+price[u])
            return dp
        
        result = [0]
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dfs(0, -1)
        return result[0]",O(n)
"n = int(input())
s = input()
b = 0
for i in s:
    if i == '+':
        b += 1
    else:
        b -= 1
        b = max(b, 0)
print(b)",O(n)
"n, m, k = map(int, input().split(' '))
p = tuple(map(int, input().split(' ')))

d = 0
part = (p[0]-1) // k
moves = 0
skip = 0

for pi in p:
    if (pi-1-d) // k == part:
        skip += 1
        continue
    d += skip
    part = (pi-1-d) // k
    skip = 1
    moves += 1

print(moves+1)
",O(n)
"import bisect



class Solution(object):
    def longestObstacleCourseAtEachPosition(self, obstacles):
        result, stk = [], []
        for x in obstacles:
            i = bisect.bisect_right(stk, x)
            result.append(i+1)
            if i == len(stk):
                stk.append(0)
            stk[i] = x
        return result
class SegmentTree(object): 
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=lambda x, y: y if x is None else max(x, y), 
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h): 
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1: 
                self.__apply(L, h) 
                L += 1
            if R & 1 == 0: 
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R): 
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = None
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1: 
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0: 
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return "","".join(map(str, showList))",O(nlogn)
"class Solution2(object):
    def prisonAfterNDays(self, cells, N):
        cells = tuple(cells)
        lookup = {}
        while N:
            lookup[cells] = N
            N -= 1
            cells = tuple([0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in range(1, 7)] + [0])
            if cells in lookup:
                assert(lookup[cells] - N in (1, 7, 14))
                N %= lookup[cells] - N
                break

        while N:
            N -= 1
            cells = tuple([0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in range(1, 7)] + [0])
        return list(cells)",O(1)
"def suma_o_resta(a, b):
	return (a & (1<<b))

def diferencia(s1, d):
	if s1:
		s1.sort()

		if s1[-1] - s1[0] >= d:

			return s1
		else:
			return diferencia(s1.remove(s1[-1]), d)
	return s1

def no_sets(v, n, l, r, d):
	s = []
	cont = 0
	for x in range(1<<n):
		for i in range(n):

			if suma_o_resta(x, i) > 0:

				s.append(v[i])
		s = diferencia(s, d)
		if s:
			if sum(s) >= l and sum(s) <= r:
				cont += 1
		s = []
	return cont;

n, l, r, x = map(int, input().split())

v = list(map(int, input().split()))

print(str(no_sets(v, n, l, r, x)))
",np
"n, k = [int(x) for x in input().split()]
if k == 1:
    print(""1"" + ""0""*(n-1))
else:
    tmp = ""0"" * ((n-k)//2) + ""1""
    s = tmp
    s = tmp * (n // len(tmp) + 1)
    s = s[:n]
    print(s)",O(1)
"n, m = map(int, input().split())
a = [list(map(int, input())) for i in range(n)]

ignorable = [True] * n

for i in range(m):
    cnt = 0
    for j in range(n):
        cnt += a[j][i]
    if cnt == 1:
        for j in range(n):
            if a[j][i]:
                ignorable[j] = False

if any(ignorable):
    print('YES')
else:
    print('NO')
",O(n ^ 2)
"class Solution(object):
    def kEmptySlots(self, flowers, k):
        days = [0] * len(flowers)
        for i in range(len(flowers)):
            days[flowers[i]-1] = i
        result = float(""inf"")
        i, left, right = 0, 0, k+1
        while right < len(days):
            if days[i] < days[left] or days[i] <= days[right]:
                if i == right:
                    result = min(result, max(days[left], days[right]))
                left, right = i, k+1+i
            i += 1
        return -1 if result == float(""inf"") else result+1",O(n)
"n, v = map(int, input().split())
if n - 1 > v:
    print(v + (n - v + 2) * (n - v - 1) // 2)
else:
    print(n - 1)",O(1)
"
import collections


class Solution(object):
    def maxNumberOfBalloons(self, text):
        TARGET = ""balloon""
        source_count = collections.Counter(text)
        target_count = collections.Counter(TARGET)
        return min(source_count[c]//target_count[c] for c in target_count.keys())
",O(n)
"class Solution(object):
    def findMaximumLength(self, nums):
        dp = prefix = left = 0
        stk = [(0, 0, 0)]
        for right in range(len(nums)):
            prefix += nums[right]
            while left+1 < len(stk) and stk[left+1][0] <= prefix:
                left += 1
            last, dp = prefix-stk[left][1], stk[left][2]+1
            while stk and stk[-1][0] >= last+prefix:
                stk.pop()
            stk.append((last+prefix, prefix, dp))
            left = min(left, len(stk)-1)
        return dp",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def maxPathSum(self, root):
        def iter_dfs(node):
            result = float(""-inf"")
            max_sum = [0]
            stk = [(1, [node, max_sum])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, [node, ret1, ret2, ret]))
                    stk.append((1, [node.right, ret2]))
                    stk.append((1, [node.left, ret1]))
                elif step == 2:
                    node, ret1, ret2, ret = params
                    result = max(result, node.val+max(ret1[0], 0)+max(ret2[0], 0))
                    ret[0] = node.val+max(ret1[0], ret2[0], 0)
            return result
        
        return iter_dfs(root)",O(n)
"import math
import sys

DEBUG = False

def inp():
    return sys.stdin.readline().rstrip()

def dprint(*value, sep=' ', end='\n'):
    if DEBUG:
        print(*value, sep=sep, end=end)

def solve(N, M, A):
    A.sort(reverse=True)

    lh = A[0]
    cnt = 1
    for a in A[1:]:
        if lh == 1:
            cnt += 1
        elif lh - 1 <= a:
            cnt += 1
            lh -= 1
        else:
            cnt += lh - a
            lh = a

    cnt += lh - 1

    return sum(A) - cnt

def main():
    N, M = [int(e) for e in inp().split()]
    A = [int(e) for e in inp().split()]
    assert len(A) == N
    print(solve(N, M, A))

if __name__ == '__main__':
    main()
",O(nlogn)
"MOD = 10 ** 9 + 7

x, k = map(int, input().split())
print(((2 * x - 1) * pow(2, k, MOD) + 1) % MOD if x else 0)
",O(logn)
"class Solution(object):
    def findDelayedArrivalTime(self, arrivalTime, delayedTime):
        return (arrivalTime + delayedTime)%24",O(1)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import gcd, ceil

def prod(a, mod=10**9+7):
    ans = 1
    for each in a:
        ans = (ans * each) % mod
    return ans

def lcm(a, b): return a * b // gcd(a, b)

def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

for _ in range(int(input()) if not True else 1):
    n = int(input())

    a = list(map(int, input().split()))

    mod =  10**9 + 7
    twopow = [1]*(10**5+69)
    for i in range(1, 10**5+69):
        twopow[i] = (twopow[i-1] * 2) % mod
    count = [0]*100069
    for i in a:
        count[i] += 1
    multiples = [0]*100069
    for i in range(1, 10**5+1):
        for j in range(i, 10**5+1, i):
            multiples[i] += count[j]
    gcd_of = [0]*100069
    for i in range(10**5, 0, -1):
        gcd_of[i] = (twopow[multiples[i]] - 1) % mod
        for j in range(2*i, 10**5+1, i):
            gcd_of[i] -= gcd_of[j]
    print(gcd_of[1] % mod)",np
"import math
a=input()
b=input()
i=a.count('+')
j=a.count('-')
k=b.count('+')
l=b.count('-')
m=b.count('?')
c1=(i-j)
c2=(k-l)
c=abs(c1-c2)
w=m-c
x=w//2
y=w//2+c
if(c==0 and m==0):
    print(1)
elif((c)>m):
    print(0)
else:
    x=math.factorial(m)//(math.factorial(x)*math.factorial(y))
    print(x/pow(2,m))
",np
"n, k = map(int, input().split())
li = [int(num) for num in input().split("" "", n - 1)]
ans = []
for i in range(0, n):
    su = 0
    for j in range(i, n):
        su += li[j]
        if (j - i + 1 >= k):
            ans.append(su / (j - i + 1))
print(max(ans))",O(n ^ 2)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def rightSideView(self, root):
        result = []
        self.rightSideViewDFS(root, 1, result)
        return result

    def rightSideViewDFS(self, node, depth, result):
        if not node:
            return

        if depth > len(result):
            result.append(node.val)

        self.rightSideViewDFS(node.right, depth+1, result)
        self.rightSideViewDFS(node.left, depth+1, result)",O(n)
"n=int(input())
arr=list(map(int,input().split()))
arr.sort()
ans=0
mark=0
for i in range(len(arr)-2):
	if(arr[i]==arr[i+1]==arr[i+2]):
		print('cslnb')
		exit(0)
	elif(arr[i+1]==arr[i+2] and arr[i]+1==arr[i+1]):
		print('cslnb')
		exit(0)

countcopy=0
for i in range(len(arr)-1):
	if(arr[i]==arr[i+1] and arr[i]==0):
		print('cslnb')
		exit(0)
	if(arr[i]==arr[i+1]):
		countcopy+=1
if(countcopy>1):
	print('cslnb')
	exit(0)

for i in range(len(arr)):
	if(arr[i]>=mark):
		ans+=(arr[i]-mark)
		mark+=1

if(ans%2==0):
	print('cslnb')
else:
	print('sjfnb')
",O(nlogn)
"n, k = [int(x) for x in input().split()]

ans = """"
while len(ans) < n:
    ans += '1' * ((n - k) // 2) + '0';
ans = ans[:n]
print(ans)",O(n)
"from sys import stdin, stdout

def pair_of_lines(n, xy_a):
    if len(xy_a) <= 3:
        return 'YES'

    p1, p2, p3 = xy_a[0], xy_a[1], xy_a[2]
    if judge(p1, kstr(p1, p2),xy_a):
        return 'YES'
    if judge(p1, kstr(p1, p3),xy_a):
        return 'YES'
    if judge(p2, kstr(p2, p3), xy_a):
        return 'YES'
    return 'NO'

def kstr(xy1, xy2):
    cx, cy = xy1[0], xy1[1]
    x, y = xy2[0], xy2[1]
    dx = x - cx
    dy = y - cy
    k = ''
    if dx == 0:
        k = str(x) + '/y'
    elif dy == 0:
        k = 'x/' + str(y)
    else:
        g = gcd(dx, dy)
        dx //= g
        dy //= g
        k = str(dx) + '/' + str(dy)
    return k

def judge(p, k, xy_a):

    rl = []
    for xy in xy_a:
        if p[0] == xy[0] and p[1] == xy[1]:
            continue
        if kstr(p, xy) != k:
            rl.append(xy)

    if len(rl) > 2:
        ck = kstr(rl[0], rl[1])
        for i in range(2, len(rl)):
            if ck != kstr(rl[0], rl[i]):
                return False

    return True

def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)

try:
    n = int(stdin.readline())
    xy_a = []
    for _ in range(n):
        xy_a.append(list(map(int, stdin.readline().split())))
    res = pair_of_lines(n, xy_a)
    stdout.write(res)
except Exception as e:
  print(e)
",O(nlogn)
"def main():
    input()
    acc = {0: 0}
    for p, c in zip(list(map(int, input().split())),
                    list(map(int, input().split()))):
        adds = []
        for b, u in acc.items():
            a = p
            while b:
                a, b = b, a % b
            adds.append((a, u + c))
        for a, u in adds:
            acc[a] = min(u, acc.get(a, 1000000000))
    print(acc.get(1, -1))

if __name__ == '__main__':
    main()
",np
"import os, sys
from io import BytesIO, IOBase

def bit_count(x):
    ans = 0
    while x:
        x &= x - 1
        ans += 1
    return ans

def main():
    n = input().strip()
    x = len(n)
    k = int(input())
    if n == '1':
        print(int(k == 0))
        exit()
    if not k:
        print(1)
        exit()
    mod = 10 ** 9 + 7
    dp = [0] * (x + 1)
    dp[1] = 1
    for i in range(2, x + 1):
        dp[i] = dp[bit_count(i)] + 1
    dp1 = [[0] * (x + 1) for _ in range(x + 1)]

    for i in range(x + 1):
        dp1[i][0] = 1
    for i in range(1, x + 1):
        for j in range(1, i + 1):
            dp1[i][j] = (dp1[i - 1][j - 1] + dp1[i - 1][j]) % mod
    ans = 0
    cou = n.count('1')
    for i in range(1, x + 1):
        if dp[i] != k:
            continue
        se = i
        for j in range(x):
            if n[j] == '0':
                continue
            ans = (ans + dp1[x - 1 - j][se] - (se == 1 and k == 1)) % mod
            se -= 1
            if se < 0:
                break
        if cou == i:
            ans = (ans + 1) % mod
    print(ans)
main()",O(n)
"n, m = map(int, input().split())

a = []

def is_center(a, y, x):
    count1 = count2 = count3 = count4 = 0

    y1 = y
    x1 = x
    while True:
        y2 = y1 - 1
        if y2 < 0:
            break
        c = a[y2][x]
        if c == ""W"":
            break
        count1 += 1
        y1 = y2

    y1 = y
    x1 = x
    while True:
        y2 = y1 + 1
        if y2 == n:
            break
        c = a[y2][x]
        if c == ""W"":
            break
        count2 += 1
        y1 = y2

    y1 = y
    x1 = x
    while True:
        x2 = x1 - 1
        if x2 < 0:
            break
        c = a[y1][x2]
        if c == ""W"":
            break
        count3 += 1
        x1 = x2

    y1 = y
    x1 = x
    while True:
        x2 = x1 + 1
        if x2 == m:
            break
        c = a[y1][x2]
        if c == ""W"":
            break
        count4 += 1
        x1 = x2

    return count1 == count2 == count3 == count4 and a[y][x] == ""B""

for k in range(n):
    s = input()
    a.append(s)

for y in range(n):
    c = False
    for x in range(m):
        if is_center(a, y, x):
            print(y+1, x+1)
            c = True
            break
    if c:
        break
",O(n ^ 2)
"x,k=map(int,input().split())
mod=1000000007
print((pow(2,k+1,mod)*x-pow(2,k,mod)+1)%mod if x>0 else 0)",O(logn)
"inputS=input()
ans=0

for i in range (0,len(inputS)-1):
    for count in range(1,len(inputS)):
        for j in range(i+1, len(inputS)-count+1):
            A=inputS[i: i+count]
            B=inputS[j: j+count]
            if A==B:
                ans=count if count>ans else ans

print(ans)",O(n ^ 3)
"class Solution(object):
    def minRemoveToMakeValid(self, s):
        result = list(s)
        count = 0
        for i, v in enumerate(result):
            if v == '(':
                count += 1
            elif v == ')':
                if count:
                    count -= 1
                else:
                    result[i] = """"
        if count:
            for i in reversed(range(len(result))):
                if result[i] == '(':
                    result[i] = """"
                    count -= 1
                    if not count:
                        break
        return """".join(result)",O(n)
"class Solution2(object):
    def maxProduct(self, A):
        global_max, local_max, local_min = float(""-inf""), 1, 1
        for x in A:
            local_max = max(1, local_max)
            if x > 0:
                local_max, local_min = local_max * x, local_min * x
            else:
                local_max, local_min = local_min * x, local_max * x
            global_max = max(global_max, local_max)
        return global_max",O(n)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

prime = [True for i in range(200001)]
pp=[0]*200001
def SieveOfEratosthenes(n=200000):

    p = 2
    while (p * p <= n):

        if (prime[p] == True):

            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1

n=int(input())
a=list(map(int,input().split()))
if n==1:
    print(1)
    sys.exit(0)
dp=[[-1 for j in range (5)] for i in range (n)]
for i in range (1,min(2,n)):
    if a[i]<a[i-1]:
        for j in range (5):
            ch=-1
            for k in range (5):
                if k>j:
                    ch=k
            dp[i][j]=ch
    elif a[i]>a[i-1]:
        for j in range (5):
            ch=-1
            for k in range (5):
                if k<j:
                    ch=k
            dp[i][j]=ch
    else:
        for j in range (5):
            ch=-1
            for k in range (5):
                if k!=j:
                    ch=k
            dp[i][j]=ch
for i in range (2,n):
    if a[i]<a[i-1]:
        for j in range (5):
            ch=-1
            for k in range (5):
                if k>j and dp[i-1][k]!=-1:
                    ch=k
            dp[i][j]=ch
    elif a[i]>a[i-1]:
        for j in range (5):
            ch=-1
            for k in range (5):
                if k<j and dp[i-1][k]!=-1:
                    ch=k
            dp[i][j]=ch
    else:
        for j in range (5):
            ch=-1
            for k in range (5):
                if k!=j and dp[i-1][k]!=-1:
                    ch=k
            dp[i][j]=ch

ind=-1
for i in range (5):
    if dp[-1][i]!=-1:
        ind=i
if ind==-1:
    print(ind)
    sys.exit(0)
res=[ind+1]
for i in range (n-1,0,-1):
    res.append(dp[i][ind]+1)
    ind=dp[i][ind]
print(*res[::-1])",O(n)
"n=int(input())
x,y=map(int,input().split())
d1=max(x-1,y-1)
d2=max(n-x,n-y)
if d1<=d2:
    print(""White"")
else:
    print(""Black"")",O(1)
"success = 0
def solve(b, freq, i, n, res):
    global success
    if i == len(b):
        success = res
    else:
        success = 0
        move = 9
        while move >= 0 and success == 0:
            m = int(b[i])
            if freq[move] > 0 and res * 10 + move <= n * 10 + m:
                res = res * 10 + move
                n = n * 10 + m
                freq[move] -= 1
                if solve(b, freq, i + 1, n, res) == 0:
                    res //= 10
                    n //= 10
                    freq[move] += 1
            move -= 1
    return success

a = input()
b = input()
freq = []
for i in range(10):
    freq.append(0)
v = []
for x in a:
    n = int(x)
    v.append(n)
    freq[n] += 1
v.sort()
ans = 0
if len(b) > len(a):
    m = 1
    for x in v:
        ans = x * m + ans
        m *= 10
else:
    ans = solve(b, freq, 0, 0, 0)
print(ans)",O(n ^ 3)
"class Solution2(object):
    def minSubArrayLen(self, s, nums):
        min_size = float(""inf"")
        sum_from_start = [n for n in nums]
        for i in range(len(sum_from_start) - 1):
            sum_from_start[i + 1] += sum_from_start[i]
        for i in range(len(sum_from_start)):
            end = self.binarySearch(lambda x, y: x <= y, sum_from_start, \
                                    i, len(sum_from_start), \
                                    sum_from_start[i] - nums[i] + s)
            if end < len(sum_from_start):
                min_size = min(min_size, end - i + 1)

        return min_size if min_size != float(""inf"") else 0

    def binarySearch(self, compare, A, start, end, target):
        while start < end:
            mid = start + (end - start) / 2
            if compare(target, A[mid]):
                end = mid
            else:
                start = mid + 1
        return start",O(nlogn)
"import math

n, m = map(int, input().split())

b = list(map(int, input().split()))
g = list(map(int, input().split()))

first_max = 0
second_max = 0
for i in range(n):
	if b[i] < first_max and b[i] > second_max:
		second_max = b[i]
	if b[i] >= first_max:
		second_max = first_max
		first_max = b[i]

first_min = min(g)

if first_max > first_min:
	print(-1)
else:
	total = sum(b) * m + sum(g) - m * first_max + (first_max - second_max) * (first_min != first_max)
	print(total)
",O(n)
"n=int(input())
print(n//2+1)",O(1)
"class Solution(object):
    def sumOfLeftLeaves(self, root):
        def sumOfLeftLeavesHelper(root, is_left):
            if not root:
                return 0
            if not root.left and not root.right:
                return root.val if is_left else 0
            return sumOfLeftLeavesHelper(root.left, True) + \
                   sumOfLeftLeavesHelper(root.right, False)

        return sumOfLeftLeavesHelper(root, False)",O(n)
"class Solution(object):
    def countDigitOne(self, n):
        DIGIT = 1
        is_zero = int(DIGIT == 0)
        result = is_zero
        base = 1
        while n >= base:
            result += (n//(10*base)-is_zero)*base + \
                      min(base, max(n%(10*base) - DIGIT*base + 1, 0))
            base *= 10
        return result",O(logn)
"import collections


class Solution(object):
    def numIdenticalPairs(self, nums):
        return sum(c*(c-1)//2 for c in collections.Counter(nums).values())",O(n)
"class Solution2(object):
    def printLinkedListInReverse(self, head):
        nodes = []
        while head:
            nodes.append(head)
            head = head.getNext()
        for node in reversed(nodes):
            node.printValue()",O(n)
"def req_num(a, b, x, y, z):
    req_a = (x * 2) + y
    req_b = (z * 3) + y
    if (req_a - a) <= 0:
        ans_a = 0
    else:
        ans_a = req_a - a
    if (req_b - b) <= 0:
        ans_b = 0
    else:
        ans_b = req_b - b
    return ans_a + ans_b

a, b = list(map(int, input().strip().split()))
x, y, z = list(map(int, input().strip().split()))
print(req_num(a, b, x, y, z))
",O(1)
"n,m,k=map(int,input().split())

MOD=1000000009

x=m-(n//k*(k-1)+(n%k))

if (x<=0):exit(print(m%MOD))

print(((m-x)+((pow(2,x+1, MOD)+2*MOD)-2)*k-x*(k-1))%MOD)",O(logn)
"def main():
    n, k = map(int, input().split(' '))

    if(k > 2*n):
        return(0)
    if(k == 2*n or k==1):
        return(2)

    iguales = [0]*(k+1)
    diferentes = [0]*(k+1)

    iguales[1] = 2
    diferentes[2] = 2

    modulo = 998244353

    for i in range(1, n):
        auxigual = [0]*(k+1)
        auxdiff = [0]*(k+1)

        for j in range(1, k+1):
            auxigual[j] = (iguales[j] + iguales[j-1] + 2*diferentes[j]) % modulo

        for k in range(2, k+1):
            auxdiff[k] = (diferentes[k] + diferentes[k-2] + 2*iguales[k-1]) % modulo

        iguales = auxigual
        diferentes = auxdiff

    return((iguales[-1] + diferentes[-1]) % modulo)

print(main())
",np
"class Solution(object):

    def __init__(self, value, k):
        self.__value = value
        self.__k = k
        self.__cnt = 0

    def consec(self, num):
        if num == self.__value:
            self.__cnt += 1
        else:
            self.__cnt = 0
        return self.__cnt >= self.__k",O(1)
"class Solution3(object):
    def minimumPerimeter(self, neededApples):
        def check(neededApples, x):
            return r*(2*r+1)*(2*r+2) >= neededApples

        left, right = 1, int((neededApples/4.0)**(1.0/3))
        while left <= right:
            mid = left + (right-left)//2
            if check(neededApples, mid):
                right = mid-1
            else:
                left = mid+1
        return 8*left",O(logn)
"import os, sys
from io import BytesIO, IOBase

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class dict(dict):
    def __missing__(self, key):
        return 0

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
valid = lambda x, y: -1 < x < n and -1 < y < m
dx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1)

n, m, k = inp(int)
if k & 1:
    [print(*([-1] * m)) for _ in range(n)]
    exit()

right, down = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]
mem = [[[float('inf')] * (k // 2 + 1) for _ in range(m)] for _ in range(n)]

for _ in range(n):
    for i, j in enumerate(inp(int)):
        right[_][i] = j

for _ in range(n - 1):
    for i, j in enumerate(inp(int)):
        down[_][i] = j

for i in range(n):
    for j in range(m):
        mem[i][j][0] = 0

for k1 in range(1, k // 2 + 1):
    for i in range(n):
        for j in range(m):
            ans = []
            if valid(i - 1, j):
                ans.append(mem[i - 1][j][k1 - 1] + down[i - 1][j])
            if valid(i + 1, j):
                ans.append(mem[i + 1][j][k1 - 1] + down[i][j])
            if valid(i, j - 1):
                ans.append(mem[i][j - 1][k1 - 1] + right[i][j - 1])
            if valid(i, j + 1):
                ans.append(mem[i][j + 1][k1 - 1] + right[i][j])

            mem[i][j][k1] = min(ans)

[print(*[mem[i][x][-1] * 2 for x in range(m)]) for i in range(n)]
",O(n ^ 3)
"N, M, K, L = map(int, input().split())
if N < M or K + L > N:
    print(-1)
else:
    print((L + K - 1) // M + 1 if ((L + K - 1) // M + 1) * M <= N else -1)",O(1)
"import sys
input = lambda: sys.stdin.readline().rstrip()

N, K = map(int, input().split())
S = [-1 if a == ""?"" else ord(a) - 97 for a in input()]
II = {1 << i: i for i in range(20)}
def calc(mmm):
    inf = 300000
    X = [[0] * N for _ in range(K)]
    for k in range(K):
        Xk = X[k]
        mi = inf
        r = 0
        for i in range(N)[::-1]:
            if S[i] < 0 or S[i] == k:
                r += 1
            else:
                r = 0
            if r >= mmm:
                mi = min(mi, i + mmm)
            Xk[i] = mi

    Y = [0] * (1 << K)
    for i in range(1, 1 << K):
        mi = inf
        for j in range(K):
            if i >> j & 1:
                ii = i ^ (1 << j)
                if Y[ii] < N:
                    mi = min(mi, X[j][Y[ii]])
        Y[i] = mi
    return 1 if Y[-1] < inf else 0

l, r = 0, N // K + 1
while r - l > 1:
    m = l + r >> 1
    if calc(m):
        l = m
    else:
        r = m
print(l)
",np
"import sys

print('? %d %d' % (0, 0))
sys.stdout.flush()
agtb = int(input())

a, b = 0, 0
ops = 29
for i in range(ops, -1, -1):
    c = a | (1 << i)
    d = b
    print('? %d %d' % (c, d))
    sys.stdout.flush()
    x = int(input())

    c = a
    d = b | (1 << i)
    print('? %d %d' % (c, d))
    sys.stdout.flush()
    y = int(input())

    if x != y:
        if y == 1:
            a = a | (1 << i)
            b = b | (1 << i)
    else:
        if agtb == 1:
            a = a | (1 << i)
        else:
            b = b | (1 << i)
        agtb = x

print('! %d %d' % (a, b))
sys.stdout.flush()",O(logn)
"class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        res = [0] * len(temperatures)
        stack = []

        for i, t in enumerate(temperatures):
            while stack and t > stack[-1][0]:
                stackT, stackInd = stack.pop()
                res[stackInd] = i - stackInd
            stack.append((t, i))
        return res
",O(n)
"n = int(input())
A = list(map(int, input().split()))

dp = [[1 for j in range(5)] for i in range(n)]
Prev = [[-1 for i in range(5)] for i in range(n)]

for i in range(1, n):
    for j in range(5):
        for finger in range(5):
            if dp[i - 1][finger] == 1:
                if (A[i - 1] < A[i] and finger < j) or (A[i - 1] > A[i] and finger > j) or (A[i - 1] == A[i] and finger != j):
                    dp[i][j] = 1
                    Prev[i][j] = finger
                    break
        else:
            dp[i][j] = 0
finger = 0
for j in range(5):
    if dp[-1][j] == 1:
        finger = j
        path = [finger]
        for i in range(n - 1, 0, -1):
            finger = Prev[i][finger]
            path.append(finger)
        path = path[::-1]
        for i in range(n):
            print(path[i] + 1, end=' ')
        break
else:
    print(-1)
",O(n ^ 2)
"n = int(input())
limit_int = limit = decimal = 9
count = 0
while True:
    count += 1
    if n <= limit:
        difference = limit - n
        position = difference % count
        difference = difference // count
        difference = decimal - difference
        print(''.join(list(reversed(str(difference))))[position])
        break
    else:
        decimal = int(str(limit_int) * (count + 1))
        limit += int(str(limit_int) + '0' * count) * (count + 1)
",O(logn)
"n, m = map(int, input().split())
m += 1

def calc(l, r, eq, eq_i):
    if l > r:
        return 1
    key = l, eq, eq_i
    if key in f:
        return f[key]

    t = 0
    for x in (['0', '1'] if s[l] == '?' else [s[l]]):
        if l == r:
            a = [x]
        else:
            a = ['0', '1'] if s[r] == '?' else [s[r]]
        for y in a:
            if not((eq and x > y) or (eq_i and x == y == '1')):
                t += calc(l + 1, r - 1, eq and x == y, eq_i and x != y)
    f[key] = t
    return t

s = ['?'] * n
for i in range(n):
    s[i] = '0'
    f = {}
    p = calc(0, n - 1, True, True)
    if m > p:
        m -= p
        s[i] = '1'

if s[0] == '0':
    print(''.join(s))
else:
    print(-1)
",O(n ^ 3)
"import sys,math
from collections import deque,defaultdict
import operator as op
from functools import reduce

I=sys.stdin.readline

def ii():
	return int(I().strip())
def li():
	return list(map(int,I().strip().split()))
def mi():
	return map(int,I().strip().split())

def ncr(n, r, p):

    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
            p - 2, p)) % p

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def valid(row,col,rows,cols,rcross,lcross):
 	return rows[row]==0 and cols[col]==0 and rcross[col+row]==0 and lcross[col-row]==0

def div(n):
	tmp=[]
	for i in range(2,int(n**.5)+1):
		if n%i==0:
			cnt=0
			while(n%i==0):
				n=n//i
				cnt+=1
			tmp.append((i,cnt))
	if n>1:
		tmp.append((n,1))
	return tmp

def isPrime(n):
	if n<=1:
		return False
	elif n<=2:
		return True
	else:
		flag=True
		for i in range(2,int(n**.5)+1):
			if n%i==0:
				flag=False
				break
		return flag

def s(b):
	ans=[]
	while b>0:
		tmp=b%10
		ans.append(tmp)
		b=b//10
	return ans

def main():
	n=ii()
	print(n,0,0)

if __name__ == '__main__':
	main()",O(1)
"a, b, c, n = map(int, input().split())
result = n - a - b + c
print(result if result > 0 and c <= a and c <= b else -1)",O(1)
"n, p = map(int, input().split())
list1 = list(map(int, input().split()))
mx = 0
curr = 0
nxt = sum(list1)
for i in range(n - 1):
    curr += list1[i]
    nxt -= list1[i]
    mx = max(mx, curr % p + nxt % p)
print(mx)",O(n)
"class Solution(object):
    def getLastMoment(self, n, left, right):
        return max(max(left or [0]), n-min(right or [n]))",O(n)
"class Solution2(object):
    def firstPalindrome(self, words):
        return next((x for x in words if x == x[::-1]), """")",O(n)
"class Solution(object):
    def balancedStringSplit(self, s):
        result, count = 0, 0      
        for c in s:
            count += 1 if c == 'L' else -1            
            if count == 0:
                result += 1
        return result",O(n)
"from sys import stdin, stdout
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))

for _ in range(1):
    n,m=lst()
    a=lst()
    a=[0]+a+[m]
    n=len(a)
    suf=[0]*n
    suf[n-2]=abs(a[-2]-a[-1])
    for i in range(n-3, -1, -1):
        suf[i]=a[i+1]-a[i]+suf[i+2]
    ans=suf[0]
    cost=0
    for i in range(1, n):
        if i&1:
            v=a[i]-1-a[i-1]
            if v!=0:ans=max(ans, cost+v+suf[i])
            cost+=a[i]-a[i-1]
        else:
            v=a[i-1]+1
            if v!=a[i]:ans=max(ans, cost+a[i]-v+(suf[i+1] if i+1<n else 0))
    print(ans)",O(n)
"import collections
from functools import reduce



class Solution(object):
    def getSum(self, nums):
        def count(d):
            result = 0
            cnt = collections.defaultdict(int)
            prefix = collections.defaultdict(int)
            for x in nums:
                c = (cnt[x-d]+1)%MOD
                cnt[x] = (cnt[x]+c)%MOD
                total = (prefix[x-d]+x*c)%MOD
                prefix[x] = (prefix[x]+total)%MOD
                result = (result+total)%MOD
            return result
    
        MOD = 10**9+7
        return (count(+1)+count(-1)-reduce(lambda accu, x: (accu+x)%MOD, nums, 0))%MOD",O(n)
"cadena = input()
n = len(cadena)

rpta = 0

for i in range(n-1):
    tamanho_cadena = n-i-1
    for j in range(n-tamanho_cadena):
        subcadena = cadena[j:j+tamanho_cadena]
        contador = 1
        for k in range(n-tamanho_cadena-j):
            if subcadena == cadena[j+k+1:j+k+1+tamanho_cadena]:
                contador = contador + 1
        if contador >=2  and rpta == 0:
            rpta = tamanho_cadena
    if rpta !=0:
        break

print(rpta)",O(n ^ 3)
"from sys import stdin

def main():
    n = int(input())
    aa = list(map(int, input().split()))
    dp = [aa]
    for i in range(n - 1, 0, -1):
        aa = aa[:]
        for j in range(i):
            aa[j] ^= aa[j + 1]
        del aa[-1]
        dp.append(aa)
    aa = dp[0]
    for i, bb in enumerate(dp[1:], 1):
        a = aa[0]
        for j, b in enumerate(bb):
            c = aa[j + 1]
            bb[j] = max(a, b, c)
            a = c
        aa = bb
    input()
    res = stdin.read().splitlines()
    for i, s in enumerate(res):
        lo, hi = map(int, s.split())
        res[i] = str(dp[hi - lo][lo - 1])
    print('\n'.join(res))

if __name__ == '__main__':
    main()
",O(n ^ 2)
"print(""?"",0,0)
e=int(input())
astr=""000000000000000000000000000000""
bstr=""000000000000000000000000000000""
abig=e
for i in range(30):
    if abig==0:
        print(""?"",int(astr,2)+2**(29-i),int(bstr,2))
        e=int(input())
        if e==1:
            continue
        else:
            if i<29:
                astr=astr[:i]+""1""+astr[i+1:]
                bstr=bstr[:i]+""1""+bstr[i+1:]
            else:
                astr=astr[:i]+""1""
                bstr=bstr[:i]+""1""
    else:
        print(""?"",int(astr,2)+2**(29-i),int(bstr,2)+2**(29-i))
        e=int(input())
        if e==-abig:
            if abig==1:
                if i<29:
                    astr=astr[:i]+""1""+astr[i+1:]
                else:
                    astr=astr[:i]+""1""
            else:
                if i<29:
                    bstr=bstr[:i]+""1""+bstr[i+1:]
                else:
                    bstr=bstr[:i]+""1""
            print(""?"",int(astr,2),int(bstr,2))
            abig=int(input())
        else:
            print(""?"",int(astr,2)+2**(29-i),int(bstr,2))
            e=int(input())
            if e==-1:
                if i<29:
                    astr=astr[:i]+""1""+astr[i+1:]
                    bstr=bstr[:i]+""1""+bstr[i+1:]
                else:
                    astr=astr[:i]+""1""
                    bstr=bstr[:i]+""1""
print(""!"",int(astr,2),int(bstr,2))",O(logn)
"x, y, z, t1, t2, t3 = map(int, input().split())
a=abs(x-y)*t1
b=abs(x-z)*t2+abs(x-y)*t2+3*t3
if b<=a:print(""YES"")
else:print(""NO"")",O(1)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        pass



class Solution(object):
    def mergeNodes(self, head):
        curr, zero = head.__next__, head
        while curr:
            if curr.val:
                zero.val += curr.val
            else:
                zero.next = curr if curr.__next__ else None
                zero = curr
            curr = curr.__next__
        return head",O(n)
"n,k = map(int, input().split())
arr = list(map(int, input().split()))
arr.sort()
c = n
j=0
for x in arr:
    while(x>arr[j]):
        if(x-arr[j]<=k):c-=1
        j+=1

print(c)
",O(nlogn)
"import math
import sys
import collections

def getdict(n):
    d = {}
    if type(n) is list:
        for i in n:
            if i in d:
                d[i] += 1
            else:
                d[i] = 1
    else:
        for i in range(n):
            t = ii()
            if t in d:
                d[t] += 1
            else:
                d[t] = 1
    return d
def cdiv(n, k): return n // k + (n % k != 0)
def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return list(map(int, input().split()))

t = ii()
for i in range(t):
    n = ii()
    d = sorted(li())
    print(min(d[-2] - 1, n - 2))
",O(nlogn)
"def find(u):
    global par
    if u != par[u]:
        par[u] = find(par[u])
    return par[u]

def union(u, v):
    u = find(u)
    v = find(v)
    par[u] = v

n, a, b = map(int, input().split())
p = list(map(int, input().split()))
mp = dict()
for i in range(n):
    mp[p[i]] = i + 1
par = [i for i in range(n + 2)]

for i in range(n):
    union(i + 1, mp.get(a - p[i], n + 1))
    union(i + 1, mp.get(b - p[i], 0))

A = find(0)
B = find(n + 1)

if A != B:
    print('YES')
    print(' '.join(['1' if find(i) == B else '0' for i in range(1, n + 1)]))
else:
    print('NO')",O(n)
"n,m,k=map(int,input().split())
x=list(map(int,input().split()))
x.sort(reverse=True)
i=-1
if k>=m:
    print(0)
else:
    for i in range(n):
        k-=1
        k+=x[i]
        if k>=m:
            break
    if k>=m:
        print(i+1)
    else:print(-1)",O(nlogn)
"class Solution(object):
    def sumGame(self, num):
        cnt = total = 0
        for i in range(len(num)):
            if num[i] == '?':
                cnt += (-1 if i < len(num)//2 else 1)
            else:
                total += (int(num[i]) if i < len(num)//2 else -int(num[i]))
        return True if cnt%2 else total != cnt//2*9",O(n)
"n,k = input().split()
n,k = int(n),int(k)

ini,fin = 1,k-1
if n == 1:
	print(""0"")
	exit(0)

if 1 + (k*(k-1) )//2 < n:
	print(""-1"")
	exit(0)

while ini < fin:
	mid = (ini+fin)//2
	s = 1 + (k-1)*mid - (mid*(mid-1))//2
	if s>=n:
		fin = mid
	else:
		ini = mid+1

print(ini)",O(logn)
"class Solution(object):
    def shortestDistance(self, words, word1, word2):
        dist = float(""inf"")
        i, index1, index2 = 0, None, None
        while i < len(words):
            if words[i] == word1:
                index1 = i
            elif words[i] == word2:
                index2 = i

            if index1 is not None and index2 is not None:
                dist = min(dist, abs(index1 - index2))
            i += 1

        return dist",O(n)
"n,m=map(int,input().split())
lst=list(map(int,input().split()))
arr=lst.copy()
arr.sort(reverse=True)
vis=[0]*n
summ=0
for i in range(m):
    temp=arr[i]
    summ+=temp
    for j in range(n):
        if vis[j]==0 and lst[j]==temp:
            vis[j]=1

            break

print(summ)
cnt=0
ans=[]
for i in range(n):
    if vis[i]==1:
        ans.append(cnt+1)
        cnt=0
    else:
        cnt+=1
ans[-1]+=cnt
print(*ans)",O(nlogn)
"class Solution(object):
    def countGoodTriplets(self, arr, a, b, c):
        return sum(abs(arr[i]-arr[j]) <= a and
                   abs(arr[j]-arr[k]) <= b and
                   abs(arr[k]-arr[i]) <= c 
                   for i in range(len(arr)-2)
                       for j in range(i+1, len(arr)-1)
                           for k in range(j+1, len(arr)))",O(n ^ 3)
"import sys
def read():
    return int(input())
def reads():
    return [int(x) for x in input().split()]
N,M=reads()
table=[reads() for i in range(N)]
A=[[0]*N for i in range(N)]
B=[[0]*N for i in range(N)]
for i in range(N):
    for j in range(N):
        res=10**9+7
        for k in range(M):
            res=min(res,abs(table[i][k]-table[j][k]))
        A[i][j]=res
        A[j][i]=res
        res=10**9+7
        for k in range(M-1):
            res=min(res,abs(table[i][k]-table[j][k+1]))
        B[i][j]=res

dp=[[-1]*N for i in range((1<<N) )]
def calc(mask,v):
    if dp[mask][v]!=-1:
        return dp[mask][v]
    res =0
    for u in range(N):
        if (mask & 1<<u) and u!=v:
            res =max(res,min(calc(mask^(1<<v),u),A[u][v]))
    dp[mask][v]=res
    return dp[mask][v]
ans=0
for i in range(N):
    dp = [[-1] * N for _ in range((1 << N))]
    for k in range(N):
        if k==i:
            dp[1<<k][k]=10**9+7
        else:
            dp[1<<k][k]=0
    for j in range(N):
        ans=max(ans,min(B[j][i],calc((1<<N)-1,j)))
print(ans)",np
"import os, sys
from io import BytesIO, IOBase
from copy import deepcopy

def main():
    n = rint()
    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []
    for i in range(4):
        ans.extend([a1.rotate(), a1.fliph()])
        a1.fliph()
    print(['No', 'Yes'][a2.mat in ans])

class Matrix:
    def __init__(self, r, c, mat=None, id=None):
        self.r, self.c = r, c

        if mat != None:
            self.mat = deepcopy(mat)
        else:
            self.mat = [[0 for i in range(c)] for j in range(r)]

    def rotate(self):
        mat0 = Matrix(self.c, self.r)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]

        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r
        return self.mat

    def flipv(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def fliph(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [list(rstr()) for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",O(n ^ 2)
"n = int(input())
a = list(map(int, input().split()))
mx = -1
for step, elem in enumerate(a):
    if elem > mx + 1:
        print(step + 1)
        exit(0)
    else:
        mx = max(mx, elem)
print(-1)
",O(n)
"import sys
input = sys.stdin.readline
def multi_input():
    return map(int, input().split())

def sum(n,r):
    return n*(2*r - (n-1))//2

def function(total, l, r):
    left = l
    right = r

    while left<=right:
        mid = (right + left) // 2
        result = sum(r-mid+1, r)
        if result==total:
            return r-mid+1
        elif result > total:
            left = mid + 1
        else:
            if sum(r-mid+2,r) > total:
                return r-mid + 2
            else:
                right = mid - 1
    return -1

n, m = multi_input()

n = n-1
m = m-1
if n==0:
    print(0)
elif sum(m,m)<n:
    print(-1)
elif m<n:
    print(function(n, 1, m))
else:
    print(1)
",O(logn)
"import bisect
n,q=map(int,input().split())
strength=list(map(int,input().split()))
arrows=list(map(int,input().split()))
for i in range(1,n):
    strength[i]+=strength[i-1]
No_arrows=0
n-=1
for i in range(q):
    No_arrows+=arrows[i]
    if(No_arrows>=strength[-1]):
        No_arrows=0
        print(n+1)
    else:
        it=bisect.bisect_left(strength,No_arrows)
        if(strength[it]==No_arrows):
            print(n-it)
        else:
            print(n-it+1)
",O(nlogn)
"x,k = map(int,input().split())
if(x==0):
    print(0)
    exit(0)
m = 10**9+7
p = pow(2,k+1,m)
q = pow(2,k,m)
a = (x*p-q+1)%m
print(a)
",O(logn)
"I = lambda: map(int, input().split())

n, l, r, x = I()
C, k = [*I()], 0

for i in range(2 ** n):
    W = [w for w, b in zip(C, bin(i)[2:].zfill(n)) if b == '1']
    if l <= sum(W) <= r and max(W) - min(W) >= x:
        k += 1

print(k)",np
"n, s = int(input()), input() * 2
h = s.count('H') // 2
print(h - max(s[i:i + h].count('H') for i in range(n)))",O(n)
"class ArrayReader(object):
    def query(self, a, b, c, d):
        pass

    def length(self):
        pass
    

class Solution(object):
    def guessMajority(self, reader):
        count_a, count_b, idx_b = 1, 0, None
        value_0_1_2_3 = reader.query(0, 1, 2, 3)
        for i in reversed(range(4, reader.length())):
            value_0_1_2_i = reader.query(0, 1, 2, i)
            if value_0_1_2_i == value_0_1_2_3: 
                count_a = count_a+1
            else:
                count_b, idx_b = count_b+1, i
        value_0_1_2_4 = value_0_1_2_i
        for i in range(3):
            value_a_b_3_4 = reader.query(*[v for v in [0, 1, 2, 3, 4] if v != i])
            if value_a_b_3_4 == value_0_1_2_4: 
                count_a = count_a+1
            else:
                count_b, idx_b = count_b+1, i
        if count_a == count_b:
            return -1
        return 3 if count_a > count_b else idx_b",O(n)
"class Solution(object):
    def subarraySum(self, nums):
        diff = [0]*(len(nums)+1)
        for i, x in enumerate(nums):
            diff[max(i-x, 0)] += 1
            diff[i+1] -= 1
        for i in range(len(nums)):
            diff[i+1] += diff[i]
        return sum(nums[i]*diff[i] for i in range(len(nums)))",O(n)
"n = int(input())
i = 1
while n:
    if i > 1:
        print(' ', end='')
    if n == 3:
        print(*[i, i, i * 3], end='')
        break
    print(' '.join([str(i)] * ((n + 1) // 2)), end='')
    i <<= 1
    n >>= 1

print()
",O(nlogn)
"import sys

sys.setrecursionlimit(10 ** 5)
int1 = lambda x: int(x) - 1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.readline())
def MI(): return map(int, sys.stdin.readline().split())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def SI(): return sys.stdin.readline()[:-1]

rn,gn,bn=MI()
rr=LI()
gg=LI()
bb=LI()
rr.sort(reverse=True)
gg.sort(reverse=True)
bb.sort(reverse=True)
dp=[[[-1]*(bn+1) for _ in range(gn+1)] for _ in range(rn+1)]
dp[0][0][0]=0
ans=0
for i in range(rn+1):
    for j in range(gn+1):
        for k in range(bn+1):
            pre=dp[i][j][k]
            if pre==-1:continue
            ans=max(ans,pre)
            if i<rn and j<gn:dp[i+1][j+1][k]=max(dp[i+1][j+1][k],pre+rr[i]*gg[j])
            if i<rn and k<bn:dp[i+1][j][k+1]=max(dp[i+1][j][k+1],pre+rr[i]*bb[k])
            if j<gn and k<bn:dp[i][j+1][k+1]=max(dp[i][j+1][k+1],pre+gg[j]*bb[k])

print(ans)
",O(n ^ 3)
"import sys
input = sys.stdin.readline

n, q = map(int, input().split())
for _ in range(q):
    u = int(input())
    s = input()
    for comm in s:
        k = 1
        while True:
            if k & u:
                break
            k <<= 1
        if comm == 'L':
            if k != 1:
                u -= k
                u += (k>>1)
        elif comm == 'R':
            if k != 1:
                u += (k>>1)
        elif comm == 'U':
            nu = u - k
            nu |= (k<<1)
            if nu <= n:
                u = nu
    print(u)",np
"N, M, K = map(int, input().split())
A = list(map(int, input().split()))
bv = 0
for ms in range(M):
    cv = 0
    for i in range(ms, N):
        v = A[i]
        if i % M == ms:
            v -= K
            cv = max(0, cv)
        cv += v
        bv = max(bv, cv)
print(bv)
",O(n ^ 2)
"import itertools


class Solution(object):
    def buddyStrings(self, A, B):
        if len(A) != len(B):
            return False
        diff = []
        for a, b in zip(A, B):
            if a != b:
                diff.append((a, b))
                if len(diff) > 2:
                    return False
        return (not diff and len(set(A)) < len(A)) or \
               (len(diff) == 2 and diff[0] == diff[1][::-1])",O(n)
"n = int(input())
ans = []
m = 1
while n > 3:
    ans += [m] * (n - n // 2)
    n //= 2
    m *= 2
if n == 3:
    ans += [m, m, m * 3]
elif n == 2:
    ans += [m, m * 2]
else:
    ans += [m]
print(*ans)
",O(nlogn)
"import sys
input = sys.stdin.readline
x,y = map(int, input().split())
if y-x<2:
	print(-1)
elif x%2 != 0 and y-x==2:
	print(-1)
elif x%2==0:
	print(x, x+1, x+2)
else:
	print(x+1, x+2, x+3)",O(1)
"def check_combination(v):
    sm = sum(v)
    if l <= sm <= r:
        if max(v) - min(v) >= x:
            global ans
            ans += 1

def go(offset, k):

    if k == 0:
        check_combination(combination)
        return
    for i in range(offset, len(problems) - k + 1):
        combination.append(problems[i])
        go(i+1, k-1)
        combination.pop()

n, l, r, x = map(int, input().split())
c = list(map(int, input().split()))

problems = list()
combination = list()

ans = 0

for i in range(2, len(c) + 1):
    problems = c.copy()
    go(0, i)

print(ans)
",np
"class Solution(object):
    def maxSubarrayLength(self, nums):
        stk = []
        for i in reversed(range(len(nums))):
            if not stk or nums[stk[-1]] > nums[i]:
                stk.append(i)
        result = 0
        for left in range(len(nums)):
            while stk and nums[stk[-1]] < nums[left]:
                result = max(result, stk.pop()-left+1)
        return result",O(n)
"class Solution(object):
    def frequenciesOfElements(self, head):
        curr = dummy = ListNode(0)
        cnt = 0
        while head:
            cnt += 1
            if not head.__next__ or head.next.val != head.val:
                curr.next = ListNode(cnt)
                curr = curr.__next__
                cnt = 0
            head = head.__next__
        return dummy.__next__",O(n)
"
import collections


class Solution(object):
    def isPossibleDivide(self, nums, k):
        count = collections.Counter(nums)
        for num in sorted(count.keys()):
            c = count[num]
            if not c:
                continue
            for i in range(num, num+k):
                if count[i] < c:
                    return False
                count[i] -= c
        return True
",O(nlogn)
"n = int(input())
a, edge = [0], []
last, sum, ans = 0, 0, 0
for i in map(int, input().split()) :
    a.append(i)
    sum += i
for i in range(1, n + 1) :
    if(a[i] == 1) :
        last = i
a[last] = 0
for i in range(1, n + 1) :
    if(a[i] > 1) :
        if(last) :
            edge.append([last, i])
            ans += 1
        last = i
for i in range(1, n + 1) :
    if(a[i] == 1 and last) :
        edge.append([last, i])
        last = 0
        a[i] = 0
        ans += 1
for i in range(1, n + 1) :
    for j in range(1, n + 1) :
        if(a[j] == 1 and a[i] > 2) :
            edge.append([i, j])
            a[i] -= 1
            a[j] -= 1
if(len(edge) != n - 1) :
    print(""NO"")
else :
    print(""YES"", ans)
    print(len(edge))
    for i in edge :
        print(i[0], i[1])
",O(n ^ 2)
"class Solution(object):

    def __init__(self):
        self.A, self.B = [], []

    def push(self, x):
        self.A.append(x)

    def pop(self):
        self.peek()
        return self.B.pop()

    def peek(self):
        if not self.B:
            while self.A:
                self.B.append(self.A.pop())
        return self.B[-1]

    def empty(self):
        return not self.A and not self.B",O(1)
"n,a,b=map(int,input().split())
alist=list(map(int,input().split()))
alist.sort(reverse=True)
p=alist[a-1]
q=alist[a]
print(p-q)",O(nlogn)
"T = int(input())
for _ in range(T):
    N = int(input())

    if N%2 == 1:
        print(""NO"")
    else:
        N //= 2
        if N**(1/2) == int(N**(1/2)):
            print(""YES"")
        else:
            if N%2 == 1:
                print(""NO"")
            else:
                N //= 2
                if N**(1/2) == int(N**(1/2)):
                    print(""YES"")
                else:
                    print(""NO"")",O(1)
"class Solution(object):
    def asteroidsDestroyed(self, mass, asteroids):
        asteroids.sort()
        for x in asteroids:
            if x > mass:
                return False
            mass += min(x, asteroids[-1]-mass)
        return True",O(nlogn)
"def max_profit(n,k,l,d):
    a=[]
    p,i=0,-1
    while(len(a)!=k-1):
        p+=1
        i+=1
        if l[i] in d:
            a.append(p)
            p=0
            d.remove(l[i])
    a.append(n-sum(a))
    print(*a)

n,k=map(int,input().split())
l=list(map(int,input().split()))
d=sorted(l,reverse=True)[:k]
print(sum(d))
max_profit(n,k,l,d)",O(nlogn)
"class Solution(object):
    def lengthOfLongestSubstringKDistinct(self, s, k):
        longest, start, distinct_count, visited = 0, 0, 0, [0 for _ in range(256)]
        for i, char in enumerate(s):
            if visited[ord(char)] == 0:
                distinct_count += 1
            visited[ord(char)] += 1
            while distinct_count > k:
                visited[ord(s[start])] -= 1
                if visited[ord(s[start])] == 0:
                    distinct_count -= 1
                start += 1
            longest = max(longest, i - start + 1)
        return longest",O(n)
"class Solution(object):
    def rob(self, nums):
        if len(nums) == 0:
            return 0

        if len(nums) == 1:
            return nums[0]

        return max(self.robRange(nums, 0, len(nums) - 1),\
                   self.robRange(nums, 1, len(nums)))

    def robRange(self, nums, start, end):
        num_i, num_i_1 = nums[start], 0
        for i in range(start + 1, end):
            num_i_1, num_i_2 = num_i, num_i_1
            num_i = max(nums[i] + num_i_2, num_i_1)

        return num_i",O(n)
"from sys import stdin,stdout
input=stdin.readline
for _ in range(int(input())):
    x=10**5
    n,k=map(int,input().split())
    s=input()
    ans=10**9
    for i in range(n-k+1):
        x=s[i:i+k]
        m=0
        curr=['R','G','B']
        for l in range(3):
            m=0
            z=l
            for j in x:
                if j!=curr[z]:
                    m+=1
                z+=1
                z%=3
            ans=min(ans,m)
    print(ans)
",O(n ^ 2)
"from sys import stdin
n = int(stdin.readline())
g = dict()
for i in range(n-1):
    u,v = map(int,stdin.readline().split())
    g.setdefault(u-1,[]).append(v-1)
    g.setdefault(v-1, []).append(u-1)
st = [0]
rank = [0]*n
tree = [0]*n
msk = [0]*n
rd = dict()
while len(st)>0:
    top = st.pop()
    msk[top] = 1
    for c in g[top]:
        if msk[c] == 0:
            st.append(c)
            tree[c] = top
            rank[c] = rank[top]+1
            rd.setdefault(rank[c], []).append(c)
max_rank = max(rank)
reach = [0]*n
build = [0]*n
ans = 0
for r in range(max_rank, 2, -1):
    for node in rd[r]:
        if reach[node] == 0:
            reach[node] = 1
            reach[tree[node]] = 1
            reach[tree[tree[node]]] = 1
            build[tree[node]] = 1
print(sum(build))",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def sumEvenGrandparent(self, root):
        def sumEvenGrandparentHelper(root, p, gp):
            return sumEvenGrandparentHelper(root.left, root.val, p) + \
                   sumEvenGrandparentHelper(root.right, root.val, p) + \
                   (root.val if gp is not None and gp % 2 == 0 else 0) if root else 0

        return sumEvenGrandparentHelper(root, None, None)",O(n)
"def main():
    import sys
    input = sys.stdin.readline

    a = int(input())
    b = int(input())
    a = list(str(a))
    a.sort()
    ans = []
    while a:
        for i in range(len(a) - 1, -1, -1):
            c = ans + [a[i]] + a[:i] + a[i+1:]
            if int(''.join(c)) <= b:
                ans.append(a[i])
                a.pop(i)
                break
    print(''.join(ans))

main()",O(n ^ 3)
"class Solution(object):
    def countTime(self, time):
        result = 1
        if time[4] == '?':
            result *= 10
        if time[3] == '?':
            result *= 6
        if time[1] == time[0] == '?':
            result *= 24
        elif time[1] == '?':
            result *= 10 if time[0] != '2' else 4
        elif time[0] == '?':
            result *= 3 if time[1] < '4' else 2
        return result",O(1)
"class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        n = len(nums)
        low, high = 1, n - 1
        while low < high:
            mid = low + (high - low) // 2
            lessOrEqual = sum(1 for num in nums if num <= mid)

            if lessOrEqual <= mid:
                low = mid + 1
            else:
                high = mid

        return low
",O(nlogn)
"from bisect import bisect_right as br
from bisect import bisect_left as bl
from math import *

def isprime(n):
    n = abs(int(n))
    if n < 2:
        return False
    if n == 2:
        return True
    if not n & 1:
        return False
    for x in range(3, int(n**0.5) + 1, 2):
        if n % x == 0:
            return False

    return True

def mhd(a,b,x,y):

    return abs(a-x)+abs(b-y)

n = int(input())
a,b = map(int,input().split())
if(mhd(a,b,1,1)<=mhd(a,b,n,n)):
    print('White')
else:
    print('Black')",O(1)
"class Solution(object):
    def partitionArray(self, nums, k):
        nums.sort()
        result, prev = 1, 0
        for i in range(len(nums)):
            if nums[i]-nums[prev] <= k:
                continue
            prev = i
            result += 1
        return result",O(nlogn)
"n=int(input())
a=[0] + list(map(int,input().split()))
d={}
for i in range(1,n+1):
    d[a[i]]=i
ans=0
for i in range(1,n+1):
    if a[i]!=i:
        ind1=d[a[i]]
        ind2=d[i]
        va1=a[i]
        val2=i
        a[ind1],a[ind2]=a[ind2],a[ind1]
        d[i]=i
        d[va1]=ind2
        ans+=1

if (3*n - ans)%2==0:
    print(""Petr"")
else:
    print(""Um_nik"")
",O(nlogn)
"class Solution2(object):
    def findRoot(self, tree):
        root = 0
        for node in tree:
            root ^= node.val
            for child in node.children:
                root ^= child.val
        for node in tree:
            if node.val == root:
                return node
        return None",O(n)
"def read4(buf):
    global file_content
    i = 0
    while i < len(file_content) and i < 4:
        buf[i] = file_content[i]
        i += 1

    if len(file_content) > 4:
        file_content = file_content[4:]
    else:
        file_content = """"
    return i






class Solution(object):
    def __init__(self):
        self.__buf4 = [''] * 4
        self.__i4 = 0
        self.__n4 = 0

    def read(self, buf, n):
        i = 0
        while i < n:
            if self.__i4 < self.__n4: 
                buf[i] = self.__buf4[self.__i4]
                i += 1
                self.__i4 += 1
            else:
                self.__n4 = read4(self.__buf4) 
                if self.__n4:
                    self.__i4 = 0
                else: 
                    break

        return i",O(n)
"n = int(input())
from collections import defaultdict, Counter
a = defaultdict(list)
count_left = Counter()
count_right = Counter()

for _ in range(n):
	l, r = map(int, input().split())
	count_left[l] += 1
	count_right[r] += 1

count = [0] * (n + 1)

pts = sorted(set(count_left.keys()) | set(count_right.keys()))

c = 0
prev = pts[0]
for pt in pts:

	if count_left[pt]:
		count[c] += pt - prev - 1
		c += count_left[pt]
		count[c] += 1
		c -= count_right[pt]
	else:
		count[c] += pt - prev
		c -= count_right[pt]

	prev = pt

print(' '.join(map(str, count[1:])))",O(nlogn)
"n = input()
seat_rows = [int(x) for x in input().strip().split()]
aliens = input().strip()

eldian = ""0""
marleyan = ""1""

empty = sorted(enumerate(seat_rows), key=lambda x: x[1], reverse=True)
non_empty = []

result = []
for alien in aliens:
    if alien == eldian:
        row = empty.pop()
        non_empty.append(row)
    else:
        row = non_empty.pop()

    result.append(row[0] + 1)

print(' '.join(map(str, result)))",O(nlogn)
"class Solution(object):
    def minOperations(self, boxes):
        result = [0]*len(boxes)
        for direction in (lambda x:x, reversed):
            cnt = accu = 0
            for i in direction(range(len(boxes))):
                result[i] += accu
                if boxes[i] == '1':
                    cnt += 1
                accu += cnt
        return result",O(n)
"import itertools



class Solution(object):
    def sumSubarrayMins(self, A):
        M = 10**9 + 7

        left, s1 = [0]*len(A), []
        for i in range(len(A)):
            count = 1
            while s1 and s1[-1][0] > A[i]:
                count += s1.pop()[1]
            left[i] = count
            s1.append([A[i], count])

        right, s2 = [0]*len(A), []
        for i in reversed(range(len(A))):
            count = 1
            while s2 and s2[-1][0] >= A[i]:
                count += s2.pop()[1]
            right[i] = count
            s2.append([A[i], count])

        return sum(a*l*r for a, l, r in zip(A, left, right)) % M",O(n)
"import sys
from collections import deque,defaultdict as dd
from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right
from itertools import permutations
from datetime import datetime
from math import ceil,sqrt,log,gcd
def ii():return int(input())
def si():return input()
def mi():return map(int,input().split())
def li():return list(mi())
abc='abcdefghijklmnopqrstuvwxyz'
abd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod=1000000007

inf = float(""inf"")
vow=['a','e','i','o','u']
dx,dy=[-1,1,0,0],[0,0,1,-1]
def read():
    tc=0
    if tc:
        input=sys.stdin.readline
    else:
        sys.stdin=open('input1.txt', 'r')
        sys.stdout=open('output1.txt','w')

def permute(b,x,ind):
    if(ind==len(b)):
        return 1
    f=0
    for i in range(9,-1,-1):
        if(x[i]>0 and i<=int(b[ind])):
            x[i]-=1
            ans[ind]=str(i)
            if(i<int(b[ind])):
                f=1
            if(f):
                k=9
                for j in range(ind+1,len(b)):
                    while(x[k]==0):
                        k-=1
                    ans[j]=str(k)
                    x[k]-=1
                return 1
            if(permute(b,x,ind+1)):
                return 1
            x[i]+=1
    return 0

def solve():

    a=ii()
    b=ii()
    if(len(str(a))<len(str(b))):
        s=list(str(a))
        s.sort(reverse=True)
        print("""".join(s))
    else:
        x=[0]*10
        for i in str(a):
            x[int(i)]+=1
        b=str(b)
        i=0
        global ans
        ans=[0]*len(b)
        permute(b,x,0)
        print("""".join(ans))

if __name__ ==""__main__"":

    solve()
",O(n ^ 3)
"import heapq


class Solution(object):
    def getOrder(self, tasks):
        idx = list(range(len(tasks)))
        idx.sort(key=lambda x: tasks[x][0])
        result, min_heap = [], []
        i, time = 0, tasks[idx[0]][0]
        while i < len(idx) or min_heap:
            while i < len(idx) and tasks[idx[i]][0] <= time:
                heapq.heappush(min_heap, (tasks[idx[i]][1], idx[i]))
                i += 1
            if not min_heap:
                time = tasks[idx[i]][0]
                continue
            t, j = heapq.heappop(min_heap)
            time += t
            result.append(j)
        return result",O(nlogn)
"if __name__ == ""__main__"":
    n, s = input().split("" "")
    n = int(n)
    s = int(s)

    sol = 0
    l = 1
    r = n
    while l <= r:
        sum = 0
        i = (l + r)//2
        a = i
        while (a > 0):
            sum += a % 10
            a = a // 10

        if i - sum >= s:
            sol = n - i + 1
            r = i - 1
        else:
            l = i + 1

    print(sol)
",O(logn)
"class Solution(object):
    def checkRecord(self, n):
        M = 1000000007
        a0l0, a0l1, a0l2, a1l0, a1l1, a1l2 = 1, 0, 0, 0, 0, 0
        for i in range(n+1):
            a0l2, a0l1, a0l0 = a0l1, a0l0, (a0l0 + a0l1 + a0l2) % M
            a1l2, a1l1, a1l0 = a1l1, a1l0, (a0l0 + a1l0 + a1l1 + a1l2) % M
        return a1l0",O(n)
"class Solution(object):
    def checkStraightLine(self, coordinates):
        i, j = coordinates[:2]
        return all(i[0] * j[1] - j[0] * i[1] +
                   j[0] * k[1] - k[0] * j[1] +
                   k[0] * i[1] - i[0] * k[1] == 0
                   for k in coordinates)",O(n)
"i = input()
i = int(i)
v = 0
g = 2
s = 4
while g <= i:
	while s <= i:
		v = v + int(s / g * 4)
		s = s + g
	g = g + 1
	s = g * 2
print(str(v))",O(n)
"class Solution2(object):
    def canSeePersonsCount(self, heights):
        result = [0]*len(heights)
        stk = []
        for i in reversed(range(len(heights))):
            cnt = 0
            while stk and heights[stk[-1]] < heights[i]:
                stk.pop()
                cnt += 1
            result[i] = cnt+1 if stk else cnt
            if stk and heights[stk[-1]] == heights[i]:
                stk.pop()
            stk.append(i)
        return result",O(n)
"def func():
    n, k = map(int, input().strip().split())
    l = 0
    r = n
    while l <= r:
        mid = (l + r) // 2
        if mid*(mid+1)/2 - (n-mid) < k:
            l = mid + 1
        elif mid*(mid+1)/2 - (n-mid) > k:
            r = mid
        else:
            print(n - mid)
            return mid

if __name__ == '__main__':
    func()",O(logn)
"MOD = 1000000007

def main():
    buf = input()
    buflist = buf.split()
    n = int(buflist[0])
    q = int(buflist[1])
    buf = input()
    x = buf
    sum_list = [0]
    for i, deliciousness in enumerate(x):
        sum_list.append(int(deliciousness) + sum_list[i])
    enjoyment_list = [0]
    for i in range(n):
        enjoyment_list.append((enjoyment_list[i] * 2 + 1) % MOD)
    query_list = []
    for i in range(q):
        buf = input()
        buflist = buf.split()
        l = int(buflist[0])
        r = int(buflist[1])
        query_list.append((l, r))
    for i, query in enumerate(query_list):
        l = query[0]
        r = query[1]
        banhmi_count = r - l + 1
        delicious_count = sum_list[r] - sum_list[l - 1]
        non_delicious_count = banhmi_count - delicious_count
        enjoyment = 0

        if delicious_count == 0:
            enjoyment = 0
        else:
            enjoyment += enjoyment_list[delicious_count]
            enjoyment += (enjoyment_list[banhmi_count] - enjoyment_list[delicious_count] - enjoyment_list[non_delicious_count])
            enjoyment = enjoyment % MOD
        print(enjoyment)

if __name__ == '__main__':
    main()
",O(n)
"class Solution(object):
    def maxJump(self, stones):
        return stones[1]-stones[0] if len(stones) == 2 else max(stones[i+2]-stones[i] for i in range(len(stones)-2))",O(n)
"import bisect as bi
n,q = map(int,input().split())
a = list(map(int,input().split()))
l = list(map(int,input().split()))
som = sum(a)
e = 0
p = []
for i in a:
    e += i
    p.append(e)

e = 0
s = set(p)
for i in l:
    e += i
    if e >= som:
        e = 0

    x = bi.bisect(p,e)
    print(n-x)
",O(nlogn)
"n,m=map(int,input().split())
x=list(map(int,input().split()))
y=list(map(int,input().split()))
l=[]
for i in range(m):
    if y[i] in x:
        l.append(x.index(y[i]))
l.sort()
for i in l:
    print(x[i],end="" "")",O(n ^ 2)
"for _ in range(int(input())):
    n,k=map(int,input().split())
    if n>31:
        print(""YES"",n-1)
        continue
    else:
        if k>(4**n-1)//3:
            print(""NO"")
            continue
    l=(4**n-1)//3
    i=1
    j=0
    k1=k
    while i<=n:
        k-=(2**i-1)
        j=i
        if k<0:
            j=j-1
            k+=(2**i-1)
            break
        i+=1
    k2=k1-k
    k3=(2**(j+1)-1)*((4**(n-j)-1)//3)

    if l-k2-k3>=k:
        print(""YES"",n-i+1)
    else:
        print(""NO"")
",O(logn)
"s1, s2 = input().split()
ans = 'z' * 21
for i in range(1, len(s1) + 1):
    for j in range(1, len(s2) + 1):
        ans = min(ans, s1[:i] + s2[:j])
print(ans)",O(n)
"input();a=sorted(map(int,input().split()));s=c=0
while s<=sum(a):s+=a.pop();c+=1
print(c)",O(nlogn)
"from math import ceil

def solve(n, k):
	if k == 1:
		return n - 1
	if k == 2:
		if n > 1:
			return n - 1
		else:
			return -1
	if k == 3:
		if n > 2:
			return n - 1
		else:
			return -1
	if k in {4, 5}:
		if n > 1:
			return n - 2
		else:
			return -1

	if 2 * n + 1 <= len(bin(3 * k)[2:]):
		return -1
	else:
		return n - ceil((len(bin(3 * k)[2:]) - 1) / 2)

for i in range(int(input())):
	n, k = map(int, input().split())
	a = solve(n, k)
	if a == -1:
		print('NO')
	else:
		print('YES', a)
",O(n)
"a,b=list(map(int,input().split()))
c,d=(((b+1)//2)-1,(b-a-1))
print(c if d<0 else c-d if c>d else 0)
",O(1)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def addTwoNumbers(self, l1, l2):
        dummy = ListNode(0)
        current, carry = dummy, 0

        while l1 or l2:
            val = carry
            if l1:
                val += l1.val
                l1 = l1.__next__
            if l2:
                val += l2.val
                l2 = l2.__next__
            carry, val = divmod(val, 10)
            current.next = ListNode(val)
            current = current.__next__

        if carry == 1:
            current.next = ListNode(1)

        return dummy.__next__",O(n)
"import sys
input = sys.stdin.readline

n=int(input())
A=list(map(int,input().split()))

A.sort()

ANS=[0]*n

NOW=1
for i in range(n):
    if ANS[i]==0:
        ANS[i]=NOW

        for j in range(i,n):
            if A[j]%A[i]==0 and ANS[j]==0:
                ANS[j]=NOW

        NOW+=1

print(max(ANS))
",O(n ^ 2)
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key = lambda pair: pair[1])
        prevEnd = intervals[0][1]
        res = 0

        for i in range(1, len(intervals)):
            if prevEnd > intervals[i][0]:
                res += 1
            else:
                prevEnd = intervals[i][1]

        return res
",O(nlogn)
"from itertools import combinations
def out1(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==1 and b==0 and c==0:
        return 1
    return a*(out2(a-1,b,c)+out3(a-1,b,c))
def out2(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==0 and b==1 and c==0:
        return 1
    return b*(out1(a,b-1,c)+out3(a,b-1,c))
def out3(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==0 and b==0 and c==1:
        return 1
    return c*(out2(a,b,c-1)+out1(a,b,c-1))
def column(matrix, i):
    return [row[i] for row in matrix]

N, T = [int(x) for x in input().split()]
A = []
s = 0
for i in range(N):
    A.append([int(x) for x in input().split()])
for i in range(1,N+1):
    comb = list(combinations(A, i))
    for x in comb:
        if sum(column(x,0))==T:
            a = column(x,1).count(1)
            b = column(x,1).count(2)
            c = column(x,1).count(3)
            s+=(out1(a,b,c)+out2(a,b,c)+out3(a,b,c))
print(s%1000000007)",np
"class Solution(object):
    def minimumAverage(self, nums):
        nums.sort()
        return min((nums[i]+nums[~i])/2.0 for i in range(len(nums)//2))",O(nlogn)
"import sys
input = sys.stdin.readline

rr, gg, bb = map(int, input().split())
inf = 114514
r = list(map(int, input().split())) + [inf]
g = list(map(int, input().split())) + [inf]
b = list(map(int, input().split())) + [inf]
r.sort(reverse = True)
g.sort(reverse = True)
b.sort(reverse = True)
dp = []
for _ in range(rr + 1):
    dp.append([[0] * (bb + 1) for _ in range(gg + 1)])
ans = 0
for i in range(rr + 1):
    ri = r[i]
    for j in range(gg + 1):
        gj = g[j]
        for k in range(bb + 1):
            bk = b[k]
            if (i + j + k) % 2:
                continue
            dpijk = 0
            if i > 0 and j > 0:
                dpijk = max(dp[i - 1][j - 1][k] + ri * gj, dpijk)
            if j > 0 and k > 0:
                dpijk = max(dp[i][j - 1][k - 1] + gj * bk, dpijk)
            if k > 0 and i > 0:
                dpijk = max(dp[i - 1][j][k - 1] + bk * ri, dpijk)
            dp[i][j][k] = dpijk
            if ans < dpijk:
                ans = dpijk
print(ans)",O(n ^ 3)
"import sys
import os.path
from collections import *
import math
import bisect

if (os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")
else:
    input = sys.stdin.readline

n = int(input())

if(n == 2 or n == 3 or n == 4 or n == 5):
    print(-1)
else:
    print(1,2)
    print(2,3)
    print(2,4)
    for i in range(5,n + 1):
        print(4,i)

for i in range(2,n + 1):
    print(1,i)
",O(n)
"class Solution2(object):
    def fib(self, N):
        prev, current = 0, 1
        for i in range(N):
            prev, current = current, prev + current,
        return prev",O(n)
"class Solution(object):
    def bagOfTokensScore(self, tokens, P):
        tokens.sort()
        result, points = 0, 0
        left, right = 0, len(tokens)-1
        while left <= right:
            if P >= tokens[left]:
                P -= tokens[left]
                left += 1
                points += 1
                result = max(result, points)
            elif points > 0:
                points -= 1
                P += tokens[right]
                right -= 1
            else:
                break
        return result",O(nlogn)
"l = []
n = []
sum = 0
multiply = 9
for i in range(1,12):
    s = '9' * i
    n.append(int(s))
    sum+=i*multiply
    multiply *= 10
    l.append(sum)
k = int(input())
if(k<9):
    print(k)
else:
    t = 0
    for i in range(len(l)):
        if(k < l[i]):
            t=i
            break
    temp = k-l[t-1]
    offset = temp%(t+1)
    value = temp//(t+1)
    number = n[t-1]+value
    if(offset == 0):
        print(number%10)
    else:
        number += 1
        offset -= 1
        print(str(number)[offset])",O(logn)
"print(""? 0 0"")
t = int(input())
A=[]
B=[]
a=0
b=0
for i in range(30):
    A.append(-1)
    B.append(-1)
i = 29
d = 2**i
while i>=0:
    a+=d
    b+=d
    print(""?"", end=' ')
    print(a, end=' ')
    print(b)
    s=int(input())
    if s == -t:
        if s==1:
            A[i]=0
            B[i]=1
            b-=d
            print(""?"", end=' ')
            print(a, end=' ')
            print(b)
            t=int(input())
        elif s==-1:
            A[i]=1
            a-=d
            B[i]=0
            print(""?"", end=' ')
            print(a, end=' ')
            print(b)
            t=int(input())
    i-=1
    d//=2
d=1
for j in range(30):
    if A[j]==-1:
        a = a^d
        print(""?"", end=' ')
        print(a, end=' ')
        print(b)
        s = int(input())
        if s==1:
            A[j]=1
            B[j]=1
        else:
            A[j]=0
            B[j]=0
        a = a^d
    d*=2
d=1
a=0
b=0
for i in range(30):
    a+=d*A[i]
    b+=d*B[i]
    d*=2
print(""!"", end=' ')
print(a, end=' ')
print(b)
",O(logn)
"class Solution2(object):
    def countWays(self, nums):
        nums.sort()
        return sum((i == 0 or nums[i-1] < i) and (i == len(nums) or nums[i] > i) for i in range(len(nums)+1))",O(nlogn)
"

class Solution(object):
    def sortPeople(self, names, heights):
        order = list(range(len(names)))
        order.sort(key=lambda x: heights[x], reverse=True)
        return [names[i] for i in order]
",O(nlogn)
"class Solution2(object):
    def calculate(self, s):
        operands, operators = [], []
        operand = """"
        for i in reversed(range(len(s))):
            if s[i].isdigit():
                operand += s[i]
                if i == 0 or not s[i-1].isdigit():
                    operands.append(int(operand[::-1]))
                    operand = """"
            elif s[i] == ')' or s[i] == '+' or s[i] == '-':
                operators.append(s[i])
            elif s[i] == '(':
                while operators[-1] != ')':
                    self.compute(operands, operators)
                operators.pop()

        while operators:
            self.compute(operands, operators)

        return operands[-1]

    def compute(self, operands, operators):
        left, right = operands.pop(), operands.pop()
        op = operators.pop()
        if op == '+':
            operands.append(left + right)
        elif op == '-':
            operands.append(left - right)",O(n)
"n,a,b,c,t=map(int,input().split())
l=list(map(int,input().split()))
if c>b:
    r=0
    for i in l:
        k=t-i
        k*=(c-b)
        r+=k
    print(a*n+r)
else:
    print(a*n)
",O(n)
"buck = [[0, 0] for i in range(2201)]
m = int(input())
for i in range(m):
    a = int(input())
    ok = True
    br = 0
    for j in range(2200, -1, -1):
        if a & (1 << j):
            if(buck[j][0]):
                a  ^= buck[j][0]
                br ^= buck[j][1]
            else:
                ok = False
                buck[j][0] = a
                buck[j][1] = br | (1 << i)
                break
    if not ok:
        print(""0"")
    else:
        lst = []
        for j in range(2201):
            if br & (1 << j):
                lst.append(j)
        print(len(lst), end = ' ')
        for j in lst:
            print(j, end = ' ')
        print('\n', end='')
",np
"class Solution(object):
    def isSubstringPresent(self, s):
        lookup = [[False]*26 for _ in range(26)]
        for i in range(len(s)-1):
            lookup[ord(s[i])-ord('a')][ord(s[i+1])-ord('a')] = True
        return any(lookup[ord(s[i+1])-ord('a')][ord(s[i])-ord('a')]  for i in range(len(s)-1))
import collections",O(n)
"class Solution(object):
    def mySqrt(self, x):
        if x < 2:
            return x

        left, right = 1, x // 2
        while left <= right:
            mid = left + (right - left) // 2
            if mid > x / mid:
                right = mid - 1
            else:
                left = mid + 1

        return left - 1",O(logn)
"class Solution3(object):
    def maxFrequencyScore(self, nums, k):
        def check(l):
            return any((prefix[i+l]-prefix[i+(l+1)//2])-(prefix[i+l//2]-prefix[i]) <= k for i in range(len(nums)-l+1))

        nums.sort()
        prefix = [0]*(len(nums)+1)
        for i, x in enumerate(nums):
            prefix[i+1] = prefix[i]+x
        left, right = 1, len(nums)
        while left <= right:
            mid = left+(right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right",O(nlogn)
"class Solution2(object):
    def asteroidCollision(self, asteroids):
        result = []
        for x in asteroids:
            while result and x < 0 < result[-1]:
                if result[-1] < -x:
                    result.pop()
                    continue
                elif result[-1] == -x:
                    result.pop()
                break
            else:
                result.append(x)
        return result",O(n)
"class Solution3(object):
    def lastMarkedNodes(self, edges):
        def increase(x):
            return (x[0]+1, x[1])

        def topological_traversal():
            p = [-2]*len(adj)
            p[0] = -1
            topological_order = [0]
            for u in topological_order:
                for v in reversed(adj[u]):
                    if p[v] != -2:
                        continue
                    p[v] = u
                    topological_order.append(v)
            dp = [[(0, u)]*2 for u in range(len(adj))]
            for u in reversed(topological_order):
                for v in adj[u]:
                    if v == p[u]:
                        continue
                    curr = increase(dp[v][0])
                    for i in range(len(dp[u])):
                        if curr > dp[u][i]:
                            curr, dp[u][i] = dp[u][i], curr
            return dp

        def bfs():
            result = [-1]*len(adj)
            q = [(0, -1, (0, -1))]
            while q:
                new_q = []
                for u, p, curr in q:
                    result[u] = max(dp[u][0], curr)[1]
                    for v in adj[u]:
                        if v == p:
                            continue
                        new_q.append((v, u, increase(max(dp[u][dp[u][0][1] == dp[v][0][1]], curr))))
                q = new_q
            return result

        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = topological_traversal()
        return bfs()",O(n)
"class Solution(object):
    def passThePillow(self, n, time):
        return n-abs((n-1)-(time%(2*(n-1))))",O(1)
"n=int(input())
m=int(input())
print(m%(pow(2,n)))",O(1)
"import decimal
decimal.getcontext().prec = 100

a, v = map(decimal.Decimal, input().split())
l, d, w = map(decimal.Decimal, input().split())

def DecimalPow(a, b):
    return decimal.Decimal(a) ** decimal.Decimal(b)

def getLastT(v1, dist):
    t1 = (v - v1) / a
    d1 = v1 * t1 + decimal.Decimal(0.5) * a * DecimalPow(t1, 2)
    if d1 >= dist:
        return (-v1 + (v1 ** decimal.Decimal(2) + 2 * a * dist) ** decimal.Decimal(0.5)) / a
    t2 = (dist - d1) / v
    return t1 + t2

if w >= v:
    t1 = v / a
    if decimal.Decimal(0.5) * a * (t1 ** decimal.Decimal(2)) <= l:
        t2 = (l - decimal.Decimal(0.5) * a * (t1 ** decimal.Decimal(2))) / v
    else:
        t1 = (decimal.Decimal(2) * l / a) ** decimal.Decimal(0.5)
        t2 = 0
    t = t1 + t2
    print('{t:.5f}'.format(t = t))

elif (w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d:
    t = getLastT(0, l)
    print('{t:.5f}'.format(t = t))

elif (v ** decimal.Decimal(2) - 0) / (2 * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d:
    t2 = -w / a + ((w ** decimal.Decimal(2)) / (2 * (a ** decimal.Decimal(2))) + d / a) ** decimal.Decimal(0.5)
    t1 = w / a + t2
    t3 = getLastT(w, l - d)
    t = t1 + t2 + t3
    print('{t:.5f}'.format(t = t))

else:
    t1 = v / a
    t3 = (v - w) / a
    t2 = (d - ((v ** decimal.Decimal(2) - 0) / (decimal.Decimal(2) * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a))) / v
    t4 = getLastT(w, l - d)
    t = t1 + t2 + t3 + t4
    print('{t:.5f}'.format(t = t))",O(1)
"n=int(input())
print('25')",O(1)
"from __future__ import division
from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]
n, m = rints()
a, cur, ans = rints()[::-1], 2, -1

for i in range(n - 2):
    cur = max(cur, i + 2)
    for j in range(cur, n):
        if a[i] - a[j] > m:
            break

        cur += 1
        v = (a[i] - a[j - 1]) / (a[i] - a[j])
        ans = max(ans, v)

print(ans)
",O(nlogn)
"[n, k]=[int(i) for i in input().split()]
print((k+n-1)//n)",O(1)
"class Solution:
    def checkValidString(self, s: str) -> bool:
        n = len(s)
        dp = [False] * (n + 1)
        dp[0] = True

        for i in range(n - 1, -1, -1):
            new_dp = [False] * (n + 1)
            for open in range(n):
                if s[i] == '*':
                    new_dp[open] = (dp[open + 1] or
                                    (open > 0 and dp[open - 1]) or
                                    dp[open])
                elif s[i] == '(':
                    new_dp[open] = dp[open + 1]
                elif open > 0:
                    new_dp[open] = dp[open - 1]
            dp = new_dp

        return dp[0]
",O(n ^ 2)
"import sys, string

n, m = map(int, sys.stdin.readline().split())
s = list(sys.stdin.readline().rstrip())
t = list(sys.stdin.readline().rstrip())
idx = -1
for i in range(n):
    if s[i] == '*':
        idx = i
if idx == -1:
    if s == t:
        print('YES')
    else:
        print('NO')
else:
    if m < n - 1:
        print('NO')
    else:
        s_left = s[0 : idx]
        s_right = s[idx + 1 : n]
        a = len(s_left)
        b = len(s_right)
        t_left = []
        t_right = []
        for i in range(a):
            t_left.append(t[i])
            t[i] = ''
        for i in range(b):
            t_right.append(t[m - i - 1])
        if s_left == t_left and s_right == t_right[::-1]:
            print('YES')
        else:
            print('NO')",O(n)
"n, m = map(int, input().split())
a = [int(input(), 2) for _ in range(n)]

s = t = 0
for x in a:
    t |= s & x
    s |= x
print((""YES"", ""NO"")[all(x & s & ~t for x in a)])
",O(n ^ 2)
"n=int(input())
a=b=[]
k=0
for _ in range(n):
	a.append(input())
for i in range(n):
	t=input()
	if t in a:
		a.remove(t)
print(len(a))",O(n)
"class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        res = 0

        def dfs(root):
            nonlocal res

            if not root:
                return 0
            left = dfs(root.left)
            right = dfs(root.right)
            res = max(res, left + right)

            return 1 + max(left, right)

        dfs(root)
        return res
",O(n)
"class Solution2(object):
    def sumCounts(self, nums):
        MOD = 10**9+7
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=None,
                         query_fn=lambda x, y: y if x is None else x if y is None else (x+y)%MOD,
                         update_fn=lambda x, y: y if x is None else (x+y)%MOD):
                self.tree = [None]*(1<<((N-1).bit_length()+1))
                self.base = len(self.tree)>>1
                self.lazy = [None]*self.base
                self.query_fn = query_fn
                self.update_fn = update_fn
                if build_fn is not None:
                    for i in range(self.base, self.base+N):
                        self.tree[i] = build_fn(i-self.base)
                    for i in reversed(range(1, self.base)):
                        self.tree[i] = query_fn(self.tree[i<<1], self.tree[(i<<1)+1])
                self.count = [1]*len(self.tree) 
                for i in reversed(range(1, self.base)): 
                    self.count[i] = self.count[i<<1] + self.count[(i<<1)+1]

            def __apply(self, x, val):
                self.tree[x] = self.update_fn(self.tree[x], val*self.count[x]) 
                if x < self.base:
                    self.lazy[x] = self.update_fn(self.lazy[x], val)

            def __push(self, x):
                for h in reversed(range(1, x.bit_length())):
                    y = x>>h
                    if self.lazy[y] is not None:
                        self.__apply(y<<1, self.lazy[y])
                        self.__apply((y<<1)+1, self.lazy[y])
                        self.lazy[y] = None

            def update(self, L, R, h): 
                def pull(x):
                    while x > 1:
                        x >>= 1
                        self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1])
                        if self.lazy[x] is not None:
                            self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]*self.count[x]) 

                L += self.base
                R += self.base
                L0, R0 = L, R
                while L <= R:
                    if L & 1: 
                        self.__apply(L, h)
                        L += 1
                    if R & 1 == 0: 
                        self.__apply(R, h)
                        R -= 1
                    L >>= 1
                    R >>= 1
                pull(L0)
                pull(R0)

            def query(self, L, R):
                if L > R:
                    return None
                L += self.base
                R += self.base
                self.__push(L)
                self.__push(R)
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L >>= 1
                    R >>= 1
                return self.query_fn(left, right)

        result = accu = 0
        sl = {}
        st = SegmentTree(len(nums))
        for i in range(len(nums)):
            j = sl[nums[i]] if nums[i] in sl else -1
            accu = (accu+((i-j)+2*max(st.query(j+1, i), 0)))%MOD
            result = (result+accu)%MOD
            st.update(j+1, i, 1) 
            sl[nums[i]] = i
        return result",O(nlogn)
"class Solution(object):
    def mctFromLeafValues(self, arr):
        result = 0
        stk = [float(""inf"")]
        for x in arr:
            while stk[-1] <= x:
                result += stk.pop() * min(stk[-1], x)
            stk.append(x)
        while len(stk) > 2:
            result += stk.pop() * stk[-1]
        return result",O(n)
"import itertools



class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def getTargetCopy(self, original, cloned, target):
        def preorder_gen(node):
            stk = [node]
            while stk:
                node = stk.pop()
                if not node:
                    continue
                yield node
                stk.append(node.right)
                stk.append(node.left)
            
        for node1, node2 in zip(preorder_gen(original),
                                           preorder_gen(cloned)):
            if node1 == target:
                return node2",O(n)
"n,k = map(int,input().split())
if(k - n >= n) :
    print(0)
    exit()
if(k <= n):
    if(k%2):
         print(k//2)
    else :
        print(k//2-1)
else:
    print(n-k//2)",O(1)
"from math import factorial
s=input().rstrip()
s1=input().rstrip()
pos1=0
pos=0
posi=0
negi=0
posi1=0
negi1=0
ques1=0
for i in s:
    if i=='+':
        pos+=1
        posi+=1

    else:
        pos-=1
        negi+=1
for i in s1:
    if i=='+':
        posi1+=1
    elif i=='-':
        negi1+=1
    else:
        ques1+=1
if posi==posi1 and negi==negi1:
    print(1)
    exit()
diff1=posi-posi1
diff=negi-negi1
if diff<0  or diff1<0:
    print(0)
else:
    outcomes=2**ques1
    nume=factorial(ques1)
    deno=factorial(ques1-diff1)*factorial(diff1)
    fav1=nume/deno
    ques1=ques1-diff1
    num1=factorial(ques1)
    deno1=factorial(ques1-diff)*factorial(diff)
    fav2=num1/deno1
    ans=fav1*fav2
    print(ans/outcomes)
",np
"class Solution(object):
    def bestRotation(self, A):
        N = len(A)
        change = [1] * N
        for i in range(N):
            change[(i-A[i]+1)%N] -= 1
        for i in range(1, N):
            change[i] += change[i-1]
        return change.index(max(change))",O(n)
"class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        stones = [-s for s in stones]
        heapq.heapify(stones)

        while len(stones) > 1:
            first = heapq.heappop(stones)
            second = heapq.heappop(stones)
            if second > first:
                heapq.heappush(stones, first - second)

        stones.append(0)
        return abs(stones[0])
",O(nlogn)
"import os, sys
from io import BytesIO, IOBase

def main():
    n = rint()
    deg, edges = [0] * n, rints_2d(n - 1)
    for u, v in edges:
        deg[u - 1] += 1
        deg[v - 1] += 1

    coun = [0, deg.count(1), deg.count(2)]

    if n - coun[1] == 1:
        print(f'Yes\n{n - 1}')
        [print(*x) for x in edges]

    elif coun[1] + coun[2] == n:
        print(f'Yes\n1\n{deg.index(1) + 1} {n - deg[::-1].index(1)}')

    elif n - sum(coun) == 1:
        for i in range(n):
            if deg[i] > 2:
                print(f'Yes\n{deg[i]}')
                for j in range(n):
                    if deg[j] == 1:
                        print(i + 1, j + 1)
                exit()
    else:
        print('No')

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [rstr() for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",O(n)
"import bisect


class Solution(object):
    def findRightInterval(self, intervals):
        sorted_intervals = sorted((interval.start, i) for i, interval in enumerate(intervals))
        result = []
        for interval in intervals:
            idx = bisect.bisect_left(sorted_intervals, (interval.end,))
            result.append(sorted_intervals[idx][1] if idx < len(sorted_intervals) else -1)
        return result",O(nlogn)
"import math
n,r=map(int,input().split())
print(r/( 1/math.cos(math.pi*(n-2)/2/n)-1))",O(1)
"def roll(i,j):
    ways = []
    if j:
        ways.append(2*hor[i][j-1] + grid[i][j-1])
    if m-1-j:
        ways.append(2*hor[i][j] + grid[i][j+1])
    if i:
        ways.append(2*ver[i-1][j] + grid[i-1][j])
    if n-1-i:
        ways.append(2*ver[i][j] + grid[i+1][j])
    return min(ways)

n , m , k = map(int, input().split())
hor = [list(map(int, input().split())) for _ in range(n)]
ver = [list(map(int, input().split())) for _ in range(n-1)]

grid = [[0]*m for _ in range(n)]
if k%2:
    for _ in range(n):
        print("" "".join([""-1""]*m))
else:
    for _ in range(k//2):
        new_grid = [[roll(i,j) for j in range(m)] for i in range(n)]
        grid = new_grid[:]
    for i in range(n):
        print("" "".join(map(str,grid[i])))",O(n ^ 3)
"class Solution(object):
    def longestWPI(self, hours):
        result, accu = 0, 0
        lookup = {}
        for i, h in enumerate(hours):
            accu = accu+1 if h > 8 else accu-1
            if accu > 0:
                result = i+1
            elif accu-1 in lookup:
                result = max(result, i-lookup[accu-1])
            lookup.setdefault(accu, i)
        return result",O(n)
"class Solution(object):
    def flipLights(self, n, m):
        if m == 0:
            return 1
        if n == 1:
            return 2
        if m == 1 and n == 2:
            return 3
        if m == 1 or n == 2:
            return 4
        if m == 2:
            return 7
        return 8",O(1)
"import collections
import sys

def can_win(i, dp):
    if i in dp:
        return dp[i]
    else:
        for next in possible[i]:
            if not can_win(next, dp):
                dp[i] = True
                return True
        dp[i] = False
        return False

data = sys.stdin.readlines()
nb = int(data[0])
nums = data[1].split(' ')
nums = [int(c) for c in nums]
possible = [[] for _ in range(nb)]
for i in range(nb):
    if nums[i] == 1:
        possible[i] = [k for k in range(nb) if k != i]
    else:
        for j in range(i+nums[i], nb, nums[i]):
            if nums[j] > nums[i]:
                possible[i].append(j)
        for j in range(i-nums[i], -1, -nums[i]):
            if nums[j] > nums[i]:
                possible[i].append(j)

res = """"
dp = {}
for i in range(nb):
    if can_win(i, dp):
        res += ""A""
    else:
        res += ""B""
print(res)
",O(n ^ 2)
"k=int(input())
a=[]
for i in range(0,12):
    s=9*pow(10,i)*(i+1)
    if k<=s:
        break
    else:
        k-=s
pos=i+1
num=(pow(10,pos-1)+(k//pos)-1)
if k%pos==0:
    print(str(num)[-1])
else:
    print(str(num+(0 if pos==1 else 1))[(k%pos)-1])
",O(1)
"from collections import deque as de
import math
from sys import stdin, stdout
import re
from collections import Counter as cnt
from functools import  reduce

from itertools import groupby as gb

from bisect import bisect_left as bl, bisect_right as br

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))

class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()

def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def binarytodecimal(n):
    return int(n,2)

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))
    return prime_factors

def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def getProduct(n):

    product = 1

    while (n != 0):
        product = product * (n % 10)
        n = n // 10

    return product

def lcm(x,y):
   lcm = (x*y)//math.gcd(x,y)
   return lcm

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

def checkisap(list):
    d=list[1]-list[0]
    for i in range(2,len(list)):
        temp=list[i]-list[i-1]
        if temp !=d:
            return False
    return True

def ceildiv(x,y):
    return (x+y-1)//y

def di():return map(int, input().split())
def ii():return int(input())
def li():return list(map(int, input().split()))
def si():return list(map(int, input()))
def indict():
    dic = {}
    for index, value in enumerate(input().split()):
        dic[int(index)+1] = int(value)
    return dic
def frqdict():

    dic={}
    for index, value in enumerate(input().split()):
        if int(value) not in dic:
            dic[int(value)] =1
        else:
            dic[int(value)] +=1
    return dic

n,pos, l, r=di()
if l==1 and r==n:
    print(0)
else:
    if pos < l:
        ans=l-pos+1
        if r <n:
            ans+=(r-l)
            ans+=1
        print(ans)
    elif l<=pos<=r:
        if l >1 and r<n:
            ans=(r-l)
            ans+=min(pos-l,r-pos)
            ans+=2
        elif l>1 and r==n:
            ans=pos-l
            ans+=1
        else:
            ans=r-pos
            ans+=1
        print(ans)

    else:
        ans=pos-r+1
        if l>1:
            ans+=(r-l)
            ans+=1
        print(ans)
",O(1)
"def max1(a,b):
    if a>=b:
        return a,b
    else:
        return  b,a
def minus(a,b):
    p=a//b
    cnt=p
    return b,(a-(b*cnt)),cnt
n=int(input())
for _ in range(n):
    a,b=input().split()
    a=int(a)
    b=int(b)
    cnt=0

    while a>0 and b>0:
        a,b=max1(a,b)
        a,b,p=minus(a,b)
        cnt+=p

    print(cnt)
",O(1)
"n = int(input())
s = input()
t = input()
pair2ind = {}
letters_s = [0] * 26
letters_t = [0] * 26
non_common = set()
cnt = 0
for i in range(n):
    if s[i] != t[i]:
        pair2ind[(s[i], t[i])] = i + 1
        letters_s[ord(s[i]) - ord('a')] = i + 1
        letters_t[ord(t[i]) - ord('a')] = i + 1
        non_common.add(i + 1)
        cnt += 1

sim = -1
for i in range(26):
    if letters_s[i] != 0 and letters_t[i] != 0:
        sim = letters_s[i]
        break
else:
    print(cnt)
    print(-1, -1)
    exit()

for i in range(n):
    if s[i] != t[i]:
        if (t[i], s[i]) in pair2ind:
            print(cnt - 2)
            print(pair2ind[(s[i], t[i])], pair2ind[(t[i], s[i])])
            exit()

non_common.remove(sim)
print(cnt - 1)
print(sim, letters_t[ord(s[sim-1]) - ord('a')])
exit()
",O(n)
"from sys import stdin
input = stdin.readline

def solve():
    n = int(input())
    x = [int(x) for x in input().split()]
    s = set(x)
    ans = [x[0]]
    for i in range(n):
        for j in range(0, 32):
            if x[i] + 2**j in s:
                ans = [x[i], x[i] + 2**j]
                if x[i] + (2**j * 2) in s:
                    ans.append(x[i] + (2**j * 2))
                    return ans
    return ans

ans = solve()
print(len(ans))
print(*ans)",O(nlogn)
"l, r = [{'0': 1, 'X': 0}[c] for cc in zip(input(), input()) for c in cc], 0
for i in range(0, len(l) - 3, 2):
    s = 7 - sum(l[i:i + 4])
    if s < 5:
        r += 1
        l[i:i + s] = [0] * s
print(r)",O(1)
"class Solution(object):
    def singleNumber(self, A):
        one, two = 0, 0
        for x in A:
            one, two = (~x & one) | (x & ~one & ~two), (~x & two) | (x & one)
        return one",O(n)
"import os
import sys
from io import BytesIO, IOBase

def main():
    n, k = map(int, input().split())
    print(n-int(((9+8*(n+k))**0.5-3)/2))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(logn)
"n = int(input())
m = int(input())

print(m % pow(2, n))
",O(1)
"from bisect import insort,bisect_right,bisect_left
from sys import stdout, stdin, setrecursionlimit
from heapq import heappush, heappop, heapify
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from string import *
from queue import *
from math import *
from re import *
from os import *

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
graph, mod, szzz =  {}, 10**9 + 7, lambda: sorted(zzz())
def getStr(): return input()
def getInt(): return int(input())
def listStr(): return list(input())
def getStrs(): return input().split()
def isInt(s): return '0' <= s[0] <= '9'
def input(): return stdin.readline().strip()
def zzz(): return [int(i) for i in input().split()]
def output(answer, end='\n'): stdout.write(str(answer) + end)
def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))

def getPrimes(N = 10**5):
    SN = int(sqrt(N))
    sieve = [i for i in range(N+1)]
    sieve[1] = 0
    for i in sieve:
        if i > SN:
            break
        if i == 0:
            continue
        for j in range(2*i, N+1, i):
            sieve[j] = 0
    prime = [i for i in range(N+1) if sieve[i] != 0]
    return prime
def primeFactor(n,prime=getPrimes()):
    lst = []
    mx=int(sqrt(n))+1
    for i in prime:
        if i>mx:break
        while n%i==0:
            lst.append(i)
            n//=i
    if n>1:
        lst.append(n)
    return lst

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]
daysInMounth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

a = getInt()
b = getInt()

arr = list(str(a))

arr = sorted(arr)
ans=''

while arr:
    for i in range(len(arr)-1,-1,-1):
        x=ans+arr[i]

        for j in arr[:i]:
            x+=j
        for j in arr[i+1:]:
            x+=j
        if int(x)<=b:
            ans+=arr[i]
            arr.pop(i)
            break

print(ans)",O(n ^ 3)
"def sum(num):

    return (num * (num + 1)) // 2

def sum_from_to(fromm, to):
    if fromm <= 1:
        return sum(to)
    return sum(to) - sum(fromm)

def min_splitters():
    start = 1
    end = k
    while start < end:
        mid = (start + end) // 2
        mid_val = sum_from_to(mid, k)
        if mid_val == n:
            return k - mid + 1
        elif mid_val > n:
            start = mid + 1
        else:
            end = mid
    return k - start + 1

n, k = (int(i) for i in input().split())

if n == 1:
    print(0)

elif n <= k:
    print(1)
else:
    k -= 1
    n -= 1

    if sum(k) < n:
        print(-1)
    else:
        print(min_splitters())
",O(logn)
"import collections


class Solution(object):
    def numberOfArithmeticSlices(self, A):
        result = 0
        dp = [collections.defaultdict(int) for i in range(len(A))]
        for i in range(1, len(A)):
            for j in range(i):
                diff = A[i]-A[j]
                dp[i][diff] += 1
                if diff in dp[j]:
                    dp[i][diff] += dp[j][diff]
                    result += dp[j][diff]
        return result",O(n ^ 2)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def checkTree(self, root):
        return root.val == root.left.val+root.right.val",O(1)
"n, l, r, x = map(int, input().split())
arr = list(map(int, input().split()))
res = 0
for j in range(1, 2**n):
    a = [arr[i] for i in range(n) if (((j >> i) & 1) == 1)]
    res += (max(a) - min(a) >= x and sum(a) >= l and sum(a) <= r)
print(res)
",np
"class Solution(object):
    def minSumOfLengths(self, arr, target):
        prefix, dp = {0: -1}, [0]*len(arr) 
        result = min_len = float(""inf"")
        accu = 0
        for right in range(len(arr)):
            accu += arr[right]
            prefix[accu] = right
            if accu-target in prefix:
                left = prefix[accu-target]
                min_len = min(min_len, right-left)
                if left != -1:
                    result = min(result, dp[left] + (right-left))
            dp[right] = min_len
        return result if result != float(""inf"") else -1",O(n)
"class Solution(object):
    def numSubseq(self, nums, target):
        MOD = 10**9 + 7
        nums.sort()
        result = 0
        left, right = 0, len(nums)-1
        while left <= right:
            if nums[left]+nums[right] > target:
                right -= 1
            else:
                result = (result+pow(2, right-left, MOD))%MOD
                left += 1
        return result",O(nlogn)
"from collections import deque, defaultdict, Counter
from itertools import product, groupby, permutations, combinations
from math import gcd, floor, inf, log2, sqrt, log10
from bisect import bisect_right, bisect_left
from statistics import mode
from string import ascii_uppercase

k = int(input()) -1

y = 9
x = 1
while k > x*y:
    k -= x*y
    y *= 10
    x += 1

start = 10**(x-1)
start += k//x

print(str(start)[k%x])
",O(logn)
"import collections


class Solution(object):
    def numberOfBoomerangs(self, points):
        result = 0

        for i in range(len(points)):
            group = collections.defaultdict(int)
            for j in range(len(points)):
                if j == i:
                    continue
                dx, dy =  points[i][0] - points[j][0], points[i][1] - points[j][1]
                group[dx**2 + dy**2] += 1

            for _, v in group.items():
                if v > 1:
                    result += v * (v-1)

        return result

    def numberOfBoomerangs2(self, points):
        cnt = 0
        for a, i in enumerate(points):
            dis_list = []
            for b, k in enumerate(points[:a] + points[a + 1:]):
                dis_list.append((k[0] - i[0]) ** 2 + (k[1] - i[1]) ** 2)
            for z in list(collections.Counter(dis_list).values()):
                if z > 1:
                    cnt += z * (z - 1)
        return cnt",O(n ^ 2)
"class Solution(object):
    def minimumScore(self, nums, edges):
        def is_ancestor(a, b):
            return left[a] <= left[b] and right[b] <= right[a]

        def iter_dfs():
            cnt = 0
            left = [0]*len(nums)
            right = [0]*len(nums)
            stk = [(1, (0, -1))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p = args
                    left[u] = cnt
                    cnt += 1
                    stk.append((2, (u, p)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        stk.append((1, (v, u)))
                elif step == 2:
                    u, p = args
                    for v in adj[u]:
                        if v == p:
                            continue
                        nums[u] ^= nums[v]
                    right[u] = cnt
            return left, right
                
        adj = [[] for _ in range(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        left, right = iter_dfs()
        result = float(""inf"")
        for i in range(1, len(nums)):
            for j in range(i+1, len(nums)):
                if is_ancestor(i, j):
                    a, b, c = nums[0]^nums[i], nums[i]^nums[j], nums[j]
                elif is_ancestor(j, i):
                    a, b, c = nums[0]^nums[j], nums[j]^nums[i], nums[i]
                else:
                    a, b, c = nums[0]^nums[i]^nums[j], nums[i], nums[j]
                result = min(result, max(a, b, c)-min(a, b, c))
        return result",O(n ^ 2)
"num=int(input())
list_=sorted(set(map(int,input().split())))
if len(list_)==1:
    print(""NO"")
else:

    print(list_[1])
",O(nlogn)
"class Solution(object):
    def checkSubarraySum(self, nums, k):
        count = 0
        lookup = {0: -1}
        for i, num in enumerate(nums):
            count += num
            if k:
                count %= k
            if count in lookup:
                if i - lookup[count] > 1:
                    return True
            else:
                lookup[count] = i

        return False",O(n)
"def Is_prime(n):
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

n = int(input())
for i in range(2, 100):
    if not Is_prime(i) and not Is_prime(n - i):
        print(i, n - i)
        break
",O(1)
"class Solution(object):
    def maxRectangleArea(self, points):
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] += val
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret += self.__bit[i]
                    i -= (i & -i)
                return ret
    
        points.sort()
        y_to_idx = {y:idx for idx, y in enumerate(sorted(set(y for _, y in points)))}
        bit = BIT(len(y_to_idx))
        lookup = {}
        result = -1
        for i, (x, y) in enumerate(points):
            y_idx = y_to_idx[y]
            bit.add(y_idx, +1)
            if not (i-1 >= 0 and points[i-1][0] == x):
                continue
            prev_y_idx = y_to_idx[points[i-1][1]]
            curr = bit.query(y_idx)-bit.query(prev_y_idx-1)
            if (prev_y_idx, y_idx) in lookup and lookup[prev_y_idx, y_idx][0] == curr-2:
                result = max(result, (x-lookup[prev_y_idx, y_idx][1])*(y-points[i-1][1]))
            lookup[prev_y_idx, y_idx] = (curr, x)
        return result",O(nlogn)
"n = int(input())

mult = 1
res = []
remain = n
while remain >0:
    if remain == 2:
        res.extend([mult, mult*2])
        remain = 0
    elif remain == 3:
        res.extend([mult, mult, mult *3])
        remain = 0
    else:
        half = remain // 2
        extra = remain - half
        res.extend([mult]*extra)
        remain  = half
        mult = mult *2
print(*res)
",O(logn)
"k, n, s, p = map(int, input().split())

paper_person = (n + s -1)//s

total_needed = paper_person * k

ans = (total_needed+p-1)//p

print(ans)
",O(1)
"from sys import stdin, stdout, exit

n = int(input())
a = list(map(int, stdin.readline().split()))

def z(winner):
    return 'sjfnb' if winner == 0 else 'cslnb'

a.sort()
dups = set(a)
if len(dups) < len(a) - 1:
    print(z(1))
    exit()

winner = 0
for i in range(n-1):
    if a[i] == a[i+1]:
        if a[i] == 0 or a[i]-1 in a:
            print(z(1))
            exit()
        winner = 1
        a[i] = a[i] - 1

s = sum(a)
final = n*(n-1) // 2
winner += (s - final) + 1
winner %= 2
print(z(winner))
",O(nlogn)
"import collections



class Solution(object):
    def minimumCost(self, start, target, specialRoads):
        start, target = tuple(start), tuple(target)
        adj = collections.defaultdict(list, {target:[]})
        for x1, y1, x2, y2, c in specialRoads:
            adj[x1, y1].append((x2, y2, c))
        dist = {start:0}
        lookup = set()
        while len(lookup) != len(dist):
            d, x1, y1 = min((dist[x1, y1], x1, y1) for x1, y1 in dist.keys() if (x1, y1) not in lookup)
            lookup.add((x1, y1))
            if (x1, y1) == target:
                return d
            for x2, y2, c in adj[x1, y1]:
                if not ((x2, y2) not in dist or dist[x2, y2] > d+c):
                    continue
                dist[x2, y2] = d+c
            for x2, y2 in adj.keys():
                if not ((x2, y2) not in dist or dist[x2, y2] > d+abs(x2-x1)+abs(y2-y1)):
                    continue
                dist[x2, y2] = d+abs(x2-x1)+abs(y2-y1)",O(n ^ 2)
"h,b = map(int,input().split())
x,y,z = map(int,input().split())
print(max(0,2*x+y-h)+max(0,3*z+y-b))",O(1)
"
import collections


class Solution(object):
    def fourSumCount(self, A, B, C, D):
        A_B_sum = collections.Counter(a+b for a in A for b in B)
        return sum(A_B_sum[-c-d] for c in C for d in D)

",O(n ^ 2)
"a = list(input())
b = list(input())
n = len(a)
a.sort()

def listtostring(string):
    return ''.join([str(ele) for ele in string])

for i in range(0,n):
    for j in range(0,n):
        t = a.copy()
        t[i],t[j] = t[j],t[i]
        if((int(listtostring(t)) >= int(listtostring(a))) and (int(listtostring(t))<= int(listtostring(b)))):

            a[i],a[j] = a[j],a[i]

print(listtostring(a))",O(n ^ 3)
"from sys import stdin

EPS = 1e-6
n = int(stdin.readline())
m = int(stdin.readline())
a = list(map(int, stdin.readline().split()))
b = list(map(int, stdin.readline().split()))
b.append(b[0])

def check(f):
    fuel_left = f
    total_weight = float(m + fuel_left)
    for i in range(n):
        cost = total_weight / a[i]
        fuel_left = fuel_left - cost
        total_weight = total_weight - cost

        cost = total_weight / b[i + 1]
        fuel_left = fuel_left - cost
        total_weight = total_weight - cost
        if fuel_left < 0:
            return False
    return True

def binary_search(left, right):
    mid = (left + right) / 2
    if abs(left - right) < EPS:
        return mid
    if check(mid):
        return binary_search(left, mid)
    else:
        return binary_search(mid, right)

res = binary_search(0, 1e9 + 1)
if res - 1e9 > EPS:
    print(-1)
else:
    print(""%.10f"" % res)
",O(n)
"index = int(input())

total = 9
n = 1

while index > total:
    total += (n + 1) * (10**n) * 9
    n += 1
last = 10**(n - 1)
total -= n * 9 * last
index = index - total

r = index % (n)
k = index // n

number = last + k

if r == 0:
    print(str(number - 1)[n-1])
else:
    print(str(number)[r - 1])
",O(logn)
"from sys import exit
t = input().split()[:3:]
s = set(t)
res = 3
if len(s)==1:
	res = min(res,0)
elif len(s)==2:
	res = min(res,1)
elif len(s)==3:
	res = min(res,2)
if res==0:
	print(res)
	exit(0)
t.sort()
m = [int(a[0]) for a in t if a[1]=='m']
p = [int(a[0]) for a in t if a[1]=='p']
s = [int(a[0]) for a in t if a[1]=='s']
def f(a):
	res = 2
	for i in a:
		if (i-1 in a and i+1 in a)or(i-2 in a and i-1 in a)or(i+1 in a and i+2 in a):
			return 0
		elif i-1 in a or i+1 in a or i-2 in a or i+2 in a:
			res = min(res,1)
	return res
res = min([res,f(m),f(p),f(s)])
print(res)",O(nlogn)
"import heapq



class Solution(object):
    def convertArray(self, nums):
        def f(nums):
            result = 0
            max_heap = []
            for x in nums:
                if max_heap and x < -max_heap[0]:
                    result += -heapq.heappop(max_heap)-x
                    heapq.heappush(max_heap, -x)
                heapq.heappush(max_heap, -x)
            return result
        
        return min(f(nums), f((x for x in reversed(nums))))",O(nlogn)
"class Solution(object):
    def largestMultipleOfThree(self, digits):
        lookup = {0: [],
                  1: [(1,), (4,), (7,), (2, 2), (5, 2), (5, 5), (8, 2), (8, 5), (8, 8)],
                  2: [(2,), (5,), (8,), (1, 1), (4, 1), (4, 4), (7, 1), (7, 4), (7, 7)]}
        count = collections.Counter(digits)
        for deletes in lookup[sum(digits)%3]:
            delete_count = collections.Counter(deletes)
            if all(count[k] >= v for k, v in delete_count.items()):
                for k, v in delete_count.items():
                    count[k] -= v
                break
        result = """".join(str(d)*count[d] for d in reversed(range(10)))
        return ""0"" if result and result[0] == '0' else result",O(n)
"def main():
    def solve():
        n = int(input())
        arr = sorted(map(int, input().split()))
        a = arr[-2]
        print(min(n - 2, a - 1))

    import sys
    input = sys.stdin.readline

    for _ in range(int(input())):
        solve()

    return 0

main()",O(nlogn)
"class Solution(object):
    def maxPartitionsAfterOperations(self, s, k):
        def popcount(n):
            n = (n & 0x55555555) + ((n >> 1) & 0x55555555)
            n = (n & 0x33333333) + ((n >> 2) & 0x33333333)
            n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F)
            n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF)
            n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF)
            return n

        left = [0]*(len(s)+1)
        left_mask = [0]*(len(s)+1)
        cnt = mask = 0
        for i in range(len(s)):
            mask |= 1<<(ord(s[i])-ord('a'))
            if popcount(mask) > k:
                cnt += 1
                mask = 1<<(ord(s[i])-ord('a'))
            left[i+1] = cnt
            left_mask[i+1] = mask
        right = [0]*(len(s)+1)
        right_mask = [0]*(len(s)+1)
        cnt = mask = 0
        for i in reversed(range(len(s))):
            mask |= 1<<(ord(s[i])-ord('a'))
            if popcount(mask) > k:
                cnt += 1
                mask = 1<<(ord(s[i])-ord('a'))
            right[i] = cnt
            right_mask[i] = mask

        result = 0
        for i in range(len(s)):
            curr = left[i]+right[i+1]
            mask = left_mask[i]|right_mask[i+1]
            if popcount(left_mask[i]) == popcount(right_mask[i+1]) == k and popcount(mask) != 26:
                curr += 3
            elif popcount(mask)+int(popcount(mask) != 26) > k: 
                curr += 2
            else:
                curr += 1
            result = max(result, curr)
        return result",O(n)
"class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if t == """":
            return """"

        countT, window = {}, {}
        for c in t:
            countT[c] = 1 + countT.get(c, 0)

        have, need = 0, len(countT)
        res, resLen = [-1, -1], float(""infinity"")
        l = 0
        for r in range(len(s)):
            c = s[r]
            window[c] = 1 + window.get(c, 0)

            if c in countT and window[c] == countT[c]:
                have += 1

            while have == need:
                if (r - l + 1) < resLen:
                    res = [l, r]
                    resLen = r - l + 1

                window[s[l]] -= 1
                if s[l] in countT and window[s[l]] < countT[s[l]]:
                    have -= 1
                l += 1
        l, r = res
        return s[l : r + 1] if resLen != float(""infinity"") else """"
",O(n)
"s1, s2 = input().split()
ans = s1[0]
for i in range(1, len(s1)):
    if s1[i] < s2[0]:ans += s1[i]
    else:break
print(ans + s2[0])",O(n)
"import sys
input = sys.stdin.readline

def main():
    n = int(input())
    if n % 2 == 1:
        print(""NO"")
        return
    n //= 2
    if n == int(n ** 0.5) ** 2:
        print(""YES"")
        return
    if n % 2 == 1:
        print(""NO"")
        return
    n //= 2
    if n == int(n ** 0.5) ** 2:
        print(""YES"")
        return
    print(""NO"")

for _ in range(int(input())):
    main()",O(1)
"def mp():
    return map(int, input().split())

def f(i):
    return (10 ** i - 10 ** (i - 1)) * i

n = int(input())

i = 1
sum = 0
while n - f(i) >= 0:
    n -= f(i)
    sum += f(i) // i
    i += 1

print(str(sum + (n + i - 1) // i)[n % i - 1])",O(logn)
"import sys,os,io
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_right , bisect_left

import math

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2

    for i in range(3,int(math.sqrt(n))+1,2):

        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))

def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res

def si():
    return input()

def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r

def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1

def ii():
    return int(input())

def li():
    return list(map(int,input().split()))

def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"")
    sys.stdout = open(""output.txt"",""w"")

t = 1
for _ in range(t):
    a = input()
    b = input()
    ans = [a]
    a = list(a)
    b1 = b[:]
    b = list(b)
    if (len(a)<len(b)):
        a.sort(reverse=True)
        print(''.join(a))
        continue
    arr = [0]*10
    for i in a:
        arr[int(i)]+=1
    f = 0
    for chota in range(len(b)):
        arr1 = arr[:]
        temp = b[:chota]

        for h in range(chota):
            if (arr1[int(b[h])]<=0):
                f = 1
                break
            else:
                arr1[int(b[h])]-=1

        if (f==1):
            break
        aa = []
        for j in range(int(b[chota])-1,-1,-1):

            if (arr1[j]>0):
                temp.append(str(j))
                arr1[j]-=1
                break
        for h in range(9,-1,-1):
            if (arr1[h]>0):
                temp+=[str(h)]*arr1[h]

        ans.append(''.join(temp))

    for i in ans:
        if (i<=b1):
            m = i
            break
    a.sort(reverse=True)
    ans.append(''.join(a))

    for i in ans:
        if (i<=b1):
            if (i>m):
                m = i
    print(m)
",O(n ^ 3)
"class Solution(object):
    def findErrorNums(self, nums):
        x_xor_y = 0
        for i in range(len(nums)):
            x_xor_y ^= nums[i] ^ (i+1)
        bit = x_xor_y & ~(x_xor_y-1)
        result = [0] * 2
        for i, num in enumerate(nums):
            result[bool(num & bit)] ^= num
            result[bool((i+1) & bit)] ^= i+1
        if result[0] not in nums:
            result[0], result[1] = result[1], result[0]
        return result",O(n)
"class Solution2(object):
    def countGoodNumbers(self, n):
        MOD = 10**9 + 7
        return pow(5, (n+1)//2%(MOD-1), MOD)*pow(4, n//2%(MOD-1), MOD) % MOD",O(logn)
"import os
import sys
from io import BytesIO, IOBase
from collections import Counter

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)

def lcm(a, b):
    return (a * b) / gcd(a, b)

def main():

    n=int(input())
    a=[]
    for i in range(n):
        a.append(list(map(int, input().split())))
    d={}
    if n==1:
        print('YES')
        return
    vis=[0]*n
    for i in range(1,n):
        num=abs(a[i][1]-a[0][1])
        den=abs(a[i][0]-a[0][0])
        k=1
        k=gcd(num, den)
        num//=k
        den//=k
        if ((a[i][1]-a[0][1])*(a[i][0]-a[0][0]))<0:
            num*=-1
        if (num, den) in d:
            d[(num, den)].append(i)
        else:
            d[(num, den)]=[i]
    maxx=0

    for i in d.keys():
        if len(d[i])>maxx:
            maxx=len(d[i])
            ki=i
    vis[0]=1
    for i in d[ki]:
        vis[i]=1
    t=[]
    for i in range(n):
        if not vis[i]:
            t.append(i)
    f=1
    if len(t)>1:
        num=abs(a[t[0]][1]-a[t[1]][1])
        den=abs(a[t[0]][0]-a[t[1]][0])
        k = 1
        k=gcd(num, den)
        num//=k
        den//=k
        if (a[t[0]][1]-a[t[1]][1])*(a[t[0]][0]-a[t[1]][0])<0:
            num*=-1
        m=(num, den)
        for i in range(2, len(t)):
            num = abs(a[t[i]][1] - a[t[0]][1])
            den = abs(a[t[i]][0] - a[t[0]][0])
            k=gcd(num, den)
            num //= k
            den //= k
            if (a[t[0]][1] - a[t[i]][1]) * (a[t[0]][0] - a[t[i]][0]) < 0:
                num *= -1
            if (num,den)!=m:
                f=0
    if f:
        print('YES')
    else:
        d = {}
        if n == 1:
            print('YES')
            return
        vis = [0] * n
        a[0], a[1]=a[1], a[0]
        for i in range(1, n):
            num = abs(a[i][1] - a[0][1])
            den = abs(a[i][0] - a[0][0])
            k = 1
            k = gcd(num, den)
            num //= k
            den //= k
            if ((a[i][1] - a[0][1]) * (a[i][0] - a[0][0])) < 0:
                num *= -1
            if (num, den) in d:
                d[(num, den)].append(i)
            else:
                d[(num, den)] = [i]
        maxx = 0

        for i in d.keys():
            if len(d[i]) > maxx:
                maxx = len(d[i])
                ki = i
        vis[0] = 1
        for i in d[ki]:
            vis[i] = 1
        t = []
        for i in range(n):
            if not vis[i]:
                t.append(i)
        f = 1
        if len(t) > 1:
            num = abs(a[t[0]][1] - a[t[1]][1])
            den = abs(a[t[0]][0] - a[t[1]][0])
            k = 1
            k=gcd(num, den)
            num //= k
            den //= k
            if (a[t[0]][1] - a[t[1]][1]) * (a[t[0]][0] - a[t[1]][0]) < 0:
                num *= -1
            m = (num, den)
            for i in range(2, len(t)):
                num = abs(a[t[i]][1] - a[t[0]][1])
                den = abs(a[t[i]][0] - a[t[0]][0])
                k = 1
                k=gcd(num, den)
                num //= k
                den //= k
                if (a[t[0]][1] - a[t[i]][1]) * (a[t[0]][0] - a[t[i]][0]) < 0:
                    num *= -1
                if (num, den) != m:
                    f = 0
        if f:
            print('YES')
        else:
            print('NO')

    return

if __name__ == ""__main__"":
    main()",O(nlogn)
"n = int(input())
print(3*n//2)",O(1)
"import bisect
import copy
import decimal
import fractions
import heapq
import itertools
import math
import random
import sys
from collections import Counter,deque,defaultdict
from functools import lru_cache,reduce
from heapq import heappush,heappop,heapify,heappushpop,_heappop_max,_heapify_max
def _heappush_max(heap,item):
    heap.append(item)
    heapq._siftdown_max(heap, 0, len(heap)-1)
def _heappushpop_max(heap, item):
    if heap and item < heap[0]:
        item, heap[0] = heap[0], item
        heapq._siftup_max(heap, 0)
    return item
from math import gcd as GCD
read=sys.stdin.read
readline=sys.stdin.readline
readlines=sys.stdin.readlines

class Prime:
    def __init__(self,N):
        assert N<=10**8
        self.smallest_prime_factor=[None]*(N+1)
        for i in range(2,N+1,2):
            self.smallest_prime_factor[i]=2
        n=int(N**.5)+1
        for p in range(3,n,2):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
                for i in range(p**2,N+1,2*p):
                    if self.smallest_prime_factor[i]==None:
                        self.smallest_prime_factor[i]=p
        for p in range(n,N+1):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]

    def Factorize(self,N):
        assert N>=1
        factorize=defaultdict(int)
        if N<=len(self.smallest_prime_factor)-1:
            while N!=1:
                factorize[self.smallest_prime_factor[N]]+=1
                N//=self.smallest_prime_factor[N]
        else:
            for p in self.primes:
                while N%p==0:
                    N//=p
                    factorize[p]+=1
                if N<p*p:
                    if N!=1:
                        factorize[N]+=1
                    break
                if N<=len(self.smallest_prime_factor)-1:
                    while N!=1:
                        factorize[self.smallest_prime_factor[N]]+=1
                        N//=self.smallest_prime_factor[N]
                    break
            else:
                if N!=1:
                    factorize[N]+=1
        return factorize

    def Divisors(self,N):
        assert N>0
        divisors=[1]
        for p,e in self.Factorize(N).items():
            A=[1]
            for _ in range(e):
                A.append(A[-1]*p)
            divisors=[i*j for i in divisors for j in A]
        return divisors

    def Is_Prime(self,N):
        return N==self.smallest_prime_factor[N]

    def Totient(self,N):
        for p in self.Factorize(N).keys():
            N*=p-1
            N//=p
        return N

    def Mebius(self,N):
        fact=self.Factorize(N)
        for e in fact.values():
            if e>=2:
                return 0
        else:
            if len(fact)%2==0:
                return 1
            else:
                return -1

N=int(readline())
A=list(map(int,readline().split()))
mod=10**9+7
m=max(A)
cnt=[0]*(m+1)
P=Prime(m)
for a,c in Counter(A).items():
    for aa in P.Divisors(a):
        cnt[aa]+=c
for i in range(1,m+1):
    cnt[i]=pow(2,cnt[i],mod)-1
    cnt[i]%=mod
for p in P.primes:
    for i in range(p,m+1,p):
        cnt[i//p]-=cnt[i]
        cnt[i//p]%=mod
ans=cnt[1]
print(ans)",np
"import os,sys,math
from io import BytesIO, IOBase
from collections import defaultdict,deque,OrderedDict
import bisect as bi
def yes():print('YES')
def no():print('NO')
def I():return (int(input()))
def In():return(map(int,input().split()))
def ln():return list(map(int,input().split()))
def Sn():return input().strip()
BUFSIZE = 8192

def find_gt(a, x):
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:
        return len(a)

def solve():
    n,m,k=In()
    rt,do=[[0]*m for i in range(n)],[[0]*m for i in range(n-1)]
    for i in range(n):
        z=list(In())
        for j in range(m-1):
            rt[i][j]=z[j]
    for i in range(n-1):
        z=list(In())
        for j in range(m):
            do[i][j]=z[j]

    dp=[[0]*m for i in range(n)]
    if k%2==1:
        for i in range(n):
            print(*[-1]*m)
        return
    k//=2
    for op in range(k):
        dp_next=[[P]*m for i in range(n)]
        for i in range(n):
            for j in range(m):
                ans=Inf
                if i!=0:
                    ans=min(ans,dp[i-1][j]+do[i-1][j])
                if j!=0:
                    ans=min(ans,dp[i][j-1]+rt[i][j-1])
                if i!=n-1:
                    ans = min( ans , dp[i+1][j]+do[i][j])
                if j!=m-1 :
                    ans=min( ans , dp[i][j+1]+rt[i][j])
                dp_next[i][j]=ans

        for i in range(n):
            for j in range(m):
                dp[i][j]=dp_next[i][j]

    for i in range(n):
        for j in range(m):
            print(2*dp[i][j],end=' ')
        print()

def main():
    T=1
    for i in range(T):
        solve()

M = 998244353
P = 1000000007
Inf=float('inf')

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

def print(*args, **kwargs):

    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()

if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(n ^ 3)
"import collections


class Solution(object):
    def subarraysWithMoreZerosThanOnes(self, nums):
        MOD = 10**9+7

        lookup = collections.defaultdict(int)
        lookup[0] = 1
        result = total = same = more = 0
        for x in nums:
            total += 1 if x == 1 else -1
            new_same = lookup[total]
            new_more = (same+more+1)%MOD if x == 1 else (more-new_same)%MOD
            lookup[total] += 1
            result = (result+new_more)%MOD
            same, more = new_same, new_more
        return result",O(n)
"t = int(input())

def get_max(n):
    ans = 0
    while n:
        ans = 4 * ans + 1
        n = n - 1
        if ans > 10**19:
            break
    return ans

for _ in range(t):
    n, k = map(int, input().split())
    if n == 1:
        if k == 1:
            print(""YES 0"")
        else:
            print(""NO"")
    elif n == 2:
        if k <= 2:
            print(""YES 1"")
        elif k != 3 and k <= 5:
            print(""YES 0"")
        else:
            print(""NO"")
    else:
        siz = n - 1
        l = 1
        cnt = 3
        while siz:
            if l <= k < l+cnt:
                print(""YES {}"".format(siz))
                break
            l = l + cnt
            cnt = 2 * cnt + 1
            siz = siz - 1
        else:
            if k <= get_max(n):
                print(""YES 0"")
            else:
                print(""NO"")
",O(logn)
"from bisect import bisect_left

if __name__ == ""__main__"":
    n, m = map(int, raw_input().split())
    verticals = [int(raw_input()) for _ in range(n)]
    h = [map(int, raw_input().split()) for _ in range(m)]
    horizontals = [t[1] for t in h if t[0] == 1]

    verticals.sort()
    horizontals.sort()
    verticals.append(10**9)
    min_blockers = n + m
    for i, v in enumerate(verticals):
        cur_blockers = len(horizontals) - bisect_left(horizontals, v) + i
        min_blockers = min(min_blockers, cur_blockers)

    print(min_blockers)
",O(nlogn)
"M = 10**9 + 7
R = lambda: map(int, input().split())
x,k = R()
if x == 0:
    print(0)
    quit()
print(((pow(2,k+1,M)*x)%M - pow(2,k,M) +1 ) % M)",O(logn)
"class Solution(object):
    def checkIfPrerequisite(self, n, prerequisites, queries):
        def floydWarshall(n, graph): 
            reachable = set([x[0]*n+x[1] for x in graph]) 
            for k in range(n): 
                for i in range(n): 
                    for j in range(n): 
                        if i*n+j not in reachable and (i*n+k in reachable and k*n+j in reachable):
                            reachable.add(i*n+j)
            return reachable

        reachable = floydWarshall(n, prerequisites)
        return [i*n+j in reachable for i, j in queries]",O(n ^ 3)
"class Solution2(object):
    def recoverFromPreorder(self, S):
        def recoverFromPreorderHelper(S, level, i):
            j = i[0]
            while j < len(S) and S[j] == '-':
                j += 1 
            if level != j - i[0]:
                return None
            i[0] = j
            while j < len(S) and S[j] != '-':
                j += 1
            node = TreeNode(int(S[i[0]:j]))
            i[0] = j
            node.left = recoverFromPreorderHelper(S, level+1, i)
            node.right = recoverFromPreorderHelper(S, level+1, i)
            return node

        return recoverFromPreorderHelper(S, 0, [0])",O(n)
"class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        n = len(gas)

        for i in range(n):
            tank = gas[i] - cost[i]
            if tank < 0:
                continue
            j = (i + 1) % n
            while j != i:
                tank += gas[j]
                tank -= cost[j]
                if tank < 0:
                    break
                j += 1
                j %= n
            if j == i:
                return i
        return -1
",O(n ^ 2)
"n, m = map(int, input().split())
s = 0
while m:
    s += n // m
    n, m = m, n % m
print(s)",O(1)
"class Solution(object):
    def rob(self, root):
        def robHelper(root):
            if not root:
                return (0, 0)
            left, right = robHelper(root.left), robHelper(root.right)
            return (root.val + left[1] + right[1], max(left) + max(right))

        return max(robHelper(root))",O(n)
"import itertools


class Solution(object):
    def gridGame(self, grid):
        result = float(""inf"")
        left, right = 0, sum(grid[0])
        for a, b in zip(grid[0], grid[1]):
            right -= a
            result = min(result, max(left, right))
            left += b
        return result",O(n)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a+b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

prime = [True for i in range(10)]
pp=[0]*10
def SieveOfEratosthenes(n=10):
    p = 2
    c=0
    while (p * p <= n):

        if (prime[p] == True):
            c+=1
            for i in range(p, n+1, p):
                pp[i]+=1
                prime[i] = False
        p += 1

def binarySearch(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[n-1]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] >= key):
            res=arr[mid]
            right = mid-1
        else:
            left = mid + 1
    return res

def binarySearch1(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[0]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] > key):
            right = mid-1
        else:
            res=arr[mid]
            left = mid + 1
    return res

n,m=map(int,input().split())
l=[]
tot=[]
done=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    l.append(input())
colsum=[[0 for i in range(m)]for j in range(n)]
rowsum=[[0 for i in range(m)]for j in range(n)]
col=[[0 for i in range(m)]for j in range(n)]
row=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            rowsum[i][j]=1
            colsum[i][j]=1
            row[i][j]=1
            col[i][j]=1
for i in range(n):
    for j in range(1,m):
        if l[i][j]=='.':
            continue
        rowsum[i][j]+=rowsum[i][j-1]
for i in range(n):
    for j in range(m-2,-1,-1):
        if l[i][j]=='.':
            continue
        row[i][j]+=row[i][j+1]
for i in range(m):
    for j in range(n-2,-1,-1):
        if l[j][i]=='.':
            continue
        col[j][i]+=col[j+1][i]
for i in range(m):
    for j in range(1,n):
        if l[j][i]=='.':
            continue
        colsum[j][i]+=colsum[j-1][i]
def check(x,y):
    i=x
    j=y
    ans=min(row[i][j],rowsum[i][j],colsum[i][j],col[i][j])-1
    if ans==0:
        return []
    return [ans]
h=[[0 for i in range(m+1)]for j in range(n)]
v=[[0 for i in range(m)]for j in range(n+1)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            ans=check(i,j)
            for j1 in ans:
                tot.append([i+1,j+1,j1])
                h[i][j-j1]+=1
                h[i][j+j1+1]-=1
                v[i-j1][j]+=1
                v[i+j1+1][j]-=1
for i in range(n):
    for j in range(1,m):
        h[i][j]+=h[i][j-1]
for i in range(m):
    for j in range(1,n):
        v[j][i]+=v[j-1][i]

for i in range(n):
    for j in range(m):
        if l[i][j]=='*' and h[i][j]==0 and v[i][j]==0:
            print(-1)
            sys.exit(0)
print(len(tot))
for i in tot:
    print(*i)",O(n ^ 2)
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
import bisect
T = int(input())
r = 1

prime = [2]

for i in range(3,4*10**3,2):
    flag = False
    if i%2==0: continue
    for j in range(3,int(i**0.5)+1,2):
        if i%j==0:
            flag = True
            break
    if not flag:  prime.append(i)

def primefactor(num):

    index = 0
    output = []

    while num>=prime[index]**2:

        times = 0
        while num%prime[index]==0:
            num = num // prime[index]
            times += 1
        if times&1:  output.append(prime[index])
        index += 1

    if num>1: output.append(num)

    return tuple(output)

while r<=T:
    n,k = map(int,input().split())

    arr = list(map(int,input().split()))

    seg = 1
    fact = {}
    left = [[0 for j in range(k+1)] for i in range(n)]
    dp = [[300000 for j in range(k+1)] for i in range(n)]

    stack = [0]
    for i in range(n):
        factor = primefactor(arr[i])
        if factor in fact:
            bisect.insort(stack,fact[factor]+1)

        fact[factor] = i

        for j in range(k+1):
            if j<len(stack):  left[i][j] = stack[-j-1]

    for i in range(n):
        for j in range(k+1):
            for t in range(j+1):
                l = left[i][t]
                if l>0:
                    dp[i][j] = min(dp[l-1][j-t] + 1, dp[i][j])
                else:
                    dp[i][j] = 1

    print(dp[-1][-1])

    r += 1
",O(n ^ 3)
"import collections



class Solution(object):
    def medianOfUniquenessArray(self, nums):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def check(k):
            result = 0
            cnt = collections.Counter()
            left = 0
            for right in range(len(nums)):
                cnt[nums[right]] += 1
                while len(cnt) == k+1:
                    cnt[nums[left]] -= 1
                    if cnt[nums[left]] == 0:
                        del cnt[nums[left]]
                    left += 1
                result += right-left+1
            return result >= total-result

        total = (len(nums)+1)*len(nums)//2
        return binary_search(1, len(set(nums)), check)",O(nlogn)
"n,k=list(map(int,input().split()))
arr=list(map(int,input().split()))
newarr=[0]

for num in arr:
  newarr+=[newarr[-1]^num]
dic={}
for num in newarr:
  x=(min(num,2**k-1-num),max(num,2**k-1-num))
  if x in dic:
    dic[x]+=1
  else:
    dic[x]=1
ans=0
for elem in dic:
  m=dic[elem]
  half=m//2
  ans+=half*(half-1)/2
  half=m-half
  ans+=half*(half-1)/2
ans=n*(n+1)/2-ans
print(int(ans))
",O(n)
"class Solution(object):
    def threeEqualParts(self, A):
        total = sum(A)
        if total % 3 != 0:
            return [-1, -1]
        if total == 0:
            return [0, len(A)-1]

        count = total//3
        nums = [0]*3
        c = 0
        for i in range(len(A)):
            if A[i] == 1:
                if c % count == 0:
                    nums[c//count] = i
                c += 1

        while nums[2] != len(A):
            if not A[nums[0]] == A[nums[1]] == A[nums[2]]:
                return [-1, -1]
            nums[0] += 1
            nums[1] += 1
            nums[2] += 1
        return [nums[0]-1, nums[1]]",O(n)
"import sys
input = sys.stdin.buffer.readline
n,m=map(lambda x:int(x), input().split())
A = []
for _ in range(n):
    scores = list(map(lambda x:int(x), input().split()))
    A.append(scores)

def solve(n,m,A):

    ans = ()
    nstats = 2**m
    def judge(finalScore):
        nonlocal ans
        seen = {}
        for i,scores in enumerate(A):
            sta = 0
            for e in scores:
                sta=sta*2+(e>=finalScore)

            seen[sta]=i

        for i in range(nstats):
            for j in range(nstats):
                if ((i|j) == nstats-1) and i in seen and j in seen:
                    ans = (seen[i], seen[j])
                    return True

        return False

    l=0
    r=2**31-1
    while l<r:
        m=l+(r-l)//2
        if not judge(m):
            r=m
        else:
            l=m+1

    print(ans[0]+1,ans[1]+1)

solve(n,m,A)
",np
"import sys

mod = 998244353
MAX_LENGTH = 20
bound = [0] * MAX_LENGTH

def mul(a, b): return (a * b) % mod
def add(a, b):
    a += b
    if a < 0: a += mod
    if a >= mod: a -= mod
    return a

def digitize(num):
    for i in range(MAX_LENGTH):
        bound[i] = num % 10
        num //= 10

def rec(smaller, start, pos, mask):
    global k
    if bit_count[mask] > k:
        return [0, 0]
    if pos == -1:
        return [0, 1]

    if dp[smaller][start][pos][mask][0] != -1:
        return dp[smaller][start][pos][mask]

    res_sum = res_ways = 0
    for digit in range(0, 10):
        if smaller == 0 and digit > bound[pos]:
            continue
        new_smaller = smaller | (digit < bound[pos])
        new_start = start | (digit > 0) | (pos == 0)
        new_mask = (mask | (1 << digit)) if new_start == 1 else 0

        cur_sum, cur_ways = rec(new_smaller, new_start, pos - 1, new_mask)
        res_sum = add(res_sum, add(mul(mul(digit, ten_pow[pos]), cur_ways), cur_sum))
        res_ways = add(res_ways, cur_ways)

    dp[smaller][start][pos][mask][0], dp[smaller][start][pos][mask][1] = res_sum, res_ways
    return dp[smaller][start][pos][mask]

def solve(upper_bound):
    global dp
    dp = [[[[[-1, -1] for _ in range(1 << 10)] for _ in range(MAX_LENGTH)] for _ in range(2)] for _ in range(2)]
    digitize(upper_bound)
    ans = rec(0, 0, MAX_LENGTH - 1, 0)
    return ans[0]

inp = [int(x) for x in sys.stdin.read().split()]
l, r, k = inp[0], inp[1], inp[2]

bit_count = [0] * (1 << 10)
for i in range(1, 1 << 10): bit_count[i] = bit_count[i & (i - 1)] + 1
ten_pow = [1]
for i in range(MAX_LENGTH): ten_pow.append(mul(ten_pow[-1], 10))

print(add(solve(r), -solve(l - 1)))
",O(n ^ 3)
"import random

n = int(input())

vec = [list(map(int, input().rstrip('\n').split(' '))) for i in range(n)]

bo = 10**6

coef = [[1, 1, 0], [1, -1, 0], [-1, 1, 0], [-1, -1, 0],
[1, 0, 1], [1, 0, -1], [-1, 0, 1], [-1, 0, -1],
[0, 1, 1], [0, 1, -1], [0, -1, 1], [0, -1, -1]]

def lv(x):
	return (x[0]**2 + x[1]**2)**0.5

if n == 1:
	res = [1]
elif n == 2:
	if vec[0][0]*vec[1][0] + vec[0][1]*vec[1][1] <= 0:
		res = [1, 1]
	else:
		res = [1, -1]
else:
	res = [0 for i in range(n)]
	fer = [[vec[0], vec[1], vec[2]],[[0], [1], [2]]]
	for l in range(len(vec)-2):
		for j in coef:
			der = [0, 0]
			der[0] = j[0]*fer[0][0][0] + j[1]*fer[0][1][0] + j[2]*fer[0][2][0]
			der[1] = j[0]*fer[0][0][1] + j[1]*fer[0][1][1] + j[2]*fer[0][2][1]
			if lv(der) <= bo:
				ner = []
				for i in range(3):
					if j[i] != 0:
						ner.append(i)
				if len(fer[1][ner[0]]) == 1:
					res[fer[1][ner[0]][0]] = j[ner[0]]
				elif j[ner[0]] == -1:
					for k in fer[1][ner[0]]:
						res[k] *= -1
				fer[0][ner[0]] = der
				fer[1][ner[0]] += fer[1][ner[1]]
				if len(fer[1][ner[1]]) == 1:
					res[fer[1][ner[1]][0]] = j[ner[1]]
				elif j[ner[1]] == -1:
					for k in fer[1][ner[1]]:
						res[k] *= -1
				if l == len(vec)-3:
					del fer[0][ner[1]]
					del fer[1][ner[1]]
				else:
					fer[0][ner[1]] = vec[3+l]
					fer[1][ner[1]] = [3+l]
				break
	if fer[0][0][0]*fer[0][1][0] + fer[0][0][1]*fer[0][1][1] <= 0:
		if len(fer[1][0]) == 1:
			res[fer[1][0][0]] = 1
		if len(fer[1][1]) == 1:
			res[fer[1][1][0]] = 1
	else:
		if len(fer[1][0]) == 1:
			res[fer[1][0][0]] = -1
		elif len(fer[1][1]) == 1:
			res[fer[1][1][0]] = -1
		else:
			for k in fer[1][0]:
				res[k] *= -1
res1 = ''
for i in res:
	res1 += str(i)+' '
res1 = res1[:-1]
print(res1)",O(nlogn)
"class Solution(object):
    def rob(self, nums):
        last, now = 0, 0
        for i in nums:
            last, now = now, max(last + i, now)
        return now",O(n)
"class Solution2(object):
    def twoEggDrop(self, n):
        K = 2
        dp = [[float(""inf"") for j in range(n+1)] for _ in range(2)]
        dp[1] = [j for j in range(n+1)]
        for i in range(2, K+1):
            dp[i%2][0] = 0
            for j in range(1, n+1):
                for k in range(1, j+1):
                    dp[i%2][j] = min(dp[i%2][j], 1+max(dp[(i-1)%2][k-1], dp[i%2][j-k]))
        return dp[K%2][n]",O(1)
"import sys

input = sys.stdin.readline

from collections import deque

n,m,k = map(int,input().split())
p = [input().rstrip() for i in range(n)]
idx = {s:i for i,s in enumerate(p)}

def match(s):
    res = []
    for i in range(2**k):
        tmp = []
        for j in range(k):
            if i>>j & 1:
                tmp.append(s[j])
            else:
                tmp.append(""_"")
        res.append("""".join(tmp))
    return set(res)

edge = [[] for i in range(n)]
deg = [0]*n
for i in range(m):
    s,mt = input().rstrip().split()
    mt = int(mt)-1
    t = p[mt]
    M = match(s)
    if t in M:
        for nv in M:
            if nv!=t and nv in idx:
                nv = idx[nv]
                edge[mt].append(nv)
                deg[nv] += 1
    else:
        exit(print(""NO""))

deq = deque([v for v in range(n) if deg[v]==0])
res = []
while deq:
    v = deq.popleft()
    res.append(v+1)
    for nv in edge[v]:
        deg[nv] -= 1
        if deg[nv]==0:
            deq.append(nv)

if len(res)!=n:
    exit(print(""NO""))

print(""YES"")
print(*res)
",np
"l, r = map(int, input().split())
if r == l + 1 or r == l:
    print(-1)
elif l%2 == 0:
    print(l, l+1, l+2)
elif abs(r - l) >= 3:
    print(l+1, l+2, l+3)
else:
    print(-1)",O(1)
"import heapq


class Solution(object):
    def minRefuelStops(self, target, startFuel, stations):
        max_heap = []
        stations.append((target, float(""inf"")))

        result = prev = 0
        for location, capacity in stations:
            startFuel -= location - prev
            while max_heap and startFuel < 0:
                startFuel += -heapq.heappop(max_heap)
                result += 1
            if startFuel < 0:
                return -1
            heapq.heappush(max_heap, -capacity)
            prev = location

        return result",O(nlogn)
"class Solution(object):
    def maximumImportance(self, n, roads):
        def inplace_counting_sort(nums, reverse=False): 
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()

        degree = [0]*n
        for a, b in roads:
            degree[a] += 1
            degree[b] += 1
        inplace_counting_sort(degree)
        return sum(i*x for i, x in enumerate(degree, 1))",O(n)
"n = int(input())
print(1+2*((n-1)*n))
",O(1)
"import os,sys
from io import BytesIO, IOBase

def main():
    a,b,c,n = map(int,input().split())
    if a+b-c > n-1 or min(a,b) < c:
        print(-1)
    else:
        print(n-(a+b-c))

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(1)
"from sys import stdin
readline = stdin.readline
def readInt():
    return int(readline())
def readInts():
    return list(map(int,readline().split()))

n, m, k = readInts()

right = []
down = []

for i in range(n):
    row = readInts()
    right.append(row)

for i in range(n-1):
    row = readInts()
    down.append(row)

if k % 2 == 1:
    for _ in range(n):
        for _ in range(m):
            print(-1, end="" "")
        print()
    exit()

k //= 2

dp = [[[0 for _ in range(k+1)] for _ in range(m)] for _ in range(n)]

for l in range(k):
    for i in range(n):
        for j in range(m):
            dp[i][j][l+1] = float(""inf"")
            if i > 0:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i-1][j][l] + down[i-1][j])
            if j > 0:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i][j-1][l] + right[i][j-1])
            if i < n - 1:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i+1][j][l] + down[i][j])
            if j < m - 1:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i][j+1][l] + right[i][j])

for i in range(n):
    for j in range(m):
        print(2*dp[i][j][k], end="" "")
    print()
",O(n ^ 3)
"class Solution(object):
    def peopleAwareOfSecret(self, n, delay, forget):
        MOD = 10**9+7
        dp = [0]*forget
        dp[0] = 1
        for i in range(1, n):
            dp[i%forget] = ((dp[(i-1)%forget] if i-1 else 0)-dp[i%forget]+dp[(i-delay)%forget]) % MOD
        return sum(dp)%MOD",O(n)
"def solve(n, arr):
	s = sum(arr)
	if s == 0:
		return ""cslnb""

	n_num = {}

	for item in arr:
		if item in n_num:
			n_num[item] += 1
		else:
			n_num[item] = 1

	if 0 in n_num and n_num[0] >= 2:
		return 'cslnb'

	for key in n_num.keys():
		if n_num[key] >= 3:
			return ""cslnb""

	ind_pairs = []
	for key in n_num.keys():
		if n_num[key] == 2:
			ind_pairs.append(key)

	if len(ind_pairs) >= 2:
		return ""cslnb""
	elif len(ind_pairs) == 1 and (ind_pairs[0]-1) in n_num:
		return ""cslnb""
	else:

		sum_targ = n*(n-1) // 2

		dif_sum = s - sum_targ

		if dif_sum % 2 == 0:
			return ""cslnb""
		else:
			return ""sjfnb""

n = int(input())

arr = list(map(int, input().split()))
print(solve(n, arr))
",O(n)
"class Solution(object):
    def numWays(self, n, k):
        if n == 0:
            return 0
        elif n == 1:
            return k
        ways = [0] * 3
        ways[0] = k
        ways[1] = (k - 1) * ways[0] + k
        for i in range(2, n):
            ways[i % 3] = (k - 1) * (ways[(i - 1) % 3] + ways[(i - 2) % 3])
        return ways[(n - 1) % 3]",O(n)
"class Solution(object):
    def maximumProduct(self, nums, k):
        MOD = 10**9+7
        nums.sort()
        total = sum(nums)
        for i in reversed(range(len(nums))):
            if nums[i]*(i+1)-total <= k:
                break
            total -= nums[i]
        q, r = divmod(k+total, i+1)
        return (pow(q, (i+1)-r, MOD)*pow(q+1, r, MOD)*
                reduce(lambda x, y: x*y%MOD, (nums[j] for j in range(i+1, len(nums))), 1)) % MOD",O(nlogn)
"z,zz=input,lambda:list(map(int,z().split()))
zzz=lambda:[int(i) for i in stdin.readline().split()]
szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())
from string import *
from re import *
from collections import *
from queue import *
from sys import *
from collections import *
from math import *
from heapq import *
from itertools import *
from bisect import *
from collections import Counter as cc
from math import factorial as f
from bisect import bisect as bs
from bisect import bisect_left as bsl
from itertools import accumulate as ac
def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))
def prime(x):
    p=ceil(x**.5)+1
    for i in range(2,p):
        if (x%i==0 and x!=2) or x==0:return 0

    return 1
def dfs(u,visit,graph):
    visit[u]=True
    for i in graph[u]:
        if not visit[i]:
            dfs(i,visit,graph)

move,can=zz()
curr=0

for i in range(1,move+1):
    curr+=i
    if curr-(move-i)==can:
        print(move-i)
        break

else:
    print(0)
",O(logn)
"class Solution2(object):
    def minOperationsToMakeMedianK(self, nums, k):
        nums.sort()
        return (sum(max(nums[i]-k, 0) for i in range(len(nums)//2+1))+
                sum(max(k-nums[i], 0) for i in range(len(nums)//2, len(nums))))",O(nlogn)
"class Solution(object):
    def largestOddNumber(self, num):
        for i in reversed(range(len(num))):
            if int(num[i])%2:
                return num[:i+1]
        return """"",O(n)
"a, b = input().split()
li = []
for i in range(len(a)):
    li.append(a[:i + 1] + b[0])
li.sort()
print(li[0])
",O(n)
"n=input()
i=0
while(True):
    if (n-9*10**i*(i+1))<=0:
        break
    n-=9*10**i*(i+1)
    i+=1

a=n/(i+1)
b=n%(i+1)
if(b!=0):
    print(str(10**i+a)[b-1])
else:
    print(str(10**i+a-1)[-1])
",O(logn)
"import collections


class Solution2(object):
    def minReorder(self, n, connections):
        def dfs(n, lookup, graph, parent, u):
            result = (parent*n+u in lookup)
            for v in graph[u]:
                if v == parent:
                    continue
                result += dfs(n, lookup, graph, u, v)  
            return result

        lookup, graph = set(), collections.defaultdict(list)
        for u, v in connections:
            lookup.add(u*n+v)
            graph[v].append(u)
            graph[u].append(v) 
        return dfs(n, lookup, graph, -1, 0)",O(n)
"x, n = map(int, input().split())
MOD = 10**9 + 7
c = 4*x
if c == 0:
    ans = 0
elif n == 0:
    ans = 2 * x
else:
    ans = (((c - 2) * pow(2, n -1, MOD) + 1) + MOD) % MOD
print(ans % MOD)",O(logn)
"class Solution2(object):
    def constructFromPrePost(self, pre, post):
        def constructFromPrePostHelper(pre, pre_s, pre_e, post, post_s, post_e, post_entry_idx_map):
            if pre_s >= pre_e or post_s >= post_e:
                return None
            node = TreeNode(pre[pre_s])
            if pre_e-pre_s > 1:
                left_tree_size = post_entry_idx_map[pre[pre_s+1]]-post_s+1
                node.left = constructFromPrePostHelper(pre, pre_s+1, pre_s+1+left_tree_size, 
                                                       post, post_s, post_s+left_tree_size,
                                                       post_entry_idx_map)
                node.right = constructFromPrePostHelper(pre, pre_s+1+left_tree_size, pre_e,
                                                        post, post_s+left_tree_size, post_e-1,
                                                        post_entry_idx_map)
            return node

        post_entry_idx_map = {}
        for i, val in enumerate(post):
            post_entry_idx_map[val] = i
        return constructFromPrePostHelper(pre, 0, len(pre), post, 0, len(post), post_entry_idx_map)",O(n)
"class Solution(object):
    def minOperations(self, logs):
        result = 0
        for log in logs:
            if log == ""../"":
                if result > 0:
                    result -= 1
            elif log != ""./"":
                result += 1
        return result",O(n)
"for _ in range(1):
    n,s=map(int,input().split())

    lo=0
    hi=n
    ans=n +1
    while lo<=hi:
        mi=(lo+hi)>>1
        curr=sum(int(i) for i in str(mi))
        if mi-curr>=s:
            hi=mi-1
            ans=mi
        else:
            lo=mi+1
    print(n-ans+1)",O(logn)
"class Solution3(object):
    def findSecretWord(self, wordlist, master):
        def solve(H, possible):
            min_max_group, best_guess = possible, None
            for guess in possible:
                groups = [[] for _ in range(7)]
                for j in possible:
                    if j != guess:
                        groups[H[guess][j]].append(j)
                max_group = groups[0]
                if len(max_group) < len(min_max_group):
                    min_max_group, best_guess = max_group, guess
            return best_guess

        H = [[sum(a == b for a, b in zip(wordlist[i], wordlist[j]))
                  for j in range(len(wordlist))]
                  for i in range(len(wordlist))]
        possible = list(range(len(wordlist)))
        n = 0
        while n < 6:
            guess = solve(H, possible)
            n = master.guess(wordlist[guess])
            possible = [j for j in possible if H[guess][j] == n]",O(n ^ 2)
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()
def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

n,k=map(int,input().split())
a=list(map(int,input().split()))
dic=get_frequency(a)
ss=sorted(list(set(a)))
tobesubtracttion=0
for i in range(len(ss)-1):
    if ss[i+1] <= ss[i]+k:
        tobesubtracttion+=dic[ss[i]]
print(n-tobesubtracttion)
",O(nlogn)
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def removeElements(self, head, val):
        dummy = ListNode(float(""-inf""))
        dummy.next = head
        prev, curr = dummy, dummy.__next__

        while curr:
            if curr.val == val:
                prev.next = curr.__next__
            else:
                prev = curr

            curr = curr.__next__

        return dummy.__next__



",O(n)
"import os
import sys
from io import BytesIO,IOBase

def main():
    n,m,k = map(int,input().split())
    a = list(map(float,input().split()))
    tree = [[0]*n for _ in range(n)]
    for i in range(k):
        x,y,z = map(int,input().split())
        tree[x-1][y-1] = float(z)
    po = [1]
    while len(po) != n:
        po.append(po[-1]*2)
    dp = [[0]*(po[-1]*2) for _ in range(n)]
    for i in range(n):
        dp[i][po[i]] = a[i]
    for i in range(po[-1]*2):
        for j in range(n):
            if i&po[j]:
                for k in range(n):
                    if not (i&po[k]):
                        dp[k][i+po[k]] = max(dp[k][i+po[k]],dp[j][i]+a[k]+tree[j][k])
    ma = 0
    for i in range(po[-1]*2):
        if bin(i)[2:].count(""1"") == m:
            for j in range(n):
                ma = max(ma,dp[j][i])
    print(int(ma))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")

sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",np
"n = int(raw_input())
a = list(raw_input())
b = list(raw_input())

ans = 0

for i in range(n - 1):
    if a[i] == b[i]:
        continue
    if a[i + 1] == b[i + 1]:
        continue

    if a[i] == b[i + 1] and a[i + 1] == b[i]:
        a[i], a[i + 1] = a[i + 1], a[i]
        ans += 1

for i in range(n):
    ans += a[i] != b[i]

print(ans)
",O(n)
"import os,io
input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
n,m,k=map(int,input().split())
dist1=[]
for i in range(n):
  dist1.append(list(map(int,input().split())))
dist2=[]
for i in range(n-1):
  dist2.append(list(map(int,input().split())))
if k%2:
  print(' '.join(map(str,[-1]*(n*m))))
  exit()
k//=2
dp=[10**9]*((k+1)*n*m)
for i in range(n):
  for j in range(m):
    dp[i*m+j]=0
for t in range(k):
  r=(t+1)*n*m
  q=t*n*m
  for i in range(n):
    for j in range(m):
      if i<n-1:
        dp[r+(i+1)*m+j]=min(dp[r+(i+1)*m+j],dp[q+i*m+j]+2*dist2[i][j])
      if i>0:
        dp[r+(i-1)*m+j]=min(dp[r+(i-1)*m+j],dp[q+i*m+j]+2*dist2[i-1][j])
      if j<m-1:
        dp[r+i*m+j+1]=min(dp[r+i*m+j+1],dp[q+i*m+j]+2*dist1[i][j])
      if j>0:
        dp[r+i*m+j-1]=min(dp[r+i*m+j-1],dp[q+i*m+j]+2*dist1[i][j-1])
ans=[]
for i in range(n):
  for j in range(m):
    ans.append(dp[k*n*m+i*m+j])
print(' '.join(map(str,ans)))",O(n ^ 3)
"n,k=map(int,input().split())
print((-(-n*2//k))+(-(-n*5//k))+(-(-n*8//k)))
",O(1)
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        for i in range(len(nums)):
            if nums[i] == target:
                return i
        return -1
",O(n)
"from collections import defaultdict

n = int(raw_input())
t = defaultdict(list)
for _ in range(n - 1):
    u, v = map(int, raw_input().split())
    t[u].append(v)
    t[v].append(u)
a = list(map(int, raw_input().split()))
o = {a_: i for i, a_ in enumerate(a)}

i = 0
q = [1]
lv = {1: 0}
par = {1: 1}
while i < len(q):
    u = q[i]
    i += 1
    for v in t[u]:
        if v not in lv:
            lv[v] = lv[u] + 1
            q.append(v)
            par[v] = u

depths = defaultdict(list)
for x in a:
    depths[lv[x]].append(o[par[x]])

ans = a[0] == 1
if ans:
    for d in depths.values():
        if not all(d[i] <= d[i + 1] for i in range(len(d) - 1)):
            ans = False
            break

if ans:
    l = [lv[x] for x in a]
    ans = all(l[i] <= l[i + 1] for i in range(len(l) - 1))

print(('No', 'Yes')[ans])
",O(n)
"class Solution4(object):
    def lengthOfLIS(self, nums):
        val_to_idx = {num:i for i, num in enumerate(sorted(set(nums)))}
        st = SegmentTree(len(val_to_idx))
        for x in nums:
            st.update(val_to_idx[x], val_to_idx[x], st.query(0, val_to_idx[x]-1)+1 if val_to_idx[x] >= 1 else 1)
        return st.query(0, len(val_to_idx)-1) if len(val_to_idx) >= 1 else 0",O(nlogn)
"n = int(input())
a = list(map(int, input().split()))
q = (10 ** 6) * [-1]
pnt = -1
ans = ""YES""
for i in range(n):
    if pnt == -1:
        pnt += 1
        q[pnt] = a[i]
    else :
        if q[pnt] == a[i] or abs(q[pnt] - a[i]) % 2 == 0:
            q[pnt] = -1
            pnt -= 1
        else:
            pnt += 1
            q[pnt] = a[i]
if pnt > 0 :
    ans = ""NO""
print(ans)
",O(n)
"class Solution(object):
    def countPairs(self, nums, target):
        nums.sort()
        result = 0
        left, right = 0, len(nums)-1
        while left < right:
            if nums[left]+nums[right] < target:
                result += right-left
                left += 1
            else:
                right -= 1
        return result",O(nlogn)
"import math


class Solution(object):
    def minimumBoxes(self, n):
        h = int((6*n)**(1.0/3))  
        if h*(h+1)*(h+2) > 6*n:
            h -= 1
        n -= h*(h+1)*(h+2)//6
        d = int(math.ceil((-1+(1+8*n)**0.5)/2)) 
        return h*(h+1)//2 + d",O(1)
"import operator
from functools import reduce


class Solution(object):
    def nimGame(self, piles):
        return reduce(operator.xor, piles, 0)",O(n)
"def solve(x, y, n):
    return ""White"" if (x-1 + y-1) <= (n-x + n-y) else ""Black""

def main():
    n = int(input())
    x, y = [int(i) for i in input().split()]
    print(solve(x, y, n))

main()
",O(1)
"class Solution2(object):
    def maxSizeSlices(self, slices):
        def maxSizeSlicesLinear(slices, start, end):
            dp = [[0]*(len(slices)//3+1) for _ in range(3)]
            for i in range(start, end):
                for j in range(1, min(((i-start+1)-1)//2+1, len(slices)//3)+1):
                    dp[i%3][j] = max(dp[(i-1)%3][j], dp[(i-2)%3][j-1] + slices[i])
            return dp[(end-1)%3][len(slices)//3]
        
        return max(maxSizeSlicesLinear(slices, 0, len(slices)-1),
                   maxSizeSlicesLinear(slices, 1, len(slices)))",O(n ^ 2)
"import collections


class Solution(object):
    def findDuplicateSubtrees(self, root):
        def getid(root, lookup, trees):
            if not root:
                return -1
            node_id = lookup[root.val,
                             getid(root.left, lookup, trees),
                             getid(root.right, lookup, trees)]
            trees[node_id].append(root)
            return node_id

        trees = collections.defaultdict(list)
        lookup = collections.defaultdict()
        lookup.default_factory = lookup.__len__
        getid(root, lookup, trees)
        return [roots[0] for roots in trees.values() if len(roots) > 1]",O(n)
"from sys import stdin
n, m, a, b = map(int, stdin.readline().split())
x = n%m
print(min(a *(m-x), b*x))",O(n)
"import os,sys
from io import BytesIO, IOBase

from collections import deque, Counter,defaultdict as dft
from heapq import heappop ,heappush
from math import log,sqrt,factorial,cos,tan,sin,radians,log2,ceil,floor
from bisect import bisect,bisect_left,bisect_right
from decimal import *
import sys,threading
from itertools import permutations, combinations
from copy import deepcopy
input = sys.stdin.readline

ii = lambda: int(input())
si = lambda: input().rstrip()
mp = lambda: map(int, input().split())
ms=  lambda: map(str,input().strip().split("" ""))
ml = lambda: list(mp())
mf = lambda: map(float, input().split())

alphs = ""abcdefghijklmnopqrstuvwxyz""

def solve():
    n,m,k=map(int,input().split())
    dct={}
    global case
    case=0
    iput=[]
    for i in range(n):
        word=input()
        dct[word]=i+1
        iput.append(word)
    d=[[] for i in range(n+1)]
    size=[0]*(n+1)
    for _ in range(m):

        word,idx=input().split()
        idx=int(idx)
        temp=1
        w=iput[idx-1]

        for x in range(k):
            if w[x]!='_' and w[x]!=word[x]:
                temp=0
                print(""NO"")
                exit()
                break

        res=[]
        for i in range(1<<k):
            s="""".join([word[x] if i & (1<<x) ==0 else '_' for x in range(k)])

            if s in dct:
                j=dct[s]
                if j!=idx:
                    d[idx].append(j)
                    size[j]+=1

    st=[nd  for nd in range(1,n+1) if size[nd]==0]

    for i in st:

        for j in d[i]:
            size[j]-=1
            if size[j]==0:
                st.append(j)

    if len(st)==n:
        print(""YES"")
        print(*st)
    else:
        print(""NO"")

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

def print(*args, **kwargs):

    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()

if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    tc=1

    for i in range(tc):
    	solve()",np
"def summing(number):
    summa = 0
    while number > 0:
        summa += number % 10
        number = number // 10
    return summa

def result(n, s):
    z = min(s, n)
    while z <= n and z - summing(z) < s:
        z += 1
    return n - z + 1

a, b = [int(i) for i in input().split()]
print(result(a, b))
",O(logn)
"from sys import stdin

n, k = map(int, stdin.readline().split())
out = [['.'] * n for _ in range(4)]
if k & 1:
    out[1][n >> 1] = '
    k -= 1

for i in range(1, 3):
    l, r = 1, n - 2
    for j in range(1, n - 2):
        if k:
            k -= 1
            if j & 1:
                out[i][l] = '
                l += 1
            else:
                out[i][r] = '
                r -= 1

for i in range(1, 3):
    if k:
        k -= 1
        out[i][n >> 1] = '
print('YES\n%s' % ('\n'.join([''.join(x) for x in out])))
",O(n)
"import itertools



class Solution4(object):
    def beautifulPair(self, nums1, nums2):
        INF = float(""inf"")
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=lambda _: [-INF, -INF], 
                         query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),
                         update_fn=lambda x: x):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def query(self, L, R):
                if L > R:
                    return [-INF, -INF] 
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L //= 2
                    R //= 2
                return self.query_fn(left, right)

        def dist(a, b):
            if a > b:
                a, b = b, a
            return [abs(points[a][0]-points[b][0])+abs(points[a][1]-points[b][1]), a, b]

        points = [(i, j) for i, j in zip(nums1, nums2)]
        result = [INF]*3
        lookup = {}
        for i in reversed(range(len(points))):
            if points[i] in lookup:
                result = [0, (i, lookup[points[i]])]
            lookup[points[i]] = i
        if result[0] == 0:
            return result[1]
        order = list(range(len(points)))
        order.sort(key=lambda x: points[x][0])
        y_set = set(y for _, y in points)
        y_to_idx = {y:i for i, y in enumerate(sorted(y_set))}
        st1, st2 = SegmentTree(len(y_to_idx)), SegmentTree(len(y_to_idx))
        for i in order:
            j = -st1.query(0, y_to_idx[points[i][1]]-1)[1] 
            if j != INF:
                assert(points[j][1] < points[i][1])
                result = min(result, dist(i, j))
            st1.update(y_to_idx[points[i][1]], [points[i][0]+points[i][1], -i])
            j = -st2.query(y_to_idx[points[i][1]], len(y_to_idx)-1)[1] 
            if j != INF:
                assert(points[j][1] >= points[i][1])
                result = min(result, dist(i, j))
            st2.update(y_to_idx[points[i][1]], [points[i][0]-points[i][1], -i])
        return result[1:]",O(nlogn)
"c = 0
def backtracking(actuales,restantes,l,r,x):
    global c
    if sum(actuales)<=r and sum(actuales) >= l:
        if max(actuales)- min(actuales) >= x:
            c += 1
    if restantes:
        for i in range(len(restantes)):
            backtracking(actuales+[restantes[i]], restantes[i+1:],l,r,x)
    return 0
def main():
    n,l,r,x = input().split("" "")
    n,l,r,x = int(n), int(l), int(r), int(x)
    difficulties = input().split("" "")
    for i in range(len(difficulties)):
        difficulties[i] = int(difficulties[i])
    difficulties.sort()
    backtracking([],difficulties,l,r,x)
    global c
    return c

if __name__ == ""__main__"":
    print(main())",np
"class Solution(object):
    def maxIncreasingGroups(self, usageLimits):
        def inplace_counting_sort(nums, reverse=False): 
            if not nums:
                return
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()

        usageLimits = [min(x, len(usageLimits)) for x in usageLimits]
        inplace_counting_sort(usageLimits)
        result = curr = 0
        for x in usageLimits:
            curr += x
            if curr >= result+1:
                curr -= result+1
                result += 1
        return result",O(n)
"import os
import sys
from io import BytesIO, IOBase
import math
from queue import Queue
import collections
import itertools
import bisect
import heapq

import random

def main():
    pass

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while (n > 1):
        n //= 2
        p += 1
    return (p)

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n = n / i
    if n > 2:
        l.append(int(n))
    return (l)

def primeFactorsCount(n):
    cnt=0
    while n % 2 == 0:
        cnt+=1
        n = n // 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            cnt+=1
            n = n // i
    if n > 2:
        cnt+=1
    return (cnt)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)

def countcon(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if (s[i] == ch):
            c += 1
        else:
            break
    return (c)

def lis(arr):
    n = len(arr)
    lis = [1] * n
    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
    maximum = 0
    for i in range(n):
        maximum = max(maximum, lis[i])
    return maximum

def isSubSequence(str1, str2):
    m = len(str1)
    n = len(str2)
    j = 0
    i = 0
    while j < m and i < n:
        if str1[j] == str2[i]:
            j = j + 1
        i = i + 1
    return j == m

def maxfac(n):
    root = int(n ** 0.5)
    for i in range(2, root + 1):
        if (n % i == 0):
            return (n // i)
    return (n)

def p2(n):
    c = 0
    while (n % 2 == 0):
        n //= 2
        c += 1
    return c

def seive(n):
    primes = [True] * (n + 1)
    primes[1] = primes[0] = False
    i = 2
    while (i * i <= n):
        if (primes[i] == True):
            for j in range(i * i, n + 1, i):
                primes[j] = False
        i += 1
    pr = []
    for i in range(0, n + 1):
        if (primes[i]):
            pr.append(i)
    return pr

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p

def denofactinverse(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (pow(fac, m - 2, m))

def numofact(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (fac)

def sod(n):
    s = 0
    while (n > 0):
        s += n % 10
        n //= 10
    return s
x,k=map(int,input().split())
mod=1000000007
tp=pow(2,k+1,mod)
tp2=pow(2,k,mod)
ans=(tp*x-tp2+1)%mod
print(ans if x!=0 else 0)
",O(logn)
"import math
n=int(input())
print((math.floor(n/2)+1)*math.ceil(n/2))",O(n)
"def chnge(last,cap,ini=(0,0)):
    for i in range(ini[1],last[1]):
        fin[i][ini[0]:last[0]] = [cap]*(last[0]-ini[0])

x1,y1,x2,y2,x3,y3 = map(int,input().split())
a = (max(x1,y1),[x1,y1],""A"")
b = (max(x2,y2),[x2,y2],""B"")
c = (max(x3,y3),[x3,y3],""C"")
m = max(a[0],b[0],c[0])
fin = [[""*"" for i in range(m)] for j in range(m)]

if (x1*y1 + x2*y2 + x3*y3)!=m**2:
    print(-1)
else:
    l = sorted([a]+[b]+[c],reverse = True)
    l[0][1].sort(reverse=True)
    chnge(l[0][1],l[0][2])
    ini=[0,l[0][1][1]]
    last = l[1][1]
    if m in [ini[0]+last[0],ini[1]+last[1]] and (ini[0]+last[0]+ini[1]+last[1])<=2*m:
        last = [ini[0]+last[0],ini[1]+last[1]]
    else:
        last = [ini[0] + last[1], ini[1] + last[0]]
    chnge(last,l[1][2],ini)
    chr = l[2][2]
    print(m)
    for i in fin:
        print("""".join(i).replace(""*"",chr))",np
"N,L,H,d = map(int, input().split())

l = list(map(int, input().split()))
e = 0
for i in range(1 << N ):
    k = []
    for j in range(N):
        if i >> j & 1:
            k.append(l[j])
    if len(k)>0:
        maz = max(k)
        mins = min(k)
        sums = sum(k)
        if sums >= L and sums <=H:
            if maz - mins >=d:
                e+=1
print(e)",np
"def solve():
    n = int(input())
    max_degs = [int(x) for x in input().split()]

    B = [[i+1, x] for i, x in enumerate(max_degs) if x >= 2]
    S = [[i+1, x] for i, x in enumerate(max_degs) if x < 2]

    if 2 + sum(b - 2 for _, b in B) < len(S):
        print('NO')
        return

    print('YES', len(B) + min(len(S), 2) - 1)
    print(n-1)

    for k in range(len(B) - 1):
        i, x = B[k]
        i_n, _ = B[k+1]
        print(i, i_n)
        B[k][1] -= 1
        B[k+1][1] -= 1

    k = 0
    for i, (s_idx, _) in enumerate(S):
        if i == 0:
            print(B[0][0], s_idx)
            B[0][1] -= 1
        elif i == 1:
            print(B[-1][0], s_idx)
            B[-1][1] -= 1
        else:
            while B[k][1] == 0:
                k += 1
            print(B[k][0], s_idx)
            B[k][1] -= 1

solve()
",O(n)
"class Solution(object):
    def missingElement(self, nums, k):
        def missing_count(nums, x):
            return (nums[x]-nums[0]+1)-(x-0+1)

        def check(nums, k, x):
            return k > missing_count(nums, x)

        left, right = 0, len(nums)-1
        while left <= right: 
            mid = left + (right-left)//2
            if not check(nums, k, mid):
                right = mid-1
            else:
                left = mid+1
        assert(check(nums, k, right))
        return nums[right] + (k-missing_count(nums, right))",O(logn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def isBalanced(self, root):
        def getHeight(root):
            if root is None:
                return 0
            left_height, right_height = \
                getHeight(root.left), getHeight(root.right)
            if left_height < 0 or right_height < 0 or \
               abs(left_height - right_height) > 1:
                return -1
            return max(left_height, right_height) + 1
        return (getHeight(root) >= 0)",O(n)
"class Solution(object):
    def minimumPossibleSum(self, n, target):
        def arithmetic_progression_sum(a, d, n):
            return (a+(a+(n-1)*d))*n//2
    
        a = min(target//2, n)
        b = n-a
        return arithmetic_progression_sum(1, 1, a)+arithmetic_progression_sum(target, 1, b)",O(1)
"def GSB(x):
	counter=0
	while x!=0:
		counter+=1
		x=x>>1
	return counter

problems,minimum,maximum,difference=[int(x) for x in input().split()]
array=[int(x) for x in input().split()]
combinations=[int(x) for x in range(2**problems)]
total=0

for i in combinations:
	checker=[x for x in array]+['a']
	j=0
	z=GSB(i)
	check=1
	while j!=z and i!=0:
		if i&1==1:
			checker[j]='a'
			check+=1
		i=i>>1
		j+=1
	for i in range(check):
		checker.remove('a')
	checker.sort()
	if minimum<=sum(checker)<=maximum and len(checker)>=2 and checker[-1]-checker[0]>=difference:
		total+=1
print(total)",np
"print(0, 0, input())
",O(1)
"n = int(input())
s = input()
t = 0
mn = 0
for i in s:
    if i == '-':
        t-=1
    else:
        t+=1
    mn = min(mn, t)
print(-mn+t)",O(n)
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1

        while l < r:
            m = (l + r) // 2
            if nums[m] > nums[r]:
                l = m + 1
            else:
                r = m

        pivot = l
        l, r = 0, len(nums) - 1

        if target >= nums[pivot] and target <= nums[r]:
            l = pivot
        else:
            r = pivot - 1

        while l <= r:
            m = (l + r) // 2
            if nums[m] == target:
                return m
            elif nums[m] < target:
                l = m + 1
            else:
                r = m - 1

        return -1
",O(logn)
"import sys
n,m=map(int,input().split())
for i in range(n//2):
    for j in range(m):
        sys.stdout.write('{} {}\n'.format(*[i+1,j+1]))
        sys.stdout.write('{} {}\n'.format(*[n-i,m-j]))
if n%2:
    for j in range(m//2):
        sys.stdout.write('{} {}\n'.format(*[n//2+1,j+1]))
        sys.stdout.write('{} {}\n'.format(*[n//2+1,m-j]))
    if m%2:
        sys.stdout.write('{} {}\n'.format(*[n//2+1,m//2+1]))",O(n ^ 2)
"class Solution(object):
    def largestIsland(self, grid):
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        def dfs(r, c, index, grid):
            if not (0 <= r < len(grid) and
                    0 <= c < len(grid[0]) and
                    grid[r][c] == 1):
                return 0
            result = 1
            grid[r][c] = index
            for d in directions:
                result += dfs(r+d[0], c+d[1], index, grid)
            return result

        area = {}
        index = 2
        for r in range(len(grid)):
            for c in range(len(grid[r])):
                if grid[r][c] == 1:
                    area[index] = dfs(r, c, index, grid)
                    index += 1

        result = max(list(area.values()) or [0])
        for r in range(len(grid)):
            for c in range(len(grid[r])):
                if grid[r][c] == 0:
                    seen = set()
                    for d in directions:
                        nr, nc = r+d[0], c+d[1]
                        if not (0 <= nr < len(grid) and
                                0 <= nc < len(grid[0]) and
                                grid[nr][nc] > 1):
                            continue
                        seen.add(grid[nr][nc])
                    result = max(result, 1 + sum(area[i] for i in seen))
        return result",O(n ^ 2)
"class Solution(object):
    def areNumbersAscending(self, s):
        prev = curr = -1
        for i, c in enumerate(s):
            if c.isdigit():
                curr = max(curr, 0)*10+int(c)
                continue
            if prev != -1 and curr != -1 and prev >= curr:
                return False
            if curr != -1:
                prev = curr
            curr = -1            
        return curr == -1 or prev < curr",O(n)
"from bisect import bisect_left
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = []
        dp.append(nums[0])

        LIS = 1
        for i in range(1, len(nums)):
            if dp[-1] < nums[i]:
                dp.append(nums[i])
                LIS += 1
                continue

            idx = bisect_left(dp, nums[i])
            dp[idx] = nums[i]

        return LIS
",O(nlogn)
"a, b = map(int, input().split())
c = input()
su = 0
cnt = 0
j = -2
i = 0
lis = ""abcdefghijklmnopqrstuvwxyz""
while i < 26 and cnt < b:
    if lis[i] in c and i-2 >= j:
        su += i+1
        cnt += 1
        j = i
    i += 1
if cnt < b:
    print(-1)
else:
    print(su)
",O(n)
"k = int(input().split()[1])
l = sorted(map(int, input().split()))

res = set()
for i in l:
    if i%k!=0:
        res.add(i)
    elif i//k not in res:
        res.add(i)
print(len(res))",O(nlogn)
"class Solution(object):
    def isGoodArray(self, nums):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        result = nums[0]
        for num in nums:
            result = gcd(result, num)
            if result == 1:
                break
        return result == 1",O(n)
"from math import *

n,k = map(int,input().split())
ans = [0] * n

lul = 2**k - 1
A = list(map(int,input().split()))
ans[0]  = A[0]
for j in range(1, n):
    ans[j] = ans[j-1]^A[j]

d = dict()
for j in range(n):
    if ans[j] in d:
        d[ans[j]]+=1;
    else:
        d[ans[j]] = 1

ans =0
def huy(n):
    return n*(n-1)//2
for j in d:
    now = d[j]

    xor = lul^j
    cur = now

    if xor in d :

        now2 = d[xor]

        cur += now2

        ans += huy(cur//2+cur%2)
        ans+=huy(cur//2)
        if j ==0:
            ans+=2*(cur//2)
    else:
        if(j==0 or xor ==0):
            ans+= 2*(cur//2)
        ans += 2*huy(cur // 2 + cur % 2)
        ans += 2*huy(cur // 2)
print(huy(n+1) - ans//2)",O(n)
"import sys
input=sys.stdin.readline
hashi=dict()
for i in range(1,10**5):
    hashi[i*i]=1
    hashi[(2*i*i)]=1
t=int(input())
for you in range(t):
    n=int(input())
    if(n%2):
        print(""NO"")
        continue
    z=n//2
    if(z in hashi):
        print(""YES"")
    else:
        print(""NO"")
",O(1)
"class Solution(object):
    def shortestSequence(self, rolls, k):
        l = 0
        lookup = set()
        for x in rolls:
            lookup.add(x)
            if len(lookup) != k:
                continue
            lookup.clear()
            l += 1
        return l+1",O(n)
"n = int(input())
print(n**2+((n-1)**2))
",O(1)
"class Solution(object):
    def maxDistance(self, s, k):
        result = x = y = 0
        for i, c in enumerate(s, 1):
            if c == 'E':
                x += 1
            elif c == 'W':
                x -= 1
            elif c == 'N':
                y += 1
            elif c == 'S':
                y -= 1
            result = max(result, min(abs(x)+abs(y)+2*k, i))
        return result",O(n)
"from bisect import bisect_right as br
from bisect import bisect_left as bl
MAX = 10**9
def isprime(n):
    n = abs(int(n))
    if n < 2:
        return False
    if n == 2:
        return True
    if not n & 1:
        return False
    for x in range(3, int(n**0.5) + 1, 2):
        if n % x == 0:
            return False

    return True

def mhd(a,b,x,y):

    return abs(a-x)+abs(b-y)

n,m = map(int,input().split())
v = []
h = []
for _ in range(n):
    v.append(int(input()))

for _ in range(m):
    x1,x2,y = map(int,input().split())
    if(x1==1):
        h.append(x2)
lh = len(h)
h.sort()
v.sort()
if not lh:
    print(0)
elif n==0:
    print(lh-bl(h,MAX))
else:
    mn = n+lh-bl(h,MAX)
    for i in range(n):
        mn = min(mn,lh-bl(h,v[i])+i)
    print(mn)
",O(nlogn)
"class Solution2(object):
    def maximalSquare(self, matrix):
        if not matrix:
            return 0

        m, n = len(matrix), len(matrix[0])
        size = [[0 for j in range(n)] for i in range(m)]
        max_size = 0

        for j in range(n):
            if matrix[0][j] == '1':
                size[0][j] = 1
            max_size = max(max_size, size[0][j])

        for i in range(1, m):
            if matrix[i][0] == '1':
                size[i][0] = 1
            else:
                size[i][0] = 0
            for j in range(1, n):
                if matrix[i][j] == '1':
                    size[i][j] = min(size[i][j - 1],  \
                                     size[i - 1][j],  \
                                     size[i - 1][j - 1]) + 1
                    max_size = max(max_size, size[i][j])
                else:
                    size[i][j] = 0

        return max_size * max_size",O(n ^ 2)
"class Solution(object):
    def maxNumberOfApples(self, arr):
        LIMIT = 5000
        arr.sort()
        result, total = 0, 0
        for x in arr:
            if total+x > LIMIT:
                break
            total += x
            result += 1
        return result",O(nlogn)
"n, k = (int(x) for x in input().split())

if k > n * 2 or k < 3:
    print(0)
elif n >= k-1:
    print(k - k//2 - 1)
else:
    print(n - k//2)",O(1)
"n=int(input())
le=[int(i) for i in input().split()]
ri=[int(i) for i in input().split()]
notp = False
check=[]
for i in range(n):
    check.append(n-le[i]-ri[i])
for i in range(n):
    tot=0
    for j in range(i-1,-1,-1):
        if(check[j]>check[i]):
            tot+=1
    if(tot!=le[i]):
        notp=True
        break
if(notp==False):
    for i in range(n):
        tot=0
        for j in range(i+1,n):
            if(check[j]>check[i]):
                tot+=1
        if(tot!=ri[i]):
            notp=True
            break
if(notp):
    print('NO')
else:
    print('YES')
    print(*check)
",O(n ^ 2)
"class Solution(object):
    def licenseKeyFormatting(self, S, K):
        result = []
        for i in reversed(range(len(S))):
            if S[i] == '-':
                continue
            if len(result) % (K + 1) == K:
                result += '-'
            result += S[i].upper()
        return """".join(reversed(result))",O(n)
"class Solution(object):
    def isGood(self, nums):
        cnt = [0]*len(nums)
        for x in nums:
            if x < len(cnt):
                cnt[x] += 1
            else:
                return False
        return all(cnt[x] == 1 for x in range(1, len(nums)-1))",O(n)
"n,s=int(input()),input()
p,q,r=len(set(s)),{},10**6
for i in range(n):
    q[s[i]]=i
    if len(q)==p:r=min(r,max(q.values())-min(q.values()))
print(r+1)",O(n)
"class Solution(object):
    def maxWidthRamp(self, A):
        result = 0
        s = []
        for i in A:
            if not s or A[s[-1]] > A[i]:
                s.append(i)
        for j in reversed(range(len(A))):
            while s and A[s[-1]] <= A[j]:
                result = max(result, j-s.pop())
        return result",O(n)
"class Solution2(object):
    def numberOfChild(self, n, k):
        r = k%(2*(n-1))
        return r if r <= n-1 else (n-1)-(r-(n-1))",O(1)
"n, a, b = map(int, input().split())
z, o = ('01', '10')[a < b]
n *= not (a > 1 < b or 1 < n * a * b < 4)
l = [[z] * n for _ in range(n)]
for i in range(n):
    l[i][i] = '0'
for i in range(n - a * b):
    l[i][i + 1] = l[i + 1][i] = o
print(('YES', 'NO')[not n])
print('\n'.join(map(''.join, l)))",O(n ^ 2)
"n, s = map(int, input().split())
l = [0 for i in range(n)]
for i in range(n-1):
	a, b = map(int, input().split())
	l[a-1]+=1
	l[b-1]+=1
count = 0
for i in range(n):
	if(l[i]==1):
		count+=1
print((s/count)*2)",O(n)
"import os
import sys
from io import BytesIO, IOBase
from heapq import *

def main():
    n,x,y=map(int,input().split())
    a,b=[],[]
    for i in range(n):
        u,v=map(int,input().split())
        a.append((u,1))
        a.append((v,-1))
    a.sort(key=lambda x:x[0]*10000000000-x[1])
    mod=10**9+7
    t,z,ans=1,1,x
    for i in range(1,len(a)):
        z+=a[i][1]
        if z<t:
            ans=(ans+t*(a[i][0]-a[i-1][0])*y)%mod
            heappush(b,-a[i][0])
        else:
            if b:
                if x<(a[i][0]+b[0])*y:
                    ans=(ans+t*(a[i][0]-a[i-1][0])*y+x)%mod
                else:
                    ans=(ans+t*(a[i][0]-a[i-1][0])*y+(a[i][0]+b[0])*y)%mod
                    heappop(b)
            else:
                ans = (ans + t * (a[i][0] - a[i - 1][0]) * y + x) % mod
        t=z
    print(ans)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(nlogn)
"def naiveSolve():

    return

class SortedList:
    def __init__(self, iterable=[], _load=200):

        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):

        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):

        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):

        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):

        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):

        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):

        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):

        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):

        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):

        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):

        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):

        return self._len

    def __getitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):

        return (value for _list in self._lists for value in _list)

    def __reversed__(self):

        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):

        return 'SortedList({0})'.format(list(self))

class OrderedList(SortedList):
    def __init__(self, arg):
        super().__init__(arg)
    def rangeCountByValue(self, leftVal, rightVal):
        leftCummulative = self.bisect_left(leftVal)
        rightCummulative = self.bisect_left(rightVal + 1)
        return rightCummulative - leftCummulative

from collections import Counter

def main():

    n=int(input())
    a=readIntArr()

    cnts=Counter(a)
    ol=OrderedList([v for v in cnts.values()])
    ol.add(0)
    canMakeFirstMove=False
    for x in a:
        if x>0:
            c=cnts[x]
            ol.remove(c)
            ol.add(c-1)
            d=cnts[x-1]
            ol.remove(d)
            ol.add(d+1)

            if ol[-1]==1:
                canMakeFirstMove=True
                break
            ol.add(c)
            ol.remove(c-1)
            ol.add(d)
            ol.remove(d+1)
    if canMakeFirstMove==False:
        print('cslnb')
    else:

        target=(n*(n-1))//2
        if (sum(a)-target)%2==0:
            print('cslnb')
        else:
            print('sjfnb')

    return

import sys

input=lambda: sys.stdin.readline().rstrip(""\r\n"")

def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))

def readIntArr():
    return [int(x) for x in input().split()]

def makeArr(defaultValFactory,dimensionArr):
    dv=defaultValFactory;da=dimensionArr
    if len(da)==1:return [dv() for _ in range(da[0])]
    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]

def queryInteractive(l,r):
    print('? {} {}'.format(l,r))
    sys.stdout.flush()
    return int(input())

def answerInteractive(x):
    print('! {}'.format(x))
    sys.stdout.flush()

inf=float('inf')
MOD=10**9+7

from math import gcd,floor,ceil

for _abc in range(1):
    main()
",O(nlogn)
"def dsum(n):
    return sum([int(c) for c in str(n)])

n, s = map(int, input().split(' '))
l = 1
r = n
while l <= r:
    mid = (l + r) // 2
    delta = mid - dsum(mid)
    if delta >= s:
        r = mid - 1
    else:
        l = mid + 1
print(n - l + 1)
",O(logn)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def sortList(self, head):
        if head == None or head.__next__ == None:
            return head

        fast, slow, prev = head, head, None
        while fast != None and fast.__next__ != None:
            prev, fast, slow = slow, fast.next.__next__, slow.__next__
        prev.next = None

        sorted_l1 = self.sortList(head)
        sorted_l2 = self.sortList(slow)

        return self.mergeTwoLists(sorted_l1, sorted_l2)

    def mergeTwoLists(self, l1, l2):
        dummy = ListNode(0)

        cur = dummy
        while l1 != None and l2 != None:
            if l1.val <= l2.val:
                cur.next, cur, l1 = l1, l1, l1.__next__
            else:
                cur.next, cur, l2 = l2, l2, l2.__next__

        if l1 != None:
            cur.next = l1
        if l2 != None:
            cur.next = l2

        return dummy.__next__",O(nlogn)
"from itertools import combinations
n, l, r, x = map(int,input().split())
a = list(map(int,input().split()))
print(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))",np
"import sys

N, M, K, L = map(int, sys.stdin.readline().split())

if M * (N / M) - K < L:
  print(""-1"")
  sys.exit(0)

def solve(curr):
  return curr * M - K >= L

l = 0
r = N / M
while r - l > 1:
  mid = (r + l) / 2
  if solve(mid):
    r = mid
  else:
    l = mid

print(r)
",O(logn)
"n, m, k = [int(i) for i in input().split()]
A = [int(i) for i in input().split()]

bestbest = 0

def brute(n, m, k, A):
    ans = 0
    val = (0, 0)
    for i in range(n):
        for j in range(i, n):
            if ans < sum(A[i:j+1]) - k*(ceil((j-i+1)/m)):
                ans = sum(A[i:j+1]) - k*(ceil((j-i+1)/m))
                val = (i, j)
    return val, ans

for off in range(m):
    B = A[off:]
    C = []
    canstart = []
    for i in range(len(B)):
        if i%m == 0:
            C.append(-k)
            canstart.append(1)
        canstart.append(0)
        C.append(B[i])

    best = 0
    run = 0

    for i in range(len(C)):
        run += C[i]
        if run < -k:
            run = -k
        best = max(best, run)

    bestbest = max(bestbest, best)

print(bestbest)
",O(n ^ 2)
"n=int(input())
a=[int(x) for x in input().split()]
pro=n*(n-1)//2
dic={}
for item in a:
    if item not in dic:
        dic[item]=1
    else:
        dic[item]+=1
counter=0
for item in dic:
    if 0 in dic and dic[0]>=2:
        print('cslnb')
        break
    if dic[item]>2:
        print('cslnb')
        break
    elif dic[item]==2:
        if counter==1 or item-1 in dic:
            print('cslnb')
            break
        else:
            counter=1
else:
    if (sum(a)-pro)%2==1:
        print('sjfnb')
    else:
        print('cslnb')
",O(n)
"from sys import *

n, k = map(int, stdin.readline().split())
arr = list(map(int, stdin.readline().split()))
avg = 0
for i in range(n):
	cnt = 0
	sum = 0
	for j in range(i, n):
		sum += arr[j]
		cnt += 1
		if cnt >= k:
			avg = max(avg, sum / cnt)
print(avg)",O(n ^ 2)
"n = int(input())
ar = [int(i) for i in input().split()]
ans = 0
for i in range(2*n):
    for j in range(i+1,2*n):
        if ar[i]==ar[j]:
            while j!=i+1:
                ar[j],ar[j-1]=ar[j-1],ar[j]
                j-=1
                ans+=1
print(ans)
",O(n ^ 2)
"import os
from io import BytesIO, IOBase
import sys

def main():
    n=int(input())
    a=[]
    for i in range(n):
        x,y=map(int,input().split())
        a.append((x,0))
        a.append((y,1))
    a.sort()
    ans,s=[0]*n,[]
    for x,y in a:
        if y:
            ans[len(s)-1]+=x-s[-1][0]+1-s[-1][1]
            z=s.pop()
            if s!=[]:
                s[-1][1]+=(x-z[0]+1)
        else:
            s.append([x,0])
    print(*ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(nlogn)
"def possible(a,index,a1,b):
    rem = []
    for i in range(len(a)):
        if i != index:
            rem.append(a[i])

    a3 = a1[:]
    rem.sort()
    a3.append(a[index])
    a3.extend(rem)
    a2 = ''
    for i in a3:
        a2 += str(i)

    if int(a2) <= b:
        return True

    return False

def main():
    a = list(map(int,input()))
    b = int(input())

    a.sort(reverse = True)
    a1 = []
    for pos in range(len(a)):
        for i in range(len(a)):
            if possible(a,i,a1,b):
                a1.append(a[i])
                a.pop(i)
                break

    for i in a1:
        print(i,end = '')

main()
",O(n ^ 3)
"class Solution(object):
    def checkPossibility(self, nums):
        modified, prev = False, nums[0]
        for i in range(1, len(nums)):
            if prev > nums[i]:
                if modified:
                    return False
                if i-2 < 0 or nums[i-2] <= nums[i]:
                    prev = nums[i]   


                modified = True
            else:
                prev = nums[i]
        return True",O(n)
"class Solution(object):
    def countHillValley(self, nums):
        result, inc = 0, -1
        for i in range(len(nums)-1):
            if nums[i] < nums[i+1]:
                result += int(inc == 0)
                inc = 1
            elif nums[i] > nums[i+1]:
                result += int(inc == 1)
                inc = 0
        return result",O(n)
"class Solution(object):
    def longestConsecutive(self, root):
        def longestConsecutiveHelper(root):
            if not root:
                return 0, 0
            left_len = longestConsecutiveHelper(root.left)
            right_len = longestConsecutiveHelper(root.right)
            cur_inc_len, cur_dec_len = 1, 1
            if root.left:
                if root.left.val == root.val + 1:
                    cur_inc_len = max(cur_inc_len, left_len[0] + 1)
                elif root.left.val == root.val - 1:
                    cur_dec_len = max(cur_dec_len, left_len[1] + 1)
            if root.right:
                if root.right.val == root.val + 1:
                    cur_inc_len = max(cur_inc_len, right_len[0] + 1)
                elif root.right.val == root.val - 1:
                    cur_dec_len = max(cur_dec_len, right_len[1] + 1)
            self.max_len = max(self.max_len, cur_dec_len + cur_inc_len - 1)
            return cur_inc_len, cur_dec_len

        self.max_len = 0
        longestConsecutiveHelper(root)
        return self.max_len",O(n)
"n = int(input())
s = list(str(input()))
t = list(str(input()))

from collections import Counter
cs = Counter(s)
ct = Counter(t)
if cs != ct:
    print(-1)
    exit()

xs = [[] for _ in range(26)]
xt = [[] for _ in range(26)]
for i in range(n):
    j = ord(s[i])-ord('a')
    xs[j].append(i)

for i in range(n):
    j = ord(t[i])-ord('a')
    xt[j].append(i)

x = [-1]*n
for i in range(26):
    for j, k in zip(xs[i], xt[i]):
        x[j] = k

ans = []
for i in range(n):
    for j in reversed(range(i+1, n)):
        if x[j-1] > x[j]:
            x[j-1], x[j] = x[j], x[j-1]
            ans.append(j)
print(len(ans))
print(*ans)",O(n ^ 2)
"import collections


class Solution(object):
    def shareCandies(self, candies, k):
        cnt = collections.Counter(candies[i] for i in range(k, len(candies)))
        result = curr = len(cnt)
        for i in range(k, len(candies)):
            cnt[candies[i]] -= 1
            curr += (cnt[candies[i-k]] == 0) - (cnt[candies[i]] == 0)
            cnt[candies[i-k]] += 1
            result = max(result, curr)
        return result",O(n)
"n,k=map(int,input().split())
if n>=k:
    print((k-1)//2)
elif n*2>k:
    print(n-k//2)
else:
    print(0)",O(1)
"import sys
input=sys.stdin.readline
n=int(input())
c=[]
for _ in range(n):
    a,b=map(int,input().split())
    c.append((a,b,_))
c.sort(key=lambda x:(x[0],-x[1]))
a=c[0][1]
b=c[0][2]
an1=-1
an2=-1
for i in range(1,n):
    if c[i][1]<=a:
        an2=b+1
        an1=c[i][2]+1
        break
    else:
        a=c[i][1]
        b=c[i][2]
print(an1,an2)",O(nlogn)
"def maxXORInRange(L, R):

    LXR = L ^ R

    msbPos = 0
    while(LXR):

        msbPos += 1
        LXR >>= 1

    maxXOR, two = 0, 1

    while (msbPos):

        maxXOR += two
        two <<= 1
        msbPos -= 1

    return maxXOR

L,R = map(int, input().split())
print(maxXORInRange(L, R))",O(logn)
"a,b,c,d,e,f=list(map(int,input().split()))
n,n2=1,a*b+c*d+e*f
while n**2<n2:
    n+=1
if n**2>n2:
    print(-1)
    exit()
l=sorted([[max(a,b),min(a,b),'A'],[max(c,d),min(d,c),'B'],[max(e,f),min(e,f),'C']])
if l[2][0]!=n:
    print(-1)
    exit(0)
v=str(n)+'\n'+(l[2][2]*n+'\n')*l[2][1]
if l[0][0]==n and l[1][0]==n:
    for i in range(2):
        v+=(l[i][2]*n+'\n')*l[i][1]
else:
    s=n-l[2][1]
    if s not in l[0] or s not in l[1]:
        print(-1)
        exit()
    if s!=l[0][0]:
        l[0][0],l[0][1]=l[0][1],l[0][0]
    if s!=l[1][0]:
        l[1][0],l[1][1]=l[1][1],l[1][0]
    v+=(l[0][2]*l[0][1]+l[1][2]*l[1][1]+'\n')*s
print(v)
",np
"n = int(input())
a = list(map(int, input().strip().split()))

b = set(a)
res = len(b)
if 0 in b:
    res -= 1
print(res)
",O(n)
"n = int(input())
x  = input()
l = list(map(int, x.split()))

dict = {}

for i in l:
    dict[i] = 0;
sum = 0
fre = 0
ans = 0
for i in range(n-1,-1, -1):

    x = sum
    y = fre
    for j in range(-1,2):
        aa = l[i]+j
        if aa in dict:
            x-= aa*dict[aa]
            y-= dict[aa]

    ans += x - l[i]*y
    fre+=1
    sum+=l[i]
    dict[l[i]]+=1
print(ans)
",O(nlogn)
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:

    sys.stdin = open(""input.txt"", ""r"")

except:
    pass
def pmat(A):
    for ele in A:
        print(*ele,end=""\n"")
def seive():
    prime=[1 for i in range(10**6+1)]
    prime[0]=0
    prime[1]=0
    for i in range(10**6+1):
        if(prime[i]):
            for j in range(2*i,10**6+1,i):
                prime[j]=0
    return prime

a,b=L()
def rec(a,b):
    if b==1:
        return a
    if a>b:
        return a//b+rec(b,a%b)
    else:
        return rec(b,a)
print(rec(a,b))

endtime = time.time()
",O(1)
"n = int(input())
a = [int(i) for i in input().split()]
indx = [0] * n
winners = [''] * n

for i, ai in enumerate(a):
    indx[ai-1] = i

for ai in range(n, 0, -1):
    i = indx[ai-1]
    can_win = False

    for j in range(i + ai, n, ai):
        if a[j] > ai and 'B' == winners[j]:
            can_win = True
            break

    if not can_win:
        for j in range(i - ai, -1, -ai):
            if a[j] > ai and 'B' == winners[j]:
                can_win = True
                break

    if can_win:
        winners[i] = 'A'
    else:
        winners[i] = 'B'

print(''.join(winners))
",O(n ^ 2)
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n+1) for _ in range(2024)]

d = [[] for _ in range(n)]
for i, v in enumerate(b):
	e[v][i] = i
	d[i].append(i)

for v in range(1, 2024):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)

a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])
",O(n ^ 3)
"from sys import stdin,stdout
def count(audrey,imba,banget):
    return((imba-audrey-1)%(banget-1))

n,q=map(int,input().split())
L=list(map(int,input().split()))
maxi=max(L)
indexmax=L.index(maxi)
P=[]
for i in range(indexmax):
    P.append((L[0],L[1]))
    if L[0]<L[1]:
        L.append(L.pop(0))
    else:
        L.append(L.pop(1))
Y=tuple(L[1:])
for p in range(q):
    m=int(stdin.readline())
    if m<=indexmax:
        print(str(P[m-1][0])+' '+str(P[m-1][1]))
    else:
        stdout.write(str(maxi)+' '+str(Y[count(indexmax,m,n)])+'\n')",O(n)
"class Solution(object):
    def countTestedDevices(self, batteryPercentages):
        result = 0
        for x in batteryPercentages:
            if x > result:
                result += 1
        return result",O(n)
"from sys import stdin, stdout, exit
import math

n, k = map(int, stdin.readline().split())

ans = round((-3 + math.sqrt(9 + 8*(k+n))) / 2)
stdout.write(str(n-ans) + ""\n"")
",O(1)
"n,m=map(int,input().split())
l1=list(map(int,input().split()))
l2=list(map(int,input().split()))
l1.sort()
l2.sort()
l2=l2[::-1]
if n==1:
    if l1[0]!=min(l2):
        print(-1)
    else :
        print(sum(l2))
elif max(l1)>min(l2):
    print(-1)
else :
    ans=0
    l1=l1[::-1]
    if min(l2)==l1[0]:
        print(sum(l2) + (sum(l1)-l1[0])*m)
    elif min(l2)!=l1[0]:
        print(sum(l2)+l1[0]+sum(l1[1:])*m-l1[1])
",O(nlogn)
"class Solution(object):
    def subArrayRanges(self, nums):
        result = 0
        stk = []
        for i in range(len(nums)+1):
            x = nums[i] if i < len(nums) else float(""inf"")
            while stk and nums[stk[-1]] <= x:
                j = stk.pop()
                k = stk[-1] if stk else -1
                result += nums[j]*(j-k)*(i-j)
            stk.append(i)
        stk = []
        for i in range(len(nums)+1):
            x = nums[i] if i < len(nums) else float(""-inf"")
            while stk and nums[stk[-1]] >= x:
                j = stk.pop()
                k = stk[-1] if stk else -1
                result -= nums[j]*(j-k)*(i-j)
            stk.append(i)
        return result",O(n)
"from math import factorial
def C(m,n):
    return factorial(n) // (factorial(m) * factorial(n - m))

command_1, command_2 = input(), input()
num = command_2.count('?')
i = command_1.count('+') - command_1.count('-') -\
command_2.count('+') + command_2.count('-') + num
if i % 2 == 0 and 0 <= i//2 <= num:
    print(""%.9f""%(C(i//2, num) / 2**num))
else:
    print(""0.000000000"")",np
"import sys

sys.setrecursionlimit(10**5)
int1 = lambda x: int(x)-1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def MI(): return map(int, sys.stdin.buffer.readline().split())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
inf = 10**16
md = 10**9+7

a,b=MI()
x,y,z=MI()
yel=x*2+y
bul=y+z*3
print(max(0,yel-a)+max(0,bul-b))
",O(1)
"fib = [0]*100
fib[1] = 1
for i in range(2, 100):
    fib[i] = fib[i-1] + fib[i-2]

n = int(input())

if (n in fib):
    if (n == 0):
        print(0, 0, 0)
    elif (n == 1):
        print(0, 0, 1)
    else:
        print(0, fib[fib.index(n)-2], fib[fib.index(n)-1])
else:
    print(""I'm too stupid to solve this problem"")
",O(1)
"class Solution(object):
    def canTransform(self, start, end):
        if start.count('X') != end.count('X'):
            return False
        i, j = 0, 0
        while i < len(start) and j < len(end):
            while i < len(start) and start[i] == 'X':
                i += 1
            while j < len(end) and end[j] == 'X':
                j += 1
            if (i < len(start)) != (j < len(end)):
                return False
            elif i < len(start) and j < len(end):
                if start[i] != end[j] or \
                   (start[i] == 'L' and i < j) or \
                   (start[i] == 'R' and i > j):
                    return False
            i += 1
            j += 1
        return True",O(n)
"import sys
from math import sqrt, log, log2, ceil, log10, gcd, floor, pow, sin, cos, tan, pi, inf, factorial
from copy import copy, deepcopy
from sys import exit, stdin, stdout
from collections import Counter, defaultdict, deque
from itertools import permutations
import heapq
from bisect import bisect_left
from bisect import bisect_right

mod = 1000000007
iinp = lambda: int(sys.stdin.readline())
inp = lambda: sys.stdin.readline().strip()
strl = lambda: list(inp().strip().split("" ""))
intl = lambda: list(map(int, inp().split("" "")))
mint = lambda: map(int, inp().split())
flol = lambda: list(map(float, inp().split("" "")))
flush = lambda: stdout.flush()

def solve():

    n,s=mint()
    cm=0
    for i in range(n):
        fi,ti=mint()
        if i==0:
            cm=fi+ti
        if i!=0:
            if fi+ti>cm:
                cm=fi+ti
    if cm>s:
        print(cm)
    else:
        print(s)

t=1
for _ in range(t):
        solve()",O(n)
"class Solution(object):
    def kLengthApart(self, nums, k):
        prev = -k-1
        for i in range(len(nums)):
            if not nums[i]:
                continue
            if i-prev <= k:
                return False
            prev = i
        return True",O(n)
"def factorial(n):
    r = 1
    for i in range(2, n + 1):
        r *= i
    return r

def n_choose_k(n, k):
    return factorial(n) // (factorial(k) * factorial(n - k))

def solve(diff, u):
    pluses = u + 1
    n = 2 ** u
    for i in range(unknown, -unknown - 1, -2):
        pluses -= 1
        if diff == i:
            k = n_choose_k(u, pluses)
            return k / n
    return 0

s1 = input()
s2 = input()
k = 0
correct_p = 0
pred_p = 0
unknown = 0
for c in s1:
    correct_p += 1 if c == '+' else -1
for c in s2:
    if c in '+-':
        pred_p += 1 if c == '+' else -1
    else:
        unknown += 1
p = 1 if unknown == 0 and correct_p == pred_p else solve(correct_p - pred_p, unknown)
print('{0:.9f}'.format(p))
",np
"
class Solution(object):
    def simplifyPath(self, path):
        stack, tokens = [], path.split(""/"")
        for token in tokens:
            if token == "".."" and stack:
                stack.pop()
            elif token != "".."" and token != ""."" and token:
                stack.append(token)
        return ""/"" + ""/"".join(stack)

",O(n)
"def main():
    n, m = list(map(int, input().split()))
    c = list(map(int, input().split()))
    a = list(map(int, input().split()))
    c_i= 0
    a_i= 0
    bought = 0
    while c_i!= n and a_i!= m:
        if(a[a_i]>=c[c_i]):
            a_i+=1
            c_i+=1
            bought+=1
        else:
            c_i+=1
    print(bought)
if __name__ == ""__main__"":
    main()",O(n)
"mod = 1000000007
eps = 10**-9

def main():
    import sys
    input = sys.stdin.readline

    N, M, K = map(int, input().split())
    P = [""""]
    for i in range(N):
        p = input().rstrip(""\n"")
        P.append(p)
    p2i = {p: i for i, p in enumerate(P)}
    adj = [set() for _ in range(N+1)]
    for i in range(M):
        s, mt = input().split()
        mt = int(mt)
        ok = 0
        for k in range(1 << K):
            s_new = [""_""] * K
            for j in range(K):
                if k >> j & 1:
                    s_new[j] = s[j]
            s_new = """".join(s_new)
            if s_new != P[mt]:
                if s_new in p2i:
                    adj[mt].add(p2i[s_new])
            else:
                ok = 1
        if not ok:
            print(""NO"")
            exit()
    in_num = [0] * (N+1)
    for v in range(1, N+1):
        for u in adj[v]:
            in_num[u] += 1
    st = []
    for v in range(1, N+1):
        if in_num[v] == 0:
            st.append(v)
    ans = []
    while st:
        v = st.pop()
        ans.append(v)
        for u in adj[v]:
            in_num[u] -= 1
            if in_num[u] == 0:
                st.append(u)
    if len(ans) == N:
        print(""YES"")
        print(*ans)
    else:
        print(""NO"")

if __name__ == '__main__':
    main()
",np
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None



class Solution(object):
    def plusOne(self, head):
        if not head:
            return None

        dummy = ListNode(0)
        dummy.next = head

        left, right = dummy, head
        while right.__next__:
            if right.val != 9:
                left = right
            right = right.__next__

        if right.val != 9:
            right.val += 1
        else:
            left.val += 1
            right = left.__next__
            while right:
                right.val = 0
                right = right.__next__

        return dummy if dummy.val else dummy.__next__",O(n)
"import math

n = int(input())
a = list(map(lambda x : int(x), input().split()))
q = len(a)

earliest_time = pow(10, 9) + 1000
earliest_queue = 1
for i in range(q):
    n = int(max(0, math.ceil((a[i] + 1 - (i + 1)) / q)))
    t = (i + 1) + n * q
    if t < earliest_time:
        earliest_time = t
        earliest_queue = i + 1

print(earliest_queue)
",O(n)
"if __name__ == ""__main__"":
    s = input().rstrip().split()
    N = int(s[0])
    K = int(s[1])
    a = list(map(int, list(input().rstrip().split())))

    diff = []
    for i in range(1, N):
        diff.append([i, a[i] - a[i - 1]])
    diff = sorted(diff, key = lambda x: -x[1])
    res = max(a) - min(a)

    k = 0
    while (k < K - 1 and k < len(diff)):
        res -= diff[k][1]

        k += 1
    print(res)",O(nlogn)
"import operator

class Solution(object):
    def evalRPN(self, tokens):
        numerals, operators = [], {""+"": operator.add, ""-"": operator.sub, ""*"": operator.mul, ""/"": operator.div}
        for token in tokens:
            if token not in operators:
                numerals.append(int(token))
            else:
                y, x = numerals.pop(), numerals.pop()
                numerals.append(int(operators[token](x * 1.0, y)))
        return numerals.pop()",O(n)
"class Solution2(object):
    def equationsPossible(self, equations):
        graph = [[] for _ in range(26)]

        for eqn in equations:
            x = ord(eqn[0]) - ord('a')
            y = ord(eqn[3]) - ord('a')
            if eqn[1] == '!':
                if x == y:
                    return False
            else:
                graph[x].append(y)
                graph[y].append(x)

        color = [None]*26
        c = 0
        for i in range(26):
            if color[i] is not None:
                continue
            c += 1
            stack = [i]
            while stack:
                node = stack.pop()
                for nei in graph[node]:
                    if color[nei] is not None:
                        continue
                    color[nei] = c
                    stack.append(nei)

        for eqn in equations:
            if eqn[1] != '!':
                continue
            x = ord(eqn[0]) - ord('a')
            y = ord(eqn[3]) - ord('a')
            if color[x] is not None and \
               color[x] == color[y]:
                return False
        return True",O(n)
"n, k  = map(int, input().split())
a = []
b = []
c = 0
d = []

for i in range(n):
    x, y= map(int, input().split())
    t = x-y
    a.append(x)
    b.append(y)
    d.append(t)
s = sum(a)
d.sort()
d = d[::-1]
if sum(b)>k:
    print(-1)
else:
    while s>k:

        s = s - d[c]
        c = c + 1
    print(c)
",O(nlogn)
"import sys
import math
import heapq
import bisect
from collections import Counter
from collections import defaultdict
from io import BytesIO, IOBase
import string

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
        self.BUFSIZE = 8192

    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def get_int():
    return int(input())

def get_ints():
    return list(map(int, input().split(' ')))

def get_int_grid(n):
    return [get_ints() for _ in range(n)]

def get_str():
    return input().split(' ')

def yes_no(b):
    if b:
        return ""YES""
    else:
        return ""NO""

def prefix_sums(a):
    p = [0]
    for x in a:
        p.append(p[-1] + x)
    return p

def binary_search(good, left, right, delta=1, right_true=False):
    limits = [left, right]
    while limits[1] - limits[0] > delta:
        if delta == 1:
            mid = sum(limits) // 2
        else:
            mid = sum(limits) / 2
        if good(mid):
            limits[int(right_true)] = mid
        else:
            limits[int(~right_true)] = mid
    if good(limits[int(right_true)]):
        return limits[int(right_true)]
    else:
        return False

def solve_a():
    n = get_int()
    m = get_int()
    a = get_ints()
    b = get_ints()

    def good(k):
        for i in range(n):
            k -= (m + k) / a[i]
            k -= (m + k) / b[i]
        return k >= 0

    ans = binary_search(good, 0, 10 ** 9 + 1, delta=10 ** (-6), right_true=True)
    if not ans:
        return -1
    else:
        return ans

print(solve_a())
",O(n)
"n = int(input())
arr = list(map(int, input().split()))
codd = 0
ceven = 0
ptodd = -1
pteven = -1
for i in range(n):
    if arr[i]%2 == 0:
        ceven += 1
        pteven = i
    else:
        codd += 1
        ptodd = i

if ceven == 1:
    print(pteven+1)
else:
    print(ptodd+1)",O(n)
"from sys import stdin
nii=lambda:map(int,stdin.readline().split())
lnii=lambda:list(map(int,stdin.readline().split()))

R,G,B=nii()
r=lnii()
g=lnii()
b=lnii()

r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

dp=[[[0]*(B+1) for i in range(G+1)] for j in range(R+1)]

for i in range(R+1):
  for j in range(G+1):
    for k in range(B+1):
      c=False
      if i<R and j<G:
        dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+r[i]*g[j])
        c=True
      if j<G and k<B:
        dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+g[j]*b[k])
        c=True
      if k<B and i<R:
        dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+b[k]*r[i])
        c=True

      if not c:
        if i<R:
          dp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k])
        if j<G:
          dp[i][j+1][k]=max(dp[i][j+1][k],dp[i][j][k])
        if k<B:
          dp[i][j][k+1]=max(dp[i][j][k+1],dp[i][j][k])

ans=0
for i in dp:
  for j in i:
    ans=max(ans,max(j))

print(ans)",O(n ^ 3)
"class Solution2(object):

    def __init__(self, width, height):
        self.__w = width
        self.__h = height
        self.__curr = 0

    def move(self, num):
        self.__curr += num

    def getPos(self):
        return self.__getPosDir()[0] 

    def getDir(self):
        return self.__getPosDir()[1]

    def __getPosDir(self):
        n = self.__curr % (2*((self.__w-1)+(self.__h-1)))
        if n < self.__w:
            return [[n, 0], ""South"" if n == 0 and self.__curr else ""East""]
        n -= self.__w-1
        if n < self.__h:
            return [[self.__w-1, n], ""North""]
        n -= self.__h-1
        if n < self.__w:
            return [[(self.__w-1)-n, self.__h-1], ""West""]
        n -= self.__w-1
        return [[0, (self.__h-1)-n], ""South""]",O(1)
"import os
import sys
from io import BytesIO, IOBase
from collections import deque

def main():
    with open('input.txt') as fp:
        input=fp.readline
        n, m = map(int, input().split())
        dx = [1, -1, 0, 0]
        dy = [0, 0, -1, 1]
        q =deque()
        k = int(input())
        a = list(map(int, input().split()))
        v = [[1] * (m + 2) for _ in range(n + 2)]
        for i in range(m + 2):
            v[0][i] = 0
            v[-1][i] = 0
        for i in range(n + 2):
            v[i][0] = 0
            v[i][-1] = 0
        for i in range(0, 2 * k, 2):
            q.append((a[i],a[i + 1]))
            v[a[i]][a[i + 1]] = 0
        while 1:
            x, y =q.popleft()
            for i in range(4):
                xx, yy = x + dx[i], y + dy[i]
                if v[xx][yy]:
                    q.append((xx, yy))
                    v[xx][yy] = 0
            if not q:
                with open('output.txt', mode='w') as fpp:
                    fpp.write(f'{x} {y}')
                break

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(n ^ 3)
"n = int(input())
curpow, t, mx2pow = 1, 1, 0
while t < n:
    t <<= 1
    mx2pow += 1

if t > n:
    mx2pow -= 1

last = 1 << (mx2pow-1) if mx2pow else 1
add = last

while last < n:
    last += add

if last > n:
    last -= add

while n:
    if n == 1:
        print(last)
        break
    print((str(curpow)+' ') * ((n+1)//2), end='')
    curpow *= 2
    n //= 2
",O(nlogn)
"import sys
import math

input = sys.stdin.readline

def inp():
    return(int(input()))
def inara():
    return(list(map(int,input().split())))
def insr():
    s = input()
    return(list(s[:len(s) - 1]))
def invr():
    return(map(int,input().split()))

n,k=invr()

ans=0
lo=0
hi=n

def possible(a,b):
	koyta=a*(a+1)//2
	return koyta>=b+k

while hi>=lo:
	mid=(hi+lo)//2

	if possible(n-mid,mid):
		lo=mid+1
		ans=mid
	else:
		hi=mid-1

print(ans)
",O(logn)
"class Solution(object):
    def rotatedDigits(self, N):
        A = list(map(int, str(N)))
        invalid, diff = set([3, 4, 7]), set([2, 5, 6, 9])
        def dp(A, i, is_prefix_equal, is_good, lookup):
            if i == len(A): return int(is_good)
            if (i, is_prefix_equal, is_good) not in lookup:
                result = 0
                for d in range(A[i]+1 if is_prefix_equal else 10):
                    if d in invalid: continue
                    result += dp(A, i+1,
                                 is_prefix_equal and d == A[i],
                                 is_good or d in diff,
                                 lookup)
                lookup[i, is_prefix_equal, is_good] = result
            return lookup[i, is_prefix_equal, is_good]

        lookup = {}
        return dp(A, 0, True, False, lookup)",O(logn)
"class Solution2(object):
    def countSubarrays(self, nums, k):
        mx = max(nums)
        result = (len(nums)+1)*len(nums)//2
        left = cnt = 0
        for right in range(len(nums)):
            cnt += int(nums[right] == mx)
            while cnt == k:
                cnt -= int(nums[left] == mx)
                left += 1
            result -= right-left+1
        return result",O(n)
"a = list(input())
b = input()
out = []
mx = '/'
a.sort()
a.reverse()
x = len(a)
if x == len (b):
    for i in range(x):
        q = 0

        for j in range(len(a)):
            if a[j] == b[i]:
                out.append(a[j])
                a.pop(a.index(a[j]))
                q = 1
                break
            elif a[j] < b[i]:
                out.append(a[j])
                a.pop(a.index(a[j]))
                print(''.join(out), end = '')
                print(''.join(a))
                exit(0)
        if q == 0:
            break
    if q == 1:
        print(''.join(out))
    else:
        y = len(out)
        for i in range(y-1, -1, -1):
            for j in range(len(a)):
                if a[j] < b[i] and a[j]>mx:
                    mx = a[j]
            if mx != '/':

                a.append(out[len(out)-1])
                out.pop()
                out.append(mx)
                a.pop(a.index(mx))
                a.sort()
                a.reverse()
                print(''.join(out), end = '')
                print(''.join(a))
                exit(0)
            else:
                a.append(out[len(out)-1])
                out.pop()
                a.sort()
                a.reverse()

        a.pop(a.index(mx))
        print(mx, end ='')
        print(''.join(a))

else:
    print(''.join(a))
",O(n ^ 3)
"l,r = map(int,input().split())

p = l
lp = -1
while p:
    p = p>>1
    lp+=1

q = r
rp = -1
while q:
    q = q>>1
    rp+=1

s = max(lp,rp)

n=0

while s>=0:
    if l>>s&1!=r>>s&1:
        n |= (r>>s&1)<<s
        break
    s-=1

s-=1

while s>=0:
    n |= 1<<s
    s-=1

print(n)
",O(logn)
"class Solution(object):
    def decodeString(self, s):
        n, curr, nums, strs = 0, [], [], []
        for c in s:
            if c.isdigit():
                n = n*10 + ord(c)-ord('0')
            elif c.isalpha():
                curr.append(c)
            elif c == '[':
                nums.append(n)
                strs.append(curr)
                n, curr = 0, []
            elif c == ']':
                strs[-1].extend(curr*nums.pop())
                curr = strs.pop()
        return """".join(curr)",O(n)
"n, k = map(int, input().split())
a = [int(x) for x in input().split()]
rda = []
for j in range(12):
    rd = dict()
    x = pow(10, j)
    for i in range(n):
        r = (a[i]*x)%k
        rd[r] = rd.setdefault(r, 0) + 1
    rda.append(rd)
ans = 0
for i in range(n):
    r = a[i]%k
    ln = len(str(a[i]))
    x = pow(10, ln)
    if r == 0: r = k
    if k-r in rda[ln]:
        ans += rda[ln][k-r]
        if (a[i]*x)%k == k-r:
            ans -= 1
print(ans)
",O(nlogn)
"import sys, heapq

n = int(sys.stdin.readline())
key = []
for i in ['S', 'M', 'L']:
    for j in range(4):
        key.append(j * 'X' + i)
prev = dict().fromkeys(key, 0)
now = dict().fromkeys(key, 0)
for _ in range(n):
    prev[sys.stdin.readline().rstrip()] += 1
for _ in range(n):
    now[sys.stdin.readline().rstrip()] += 1
for i in key:
    temp = min(prev[i], now[i])
    prev[i] -= temp
    now[i] -= temp
ans = 0
for i in key:
    ans += now[i]
print(ans)
",O(n)
"n,d=[int(x) for x in input().split("" "")]
a=[int(x) for x in input().split("" "")]
pos=2
for i in range(n-1):
    l=a[i]+d
    r=a[i+1]-d
    if l==r:
        pos+=1
    elif l<r:
        pos+=2
print(pos)
",O(n)
"l,r=input().split("" "")
l,r=int(l),int(r)

a,b,c=l,l+1,l+2

if (l % 2 != 0):
    a,b,c=a+1,b+1,c+1

if (c > r):
    print(-1)

else:
    print(a,b,c)",O(1)
"class Solution(object):
    def longestMountain(self, A):
        result, up_len, down_len = 0, 0, 0
        for i in range(1, len(A)):
            if (down_len and A[i-1] < A[i]) or A[i-1] == A[i]:
                up_len, down_len = 0, 0
            up_len += A[i-1] < A[i]
            down_len += A[i-1] > A[i]
            if up_len and down_len:
                result = max(result, up_len+down_len+1)
        return result",O(n)
"n=int(input())
l=list(str(n))
if n>=0:
	print(n)
else:
	if int(l[-1])>int(l[-2]):
		l.pop(-1)
	else:
		l.pop(-2)
	print(int(''.join(l)))
",O(1)
"class Solution(object):
    def maximumLengthOfRanges(self, nums):
        result = [0]*len(nums)
        stk = [-1]
        nums.append(float(""inf""))
        for i, x in enumerate(nums):
            while stk[-1] != -1 and nums[stk[-1]] < x:
                j = stk.pop()
                result[j] = (i-1)-stk[-1]
            stk.append(i)
        return result",O(n)
"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        res = nums[0]
        curMin, curMax = 1, 1

        for num in nums:
            tmp = curMax * num
            curMax = max(num * curMax, num * curMin, num)
            curMin = min(tmp, num * curMin, num)
            res = max(res, curMax)
        return res
",O(n)
"class Solution(object):
    def arithmeticTriplets(self, nums, diff):
        lookup = set(nums)
        return sum((x-diff in lookup) and (x-2*diff in lookup) for x in nums)

import collections",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def lcaDeepestLeaves(self, root):
        def lcaDeepestLeavesHelper(root):
            if not root:
                return 0, None
            d1, lca1 = lcaDeepestLeavesHelper(root.left)
            d2, lca2 = lcaDeepestLeavesHelper(root.right)
            if d1 > d2:
                return d1+1, lca1
            if d1 < d2:
                return d2+1, lca2
            return d1+1, root

        return lcaDeepestLeavesHelper(root)[1]",O(n)
"numeros = [int(i) for i in input().split(' ')]

l = bin(numeros[0])
r = bin(numeros[1])

p = -1

if (len(r) == len(l)):
    for i in range (len(l)):
        if (l[i] != r[i]):
            p = i
            break
    if(numeros[0] != numeros[1]):
        saida = 2**(len(r) - p) - 1
        print(saida)
    else:
        print(0)

else:
    if(numeros[0] != numeros[1]):
        saida = 2**(len(r) - 2) - 1
        print(saida)
    else:
        print(0)
",O(logn)
"n,val=map(int,input().split());
a=[0]+list(map(int,input().split()));
suma=[0 for i in range(n+1)];
mx=0;
target=0;
for i in range(1,n+1):
	suma[i]=suma[i-1];
	mx=max(mx,a[i]);
	if (a[i]==val):
		target+=1;
		suma[i]+=1;

ans=0;
pre=[0 for i in range(mx+1)];
dp=[0];
for i in range(1,n+1):
	dp.append(max(1,1+dp[pre[a[i]]]-suma[i]+suma[pre[a[i]]]));
	if (a[i]!=val):
		ans=max(ans,dp[i]);
	pre[a[i]]=i;
print(ans+target);",O(n)
"class Solution(object):
    def makeArrayPositive(self, nums):
        MAX_VAL = 10**18
        result = 0
        prev1 = nums[0]+nums[1]
        prev2 = nums[0]
        max_prev3 = 0
        for i in range(2, len(nums)):
            prefix = prev1+nums[i]
            if prefix-max_prev3 <= 0:
                prefix = prev1+MAX_VAL
                result += 1
            max_prev3 = max(max_prev3, prev2)
            prev1, prev2 = prefix, prev1
        return result",O(n)
"n = int(input())

def prefix_sums(A):
    n = len(A)
    P = [0] * n
    P[0] = A[0]
    for k in range(1, n):
        P[k] = int((P[k - 1] + A[k]) % (1e9+7))
    return P

arr = [[0] * n for _ in range(n)]

s = ''
for i in range(n):
    inst = input()
    s += inst

def find_ans():
    idx = 0
    for i in range(len(arr)-1):
        arr[0][0] = 1

        if s[i] == 'f':
            for j in range(0, len(arr)):
                arr[i+1][0] = 0
                if j > 0:
                    arr[i+1][j] = arr[i][j-1]
                    idx = i+1

        else:
            val = 0
            arr[i+1] = prefix_sums(arr[i][::-1])[::-1]
    return arr

if n == 1 or 'f' not in s:
    if s[0] == 's':
        print(1)
    else:
        print(int(sum(find_ans()[-1]) % (1e9+7)))
else:
    print(int(sum(find_ans()[-1]) % (1e9+7)))
",O(n ^ 2)
"import sys
input=sys.stdin.buffer.readline
n,k=map(int,input().split())
arr=list(map(int,input().split()))
d=[{} for i in range(11)]
for i in range(n):
    st=arr[i]
    for j in range(11):
        r=st % k
        try:
            d[j][r]+=1
        except KeyError:
            d[j][r] =1
        st*=10
count_pair=0
for i in arr:
    st=str(i)
    l=len(st)
    mod_st=(k-(i % k)) %k
    if mod_st in d[l]:
        count_pair +=d[l][mod_st]
        if int(st + st) %k==0:
            count_pair -=1
print(count_pair)",O(nlogn)
"n = int(input())
s = input()
x = s.count('0')
if s == '0':
    print('0')
else:
    print('1' + '0'*x)",O(n)
"A,B = map(int, input().split())
x,y,z = map(int, input().split())
A1 = 2*x + y - A
B1 = 3*z + y - B
final = 0
if A1 > 0:
    final = final + A1
if B1 > 0:
    final = final + B1
print(final)",O(1)
"class Solution(object):
    def toHexspeak(self, num):
        lookup = {0:'O', 1:'I'}
        for i in range(6):
            lookup[10+i] = chr(ord('A')+i)
        result = []
        n = int(num)
        while n:
            n, r = divmod(n, 16)
            if r not in lookup:
                return ""ERROR""
            result.append(lookup[r])
        return """".join(reversed(result))",O(logn)
"n, m = map(int, input().split())
A = list(map(int, input().split()))
from collections import Counter
C = Counter(A)

def is_ok(x):
    cnt = 0
    for v in C.values():
        cnt += v//x
    if cnt >= n:
        return True
    else:
        return False

ok = 0
ng = 1000
while ok+1 < ng:
    c = (ok+ng)//2
    if is_ok(c):
        ok = c
    else:
        ng = c
print(ok)
",O(nlogn)
"class Solution2(object):
    def subarraysWithMoreZerosThanOnes(self, nums):
        MOD = 10**9+7

        lookup = {0:-1}
        dp = [0]*len(nums)
        result = total = 0
        for i, x in enumerate(nums):
            total += 1 if x == 1 else -1
            if total not in lookup:
                if total > 0:
                    dp[i] = i+1
            else:
                j = lookup[total]
                if j != -1:
                    dp[i] = dp[j]
                if x > 0:
                    dp[i] += (i-1)-j
            lookup[total] = i
            result = (result+dp[i])%MOD
        return result",O(n)
"class Solution(object):
    def canChange(self, start, target):
        i = j = 0
        while True:
            while i < len(start) and start[i] == '_':
                i += 1
            while j < len(target) and target[j] == '_':
                j += 1
            if i == len(start) and j == len(target):
                break
            if i == len(start) or j == len(target) or start[i] != target[j] or \
               (start[i] == 'L' and i < j) or (start[i] == 'R' and i > j):
                    return False
            i += 1
            j += 1
        return True",O(n)
"r,g,b = map(int,input().split())
R = list(map(int,input().split()))
G = list(map(int,input().split()))
B = list(map(int,input().split()))
R.sort()
G.sort()
B.sort()
dp = [[[-1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
def solve(r,g,b):
	if ((r==0 and g==0) or (g==0 and b==0) or (b==0 and r==0)):
		return 0
	if dp[r][g][b]==-1:
		if r==0:
			ans =  G[g-1]*B[b-1]+solve(r,g-1,b-1)
		elif g==0:
			ans =  R[r-1]*B[b-1]+solve(r-1,g,b-1)
		elif b==0:
			ans =  G[g-1]*R[r-1]+solve(r-1,g-1,b)
		else:
			ans =  max(G[g-1]*B[b-1]+solve(r,g-1,b-1),G[g-1]*R[r-1]+solve(r-1,g-1,b),R[r-1]*B[b-1]+solve(r-1,g,b-1))
		dp[r][g][b] = ans
	return dp[r][g][b]
ans = solve(r,g,b)
print(ans)",O(n ^ 3)
"import math

line = input().split()
N = int(line[0])
K = int(line[1])

n = (-3 + math.sqrt(9+4*(2*N+2*K)))/2

print(int(N-n))
",O(logn)
"class Solution2(object):
    def isPowerOfFour(self, num):
        while num and not (num & 0b11):
            num >>= 2
        return (num == 1)",O(1)
"class Solution(object):
    def firstDayBeenInAllRooms(self, nextVisit):
        MOD = 10**9+7

        dp = [0]*len(nextVisit)
        for i in range(1, len(dp)):
            dp[i] = (dp[i-1]+1+(dp[i-1]-dp[nextVisit[i-1]])+1)%MOD
        return dp[-1]",O(n)
"import sys

n, m, k = list(map(int,sys.stdin.readline().strip().split()))
p = list(map(int,sys.stdin.readline().strip().split()))
i = 0
c = 0
d = 0
while i < m:
    c = c + 1
    d2 = d
    x = k*((p[i]-d2-1)//k) + k
    while p[i]-d2 <= x:
        i = i + 1
        d = d + 1
        if i == m:
            break
print(c)
",O(n)
"from math import *
from collections import *
n = int(input())
a = list(map(int,input().split()))
d = Counter(a)
ans = 0
for i in range(n):
    for j in range(31):
        s = 2**j
        s = s-a[i]
        if d.get(s)!=None and ((d[s]==1 and s!=a[i]) or d[s]>=2):
            break
    else:
        ans+=1
print(ans)",O(nlogn)
"n = int(input())
print(n**2 + (n-1)**2)
",O(1)
"n, m, k, l = map(int, input().split())
if (k+l+m-1)//m*m > n:
    print(-1)
else:
    print((k+l+m-1)//m)
",O(1)
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest
sys.setrecursionlimit(111111)
INF=99999999999999999999999999999999
class SortedList:
    def __init__(self, iterable=[], _load=200):

        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):

        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):

        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):

        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):

        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):

        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):

        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):

        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):

        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):

        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):

        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):

        return self._len

    def __getitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):

        return (value for _list in self._lists for value in _list)

    def __reversed__(self):

        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):

        return 'SortedList({0})'.format(list(self))
def main():

    mod=1000000007

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc = 1
    for _ in range(tc):
        n=ri()
        s=rs()

        d={}
        for i in range(n):

            d[s[i]]=1
        l=0
        r=0
        td={}
        ans=INF
        while l<=r and r<n:
            while len(td)!=len(d):
                if r==n:
                    print(ans)
                    exit()
                if s[r] in td:
                    td[s[r]]+=1
                else:
                    td[s[r]]=1
                r+=1

            if len(td)==len(d):
                r-=1
                ans=min(ans,r-l+1)
            while l<=r:

                td[s[l]]-=1
                if td[s[l]]==0:
                    del td[s[l]]
                    ans=min(ans,r-l+1)
                    l+=1
                    break
                l+=1
            r+=1
        wi(ans)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(n)
"def make_nCr_mod(max_n=2 * 10 ** 5, mod=10 ** 9 + 7):
	max_n = min(max_n, mod - 1)

	fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)
	fact[0] = 1
	for i in range(max_n):
		fact[i + 1] = fact[i] * (i + 1) % mod

	inv_fact[-1] = pow(fact[-1], mod - 2, mod)
	for i in reversed(range(max_n)):
		inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod

	def nCr_mod(n, r):
		res = 1
		while n or r:
			a, b = n % mod, r % mod
			if a < b:
				return 0
			res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod
			n //= mod
			r //= mod
		return res

	return nCr_mod

def f():
	dp = [0] * (1000 + 100)
	dp[1] = 1

	for i in range(2, len(dp)):
		o = bin(i).count(""1"")
		if o == 1:
			dp[i] = 2
		else:
			dp[i] += dp[o] + 1
	return dp

def bit(s, k):
	dp = f()
	l = []
	comb=make_nCr_mod()
	ans = 0
	ll = len(s)
	ans = 0
	ones = 0
	if k == 0:
		return 1
	for i in range(ll):
		if s[i] == ""0"":
			continue
		else:
			for j in range(max(ones, 1), 1000):
				if dp[j] == k:
					ans = (ans + comb(ll - i - 1, j - ones)) % (10 ** 9 + 7)
					if i == 0 and k == 1:
						ans -= 1
		ones += 1
	if dp[ones] == k:
		ans += 1
	return (ans) % (10 ** 9 + 7)

s = input().strip()
k = int(input())
print(bit(s, k))
",O(n)
"class Solution(object):
    def threeSum(self, nums):
        result = []
        nums.sort()
        for i in reversed(list(range(2, len(nums)))):
            if i+1 < len(nums) and nums[i] == nums[i+1]:
                continue
            target = -nums[i]
            left, right = 0, i-1
            while left < right:
                if nums[left]+nums[right] < target:
                    left += 1
                elif nums[left]+nums[right] > target:
                    right -= 1
                else:
                    result.append([nums[left], nums[right], nums[i]])
                    left += 1
                    right -= 1
                    while left < right and nums[left] == nums[left-1]:
                        left += 1
                    while left < right and nums[right] == nums[right+1]:
                        right -= 1
        return result",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase

def main():
    n,m=map(int,input().split())
    s,e,ans=[1,1],[n,m],[]
    for i in range(n*m//2):
        ans.append(s[:])
        ans.append(e[:])
        s[1],e[1]=s[1]+1,e[1]-1
        if s[1]==m+1:
            s=[s[0]+1,1]
        if not e[1]:
            e=[e[0]-1,m]
    if (n*m)&1:
        ans.append([s[0],s[1]])
    for i in ans:
        print(*i)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(n ^ 2)
"t = int(input())
for i in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    a = sorted(a)
    print(min(a[-2]-1, n-2))
",O(nlogn)
"import sys
k=int(input())
if type(k)!=int or k<=0 or k>pow(10,12) :
        print(""wrong input. try again"")
        sys.exit()
lim_init=lim=decimal=9
c=0
while True:
        c+=1
        if k<=lim:
                diff=lim-k
                pos=diff%c
                diff=int(diff/c)
                diff=decimal-diff
                print(''.join(list(reversed(str(diff))))[pos])
                break
        else:
                decimal = int(str(lim_init)*(c+1))
                lim+=int(str(lim_init)+'0'*c)*(c+1)
",O(1)
"n = int(input())
l = [int(i) for i in input().split()]
r = [int(i) for i in input().split()]

items = [(-l[i]-r[i],i) for i in range(n)]
items.sort()
vals = [1] * n
m = 1
for i in range(1, n):
    if items[i-1][0] != items[i][0]:
        m += 1
    vals[items[i][1]] = m

for i in range(n):
    ln = sum(map(lambda x: x-vals[i] > 0, vals[:i]))
    lr = sum(map(lambda x: x-vals[i] > 0, vals[i:]))
    if ln != l[i] or lr != r[i]:
        print('NO')
        break
else:
    print('YES')
    print(' '.join(str(i) for i in vals))
",O(n ^ 2)
"class Solution(object):
    def findDisappearedNumbers(self, nums):
        for i in range(len(nums)):
            if nums[abs(nums[i]) - 1] > 0:
                nums[abs(nums[i]) - 1] *= -1

        result = []
        for i in range(len(nums)):
            if nums[i] > 0:
                result.append(i+1)
            else:
                nums[i] *= -1
        return result

    def findDisappearedNumbers2(self, nums):
        return list(set(range(1, len(nums) + 1)) - set(nums))

    def findDisappearedNumbers3(self, nums):
        for i in range(len(nums)):
            index = abs(nums[i]) - 1
            nums[index] = - abs(nums[index])

        return [i + 1 for i in range(len(nums)) if nums[i] > 0]",O(n)
"T = (0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889)
k = int(input())
a = 0
for i in T:
    if i - k > 0:
        a = T.index(i)
        break
temp = T[a] - k
x = temp % a
res = (10 ** a) - 1 - int(temp / a)
ans = int((res % (10 ** (x+1))) / (10 ** x))
print(ans)
",O(1)
"import math
send=input()
rcv=input()
d={}
d['+']=0
d['-']=0
for i in range(len(send)):
	d[send[i]]=d[send[i]]+1

flag=1
c=0
for i in range(len(rcv)):
	if rcv[i] in d:
		if d[rcv[i]]==0:
			flag=0
		else:
			d[rcv[i]]=d[rcv[i]]-1
tot=d['+']+d['-']
totComb=2**tot
n=tot
r=d['+']
npr=math.factorial(n)/math.factorial(n-r)
reqComb=npr/math.factorial(r)

if flag==0:
	print('0.00000000')
else:
	print(float(reqComb)/totComb)",np
"class Solution(object):
    def getMoneyAmount(self, n):
        dp = [[0]*(n+1) for _ in range(n+1)] 
        for j in range(n+1):
            for i in reversed(range(j-1)):
                dp[i][j] = min((k+1) + max(dp[i][k], dp[k+1][j]) for k in range(i, j))
        return dp[0][n]",O(n ^ 3)
"import math
k = int(input())

flag = True
i = 0
value=0

if(k <= 9):
    print(k)

else:
    while(flag):
        a = 9 * pow(10, i) * (i+1)
        if(k >= a):
            k -= a
            value+=9 * pow(10, i)
            i+=1
        else:
            n=int(math.ceil(k/(i+1)))
            value+=n
            index=k%(i+1)-1
            print(str(value)[index])
            flag=False
",O(logn)
"def combinations(arr,n):
    if(n==0):
        return([[]])
    l=[]
    for i in range(len(arr)):
        m=arr[i]
        rem=arr[i+1:]
        for j in combinations(rem,n-1):
            l.append([m]+j)
    return l

def solve(arr,n,l,r,x):
    subset=[]
    for i in range(2,n+1):
        for j in combinations(arr,i):
            if(sum(j)>=l and sum(j)<=r):
                subset.append(j)
    count=0
    for i in subset:
        mn=min(i)
        mx=max(i)
        if(mx-mn>=x):
            count+=1

    return(count)

n,l,r,x=map(int,input().split())
arr=list(map(int,input().split()))
print(solve(arr,n,l,r,x))
",np
"i = int(input())
print(int(i/2) * 3)",O(1)
"x, k = map(int, input().split())

twoPow = pow(2, k, 1000000007)

minQ = max(0, (x * twoPow - twoPow + 1))
minQ *= 2

maxQ = (x * twoPow * 2)

print(((maxQ*(maxQ+1)//2 - minQ*(minQ+1)//2 + minQ) // (maxQ-minQ+1)) % 1000000007)",O(logn)
"from sys import stdin

n = int(stdin.readline())

p = [int(x)-1 for x in stdin.readline().split()]

visited = [False for x in range(n)]

loops = []

for x in range(n):
    if not visited[x]:
        visited[x] = True
        start = x
        l = [x]
        cur = p[x]
        while cur != start:
            visited[cur] = True
            l.append(cur)
            cur = p[cur]
        loops.append(len(l)-1)

tot = sum(loops)

if n % 2 == 1:
    if tot % 2 == 1:
        print('Petr')
    else:
        print('Um_nik')
else:
    if tot % 2 == 0:
        print('Petr')
    else:
        print('Um_nik')
",O(nlogn)
"import collections


class Solution(object):
    def canConstruct(self, s, k):
        count = collections.Counter(s)
        odd = sum(v%2 for v in count.values())
        return odd <= k <= len(s)",O(n)
"query = input().split()

n = int(query[0])
k = int(query[1])
import math

temp = 2* (k + n)

m = (-3 + math.sqrt(9 + 4*temp))/2

print(int(n-m))
",O(logn)
"n, m = [int(v) for v in input().split()]

a = []
for _ in range(n):
    a.append([int(v) for v in input()])

colsums = [sum(a[i][j] for i in range(n)) for j in range(m)]

for row in a:
    if all(rv < sv for (rv, sv) in zip(row, colsums)):
        print(""YES"")
        exit()

print(""NO"")
",O(n ^ 2)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def reverseOddLevels(self, root):
        q = [root]
        parity = 0
        while q:
            if parity:
                left, right = 0, len(q)-1
                while left < right:
                    q[left].val, q[right].val = q[right].val, q[left].val
                    left += 1
                    right -= 1
            if not q[0].left:
                break
            new_q = []
            for node in q:
                new_q.append(node.left)
                new_q.append(node.right)
            q = new_q       
            parity ^= 1
        return root",O(n)
"import collections


class Solution(object):
    def findFrequentTreeSum(self, root):
        def countSubtreeSumHelper(root, counts):
            if not root:
                return 0
            total = root.val + \
                    countSubtreeSumHelper(root.left, counts) + \
                    countSubtreeSumHelper(root.right, counts)
            counts[total] += 1
            return total

        counts = collections.defaultdict(int)
        countSubtreeSumHelper(root, counts)
        max_count = max(counts.values()) if counts else 0
        return [total for total, count in counts.items() if count == max_count]",O(n)
"n=int(input())

x=1

while n>(10**(len(str(x))-1)*9*len(str(x))):
    n-=10**(len(str(x))-1)*9*len(str(x))

    x*=10

t=len(str(x))
nadighe=False
while nadighe==False:
    qw=1
    nadighe=True
    while n>(10**(len(str(qw))-1)*9*t):
        n-=10**(len(str(qw))-1)*9*t
        nadighe=False
        qw*=10
    x+=qw-1

while n>len(str(x)):
    n-=len(str(x))
    x+=1
for i in range(len(str(x))):
    if n!=0:
        s=str(x)[i]
        n-=1
print(s)
",O(logn)
"s = input()
n = len(s)

for L in range(n-1, 0, -1):
    if len({s[i:i+L] for i in range(n-L+1)}) < n-L+1:
        print(L)
        break
else:
    print(0)",O(n ^ 3)
"class Solution(object):
    def removeDuplicates(self, A):
        if not A:
            return 0

        last, i, same = 0, 1, False
        while i < len(A):
            if A[last] != A[i] or not same:
                same = A[last] == A[i]
                last += 1
                A[last] = A[i]
            i += 1

        return last + 1",O(n)
"n, m = map(int, input().split())
a = list(map(int, input().split()))

class BIT:
    def __init__(self, n):
        self.n = n
        self.data = [0]*(n+1)

    def to_sum(self, i):
        s = 0
        while i > 0:
            s += self.data[i]
            i -= (i & -i)
        return s

    def add(self, i, x):
        while i <= self.n:
            self.data[i] += x
            i += (i & -i)

    def get(self, i, j):

        return self.to_sum(j) - self.to_sum(i - 1)

def f(x, V):
    if x < V:
        return -1
    return 1

def calc_median(M):
    b = [f(v, M) for v in a]
    res = 0
    c = [0]
    for x in b:
        c.append(c[-1] + x)
    d = [(c[i], i) for i in range(n + 1)]
    bit = BIT(2*n + 10)
    for value, index in d:
        if index == 0:
            bit.add(value + n + 1, 1)
            continue
        res += bit.get(1, value + n)
        bit.add(value + n + 1, 1)

    return res

print(calc_median(m) - calc_median(m + 1))
",O(nlogn)
"class Solution(object):
    def duplicateZeros(self, arr):
        shift, i = 0, 0
        while i+shift < len(arr):
            shift += int(arr[i] == 0)
            i += 1
        i -= 1
        while shift:
            if i+shift < len(arr):
                arr[i+shift] = arr[i]
            if arr[i] == 0:
                shift -= 1
                arr[i+shift] = arr[i]
            i -= 1",O(n)
"n=int(input())
a=list(map(int,input().split()))
b=list(map(int,input().split()))
a=a[::-1]
c=[0]*n
bk=[]
for i in range(n):
    co=0
    if c[b[i]-1]==0:
        while a[-1]!=b[i]:
            co+=1
            c[a[-1]-1]=1
            a.pop()
        co+=1
        c[a[-1]-1]=1
        a.pop()
    bk.append(co)
print(*bk)
",O(n)
"import sys

got=[10**18]*100005

def getnum(i):
    if got[i]==10**18:
        print(""? %d""%i)
        sys.stdout.flush()
        got[i]=int(input())
    return got[i]

n=int(input())
if n%4==2:

    print(""! -1"")
else:
    lo=1
    hi=n//2+1
    t1=getnum(lo)
    t2=getnum(hi)
    lo2=t1-t2
    hi2=t2-t1
    if lo2==0:
        print(""! 1"")
    else:

        while lo<hi:
            mid=(lo+hi)//2

            mid2=getnum(mid)-getnum(mid+n//2)
            if mid2==0:
                print(""! %d""%mid)
                break
            if (lo2>0) == (mid2>0):
                lo=mid+1
            else:
                hi=mid-1
        else:
            print(""! %d""%lo)
sys.stdout.flush()
",O(logn)
"from sys import stdin, stdout
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))

for _ in range(1):
    r, c=lst()
    a=[input() for i in range(r)]
    pre=[[0 for i in range(c)] for i in range(r)]
    suf=[[0 for i in range(c)] for i in range(r)]
    for i in range(c):
        pre[0][i]=int(a[0][i])
        suf[r-1][i]=int(a[r-1][i])
    for i in range(1, r):
        for j in range(c):
            pre[i][j]=pre[i-1][j]+int(a[i][j])

    for i in range(r-2, -1 ,-1):
        for j in range(c):
            suf[i][j]=suf[i+1][j]+int(a[i][j])
    ans='NO'
    for i in range(r):
        f=1
        for j in range(c):
            up=down=0
            if i-1>=0:up=pre[i-1][j]
            if i+1<r:down=suf[i+1][j]
            if up+down==0:
                f=0
                break
        if f:
            ans=""YES""
            break
    print(ans)
",O(n ^ 2)
"l,r = map(int,input().split())

x = 64
while x>=0 and  (l&(1<<x)) == (r&(1<<x)):
    x-=1
print((1<<(x+1))-1)",O(logn)
"class Solution(object):
    def minSubsequence(self, nums):
        result, total, curr = [], sum(nums), 0
        nums.sort(reverse=True)
        for i, x in enumerate(nums):
            curr += x
            if curr > total-curr:
                break
        return nums[:i+1]",O(nlogn)
"class Solution(object):
    def fizzBuzz(self, n):
        result = []

        for i in range(1, n+1):
            if i % 15 == 0:
                result.append(""FizzBuzz"")
            elif i % 5 == 0:
                result.append(""Buzz"")
            elif i % 3 == 0:
                result.append(""Fizz"")
            else:
                result.append(str(i))

        return result

    def fizzBuzz2(self, n):
        l = [str(x) for x in range(n + 1)]
        l3 = list(range(0, n + 1, 3))
        l5 = list(range(0, n + 1, 5))
        for i in l3:
            l[i] = 'Fizz'
        for i in l5:
            if l[i] == 'Fizz':
                l[i] += 'Buzz'
            else:
                l[i] = 'Buzz'
        return l[1:]

    def fizzBuzz3(self, n):
        return ['Fizz' * (not i % 3) + 'Buzz' * (not i % 5) or str(i) for i in range(1, n + 1)]

    def fizzBuzz4(self, n):
        return ['FizzBuzz'[i % -3 & -4:i % -5 & 8 ^ 12] or repr(i) for i in range(1, n + 1)]",O(n)
"n = int(input())
board = list(map(int, input().strip().split()))
board.insert(0,0)
hashed = [0] * (n+1)
for i in range(n+1):
	hashed[board[i]] = i
answer = ['C'] * (n+1)
for i in range(n,0,-1):
	flag = 0
	k = hashed[i] - board[hashed[i]]
	while(k > 0):
		if(answer[k] == 'B'):
			flag = 1
			break
		k-=board[hashed[i]]
	k = hashed[i] + board[hashed[i]]
	while(k <= n and k != 0):
		if(answer[k] == 'B'):
			flag = 1
			break
		k+=board[hashed[i]]
	if(flag == 1):
		answer[hashed[i]] = 'A'
	else:
		answer[hashed[i]] = 'B'
answer.pop(0)
print(''.join(answer))
",O(nlogn)
"import sys,math
class Node:
    def __init__(self,u=math.inf,d=math.inf,l=math.inf,r=math.inf):
        self.up=u
        self.dn=d
        self.lt=l
        self.rt=r
    def __str__(self):
        return 'U:{},D:{},L:{},R:{}'.format(self.up,self.dn,self.lt,self.rt)

n,m,k=list(map(int,sys.stdin.readline().strip().split()))
graph=[[Node() for j in range(m)]for i in range(n)]
for i in range(n):
    wts=list(map(int,sys.stdin.readline().strip().split()))
    for j in range(m-1):
        graph[i][j].rt=wts[j]
        graph[i][j+1].lt=wts[j]

for i in range(n-1):
    wts=list(map(int,sys.stdin.readline().strip().split()))
    for j in range(m):
        graph[i][j].dn=wts[j]
        graph[i+1][j].up=wts[j]

ans=[[math.inf for j in range(m)]for i in range(n)]

if k%2:
    [[print(' '.join(list(map(lambda x:str(-1) if x==math.inf else str(x),s))))]for s in ans]

else:
    def bfs(prsnt,stps):

        if stps==0:
            return 0
        else:
            if dp[prsnt[0]][prsnt[1]][stps]==math.inf:
                min_cost=math.inf
                for x,y,c in [(0,1,graph[prsnt[0]][prsnt[1]].dn),(1,0,graph[prsnt[0]][prsnt[1]].rt),(0,-1,graph[prsnt[0]][prsnt[1]].up),(-1,0,graph[prsnt[0]][prsnt[1]].lt)]:
                    if -1<prsnt[1]+x<m and -1<prsnt[0]+y<n:
                        min_cost=min(bfs((prsnt[0]+y,prsnt[1]+x),stps-1)+c,min_cost)
                dp[prsnt[0]][prsnt[1]][stps]=min_cost
                return min_cost
            else:
                return dp[prsnt[0]][prsnt[1]][stps]

    dp=[[[math.inf for k in range(k+1)] for j in range(m)]for i in range(n)]
    for i in range(n):
        for j in range(m):
            ans[i][j]=bfs((i,j),k//2)*2
    [[print(' '.join(list(map(lambda x:str(-1) if x==math.inf else str(x),s))))]for s in ans]",O(n ^ 3)
"def secondorder(arr, size):
	arr.sort()
	return arr[1]
size = int(input())
list = []
num = input().split("" "")
for i in num:
	if(int(i) not in list):
		list.append(int(i))
if len(list) == 1:
	print(""NO"")
else:
	print(secondorder(list, size))
",O(nlogn)
"import heapq
n,k = map(int,input().split())
P = list(map(int,input().split()))
C = list(map(int,input().split()))
X = []
for i in range(n):
    X.append([P[i],C[i],i])
X.sort(key = lambda x : x[0])
coins = []
heapq.heapify(coins)
curr = 0
res = [0 for i in range(n)]
for i in range(k):
    heapq.heappush(coins,X[i][1])
    curr += X[i][1]
    res[X[i][2]] = curr
for j in range(k,n):

    res[X[j][2]] = X[j][1] + sum(coins)
    if len(coins)>0:
        x = heapq.heappop(coins)
        if x < X[j][1]:
            heapq.heappush(coins,X[j][1])
        else:
            heapq.heappush(coins,x)

print(*res)",O(nlogn)
"class Solution2(object):
    def missingNumber(self, arr):
        return (min(arr)+max(arr))*(len(arr)+1)//2 - sum(arr)",O(n)
"class Solution:
    def getSum(self, a: int, b: int) -> int:
        carry = 0
        res = 0
        mask = 0xFFFFFFFF

        for i in range(32):
            a_bit = (a >> i) & 1
            b_bit = (b >> i) & 1
            cur_bit = a_bit ^ b_bit ^ carry
            carry = (a_bit + b_bit + carry) >= 2
            if cur_bit:
                res |= (1 << i)

        if res > 0x7FFFFFFF:
            res = ~(res ^ mask)

        return res
",O(1)
"from collections import defaultdict

class Solution(object):
    def firstUniqChar(self, s):
        lookup = defaultdict(int)
        candidtates = set()
        for i, c in enumerate(s):
            if lookup[c]:
                candidtates.discard(lookup[c])
            else:
                lookup[c] = i+1
                candidtates.add(i+1)

        return min(candidtates)-1 if candidtates else -1",O(n)
"class Solution(object):
    def prefixesDivBy5(self, A):
        for i in range(1, len(A)):
            A[i] += A[i-1] * 2 % 5
        return [x % 5 == 0 for x in A]",O(n)
"n = int(input())
ans = 1
for i in range(n):
    ans += i * 4
print(ans)",O(n)
"class Solution(object):
    def reverseString(self, s):
        i, j = 0, len(s) - 1
        while i < j:
            s[i], s[j] = s[j], s[i]
            i += 1
            j -= 1",O(n)
"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        indices = {val: idx for idx, val in enumerate(inorder)}

        self.pre_idx = 0
        def dfs(l, r):
            if l > r:
                return None

            root_val = preorder[self.pre_idx]
            self.pre_idx += 1
            root = TreeNode(root_val)
            mid = indices[root_val]
            root.left = dfs(l, mid - 1)
            root.right = dfs(mid + 1, r)
            return root

        return dfs(0, len(inorder) - 1)
",O(n)
"I=lambda:[*map(int, input().split())]
R = range
m = min
N, M, K = I()
R = range

if K&1:
	for _ in R(N):
		print(*[-1]*M)
	exit()
A = [I() for _ in R(N)]
B = [I() for _ in R(N-1)]
X = [M*[0]for _ in R(N)]
for k in R(1, K//2+1):
	Y = [M*[9**9]for _ in R(N)]
	for i in R(N):
		for j in R(M):
			if i:
				Y[i][j] = X[i-1][j] + 2*B[i-1][j]
			if i<N-1:
				Y[i][j] = m(Y[i][j], X[i+1][j] + 2*B[i][j])
			if j:
				Y[i][j] = m(Y[i][j], X[i][j-1] + 2*A[i][j-1])
			if j<M-1:
				Y[i][j] = m(Y[i][j], X[i][j+1] + 2*A[i][j])
	X = Y
for x in X:
	print(*x)",O(n ^ 3)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def hasPathSum(self, root, sum):
        if root is None:
            return False

        if root.left is None and root.right is None and root.val == sum:
            return True

        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)

",O(n)
"a = list(input())
b = int(input())
a.sort(reverse=True)

ans=''
while a:
    for i in range(len(a)):
        temp=''
        x=ans+a[i]+temp.join(sorted(a[:i]+a[i+1:]))
        if int(x)<=b:
            ans+=a[i]
            a=a[:i]+a[i+1:]
            break
print(int(ans))",O(n ^ 3)
"from itertools import combinations as cmb
n ,l ,r ,x = map(int , input().split())
*a , = map(int ,input().split())
b = []
a.sort()
for i in range(2 ,n+1):
    b.extend(cmb(a ,i))
ans = 0
for i in b:

    if(sum(i) >= l and sum(i) <= r):
        if(i[-1]-i[0] >= x):

            ans+=1

print(ans)",np
"n = int(input())

check = True
t=0
tnext=9

count=1
i=1
j=1
res = 0
while(check):

    if(n<=tnext):
        res=n-t
        check = False

    else:

        count = count+1

        if(t!=0):
            t=t+9*i*j
        else:
            t=9

        tnext = tnext + 9 * (i+1)*(j*10)
        i=i+1
        j=j*10

num1 = int(res/count)
num2 = res%count

des = pow(10,count-1)
despac = des + num1

if(num2 == 0):
    despac = str(despac -1)
    print(despac[-1])

else :
    despac = str(despac)
    print(despac[num2-1])
",O(logn)
"n,t=map(int,input().split())
list=[]
for i in range (n):
    x,a=map(int,input().split())
    list.append((x-a/2,x+a/2))
list.sort()
ans=2
for i in range(n-1):
    dis=list[i+1][0]-list[i][1]
    if dis>t:
        ans+=2
    elif dis==t:
        ans+=1
print(ans)",O(nlogn)
"import sys
input=sys.stdin.readline
a=list(map(int,input().rstrip()))
b=list(map(int,input().rstrip()))
if len(a)<len(b):
    a.sort(reverse=True)
    print(''.join(map(str,a)))
else:
    ans=-1
    ca=[0]*10
    for aa in a:
        ca[aa]+=1
    lim=-1
    for i in range(len(a)):
        if ca[b[i]]:
            candi=[]
            for j in range(i):
                candi.append(b[j])
            use=-1
            for j in range(b[i]-1,-1,-1):
                if ca[j]:
                    use=j
                    ca[j]-=1
                    candi.append(j)
                    break
            if use<0:
                ca[b[i]]-=1
                continue
            else:
                for j in range(10)[::-1]:
                    candi.extend([j]*ca[j])
                res=''.join(map(str,candi))
                res=int(res)
                ans=max(ans,res)
                ca[use]+=1
                ca[b[i]]-=1
        else:
            candi=[]
            for j in range(i):
                candi.append(b[j])
            use=-1
            for j in range(b[i]-1,-1,-1):
                if ca[j]:
                    use=j
                    ca[j]-=1
                    candi.append(j)
                    break
            if use<0:
                break
            else:
                for j in range(10)[::-1]:
                    candi.extend([j]*ca[j])
                res=''.join(map(str,candi))
                res=int(res)
                ans=max(ans,res)
                ca[use]+=1
                break
    flg=True
    ca=[0]*10
    for i in range(len(a)):
        ca[a[i]]+=1
    for i in range(len(a)):
        if ca[b[i]]:
            ca[b[i]]-=1
        else:
            flg=False
    if flg:
        ans=max(ans,int(''.join(map(str,b))))
    print(ans)",O(n ^ 3)
"class Solution(object):
    def isValid(self, word):
        VOWELS = ""aeiou""

        if len(word) < 3:
            return False
        vowel = consonant = False
        for x in word:
            if x.isalpha():
                if x.lower() in VOWELS:
                    vowel = True
                else:
                    consonant = True
            elif not x.isdigit():
                return False
        return vowel and consonant",O(n)
"import sys
m,n = [int(i) for i in input().split(' ')]
l = [[] for _ in range(m)]
for i in range(m):
	l[i] = input()
inks = []
for i in range(1, m-1):
	for j in range(1, n-1):
		if l[i-1][j-1] == '
			   inks += [(i-1,j-1),(i,j-1),(i+1,j-1),
					    (i-1,j  )        ,(i+1,j  ),
						(i-1,j+1),(i,j+1),(i+1,j+1),]
for i in range(m):
	for j in range(n):
		if l[i][j] == '
			print(""NO"")
			sys.exit()
else:
	print(""YES"")
",O(n ^ 2)
"n, k = [int(i) for i in input().split()]
data = [int(i) for i in input().split()]
span = data[-1] - data[0]
delta = [data[i+1] - data[i] for i in range(n-1)]
delta.sort(reverse=True)
print(span - sum(delta[:k-1]))
",O(nlogn)
"import math
n, r = [int(i) for i in input().split()]

t = math.sin(math.pi/n)
res = r*t/(1-t)
print(res)",O(1)
"n,m=map(int,input().split())
dp=[[-1 for i in range(m)] for j in range(n)]
dp2=[[-1 for i in range(m)] for j in range(n)]

for i in range(0,n):
    s=input()
    for j in range(0,m):
        if(s[j]=='.'):
            dp[i][j]=-1
        else:
            dp[i][j]=s[j]
for i in range(0,n-2):
    for j in range(0,m-2):

        p=0
        c=0
        for k in range(i,i+3):
            for h in range(j,j+3):
                p=p+1
                if(p!=5):
                    if(dp[k][h]=='
                        c=c+1

        if(c==8):
            p=0
            for k in range(i,i+3):
                for h in range(j,j+3):
                    p=p+1
                    if(p!=5):
                        dp2[k][h]='

if(dp==dp2):
    print('YES')
else:
    print('NO')
",O(n ^ 2)
"class Solution(object):
    def countSeniors(self, details):
        return sum(x[-4:-2] > ""60"" for x in details)",O(n)
"from collections import defaultdict
from collections import Counter
from collections import deque
import heapq

inf = float('inf')
ninf = float('-inf')

M1 = 10**9 + 7
M2 = 998244353

def li():
    return list(map(int,input().split()))

def pre():
    ""Start""

def solve():
    a = input()
    b = input()
    n = len(a)
    if(len(a)<len(b)):
        a = sorted(list(a),reverse = True)
        print("""".join(a))
        return
    b = int(b)
    ans = 0
    cnt = [0]*10
    for i in range(n):
        cnt[ord(a[i])-ord('0')] += 1

    def getrem(k):
        cnt[k] -= 1
        ans = """"
        for i in range(10):
            for j in range(cnt[i]):
                ans += str(i)
        cnt[k] += 1
        return ans

    prev = """"
    for i in range(n):
        for j in range(9,-1,-1):
            if(cnt[j]>0):
                newval = prev + str(j)+ getrem(j)
                if(int(newval)<=b):
                    ans = max(ans,int(newval))
                    prev += str(j)
                    cnt[j] -= 1
                    break
    print(ans)

pre()

__ = 1

for _ in range(__):
    solve()",O(n ^ 3)
"a=str(input())
b=str(input())
count=0
al=len(a)
bl=len(b)
s=b[:bl-al+1].count('1')
for i in range(al-1):
    if a[i]=='0':
        count+=s
    else:
        count+=bl-al+1-s
    s+=int(b[bl-al+i+1])-int(b[i])

if a[-1]=='0':
    count+=s
else:
    count+=bl-al+1-s
print(count)",O(n)
"class Solution(object):
    def countNumbersWithUniqueDigits(self, n):
        if n == 0:
            return 1
        result = cnt = 1
        for i in range(n-1):
            cnt *= 9-i
            result += cnt
        return 1+9*result",O(n)
"n, m = map(int, input().split())
a = list(map(str, input().strip()))

dp = [10 ** 10] * (1 << 20)
cnt = [0] * (1 << 20)

def get(x):
    return 1 << (ord(x) - ord('a'))

for i, v in enumerate(a):
    if i:
        cnt[get(a[i]) | get(a[i - 1])] += 1

for i in range(m):
    for j in range(1 << m):
        if (1 << i) & j:
            cnt[j] += cnt[j ^ (1 << i)]

dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if not i & (1 << j):
            dp[i | (1 << j)] = min(dp[i | (1 << j)],
                                   dp[i] + n - 1 - cnt[i | (1 << j)] - cnt[(1 << m) - 1 - (i | (1 << j))])
print(dp[(1 << m) - 1])
",np
"import math
n  = int(input())

for i in range(n):
    l,r = [*map(int, input().split())]
    l-=1
    war1 = math.ceil(l/2)
    if(l%2 == 1):
        war1 = -1*war1

    war2 = math.ceil(r/2)
    if(r%2 == 1):
        war2 = -1*war2

    print(war2-war1)",O(1)
"n=int(input())

if n<=2:
    print(n)
else:
    if n%2!=0:
        print(n*(n-1)*(n-2))
    elif n%3==0:
        print((n-1)*(n-2)*(n-3))
    else:
        print(n*(n-1)*(n-3))",O(1)
"n,m=map(int,input().split())
s=input()
t=input()
if n==1:
	if s==t or s=='*':
		print('YES')
	else:
		print('NO')
elif s.count('*')==0:
	if s==t:
		print('YES')
	else:
		print('NO')
elif n>m+1:
	print('NO')
else:
	l=s.split('*')
	x=t[:len(l[0])]
	y=t[-len(l[1]):]
	if (l[0]==x and l[1]==y) or (s[:1]=='*' and l[1]==y) or (l[0]==x and s[-1:]=='*'):
		print('YES')
	else:
		print('NO')",O(n)
"class Solution2(object):
    def findDistance(self, root, p, q):
        def dfs(node, p, q, result):
            if not node:
                return -1
            left = dfs(node.left, p, q, result)
            right = dfs(node.right, p, q, result)
            if node.val in (p, q):
                if left == right == -1:
                    return 0
                result[0] = left+1 if left != -1 else right+1
            if left != -1 and right != -1:
                result[0] = left+right+2
            elif left != -1:
                return left+1
            elif right != -1:
                return right+1
            return -1
        
        result = [0]
        dfs(root, p, q, result)
        return result[0]",O(n)
"class Solution(object):
    def minimumXORSum(self, nums1, nums2):
        def hungarian(a): 
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in range(1, n):
                p[0] = i
                j0 = 0 
                dist, pre = [float(""inf"")]*m, [-1]*m
                done = [False]*(m+1)
                while True: 
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float(""inf"")
                    for j in range(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur < dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] < delta:
                            delta, j1 = dist[j], j
                    for j in range(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0: 
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in range(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans 
        
        adj = [[0]*len(nums2) for _ in range(len(nums1))]
        for i in range(len(nums1)):
            for j in range(len(nums2)):
                adj[i][j] = nums1[i]^nums2[j]
        return hungarian(adj)[0]",O(n ^ 3)
"n, k = map(int, input().split())
print((8 * n + k - 1) // k + (5 * n + k - 1) // k + (2 * n + k - 1) // k)",O(1)
"import collections



class Solution2(object):
    def countPalindromePaths(self, parent, s):
        def dfs(u, mask):
            result = 0
            if u:
                mask ^= 1<<(ord(s[u])-ord('a'))
                result += cnt[mask]+sum(cnt[mask^(1<<i)] if mask^(1<<i) in cnt else 0 for i in range(26))
                cnt[mask] += 1
            return result+sum(dfs(v, mask) for v in adj[u])

        adj = [[] for _ in range(len(parent))]
        for u, p in enumerate(parent):
            if p != -1:
                adj[p].append(u)
        cnt = collections.defaultdict(int)
        cnt[0] = 1
        return dfs(0, 0)",O(n)
"import sys, math, queue

MOD = 10**9+7
sys.setrecursionlimit(1000000)

def getMul(x):
    a = 1
    for xi in x:
        a *= xi
    return a

n = int(input())
a = list(map(int, input().split()))
d = {}
for ai in a:
    if ai in d: d[ai] += 1
    else: d[ai] = 1

f = [[] for i in range(max(a)+10)]
for i in range(1, len(f)):
    for j in range(i, len(f), i):
        f[j].append(i)

seq = [0 for i in range(max(a)+10)]
for ai in d:
    for fi in f[ai]:
        seq[fi] += d[ai]
for i in range(len(seq)):
    seq[i] = (pow(2, seq[i], MOD) -1 +MOD) % MOD

pf = [[] for i in range(max(a)+10)]
pf[0] = None
pf[1].append(1)
for i in range(2, len(f)):
    if len(pf[i]) == 0:
        for j in range(i, len(pf), i):
            pf[j].append(i)
for i in range(1, len(pf)):
    mul = getMul(pf[i])
    if mul == i:
        if len(pf[i])&1 == 1: pf[i] = -1
        else: pf[i] = 1
    else:
        pf[i] = 0
pf[1] = 1

ans = 0
for i in range(1, len(seq)):
    ans += seq[i]*pf[i]
    ans = (ans + MOD) % MOD
print(ans)",np
"class Solution2(object):
    def nthPersonGetsNthSeat(self, n):
        dp = [0.0]*2
        dp[0] = 1.0 
        for i in range(2, n+1):
            dp[(i-1)%2] = 1.0/i+dp[(i-2)%2]*(i-2)/i
        return dp[(n-1)%2]",O(n)
"from sortedcontainers import SortedList



class Solution(object):
    def minimumSumSubarray(self, nums, l, r):
        INF = float(""inf"")
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        result = INF
        sl = SortedList()
        for i in range(len(nums)):
            if i-l+1 >= 0:
                sl.add(prefix[i-l+1])
            if i-r >= 0:
                sl.remove(prefix[i-r])
            idx = sl.bisect_left(prefix[i+1])-1
            if idx >= 0:
                result = min(result, prefix[i+1]-sl[idx])
        return result if result != INF else -1",O(nlogn)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

n, a, b = mi()
c = max(a, b)
if a != 1 and b != 1:
    print('NO')
elif n == 2 and c == 1:
    print('NO')
elif n == 3 and c == 1:
    print('NO')
else:
    if a == 1:
        g = [[1] * n for i in range(n)]
        for i in range(n):
            g[i][i] = 0
        for i in range(c - 1, n - 1):
            g[i][i + 1] = g[i + 1][i] = 0
    else:
        g = [[0] * n for i in range(n)]
        for i in range(c - 1, n - 1):
            g[i][i + 1] = g[i + 1][i] = 1
    print('YES')
    for r in g:
        print(''.join(str(x) for x in r))",O(n ^ 2)
"list1=list(input())
list2=list(input())
plus1=list1.count('+')
plus2=list2.count('+')
minus1=list1.count('-')
minus2=list2.count('-')
wths=list2.count('?')
def giveFactorial(n,x):
    if x==0 or x==n or x>n or n==0:
        return 1
    else:
        return giveFactorial(n-1,x-1)+giveFactorial(n-1,x)
a=(giveFactorial(wths,plus1-plus2))

if plus1==plus2 and wths==0:
    print(1)
elif wths==0 :
    print(0)
elif plus1-plus2>wths or minus1-minus2>wths:
    print(0)
else:
    print((0.5**(plus1-plus2+minus1-minus2))*a)",np
"n = int(input())
ar = []
for i in range(n):
    ar.append(input())
sortedAr = sorted(ar,key=len)
flag = False
for i in range(n-1):
    if sortedAr[i+1].find(sortedAr[i]) == -1:
        print('NO')
        flag = True
        break
if not flag:
    print('YES')
    for i in sortedAr:
        print(i)
",O(nlogn)
"import io,os

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
n,m=map(lambda x:int(x), input().split())
A = []
for _ in range(n):
    scores = list(map(lambda x:int(x), input().split()))
    A.append(scores)

def solve(n,m,A):

    ans = ()
    nstats = 2**m
    def judge(finalScore):
        nonlocal ans
        seen = {}
        for i,scores in enumerate(A):
            sta = 0
            for e in scores:
                sta=sta*2+(e>=finalScore)

            seen[sta]=i

        for i in range(nstats):
            for j in range(nstats):
                if ((i|j) == nstats-1) and i in seen and j in seen:
                    ans = (seen[i], seen[j])
                    return True

        return False

    l=0
    r=2**31-1
    while l<r:
        m=l+(r-l)//2
        if not judge(m):
            r=m
        else:
            l=m+1

    print(ans[0]+1,ans[1]+1)

solve(n,m,A)
",np
"k = int(input())
ch = 0
i = 0
r = 1
while k > r - 1:
    r += 9 * (i + 1) * 10 ** i
    i += 1
r -= 9 * i * 10 ** (i - 1)

print(str((k - r) // i + 10 ** (i - 1))[(k - r) % i]  )
",O(1)
"s=list(input())
ans=0
far=0
for i in range(len(s)-1):
    if(s[i]!=s[i+1]):
        far+=1
        continue
    if(s[0]!=s[-1]):
        s[:i+1]=s[:i+1][::-1]
        s[i+1:]=s[i+1:][::-1]
        far+=1
    else:
        ans=max(ans,far+1)
        far=0

print(max(far+1,ans))
",O(n)
"from collections import Counter

n = int(input())
a = Counter()
b = Counter()
for _ in range(n):
    a[input().strip()] += 1
for _ in range(n):
    b[input().strip()] += 1
ans = 0
for key in b:
    ans += max(b[key] - a[key], 0)

print(ans)",O(n)
"N = int(input())

arr = list(map(int, input().split()))

dp = [[-1 for x in range(N)] for y in range(N)]

for size in range(1, N + 1):
    for i in range(N - size + 1):
        j = i + size - 1
        if (i == j):
            dp[i][j] = arr[i]
        else:
            for k in range(i, j):
                if (dp[i][k] != -1 and dp[i][k] == dp[k + 1][j]):
                    dp[i][j] = dp[i][k] + 1

dp2 = [x+1 for x in range(N)]

for i in range(N):
    for k in range(i + 1):
        if (dp[k][i] != -1):
            if (k == 0):
                dp2[i] = 1
            else:
                dp2[i] = min(dp2[i], dp2[k - 1] + 1)

print(dp2[N - 1])
",O(n ^ 3)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def maxAncestorDiff(self, root):
        result = 0
        stack = [(root, 0, float(""inf""))]
        while stack:
            node, mx, mn = stack.pop()
            if not node:
                continue
            result = max(result, mx-node.val, node.val-mn)
            mx = max(mx, node.val)
            mn = min(mn, node.val)
            stack.append((node.left, mx, mn))
            stack.append((node.right, mx, mn))
        return result",O(n)
"class Solution(object):
    def maximumOddBinaryNumber(self, s):
        a = list(s)
        left = 0
        for i in range(len(a)):
            if a[i] != '1':
                continue
            a[i], a[left] = a[left], a[i]
            left += 1
        if a[-1] != '1':
            a[-1], a[left-1] = a[left-1], a[-1]
        return """".join(a)",O(n)
"def check(e,value,pre):
    global maxi,count
    e[str(value)]-=1
    pre+=str(value)
    arr=[]
    for i in e:
        for j in range(e[i]):
            arr.append(i)
    arr.sort(reverse=True)
    st=''
    for i in arr:
        st+=str(i)
    alpha=int(pre+st)
    if alpha<=int(b):
        maxi=max(maxi,int(pre+st))

a=input()
b=input()
maxi=0
d={}
for i in a:
    if i not in d:
        d[i]=1
    else:
        d[i]+=1
maxi=0
num=""""
count=0
if len(a)<len(b):
    check(d.copy(),max(d),'')
else:
    for i in b:
        if i in d and d[i]>0:
            for j in range(int(i)-1,-1,-1):
                if str(j) in d and d[str(j)]>0:
                    check(d.copy(),j,num)
                    break
            check(d.copy(),i,num)
            num+=i
            d[i]-=1

        else:
            j=0
            for j in range(int(i)-1,-1,-1):
                if str(j) in d and d[str(j)]>0:
                    check(d.copy(),j,num)
                    break
            break
print(maxi)",O(n ^ 3)
"n = int(input())
s = list(input())
t = input()
if sorted(s) != sorted(t):
    print(-1)
else:
    lst = [0] * n
    for i in range(n):
        for j in range(n):
            if s[j] == t[i]:
                lst[j] = i + 1
                s[j] = "".""
                break
    ans = 0
    a = []
    for i in range(n):
        for j in range(n - 1):
            if i != j:
                if lst[j] > lst[j + 1]:
                    ans += 1
                    lst[j], lst[j + 1] = lst[j + 1], lst[j]
                    a.append(j+1)
    print(ans)
    print(*a)",O(n ^ 2)
"n = int(input())
maxlength = 12

lengths = [1]
for i in range(1, maxlength+1):
    lengths.append(lengths[i-1]+9*i*(10**(i-1)))

def getnum(n):
    global lengths
    mx = maxlength - 1
    mn = 0
    while 1:
        chk = (mx - mn) // 2
        if chk == 0:
            break
        chk += mn
        if n < lengths[chk]:
            mx = chk
        else:
            mn = chk
    curlength = mx
    curlength_ind = n - lengths[curlength - 1]
    curdigind = curlength_ind % curlength
    beforenumscount = curlength_ind // curlength
    result = 0 + (beforenumscount // (10 ** (curlength - curdigind - 1)) + (curdigind == 0)) % 10
    return result

print(getnum(n))
",O(logn)
"class Solution(object):
    def minKBitFlips(self, A, K):
        result, curr = 0, 0
        for i in range(len(A)):
            if i >= K:
                curr -= A[i-K]//2
            if curr & 1 ^ A[i] == 0:
                if i+K > len(A):
                    return -1
                A[i] += 2
                curr, result = curr+1, result+1
        return result",O(n)
"class Solution(object):
    def tictactoe(self, moves):
        row, col = [[0]*3 for _ in range(2)], [[0]*3 for _ in range(2)]
        diag, anti_diag = [0]*2, [0]*2
        p = 0
        for r, c in moves:
            row[p][r] += 1
            col[p][c] += 1
            diag[p] += r == c
            anti_diag[p] += r+c == 2
            if 3 in (row[p][r], col[p][c], diag[p], anti_diag[p]):
                return ""AB""[p]
            p ^= 1
        return ""Draw"" if len(moves) == 9 else ""Pending""",O(1)
"n = int(input().rstrip())
arr = []
mod = pow(10,9) + 7
indent_num = 0
for i in range(n):
    arr.append(input().rstrip())
    if arr[i] == 'f':
        indent_num += 1
dp = [0 for i in range(indent_num + 1)]
max_indent = 0

cur_indent = 0
pref = [0 for i in range(indent_num + 1)]

def cal_pref(dp, pref):
    pref[0] = dp[0]
    for i in range(1, len(dp)):
        pref[i] = pref[i - 1] + dp[i]

for i in range(n):
    if arr[i] == 'f':
        cur_indent += 1
        max_indent += 1
        continue
    cur = [0 for i in range(indent_num + 1)]
    cal_pref(dp, pref)
    for j in range(cur_indent,indent_num + 1):
        res_idx = j - cur_indent
        res_result = pref[res_idx - 1] if res_idx > 0 else 0
        cur[j] = (pref[indent_num] - res_result) % mod

    cur[max_indent] = 1 if not cur[max_indent] else cur[max_indent]
    dp = cur
    cur_indent = 0

print(sum(dp) % mod)
",O(n ^ 2)
"class Solution(object):
    def breakPalindrome(self, palindrome):
        for i in range(len(palindrome)//2):
            if palindrome[i] != 'a':
                return palindrome[:i] + 'a' + palindrome[i+1:]
        return palindrome[:-1] + 'b' if len(palindrome) >= 2 else """"",O(n)
"n, s = map( int, input().split() )

ans = 0
while s > 0:
    a = s // n
    s -= n * a
    ans += a
    n -= 1

print( ans )
",O(n)
"n, a, b = map(int, input().split())
if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:
    print('NO')
    exit()
print('YES')
f = int(a == 1)
g = [a, b][f]
r = [[f] * n for i in range(n)]
for i in range(n):
    r[i][i] = 0
for i in range(n - g):
    r[i][i + 1] ^= 1
    r[i + 1][i] ^= 1
for x in r:
    print(*x, sep='')
johnny=0
",O(n ^ 2)
"p1, g1, ig1 = 104857601, 3, 34952534
p2, g2, ig2 = 111149057, 3, 37049686
p3, g3, ig3 = 113246209, 7, 16178030
z1 = 439957480532171226961446
z2 = 879898597692195524486915
z3 = 8496366309945115353
ppp = p1 * p2 * p3
W1 = [pow(g1, (p1 - 1) >> i, p1) for i in range(22)]
W2 = [pow(g2, (p2 - 1) >> i, p2) for i in range(22)]
W3 = [pow(g3, (p3 - 1) >> i, p3) for i in range(22)]
iW1 = [pow(ig1, (p1 - 1) >> i, p1) for i in range(22)]
iW2 = [pow(ig2, (p2 - 1) >> i, p2) for i in range(22)]
iW3 = [pow(ig3, (p3 - 1) >> i, p3) for i in range(22)]

def fft1(k, f):
    for l in range(k, 0, -1):
        d = 1 << l - 1
        U = [1]
        for i in range(d):
            U.append(U[-1] * W1[l] % p1)

        for i in range(1 << k - l):
            for j in range(d):
                s = i * 2 * d + j
                f[s], f[s+d] = (f[s] + f[s+d]) % p1, U[j] * (f[s] - f[s+d]) % p1
def fft2(k, f):
    for l in range(k, 0, -1):
        d = 1 << l - 1
        U = [1]
        for i in range(d):
            U.append(U[-1] * W2[l] % p2)

        for i in range(1 << k - l):
            for j in range(d):
                s = i * 2 * d + j
                f[s], f[s+d] = (f[s] + f[s+d]) % p2, U[j] * (f[s] - f[s+d]) % p2
def fft3(k, f):
    for l in range(k, 0, -1):
        d = 1 << l - 1
        U = [1]
        for i in range(d):
            U.append(U[-1] * W3[l] % p3)

        for i in range(1 << k - l):
            for j in range(d):
                s = i * 2 * d + j
                f[s], f[s+d] = (f[s] + f[s+d]) % p3, U[j] * (f[s] - f[s+d]) % p3

def ifft1(k, f):
    for l in range(1, k + 1):
        d = 1 << l - 1
        for i in range(1 << k - l):
            u = 1
            for j in range(i * 2 * d, (i * 2 + 1) * d):
                f[j+d] *= u
                f[j], f[j+d] = (f[j] + f[j+d]) % p1, (f[j] - f[j+d]) % p1
                u = u * iW1[l] % p1
def ifft2(k, f):
    for l in range(1, k + 1):
        d = 1 << l - 1
        for i in range(1 << k - l):
            u = 1
            for j in range(i * 2 * d, (i * 2 + 1) * d):
                f[j+d] *= u
                f[j], f[j+d] = (f[j] + f[j+d]) % p2, (f[j] - f[j+d]) % p2
                u = u * iW2[l] % p2
def ifft3(k, f):
    for l in range(1, k + 1):
        d = 1 << l - 1
        for i in range(1 << k - l):
            u = 1
            for j in range(i * 2 * d, (i * 2 + 1) * d):
                f[j+d] *= u
                f[j], f[j+d] = (f[j] + f[j+d]) % p3, (f[j] - f[j+d]) % p3
                u = u * iW3[l] % p3

def convolve(a, b):
    n0 = len(a) + len(b) - 1
    if len(a) < 50 or len(b) < 50:
        ret = [0] * n0
        if len(a) > len(b): a, b = b, a
        for i, aa in enumerate(a):
            for j, bb in enumerate(b):
                ret[i+j] = (ret[i+j] + aa * bb) % P
        return ret

    k = (n0).bit_length()
    n = 1 << k
    a = a + [0] * (n - len(a))
    b = b + [0] * (n - len(b))

    a1 = [x % p1 for x in a]
    a2 = [x % p2 for x in a]
    a3 = [x % p3 for x in a]
    b1 = [x % p1 for x in b]
    b2 = [x % p2 for x in b]
    b3 = [x % p3 for x in b]
    fft1(k, a1), fft1(k, b1)
    fft2(k, a2), fft2(k, b2)
    fft3(k, a3), fft3(k, b3)
    for i in range(n): a1[i] = a1[i] * b1[i] % p1
    for i in range(n): a2[i] = a2[i] * b2[i] % p2
    for i in range(n): a3[i] = a3[i] * b3[i] % p3
    ifft1(k, a1)
    ifft2(k, a2)
    ifft3(k, a3)
    invn1 = pow(n, p1 - 2, p1)
    invn2 = pow(n, p2 - 2, p2)
    invn3 = pow(n, p3 - 2, p3)
    for i in range(n0): a1[i] = a1[i] * invn1 % p1
    for i in range(n0): a2[i] = a2[i] * invn2 % p2
    for i in range(n0): a3[i] = a3[i] * invn3 % p3
    return [(x1 * z1 + x2 * z2 + x3 * z3) % ppp % P for x1, x2, x3 in zip(a1[:n0], a2[:n0], a3[:n0])]
def chk(L):
    return [fa[i] * x % P for i, x in enumerate(L)]
def chkinv(L):
    return [fainv[i] * x % P for i, x in enumerate(L)]
N, P = map(int, input().split())

nn = 1001

fa = [1] * (nn+1)
fainv = [1] * (nn+1)
for i in range(nn):
    fa[i+1] = fa[i] * (i+1) % P
fainv[-1] = pow(fa[-1], P-2, P)
for i in range(nn)[::-1]:
    fainv[i] = fainv[i+1] * (i+1) % P

X = [[] for _ in range(444)]
Y = [[] for _ in range(444)]
X[0] = [1]
X[1] = [0, 1]
X[2] = [0, 1, 1]
X[3] = [0, 0, 4, 1]

Y[0] = [1]
Y[1] = [1, 0]
Y[2] = [0, 2, 0]
Y[3] = [0, 1, 4, 0]

for i in range(4, 404):
    X[i] = [0] * i + [1]
    Y[i] = [0] * (i + 1)
    for j in range(1, i):
        k = i - j
        X[i][j] = (X[i-1][j-1] * (2 * k + 1) + X[i-2][j-1] * k) % P
        Y[i][j] = (Y[i-1][j-1] * (2 * k) + Y[i-2][j-1] * (k-1)) % P

X = [chkinv(a) for a in X]
Y = [chkinv(a) for a in Y]

ANS = [0] * (N + 1)
for i in range(N):
    t = convolve(X[i], X[N-1-i])
    for j, a in enumerate(t):
        ANS[j] = (ANS[j] + a) % P

ans = 0
for i, a in enumerate(ANS):
    ans = (ans + a * fa[i]) % P
print(ans)
",O(n ^ 3)
"class Solution(object):
    def longestConsecutive(self, num):
        result, lengths = 1, {key: 0 for key in num}
        for i in num:
            if lengths[i] == 0:
                lengths[i] = 1
                left, right = lengths.get(i - 1, 0), lengths.get(i + 1, 0)
                length = 1 + left + right
                result, lengths[i - left], lengths[i + right] = max(result, length), length, length
        return result",O(n)
"class Solution(object):
    def removeDuplicates(self, S):
        result = []
        for c in S:
            if result and result[-1] == c:
                result.pop()
            else:
                result.append(c)
        return """".join(result)",O(n)
"import math
ans = [1, 3, 15, 133, 2025, 37851, 1030367, 36362925]
n = int(input())

if (n % 2 == 1):
	print(ans[n // 2] * math.factorial(n) % 1000000007)
else:
	print(0)",np
"n=int(input())
print(""0"",""0"",n)",O(1)
"from sys import stdin, stdout

def dfs(l, r, dp, a_a):
    if l == r:
        return a_a[l]
    if l+1 == r:
        if a_a[l] == a_a[r]:
            return a_a[l] + 1
        else:
            return -1

    if dp[l][r] != 10**6:
        return dp[l][r]

    dp[l][r] = -1
    for m in range(l, r):
        r1 = dfs(l, m, dp, a_a)
        r2 = dfs(m+1, r, dp, a_a)
        if r1 > 0 and r1 == r2:
            dp[l][r] = r1 + 1
            return dp[l][r]

    return dp[l][r]

def array_shrinking(n, a_a):
    dp = [[10**6 for _ in range(n)]  for _ in range(n)]
    dp2 = [10**6 for _ in range(n)]
    for i in range(n):
        dp2[i] = min(i + 1, dp2[i])
        for j in range(i, n):
            r = dfs(i, j, dp, a_a)
            if r != -1:
                if i > 0:
                    dp2[j] = min(dp2[i-1] + 1, dp2[j])
                else:
                    dp2[j] = min(1, dp2[j])

    return dp2[n-1]

n = int(stdin.readline())
a_a = list(map(int, stdin.readline().split()))
res = array_shrinking(n, a_a)
stdout.write(str(res))
",O(n ^ 3)
"n, m = [int(x) for x in input().split()]
xs = [int(x) for x in input().split()]
ts = [int(x) for x in input().split()]

taxi_idx = sorted([xs[idx] for idx in range(n + m) if ts[idx] == 1])
passenger_idx = sorted([xs[idx] for idx in range(n + m) if ts[idx] == 0])

a_is = [0] * len(taxi_idx)
t_idx = 0
p_idx = 0

while True:
    if p_idx >= len(passenger_idx):
        break

    if t_idx == len(taxi_idx) - 1:
        a_is[t_idx] += 1
    else:
        while t_idx < len(taxi_idx) - 1:
            d1 = abs(passenger_idx[p_idx] - taxi_idx[t_idx])
            d2 = abs(passenger_idx[p_idx] - taxi_idx[t_idx + 1])

            if d1 > d2:
                t_idx += 1
            else:
                break

        a_is[t_idx] += 1

    p_idx += 1

print(' '.join([str(x) for x in a_is]))
",O(n ^ 2)
"class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def removeStones(self, stones):
        MAX_ROW = 10000
        union_find = UnionFind(2*MAX_ROW)
        for r, c in stones:
            union_find.union_set(r, c+MAX_ROW)
        return len(stones) - len({union_find.find_set(r) for r, _ in stones})",O(n)
"n,s = map(int,input().split())
t=[[0,0]]
for j in range(n):

    a,b = map(int,input().split())

    total = a*60+b

    last = t[-1][0]*60+t[-1][1]+1

    t.append([a,b])

    if j==0:
        if total>= s+1:
            print(0,0)
            break
    if total-last > 2*s:
        u = last+s
        print(u//60, u%60)
        break

    if j==n-1:
        x = t[-1][0]*60+t[-1][1]
        print((x+s+1)//60 ,(x+s+1)%60 )
        break
",O(n)
"import sys
n=int(input())

i=0
ANS=[]
while n>0:
    if n==3:
        ANS=ANS+[2**i,2**i,3*2**i]
        break
    x=(n+1)//2
    ANS=ANS+[2**i]*x
    n=n-x
    i+=1

for a in ANS:
    print(a,end="" "")
",O(logn)
"class Solution2(object):
    def countGoodNodes(self, edges):
        def dfs(u, p):
            total = l = 0
            valid = True
            for v in adj[u]:
                if v == p:
                    continue
                cnt = dfs(v, u)
                total += cnt
                l += 1
                if l*cnt != total:
                    valid = False
            if valid:
                result[0] += 1
            return total+1
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]
        dfs(0, -1)
        return result[0]",O(n)
"class Solution(object):
    def baseNeg2(self, N):
        result = []
        while N:
            result.append(str(-N & 1)) 
            N = -(N >> 1) 
        result.reverse()
        return """".join(result) if result else ""0""",O(logn)
"n = input()
ans = 0
j = 2
for i in range(2,n/2 + 1):
    while i * j <= n:
        ans += j * 4

        j += 1
    else :j = 2
print(ans)",O(nlogn)
"import copy
import sys

def find_loop(g, w, k, n):
    visited = [False] * n
    visited_int = [False] * n
    for i in range(n):
        if visited[i]:
            continue
        stack = [g[i][:]]
        path = [i]
        visited[i] = True
        visited_int[i] = True
        while stack:
            if not stack[-1]:
                stack.pop()
                visited_int[path[-1]] = False
                path.pop()
                continue
            nxt = stack[-1][-1]
            stack[-1].pop()
            if w[(path[-1], nxt)] <= k:
                continue
            if visited_int[nxt]:
                return True
            if visited[nxt]:
                continue
            visited[nxt] = True
            visited_int[nxt] = True
            stack.append(g[nxt][:])
            path.append(nxt)
    return False

def top_sort(g, w, k, n):
    visited = [False] * n
    order = [-1] * n
    cnt = 0
    for i in range(n):
        if visited[i]:
            continue
        stack = [g[i][:]]
        path = [i]
        visited[i] = True
        while stack:
            if not stack[-1]:
                order[path[-1]] = cnt
                path.pop()
                stack.pop()
                cnt += 1
                continue
            nxt = stack[-1][-1]
            stack[-1].pop()
            if w[(path[-1], nxt)] <= k:
                continue
            if visited[nxt]:
                continue
            visited[nxt] = True
            stack.append(g[nxt][:])
            path.append(nxt)

    to_reverse = []
    for a, b in w.items():
        if b > k:
            continue
        if order[a[0]] < order[a[1]]:
            to_reverse.append(a)
    return to_reverse

if __name__ == '__main__':
    n, m = map(int, input().split())
    w = {}
    g = [[] for _ in range(n)]
    w_tmp = {}
    c_m = 0
    kk = [0]
    lines = sys.stdin.readlines()
    for i, line in enumerate(lines):
        u, v, c = map(int, line.split())
        g[u - 1].append(v - 1)
        if (u - 1, v - 1) in w.keys():
            w[(u - 1, v - 1)] = max(w[(u - 1, v - 1)], c)
        else:
            w[(u - 1, v - 1)] = c
        if (u - 1, v - 1) in w_tmp.keys():
            w_tmp[(u - 1, v - 1)].append(str(i + 1))
        else:
            w_tmp[(u - 1, v - 1)] = [str(i + 1)]
        kk.append(c)

    kk.sort()
    l, r = 0, len(kk)
    if not find_loop(g, w, kk[l], n):
        print(0, 0)
        exit(0)
    if find_loop(g, w, kk[-1], n):
        kkk = kk[-1]
    else:
        while l + 1 != r:
            m = int((l + r) / 2)

            if find_loop(g, w, kk[m], n):
                l = m
            else:
                r = m
        kkk = kk[l+1]

    to_reverse = top_sort(g, w, kkk, n)
    num = 0
    s = []
    for t in to_reverse:
        num += len(w_tmp[t])
        s.extend(w_tmp[t])

    print(kkk, num)
    print("" "".join(s))
",O(nlogn)
"z=)]

n, m = map(int, input().split())

print(k[n]%m)",O(n ^ 2)
"def bs(l, h):
    while l < h:
        m = (l + h) // 2
        if gf(m):
            h = m
        else:
            l = m + 1
    return l

def gf(x):
    d = {}
    for i in range(x):
        if s[i] in d:
            d[s[i]] += 1
        else:
            d[s[i]] = 1
    if len(d) == len(u):
        return 1
    for i in range(x, n):
        if s[i] in d:
            d[s[i]] += 1
        else:
            d[s[i]] = 1
        d[s[i - x]] -= 1
        if not d[s[i - x]]:
            del d[s[i - x]]
        if len(d) == len(u):
            return 1
    return 0

n = int(input())
s = input()
u = set([*s])
print(bs(1, n))",O(n)
"class Solution(object):
    def minimumHammingDistance(self, source, target, allowedSwaps):
        def iter_flood_fill(adj, node, lookup, idxs):
            stk = [node]
            while stk:
                node = stk.pop()
                if node in lookup:
                    continue
                lookup.add(node)
                idxs.append(node)
                for child in adj[node]:
                    stk.append(child)

        adj = [set() for i in range(len(source))]
        for i, j in allowedSwaps:
            adj[i].add(j)
            adj[j].add(i)
        result = 0
        lookup = set()
        for i in range(len(source)):
            if i in lookup:
                continue
            idxs = []
            iter_flood_fill(adj, i, lookup, idxs)
            source_cnt = collections.Counter([source[i] for i in idxs])
            target_cnt = collections.Counter([target[i] for i in idxs])
            diff = source_cnt-target_cnt
            result += sum(diff.values())
        return result",O(n)
"import math

n, m, k = list(map(lambda i: int(i), input().split(sep=' ')))
p = list(map(lambda i: int(i), input().split(sep=' ')))
p.sort()
page_max = k
action_count = 0
index = 0
while index < m:
    while index < m and p[index] <= page_max:
        count = 0
        while index < m and p[index] <= page_max:
            index += 1
            count += 1
        if count > 0:
            action_count += 1
        page_max += count

    pc = 1 if index >= m else math.ceil((p[index] - page_max) / k)
    page_max += k * pc

print(action_count)
",O(nlogn)
"class Solution(object):
    def __init__(self):
        self.__max_log3 = int(math.log(0x7fffffff) / math.log(3))
        self.__max_pow3 = 3 ** self.__max_log3

    def isPowerOfThree(self, n):
        return n > 0 and self.__max_pow3 % n == 0",O(1)
"from math import *
from fractions import *
def li():
  return list(map(int, input().split("" "")))
n,k = li()
if k == 1:
  print(""1"" + ""0""*(n-1))
else:
  a = (n-k)//2
  p = ""1"" + ""0""*a
  ans = p * (n//(a+1)) + p[:(n%(a+1))]
  print(ans)",O(1)
"class Solution2(object):
    def lowestCommonAncestor(self, root, nodes):
        def dfs(node, lookup):
            if not node or node in lookup:
                return node
            left, right = dfs(node.left, lookup), dfs(node.right, lookup)
            if left and right:
                return node
            return left or right
        
        return dfs(root, set(nodes))",O(n)
"print(""? 0 0"")
ans00 = input()
xr = 0
a = 0
b = 0
cb = 2 ** 29
while cb:
	print(""?"", xr + cb, cb)
	ans11 = input()
	print(""?"", xr, cb)
	if ans11 == ans00:
		ans01 = input()
		if ans01 == '1':
			a += cb
			b += cb
	else:
		ans00 = input()
		if ans11 == '1':
			b += cb
		else:
			a += cb
		xr += cb
	cb //= 2
print(""!"", a, b)
",O(1)
"n, m =map(int, input().split())
if m % n != 0:
	print( m // n + 1)
else:
	print(m // n)
",O(1)
"k = int(input())
k_=k
ca = 9
di = 1
tem = 9
while k_>0:
    k_-=ca*di
    ca*=10
    di+=1
    tem += ca*di
    if k_==0:
        break
tem -= ca*di
ca=int(ca/10)
di-=1
tem -= ca*di
ca=int(ca/10)
ca_=0
while ca>0:
    ca_+=ca
    ca= int(ca/10)
k -= tem
re = int((k+di-1)//di)+ca_
re_= k%di
if re_==0:
    l=1
else:
    l = 10**(di-re_)
re = int(re//l)
print(re%10)
",O(logn)
"class Solution(object):
    def countMatchingSubarrays(self, nums, pattern):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        def KMP(text, pattern):
            prefix = getPrefix(pattern)
            j = -1
            for i, x in enumerate(text):
                while j+1 > 0 and pattern[j+1] != x:
                    j = prefix[j]
                if pattern[j+1] == x:
                    j += 1
                if j+1 == len(pattern):
                    yield i-j
                    j = prefix[j]

        return sum(1 for _ in KMP((cmp(nums[i+1], nums[i]) for i in range(len(nums)-1)), pattern))",O(n)
"n=int(input())
a=list(map(int,input().split()))
c=0
po=[0]*1000000
ne=[0]*1000000
for i in range(n):
    if(a[i]<0 and ne[a[i]]!=1):
        c+=1
        ne[a[i]]=1
    elif(a[i]>0 and po[a[i]]!=1):
        c+=1
        po[a[i]]=1
print(c)",O(n)
"import os
from io import BytesIO, IOBase
import sys

def main():
    n = int(input())
    a = list(map(int,input().split()))
    a = set(a)
    a = list(sorted(list(a)))
    if len(a) == 1:
        print(""NO"")
    else:
        print(a[1])
    return

BUFSIZE = 1048576

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda: self.buffer.read().decode('ascii')
        self.readline = lambda: self.buffer.readline().decode('ascii')

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
def input(): return sys.stdin.readline().rstrip('\r\n')

if __name__ == '__main__':
    main()",O(nlogn)
"def iscollinear(p1, p2, p3):
    x1, y1 = p1
    x2, y2 = p2
    x3, y3 = p3
    cross = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)
    ans = bool(cross)
    return not ans

def checkfortwolines(a, b, points):
    set1 = set(points)
    for i in range(n):
        if iscollinear(a, b, points[i]): set1.remove(points[i])

    if len(set1) <= 2: return True
    else:
        pts1 = list(set1)
        for i in range(len(pts1)):
            if not iscollinear(pts1[0], pts1[1], pts1[i]): return False
        return True

n = int(input())
if n <= 4: print(""YES"")
else:
    points = [0 for i in range(n)]
    for i in range(n):
        points[i] = tuple(map(int, input().split()))
    a = points[0]
    b = points[1]
    c = points[2]
    if checkfortwolines(a, b, points) or checkfortwolines(b, c, points) or checkfortwolines(c, a, points):
        print(""YES"")
    else: print(""NO"")
",O(nlogn)
"class Solution(object):
    def removeElement(self, A, elem):
        i, last = 0, len(A) - 1
        while i <= last:
            if A[i] == elem:
                A[i], A[last] = A[last], A[i]
                last -= 1
            else:
                i += 1
        return last + 1",O(n)
"modulo = 1000 ** 3 + 7

def mat_oz(x, k):
    if k == 0:
        return (2 * x) % modulo
    if x == 0:
        return 0
    b = (pow(2, k, modulo) * (2 * x - 1) + 1) % modulo
    return b

y, m = [int(i) for i in input().split()]
print(mat_oz(y, m))
",O(logn)
"x,k=map(int,input().split())
print(0 if x==0 else (x*pow(2,k+1,10**9+7)-pow(2,k,10**9+7)+1)%(10**9+7))",O(logn)
"from collections import deque
n = int(input())
graph = [set() for i in range(n + 1)]
graph[0].add(1)
graph[1].add(0)
for i in range(n - 1):
    x, y = map(int, input().split())
    graph[x].add(y)
    graph[y].add(x)
a = list(map(int, input().split()))
q = deque()
q.append(0)
i = 0
par = [0] * (n + 1)
while len(q):
    v = q.popleft()
    graph[v].discard(par[v])
    l = len(graph[v])
    if graph[v] != set(a[i:i + l]):
        print(""No"")
        break
    for j in range(i, i + l):
        q.append(a[j])
        par[a[j]] = v
    i += l
else:
    print(""Yes"")",O(n)
"ri,gi,bi=map(int,input().split())
rr=sorted(list(map(int,input().split())))
gr=sorted(list(map(int,input().split())))
br=sorted(list(map(int,input().split())))
dp=[[[-1]*(bi+1) for i in range(gi+1)] for j in range(ri+1)]
def area(r,g,b):
	if dp[r+1][g+1][b+1]!=-1:
		return dp[r+1][g+1][b+1]
	ans=0
	if r>=0 and g>=0:
		ans=max(ans,rr[r]*gr[g]+area(r-1,g-1,b))
	if r>=0 and b>=0:
		ans=max(ans,rr[r]*br[b]+area(r-1,g,b-1))
	if b>=0 and g>=0:
		ans=max(ans,br[b]*gr[g]+area(r,g-1,b-1))
	dp[r+1][g+1][b+1]=ans
	return ans
print(area(ri-1,gi-1,bi-1))",O(n ^ 3)
"start, end, height = 0, 1, 2
class Solution(object):
    def getSkyline(self, buildings):
        intervals = self.ComputeSkylineInInterval(buildings, 0, len(buildings))

        res = []
        last_end = -1
        for interval in intervals:
            if last_end != -1 and last_end < interval[start]:
                res.append([last_end, 0])
            res.append([interval[start], interval[height]])
            last_end = interval[end]
        if last_end != -1:
            res.append([last_end, 0])

        return res

    def ComputeSkylineInInterval(self, buildings, left_endpoint, right_endpoint):
        if right_endpoint - left_endpoint <= 1:
            return buildings[left_endpoint:right_endpoint]
        mid = left_endpoint + ((right_endpoint - left_endpoint) / 2)
        left_skyline = self.ComputeSkylineInInterval(buildings, left_endpoint, mid)
        right_skyline = self.ComputeSkylineInInterval(buildings, mid, right_endpoint)
        return self.MergeSkylines(left_skyline, right_skyline)

    def MergeSkylines(self, left_skyline, right_skyline):
        i, j = 0, 0
        merged = []

        while i < len(left_skyline) and j < len(right_skyline):
            if left_skyline[i][end] < right_skyline[j][start]:
                merged.append(left_skyline[i])
                i += 1
            elif right_skyline[j][end] < left_skyline[i][start]:
                merged.append(right_skyline[j])
                j += 1
            elif left_skyline[i][start] <= right_skyline[j][start]:
                i, j = self.MergeIntersectSkylines(merged, left_skyline[i], i,\
                                                   right_skyline[j], j)
            else:
                j, i = self.MergeIntersectSkylines(merged, right_skyline[j], j, \
                                                   left_skyline[i], i)

        merged += left_skyline[i:]
        merged += right_skyline[j:]
        return merged

    def MergeIntersectSkylines(self, merged, a, a_idx, b, b_idx):
        if a[end] <= b[end]:
            if a[height] > b[height]:  
                if b[end] != a[end]:   
                    b[start] = a[end]
                    merged.append(a)
                    a_idx += 1
                else:            
                    b_idx += 1   
            elif a[height] == b[height]: 
                b[start] = a[start]      
                a_idx += 1
            else: 
                if a[start] != b[start]:                           
                    merged.append([a[start], b[start], a[height]]) 
                a_idx += 1
        else: 
            if a[height] >= b[height]: 
                b_idx += 1             
            else:
                if a[start] != b[start]:
                    merged.append([a[start], b[start], a[height]])
                a[start] = b[end]
                merged.append(b)
                b_idx += 1
        return a_idx, b_idx",O(nlogn)
"n=int(input())
if(n<3):
	print(n)
	exit(0)
if n%2==1:
	print(n*(n-1)*(n-2))
else:
	g=0;
	if n%3==0:
		g=n-2
	else:g=n;
	print((n-1)*(n-3)*(g))
",O(1)
"k = int(input()) - 1

l = 1
c = 9
while k >= c*l:
    k -= c * l
    l += 1
    c *= 10

c = 10**(l-1) + k // l
print(str(c)[k % l])
",O(1)
"def main():
    n = int(input())
    arr = list(map(int, input().split()))
    ans = 10 ** 10
    for i in range(n):
        x = i if i > n - i - 1 else n - i - 1
        ans = min(ans, arr[i] // x)
    print(ans)
main()",O(n)
"class Solution3(object):
    def isAnagram(self, s, t):
        return sorted(s) == sorted(t)",O(nlogn)
"import sys
input = sys.stdin.buffer.readline

n = int(input())
a = list(map(int,input().split()))

parity = 0
for i in range(n):
    for j in range(i+1,n):
        if a[j] < a[i]:
            parity ^= 1

m = int(input())
for i in range(m):
    l,r = map(int,input().split())

    dist = (r-l+1)
    pairs = (dist-1)*(dist)//2

    if pairs & 1:
        parity ^= 1

    if parity:
        print(""odd"")
    else:
        print(""even"")",O(n ^ 2)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def pairSum(self, head):
        def reverseList(head):
            dummy = ListNode()
            while head:
                dummy.next, head.next, head = head, dummy.next, head.next
            return dummy.__next__

        dummy = ListNode(next=head)
        slow = fast = dummy
        while fast.__next__ and fast.next.__next__:
            slow, fast = slow.__next__, fast.next.__next__
        result = 0
        head2 = reverseList(slow)
        while head:
            result = max(result, head.val+head2.val)
            head, head2 = head.__next__, head2.__next__
        return result",O(n)
"class Solution(object):
    def minimumOneBitOperations(self, n):
        def gray_to_binary(n):
            result = 0
            while n:
                result ^= n
                n >>= 1
            return result
        return gray_to_binary(n)",O(logn)
"n, m = map(int, input().split())
a = 1
for i in range(n - 1):
  a *= 10
  a += 1
b = 10 ** n - a
print(a)
print(b)",O(1)
"str=input()
n=len(str)
ans=0
amap={}
def fun():
    global ans
    for strLen in range(n,0,-1):
        mark=0
        for t in range(0,n):
            if t+strLen>n:
                break
            s=str[t:t+strLen]
            if s in amap:
                amap[s]+=1
            else:
                amap[s]=1
            if amap[s]>=2:
                mark=1
                ans=len(s)
                print(ans)
                break
        if mark==1:
            break
fun()
if ans==0:
    print(ans)",O(n ^ 3)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

import random
import time
random.seed( int(time.time()) )

bb = random.randint(0, 2**30-1)

hat1 = 0
hat2 = 0
lastresult = None
for i in range(29, -1, -1):
    g1 = hat1 + (1<<i)
    g2 = hat2 + (1<<i)

    if lastresult is None:
        print('?',hat1^ bb,hat2)
        t1 = int(input())
    else:
        t1 = lastresult
    if t1!=0:
        print('?',g1^ bb,g2)
        t2 = int(input())
        if t1!=t2:
            if t1==1:
                hat1+= (1<<i)
            else:
                hat2+= (1<<i)
            lastresult = None
            continue
    lastresult = t1
    print('?',g1^ bb,hat2)
    t3 = int(input())
    if t3==1:
        pass
    else:
        hat1+= (1<<i)
        hat2+= (1<<i)

print('!', hat1^bb% (2**30), hat2)
",O(logn)
"import sys
from math import floor, ceil

input = sys.stdin.readline

n, k = map(int, input().split())

print(ceil((n*2)/k) + ceil((n*5)/k) + ceil((n*8)/k))",O(1)
"n, a, b = map(int, input().split())
ghosts = [(vx, vy) for x, vx, vy in (map(int, input().split()) for i in range(n))]
speeds = {}
for vx, vy in ghosts:
    vl = a * vx - vy
    k = vx + a * vy
    ss = speeds.setdefault(vl, {})
    ss[k] = ss.get(k, 0) + 1

result = 0
for vl, ss in speeds.items():
    group_size = sum(ss.values())
    for sss in ss.values():
        result += sss * (group_size - sss)
print(result)",O(n)
"class Solution(object):
    def maximumBeauty(self, nums, k):
        nums.sort()
        left = 0
        for right in range(len(nums)):
            if nums[right]-nums[left] > k*2:
                left += 1
        return right-left+1",O(nlogn)
"n = int(input())
ax,ay = [int(s) for s in input().split()]
bx,by = [int(s) for s in input().split()]
cx,cy = [int(s) for s in input().split()]
if ((bx-ax < 0 and cx-ax < 0 or
    bx-ax > 0 and cx-ax > 0) and
    (by-ay < 0 and cy-ay < 0 or
    by-ay > 0 and cy-ay > 0)):
        print(""YES"")
else:
    print(""NO"")",O(1)
"def merge(a,b):
    inda=0
    indb=0
    lena=len(a)
    lenb=len(b)
    d=[a[-1]+b[-1]+1000]
    a+=d
    b+=d
    c=[]
    inversions=0
    for i in range(lena+lenb):
        if a[inda]<b[indb]:
            c.append(a[inda])
            inda+=1
        else:
            c.append(b[indb])
            indb+=1
            inversions+=lena-inda
    return((c,inversions))
def mergesort(a):
    if len(a)<=1:
        return((a,0))
    split=len(a)//2
    b=a[:split]
    c=a[split:]
    d=mergesort(b)
    e=mergesort(c)
    f=merge(d[0],e[0])
    return((f[0],f[1]+d[1]+e[1]))
n=int(input())
a=list(map(int,input().split()))
b=[]
for guy in a:
    if guy!=-1:
        b.append(guy)
invs=mergesort(b)[1]
negs=len(a)-len(b)
pairs=(negs*(negs-1))//2
used=[0]*n
for guy in a:
    if guy!=-1:
        used[guy-1]+=1
unused=[0]
for i in range(n-1):
    unused.append(unused[-1]+1-used[i])
negsseen=0
mix=0
for i in range(n):
    if a[i]==-1:
        negsseen+=1
    else:
        mix+=unused[a[i]-1]*(negs-negsseen)+negsseen*(negs-unused[a[i]-1])
num=invs*2*negs+pairs*negs+mix*2
denom=2*negs
if negs==0:
    print(invs%998244353)
else:
    for i in range(denom):
        if (998244353*i+1)%denom==0:
            inv=(998244353*i+1)//denom
            break
    print((num*inv)%998244353)",O(nlogn)
"class Solution2_TLE(object):
    def longestObstacleCourseAtEachPosition(self, obstacles):
        sorted_obstacles = sorted(set(obstacles))
        lookup = {x:i for i, x in enumerate(sorted_obstacles)}
        segment_tree = SegmentTree(len(lookup))
        result = []
        for x in obstacles:
            cnt = segment_tree.query(0, lookup[x])+1
            result.append(cnt)
            segment_tree.update(lookup[x], lookup[x], cnt)
        return result",O(nlogn)
"from math import inf
n, m, k = map(int, input().split())
horizontal = []
vertical = []
for _ in range(n):
    horizontal.append(list(map(int, input().split())))
for _ in range(n - 1):
    vertical.append(list(map(int, input().split())))
if k & 1:
    ans = [""-1""] * m
    for _ in range(n):
        print(*ans)
else:
    grid = [[0 for i in range(m)] for j in range(n)]
    for _ in range(k // 2):
        X = [[inf for i in range(m)] for j in range(n)]
        for i in range(n):
            for j in range(m):
                if i >= 1:
                    X[i][j] = min(2 * vertical[i - 1][j] + grid[i - 1][j], X[i][j])
                if i < n - 1:
                    X[i][j] = min(2 * vertical[i][j] + grid[i + 1][j], X[i][j])
                if j >= 1:
                    X[i][j] = min(2 * horizontal[i][j - 1] + grid[i][j - 1], X[i][j])
                if j < m - 1:
                    X[i][j] = min(2 * horizontal[i][j] + grid[i][j + 1], X[i][j])

        grid = X[:]
    for _ in range(n):
        print(*grid[_])
",O(n ^ 3)
"import math
from decimal import Decimal

def sum2(s, e):
    return sum1(e) - sum1(s - 1) - (e - s)

def sum1(i):
    return i * (i + 1) / 2

line = input().split()
n = Decimal(line[0])
k = Decimal(line[1])
if(n == 1):
    print(0)
elif(k > n):
    print(1)
elif(sum2(Decimal(2),k) < n):
    print(-1)
else:
    c = 2 * n + k - k * k
    discriminant = (9 - 4 * c).sqrt()
    tmp = discriminant / 2
    const = Decimal(3/2)
    res1 = math.floor(const + tmp)
    res2 = math.floor(const - tmp)
    res1 = max(res1, res2)
    print(k - res1 + 1);",O(logn)
"a = input()
b = input()
l = a.count(""+"")-a.count(""-"")
k = b.count(""?"")
if k==0:
    if (b.count(""+"")-b.count(""-""))==l:
        print(1)
    else:
        print(0)
else:
    n=2**k
    r=k
    c=[]
    t=0
    while r>=0:
        c.append(r-t)
        t+=1
        r-=1
    import math
    d=[]
    for i in range(k+1):
        d.append((math.factorial(k))//(math.factorial(i)*math.factorial(k-i)))
    f = b.count(""+"")-b.count(""-"")
    if l-f in c:
        print((d[c.index(l-f)])/sum(d))
    else:
        print(0)",np
"import sys
import string

from collections import Counter, defaultdict
from math import fsum, sqrt, gcd, ceil, factorial
from operator import *
from itertools import accumulate, count

inf = float(""inf"")

flush = lambda: sys.stdout.flush
comb = lambda x, y: (factorial(x) // factorial(y)) // factorial(x - y)

ip = lambda: input()
ii = lambda: int(input())
r = lambda: map(int, input().split())
rr = lambda: list(r())

arr = ip()
n = len(arr)
ms = """"
mn = 0

def counter(s, x):
    p = len(x)
    px = 0
    for i in range(len(s)):
        if s[i : i + p] == x:
            px += 1

    return px

for i in range(n):
    s = """"
    for j in range(i, n):
        s += arr[j]
        c = counter(arr, s)
        if c > 1 and len(s) > mn:
            ms = s
            mn = len(s)

print(mn)",O(n ^ 3)
"class Solution(object):
    def depthSumInverse(self, nestedList):
        def depthSumInverseHelper(list, depth, result):
            if len(result) < depth + 1:
                result.append(0)
            if list.isInteger():
                result[depth] += list.getInteger()
            else:
                for l in list.getList():
                    depthSumInverseHelper(l, depth + 1, result)

        result = []
        for list in nestedList:
            depthSumInverseHelper(list, 0, result)

        sum = 0
        for i in reversed(range(len(result))):
            sum += result[i] * (len(result) - i)
        return sum",O(n)
"import sys
import string

def ria():
    return [int(i) for i in input().split()]

n, k = ria()
mp = {}
for i in string.ascii_uppercase[:k]:
    mp[i] = 0
for i in input():
    if i in mp:
        mp[i] += 1
print(min(mp.values())*k)",O(n)
"class Solution(object):
    def maxProfit(self, prices):
        hold1, hold2 = float(""-inf""), float(""-inf"")
        release1, release2 = 0, 0
        for i in prices:
            hold1 = max(hold1, -i)
            release1 = max(release1, hold1 + i)
            hold2 = max(hold2, release1 - i)
            release2 = max(release2, hold2 + i)
        return release2",O(n)
"class Solution(object):
    def theMaximumAchievableX(self, num, t):
        return num+2*t",O(1)
"class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost)
        dp = [0] * (n + 1)

        for i in range(2, n + 1):
            dp[i] = min(dp[i - 1] + cost[i - 1],
                        dp[i - 2] + cost[i - 2])

        return dp[n]
",O(n)
"class Solution(object):
    def validPartition(self, nums):
        dp = [False]*4
        dp[0] = True
        for i in range(len(nums)):
            dp[(i+1)%4] = False
            if i-1 >= 0 and nums[i] == nums[i-1]:
                dp[(i+1)%4] |= dp[((i+1)-2)%4]
            if i-2 >= 0 and (nums[i] == nums[i-1] == nums[i-2] or
                             nums[i] == nums[i-1]+1 == nums[i-2]+2):
                dp[(i+1)%4] |= dp[((i+1)-3)%4]
        return dp[len(nums)%4]",O(n)
"from sys import stdin

add = lambda a, b: (a % mod + b % mod) % mod
mod, bits = 998244353, ['00', '01', '10', '11']
pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]

n, k = map(int, stdin.readline().split())
mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(2)]

for i in range(4):
    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)
    if val <= k:
        mem[0][val][i] = 1

for i in range(1, n):
    for j in range(1, i * 2 + 1):
        for k1 in range(4):
            for k2 in range(4):
                val = j + pat[k1][k2]
                if val <= k:
                    mem[i & 1][val][k2] = add(mem[(i - 1) & 1][j][k1], mem[i & 1][val][k2])

    for j in range(1, min(i * 2 + 1, k + 1)):
        for k1 in range(4):
            mem[(i - 1) & 1][j][k1] = 0

print(sum(mem[(n - 1) & 1][k]) % mod)
",np
"n=int(input())
if(n>=0):
    print(n)
else:
    if((n*-1)//10==0):
        print(0)
    else:
        n*=-1
        y=n//10
        z=n%10
        x=y//10
        x*=10;
        x+=z;
        x*=-1
        y*=-1
        if(x>=y):
            print(x)
        else:
            print(y)",O(1)
"class Solution3(object):
    def findDuplicate(self, nums):
        duplicate = 0
        for num in nums:
            if nums[abs(num) - 1] > 0:
                nums[abs(num) - 1] *= -1
            else:
                duplicate = abs(num)
                break
        for num in nums:
            if nums[abs(num) - 1] < 0:
                nums[abs(num) - 1] *= -1
            else:
                break
        return duplicate",O(n)
"from sys import stdin, stdout
from itertools import accumulate
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int, stdin.readline().split()))
for _ in range(1):
    n,k=lst()
    a=lst()
    b=lst()
    ps=list(accumulate(a))
    dp=[[0 for _ in range(2)] for _ in range(1+n)]
    for i in range(1,n+1):
        dp[i][0]=dp[i-1][0]+a[i-1]*b[i-1]
        dp[i][1]=max(dp[i-1][1]+a[i-1]*b[i-1],ps[i-1]-(ps[i-k-1] if i-k-1>=0 else 0)+dp[max(i-k,0)][0])

    print(max(dp[n]))",O(n)
"n, m = map(int, input().split())
a = (n * (n - 1)) // 2
n2 = n // 2
b = n2 * (n2 + 1)
if n % 2 == 0:
    b -= n2
s = 0
for i in range(m):
    x, d = map(int, input().split())
    s += x * n
    s += d * (a if d > 0 else b)

print(s / n)
",O(n)
"import os,sys
from io import BytesIO,IOBase

def main():
    mod = 998244353
    n,k = map(int,input().split())
    dp = [[[0]*4 for _ in range(k+2)]for _ in range(n)]
    dp[0][1] = [0,1,1,0]
    dp[0][0] = [1,0,0,1]
    for i in range(1,n):
        for r in range(k):
            dp[i][r+1][3] = (dp[i][r+1][3]+dp[i-1][r][0])%mod
            dp[i][r+1][2] = (dp[i][r+1][2]+dp[i-1][r][0])%mod
            dp[i][r+1][1] = (dp[i][r+1][1]+dp[i-1][r][0])%mod
            dp[i][r][0] = (dp[i][r][0]+dp[i-1][r][0])%mod
            dp[i][r+2][2] = (dp[i][r+2][2]+dp[i-1][r][1])%mod
            dp[i][r][0] = (dp[i][r][0]+dp[i-1][r][1])%mod
            dp[i][r][3] = (dp[i][r][3]+dp[i-1][r][1])%mod
            dp[i][r][1] = (dp[i][r][1]+dp[i-1][r][1])%mod
            dp[i][r+2][1] = (dp[i][r+2][1]+dp[i-1][r][2])%mod
            dp[i][r][0] = (dp[i][r][0]+dp[i-1][r][2])%mod
            dp[i][r][3] = (dp[i][r][3]+dp[i-1][r][2])%mod
            dp[i][r][2] = (dp[i][r][2]+dp[i-1][r][2])%mod
            dp[i][r+1][0] = (dp[i][r+1][0]+dp[i-1][r][3])%mod
            dp[i][r+1][2] = (dp[i][r+1][2]+dp[i-1][r][3])%mod
            dp[i][r+1][1] = (dp[i][r+1][1]+dp[i-1][r][3])%mod
            dp[i][r][3] = (dp[i][r][3]+dp[i-1][r][3])%mod
    print((dp[-1][k-1][0]+dp[-1][k-1][1]+dp[-1][k-1][2]+dp[-1][k-1][3])%mod)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",np
"def is_good(x, n, k):
    y = k - x + 1
    return (y + k * (k - 1) // 2 - y * (y - 1) // 2) >= n

if __name__ == '__main__':
    n, k = [int(x) for x in input().split()]
    if n == 1:
        print(0)
    elif (k + (k - 2) * (k - 1) // 2) < n:
        print(-1)
    elif k >= n:
        print(1)
    else:
        l = 0
        r = k
        while r > l + 1:
            m = (l + r) // 2

            if is_good(m, n, k):
                r = m
            else:
                l = m
        print(r)
",O(logn)
"import re
import sys
exit=sys.exit
from bisect import bisect_left as bsl,bisect_right as bsr
from collections import Counter,defaultdict as ddict,deque
from functools import lru_cache
cache=lru_cache(None)
from heapq import *
from itertools import *
from math import inf
from pprint import pprint as pp
enum=enumerate
ri=lambda:int(rln())
ris=lambda:list(map(int,rfs()))
rln=sys.stdin.readline
rl=lambda:rln().rstrip('\n')
rfs=lambda:rln().split()
cat=''.join
catn='\n'.join
mod=1000000007
d4=[(0,-1),(1,0),(0,1),(-1,0)]
d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]

figures=[
  [(0,0),(0,1),(1,0)],
  [(0,0),(0,1),(1,1)],
  [(0,1),(1,0),(1,1)],
  [(0,0),(1,0),(1,1)],
]

board=[]
for _ in range(2):
  s=rl()
  board.append(list(s))

n=len(board[0])

ans=0
for j in range(n-1):
  for fig in figures:
    ok=1
    for fi,fj in fig:
      if board[fi][j+fj]=='X':
        ok=0
        break
    if not ok:
      continue
    ans+=1
    for fi,fj in fig:
      board[fi][j+fj]='X'
    break

print(ans)
",O(1)
"

class Solution(object):
    def mostExpensiveItem(self, primeOne, primeTwo):
        return primeOne*primeTwo-primeOne-primeTwo


",O(1)
"from os import path
import sys,time

from math import ceil, floor,gcd,log,log2 ,factorial
from collections import *

maxx = float('inf')

I = lambda :int(sys.stdin.buffer.readline())
tup= lambda : map(int , sys.stdin.buffer.readline().split())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().replace('\n', '').strip()
def grid(r, c): return [lint() for i in range(r)]
stpr = lambda x : sys.stdout.write(f'{x}' + '\n')
star = lambda x: print(' '.join(map(str, x)))
localsys = 0
start_time = time.time()
if (path.exists('input.txt')):
	sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');

n , k= tup()
s = S()

fl =0
l = None
for i in range(1, n):
	x =s[i:n]
	for j in range(n):
		if x == s[:j+1]:
			l = j+1
			fl = 1
			break
	if fl :
		break
if fl :
	ans = s + s[l:n]*(k-1)
	print(ans)
else:
	print(s*k)

if localsys:
	print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")
",O(n ^ 2)
"k = int(input())

nc = [0 for i in range(14)]

for i in range(1, 14):
    nc[i] += nc[i - 1] + 9 * (10 ** (i - 1)) * i

for i in range(13):
    if nc[i] < k <= nc[i + 1]:
        cif = i + 1

if cif == 1:
    print(k)
    quit()

c = k - nc[cif - 1]

if c % cif == 0:
    nnr = c // cif
    ncif = cif
else:
    nnr = 1 + c // cif
    ncif = c % cif

number = nnr + 10 ** (cif - 1) - 1

while cif != ncif:
    number //= 10
    cif -= 1

print(number % 10)",O(logn)
"import os
import sys
from io import BytesIO, IOBase
import heapq as h
from bisect import bisect_left, bisect_right
import time

from types import GeneratorType
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict as dd, deque as dq, Counter as dc
import string
from math import sqrt

def getInts():
    return [int(s) for s in input().split()]

def getInt():
    return int(input())

def getStrs():
    return [s for s in input().split()]

def getStr():
    return input()

def listStr():
    return list(input())

def getMat(n):
    return [getInts() for _ in range(n)]

def isInt(s):
    return '0' <= s[0] <= '9'

MOD = 10**9 + 7

def t_from_s_a_u(s,a,u):
    return (-2*u + sqrt(4*u*u + 8*s*a))/(2*a)

def solve():
    A, V = getInts()
    L, D, W = getInts()
    if V <= W or W**2 >= 2*A*D:

        if V**2 >= 2*A*L:
            return sqrt(2*L/A)
        else:
            dist_1 = (V**2)/(2*A)
            T1 = 2*dist_1/V
            dist_2 = L - dist_1
            T2 = dist_2/V
            return T1+T2
    else:

        dist_1 = (W**2)/(2*A)
        T1 = sqrt(2*dist_1/A)
        rem_dist = D - dist_1
        dist_A = (V**2 - W**2)/(2*A)
        if 2*dist_A >= rem_dist:

            TA = 2*t_from_s_a_u(rem_dist/2,A,W)
        else:
            TA1 = 2*(V-W)/A
            SA1 = (V+W)*(V-W)/A
            SA2 = rem_dist - SA1
            TA2 = SA2/V
            TA = TA1 + TA2
        T1 += TA

        if V**2 - W**2 >= 2*A*(L-D):

            return T1 + t_from_s_a_u(L-D,A,W)
        else:
            dist_2 = (V**2 - W**2)/(2*A)
            T2 = 2*dist_2/(V+W)
            dist_3 = L - D - dist_2
            T3 = dist_3/V

            return T1+T2+T3
    return

print(solve())
",O(1)
"class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        leftHeight = self.maxHeight(root.left)
        rightHeight = self.maxHeight(root.right)
        diameter = leftHeight + rightHeight
        sub = max(self.diameterOfBinaryTree(root.left),
                  self.diameterOfBinaryTree(root.right))
        return max(diameter, sub)

    def maxHeight(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        return 1 + max(self.maxHeight(root.left), self.maxHeight(root.right))
",O(n ^ 2)
"from sys import stdin
import collections
import copy
import math

n = int(stdin.readline())
m = int(stdin.readline())
up = list(map(int, stdin.readline().split()))
down = list(map(int, stdin.readline().split()))

def check(x):
    weight = m + x
    fuel = x
    for i in range(n):
        f = weight/up[i]
        if fuel<f:
            return False
        else:
            weight -= f
            fuel -= f
        f = weight/down[i]
        if fuel<f:
            return False
        else:
            weight -= f
            fuel -= f
    return True

l = 0
r = 1e9 + 1e-6

for ii in range(100):
    mid = (r + l)/2

    if(check(mid)):
        r = mid
    else:
        l = mid
    if r-l <= 1e-10:
        break
if l >= 1e9+ 1e-6:
    print(-1)
else:
    print(""%.10f"" %l)
",O(n)
"class Solution(object):
    def decodeCiphertext(self, encodedText, rows):
        cols = len(encodedText)//rows
        k = len(encodedText)
        for i in reversed(range(cols)):
            for j in reversed(range(i, len(encodedText), cols+1)):
                if encodedText[j] != ' ':
                    k = j
                    break
            else:
                continue
            break
        result = []
        for i in range(cols):
            for j in range(i, len(encodedText), cols+1):
                result.append(encodedText[j])
                if j == k:
                    break
            else:
                continue
            break
        return """".join(result)",O(n)
"f, d, s = [int(i) for i in input().split()]
filters = [int(i) for i in input().split()]
filters.sort(reverse=True)

freeSockets = s
usedFilters = 0
for i in range(len(filters)):
    if freeSockets >= d:
        break
    usedFilters += 1
    freeSockets += filters[i]-1

if freeSockets >= d:
    print(usedFilters)
else:
    print(-1)
",O(nlogn)
"import sys
input = sys.stdin.readline

n = int(input())
a = sorted(list(set(map(int, input().split()))))
n = len(a)
used = [0] * n
cnt = 0
for i in range(n):
    if not used[i]:
        used[i] = 1
        cnt += 1
        for j in range(i + 1, n):
            if a[j] % a[i] == 0:
                used[j] = 1
print(cnt)
",O(n ^ 2)
"class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        dummy = ListNode(0, head)
        groupPrev = dummy

        while True:
            kth = self.getKth(groupPrev, k)
            if not kth:
                break
            groupNext = kth.next

            prev, curr = kth.next, groupPrev.next
            while curr != groupNext:
                tmp = curr.next
                curr.next = prev
                prev = curr
                curr = tmp

            tmp = groupPrev.next
            groupPrev.next = kth
            groupPrev = tmp
        return dummy.next

    def getKth(self, curr, k):
        while curr and k > 0:
            curr = curr.next
            k -= 1
        return curr
",O(n)
"from sys import stdin,stdout
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int, stdin.readline().split()))
for _ in range(1):
    n=nmbr()
    a=lst()
    b=lst()
    ans=PI=float('inf')
    dp=[[PI for _ in range(4)] for _ in range(n)]
    for i in range(n):
        dp[i][1]=b[i]
        for j in range(i):
            if a[j]<a[i]:
                dp[i][2]=min(dp[i][2],dp[j][1]+b[i])
                dp[i][3]=min(dp[i][3],dp[j][2]+b[i])
                ans=min(ans,dp[i][3])
    print(ans if ans!=PI else -1)",O(n ^ 2)
